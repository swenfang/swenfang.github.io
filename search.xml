<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[IntelliJ IDEA 调试教程]]></title>
    <url>%2F2017%2F12%2F12%2FIntelliJ%20IDEA%20%20%E8%B0%83%E8%AF%95%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[IntelliJ IDEA 调试教程在调试代码的时候，你的项目得debug模式启动，也就是点那个绿色的甲虫启动服务器，然后，就可以在代码里面断点调试啦。下面不要在意，这个快捷键具体是啥，因为，这个keymap是可以自己配置的，有的人keymap是mac版的，有的是Windows版的。我的就是Windows，而且修改keymap为eclipse的keymap，因为我算是eclipse转过来的吧。下面直接看图，详细解释，每一个按钮（按钮对应图中的数字）都是什么功能。 1，rerun XXX，这个就是直接重新跑某个程序。2，这个相当于eclipse里面的f8，直接跑完，到下一个断点停下，没有就直接跑完程序。3，停止项目或者程序。要是自己的main呢，点一下就停下了，要是Java web项目，则点2下，就把服务器给停了。4，查看所有的断点设置情况。具体详情，下面有示意图，再细细解释。5，直接取消所有断点，让所有断点无效。6，要是你一不小心把这个下面的布局给弄乱了，你点这个，就把下面的布局给还原咯。7，跳转到当前代码所执行的地方，也就是说你在看代码的时候，点到其他地方，一点这个按钮，就到了程序执行到当前哪行的代码的地方。8，下一步，如果是方法，他是不会跳进去的。就是一行行的往下走。（eclipse里面的快捷键就是f6）9，跳转到详情，如果下一行调试代码是可执行方法，就可以f7进去，查看这个方法的运行详细情况。重点就是点进去执行10，从详情跳出去，和上面的9相反。11，看字面意思就是跳转到下一个断点12，这个点开之后，可以计算你想要看的代码段的值，后面详细上图。13，看意思，同eclipse里面的watch，查看某个对象的值，自定义的对象。14，把自定义的查看对象的值，分开到另一个tab页。15，有时候当我们步入方法体之后，还想回退到方法体外，点这个按钮后，断点重新回到方法体之外。在继续还是可以再次进到方法内 查看断点处的某个对象的值，可以 如下几个方法：1，选中对象后，鼠标悬停在对象上 2 秒左右2，在watch里面添加这个对象，3，下面也许会自动列出来你代码里面有的4，使用上面图上标注的12的那个按钮 下面就再详细说下 4，12，13，144，查看所有的断点的详情，点开如下所示。在图中condition中可以设置断点的条件，当i==4的时候，才停下。查看具体断点内容。 关于设置断点条件，还可以，直接在代码断点处，右键设置，完啦之后，done，设置完成。 12，这个用的也比较多，这个就比较随意。可以根据你的输入，计算你要的结果，不局限代码里面的变量啥的。这个在debug的时候，使用起来是很方便的。 13，14，这2个点完之后，效果如下图，只是把自定义的变量和代码里面自带的变量分在两个tab页面展示。你可以点13号按钮，自行添加，你想查看的变量的值。 还有个需求，就是在调试代码的时候，实时的修改，运行状态的代码变量的值。 仔细看下图，就知道，怎么在实时调试代码的时候，怎么设置某些变量的值，可以看到，我上面在输入a之后，下面就有类似你写代码时候的提示，你就可以在这地方修改变量的值啦 关于调试的时候，设置运行时的参数，如下： 入口如下，2个地方都可以。 一般都是跑简单的main方法，跑main方法的时候，还带参数文件的，还是第一次，顺带做个记录吧。 更新：这个编辑器为了方便从eclipse编辑器转过来的同学们，他可以设置keymap的。具体看图。 因为我就是刚刚开始的时候，使用的就是eclipse，后来转过来的，所以，在使用的时候，就先设置了一下，这个键盘映射。使用的还是以前在eclipse上使用的快捷键。不需要再次去记一遍新的快捷键映射。这个也是极其方便的。 所以，在这个debug的快捷键上和使用eclipse时候，是一样的f5进去，f6是下一步。]]></content>
      <categories>
        <category>IntelliJ IDEA</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程面试题]]></title>
    <url>%2F2017%2F12%2F10%2FJava%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%20Top%2050%2F</url>
    <content type="text"><![CDATA[Java线程面试题摘要： 不管你是新程序员还是老手，你一定在面试中遇到过有关线程的问题。Java语言一个重要的特点就是内置了对并发的支持，让Java大受企业和程序员的欢迎。大多数待遇丰厚的Java开发职位都要求开发者精通多线程技术并且有丰富的Java程序开发、调试、优化经验，所以线程相关的问题在面试中经常会被提到。 不管你是新程序员还是老手，你一定在面试中遇到过有关线程的问题。Java语言一个重要的特点就是内置了对并发的支持，让Java大受企业和程序员的欢迎。大多数待遇丰厚的Java开发职位都要求开发者精通多线程技术并且有丰富的Java程序开发、调试、优化经验，所以线程相关的问题在面试中经常会被提到。 在典型的Java面试中， 面试官会从线程的基本概念问起, 如：为什么你需要使用线程， 如何创建线程，用什么方式创建线程比较好（比如：继承thread类还是调用Runnable接口），然后逐渐问到并发问题像在Java并发编程的过程中遇到了什么挑战，Java内存模型，JDK1.5引入了哪些更高阶的并发工具，并发编程常用的设计模式，经典多线程问题如生产者消费者，哲学家就餐，读写器或者简单的有界缓冲区问题。仅仅知道线程的基本概念是远远不够的， 你必须知道如何处理死锁，竞态条件，内存冲突和线程安全等并发问题。掌握了这些技巧，你就可以轻松应对多线程和并发面试了。 许多Java程序员在面试前才会去看面试题，这很正常。因为收集面试题和练习很花时间，所以我从许多面试者那里收集了Java多线程和并发相关的50个热门问题。我只收集了比较新的面试题且没有提供全部答案。想必聪明的你对这些问题早就心中有数了， 如果遇到不懂的问题，你可以用Google找到答案。若你实在找不到答案，可以在文章的评论中向我求助。你也可以在这找到一些答案Java线程问答Top 12。 50道Java线程面试题 下面是Java线程相关的热门面试题，你可以用它来好好准备面试。 什么是线程？ 线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。Java在语言层面对多线程提供了卓越的支持，它也是一个很好的卖点。欲了解更多详细信息请点击这里。 线程和进程有什么区别？ 线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。更多详细信息请点击这里。 如何在Java中实现线程？ 在语言层面有两种方式。java.lang.Thread 类的实例就是一个线程但是它需要调用java.lang.Runnable接口来执行，由于线程类本身就是调用的Runnable接口所以你可以继承java.lang.Thread 类或者直接调用Runnable接口来重写run()方法实现线程。更多详细信息请点击这里. 用Runnable还是Thread？ 这个问题是上题的后续，大家都知道我们可以通过继承Thread类或者调用Runnable接口来实现线程，问题是，那个方法更好呢？什么情况下使用它？这个问题很容易回答，如果你知道Java不支持类的多重继承，但允许你调用多个接口。所以如果你要继承其他类，当然是调用Runnable接口好了。更多详细信息请点击这里。 Thread 类中的start() 和 run() 方法有什么区别？ 这个问题经常被问到，但还是能从此区分出面试者对Java线程模型的理解程度。start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。更多讨论请点击这里 Java中Runnable和Callable有什么不同？ Runnable和Callable都代表那些要在不同的线程中执行的任务。Runnable从JDK1.0开始就有了，Callable是在JDK1.5增加的。它们的主要区别是Callable的 call() 方法可以返回值和抛出异常，而Runnable的run()方法没有这些功能。Callable可以返回装载有计算结果的Future对象。我的博客有更详细的说明。 Java中CyclicBarrier 和 CountDownLatch有什么不同？ CyclicBarrier 和 CountDownLatch 都可以用来让一组线程等待其它线程。与 CyclicBarrier 不同的是，CountdownLatch 不能重新使用。点此查看更多信息和示例代码。 Java内存模型是什么？ Java内存模型规定和指引Java程序在不同的内存架构、CPU和操作系统间有确定性地行为。它在多线程的情况下尤其重要。Java内存模型对一个线程所做的变动能被其它线程可见提供了保证，它们之间是先行发生关系。这个关系定义了一些规则让程序员在并发编程时思路更清晰。比如，先行发生关系确保了： 线程内的代码能够按先后顺序执行，这被称为程序次序规则。对于同一个锁，一个解锁操作一定要发生在时间上后发生的另一个锁定操作之前，也叫做管程锁定规则。前一个对volatile的写操作在后一个volatile的读操作之前，也叫volatile变量规则。一个线程内的任何操作必需在这个线程的start()调用之后，也叫作线程启动规则。一个线程的所有操作都会在线程终止之前，线程终止规则。一个对象的终结操作必需在这个对象构造完成之后，也叫对象终结规则。可传递性 我强烈建议大家阅读《Java并发编程实践》第十六章来加深对Java内存模型的理解。 Java中的volatile 变量是什么？ volatile是一个特殊的修饰符，只有成员变量才能使用它。在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。volatile变量可以保证下一个读取操作会在前一个写操作之后发生，就是上一题的volatile变量规则。点击这里查看更多volatile的相关内容。 什么是线程安全？Vector是一个线程安全类吗？ （详见这里) 如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。 Java中什么是竞态条件？ 举个例子说明。 竞态条件会导致程序在并发情况下出现一些bugs。多线程对一些资源的竞争的时候就会产生竞态条件，如果首先要执行的程序竞争失败排到后面执行了，那么整个程序就会出现一些不确定的bugs。这种bugs很难发现而且会重复出现，因为线程间的随机竞争。一个例子就是无序处理，详见答案。 Java中如何停止一个线程？ Java提供了很丰富的API但没有为停止线程提供API。JDK 1.0本来有一些像stop(), suspend() 和 resume()的控制方法但是由于潜在的死锁威胁因此在后续的JDK版本中他们被弃用了，之后Java API的设计者就没有提供一个兼容且线程安全的方法来停止一个线程。当run() 或者 call() 方法执行完的时候线程会自动结束,如果要手动结束一个线程，你可以用volatile 布尔变量来退出run()方法的循环或者是取消任务来中断线程。点击这里查看示例代码。 一个线程运行时发生异常会怎样？ 这是我在一次面试中遇到的一个很刁钻的Java面试题, 简单的说，如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理。 如何在两个线程间共享数据？ 你可以通过共享对象来实现这个目的，或者是使用像阻塞队列这样并发的数据结构。这篇教程《Java线程间通信》(涉及到在两个线程间共享对象)用wait和notify方法实现了生产者消费者模型。 Java中notify 和 notifyAll有什么区别？ 这又是一个刁钻的问题，因为多线程可以等待单监控锁，Java API 的设计人员提供了一些方法当等待条件改变的时候通知它们，但是这些方法没有完全实现。notify()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。我的博客有更详细的资料和示例代码。 为什么wait, notify 和 notifyAll这些方法不在thread类里面？ 这是个设计相关的问题，它考察的是面试者对现有系统和一些普遍存在但看起来不合理的事物的看法。回答这些问题的时候，你要说明为什么把这些方法放在Object类里是有意义的，还有不把它放在Thread类里的原因。一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。你也可以查看这篇文章了解更多。 什么是ThreadLocal变量？ ThreadLocal是Java里一种特殊的变量。每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用ThreadLocal让SimpleDateFormat变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。线程局部变量的另一个不错的例子是ThreadLocalRandom类，它在多线程环境中减少了创建代价高昂的Random对象的个数。查看答案了解更多。 什么是FutureTask？ 在Java并发程序中FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对调用了Callable和Runnable的对象进行包装，由于FutureTask也是调用了Runnable接口所以它可以提交给Executor来执行。 Java中interrupted 和 isInterruptedd方法的区别？ interrupted() 和 isInterrupted()的主要区别是前者会将中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能被其它线程调用中断来改变。 为什么wait和notify方法要在同步块中调用？ 主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。还有一个原因是为了避免wait和notify之间产生竞态条件。 为什么你应该在循环中检查等待条件? 处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait()方法效果更好的原因，你可以在Eclipse中创建模板调用wait和notify试一试。如果你想了解更多关于这个问题的内容，我推荐你阅读《Effective Java》这本书中的线程和同步章节。 Java中的同步集合与并发集合有什么区别？ 同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在Java1.5之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。更多内容详见答案。 Java中堆和栈有什么不同？ 为什么把这个问题归类在多线程和并发面试题里？因为栈是一块和线程紧密相关的内存区域。每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的。而堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时volatile 变量就可以发挥作用了，它要求线程从主存中读取变量的值。 更多内容详见答案。 什么是线程池？ 为什么要使用它？ 创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）。更多内容详见这篇文章。 如何写代码来解决生产者消费者问题？ 在现实中你解决的许多线程问题都属于生产者消费者模型，就是一个线程生产任务供其它线程进行消费，你必须知道怎么进行线程间通信来解决这个问题。比较低级的办法是用wait和notify来解决这个问题，比较赞的办法是用Semaphore 或者 BlockingQueue来实现生产者消费者模型，这篇教程有实现它。 如何避免死锁？http://www.cnblogs.com&amp;iframeId=iframe_0.21145907562000632“ frameborder=”0” scrolling=”no” height=”20”&gt; Java多线程中的死锁 死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件： 互斥条件：一个资源每次只能被一个进程使用。请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。这篇教程有代码示例和避免死锁的讨论细节。 Java中活锁和死锁有什么区别？ 这是上题的扩展，活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者进程的状态可以改变但是却不能继续执行。 怎么检测一个线程是否拥有锁？ 我一直不知道我们竟然可以检测一个线程是否拥有锁，直到我参加了一次电话面试。在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。你可以查看这篇文章了解更多。 你如何在Java中获取线程堆栈？ 对于不同的操作系统，有多种方法来获得Java进程的线程堆栈。当你获取线程堆栈时，JVM会把所有线程的状态存到日志文件或者输出到控制台。在Windows你可以使用Ctrl + Break组合键来获取线程堆栈，Linux下用kill -3命令。你也可以用jstack这个工具来获取，它对线程id进行操作，你可以用jps这个工具找到id。 JVM中哪个参数是用来控制线程的栈堆栈小的 这个问题很简单， -Xss参数用来控制线程的堆栈大小。你可以查看JVM配置列表来了解这个参数的更多信息。 Java中synchronized 和 ReentrantLock 有什么不同？ Java在过去很长一段时间只能通过synchronized关键字来实现互斥，它有一些缺点。比如你不能扩展锁之外的方法或者块边界，尝试获取锁时不能中途取消等。Java 5 通过Lock接口提供了更复杂的控制来解决这些问题。 ReentrantLock 类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义且它还具有可扩展性。你可以查看这篇文章了解更多 有三个线程T1，T2，T3，怎么确保它们按顺序执行？ 在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成。你可以查看这篇文章了解更多。 Thread类中的yield方法有什么作用？ Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。点击这里查看更多yield方法的相关内容。 Java中ConcurrentHashMap的并发度是什么？ ConcurrentHashMap把实际map划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是ConcurrentHashMap类构造函数的一个可选参数，默认值为16，这样在多线程情况下就能避免争用。欲了解更多并发度和内部大小调整请阅读我的文章How ConcurrentHashMap works in Java。 Java中Semaphore是什么？ Java中的Semaphore是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore只对可用许可的号码进行计数，并采取相应的行动。信号量常常用于多线程的代码中，比如数据库连接池。更多详细信息请点击这里。 如果你提交任务时，线程池队列已满。会时发会生什么？ 这个问题问得很狡猾，许多程序员会认为该任务会阻塞直到线程池队列有空位。事实上如果一个任务不能被调度执行那么ThreadPoolExecutor’s submit()方法将会抛出一个RejectedExecutionException异常。 Java线程池中submit() 和 execute()方法有什么区别？ 两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中, 而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。更多详细信息请点击这里。 什么是阻塞式方法？ 阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。更多详细信息请点击这里。 Swing是线程安全的吗？ 为什么？ 你可以很肯定的给出回答，Swing不是线程安全的，但是你应该解释这么回答的原因即便面试官没有问你为什么。当我们说swing不是线程安全的常常提到它的组件，这些组件不能在多线程中进行修改，所有对GUI组件的更新都要在AWT线程中完成，而Swing提供了同步和异步两种回调方法来进行更新。点击这里查看更多swing和线程安全的相关内容。 Java中invokeAndWait 和 invokeLater有什么区别？ 这两个方法是Swing API 提供给Java开发者用来从当前线程而不是事件派发线程更新GUI组件用的。InvokeAndWait()同步更新GUI组件，比如一个进度条，一旦进度更新了，进度条也要做出相应改变。如果进度被多个线程跟踪，那么就调用invokeAndWait()方法请求事件派发线程对组件进行相应更新。而invokeLater()方法是异步调用更新组件的。更多详细信息请点击这里。 Swing API中那些方法是线程安全的？ 这个问题又提到了swing和线程安全，虽然组件不是线程安全的但是有一些方法是可以被多线程安全调用的，比如repaint(), revalidate()。 JTextComponent的setText()方法和JTextArea的insert() 和 append() 方法也是线程安全的。 如何在Java中创建Immutable对象？ 这个问题看起来和多线程没什么关系， 但不变性有助于简化已经很复杂的并发程序。Immutable对象可以在没有同步的情况下共享，降低了对该对象进行并发访问时的同步化开销。可是Java没有@Immutable这个注解符，要创建不可变类，要实现下面几个步骤：通过构造方法初始化所有成员、对变量不要提供setter方法、将所有的成员声明为私有的，这样就不允许直接访问这些成员、在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝。我的文章how to make an object Immutable in Java有详细的教程，看完你可以充满自信。 Java中的ReadWriteLock是什么？ 一般而言，读写锁是用来提升并发程序性能的锁分离技术的成果。Java中的ReadWriteLock是Java 5 中新增的一个接口，一个ReadWriteLock维护一对关联的锁，一个用于只读操作一个用于写。在没有写线程的情况下一个读锁可能会同时被多个读线程持有。写锁是独占的，你可以使用JDK中的ReentrantReadWriteLock来实现这个规则，它最多支持65535个写锁和65535个读锁。 多线程中的忙循环是什么? 忙循环就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。你可以查看这篇文章获得更多信息。 volatile 变量和 atomic 变量有什么不同？ 这是个有趣的问题。首先，volatile 变量和 atomic 变量看起来很像，但功能却不一样。Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么 count++ 操作就不是原子性的。而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。 如果同步块内的线程抛出异常会发生什么？ 这个问题坑了很多Java程序员，若你能想到锁是否释放这条线索来回答还有点希望答对。无论你的同步块是正常还是异常退出的，里面的线程都会释放锁，所以对比锁接口我更喜欢同步块，因为它不用我花费精力去释放锁，该功能可以在finally block里释放锁实现。 单例模式的双检锁是什么？ 这个问题在Java面试中经常被问到，但是面试官对回答此问题的满意度仅为50%。一半的人写不出双检锁还有一半的人说不出它的隐患和Java1.5是如何对它修正的。它其实是一个用来创建线程安全的单例的老方法，当单例实例第一次被创建时它试图用单个锁进行性能优化，但是由于太过于复杂在JDK1.4中它是失败的，我个人也不喜欢它。无论如何，即便你也不喜欢它但是还是要了解一下，因为它经常被问到。你可以查看how double checked locking on Singleton works这篇文章获得更多信息。 如何在Java中创建线程安全的Singleton？ 这是上面那个问题的后续，如果你不喜欢双检锁而面试官问了创建Singleton类的替代方法，你可以利用JVM的类加载和静态变量初始化特征来创建Singleton实例，或者是利用枚举类型来创建Singleton，我很喜欢用这种方法。你可以查看这篇文章获得更多信息。 写出3条你遵循的多线程最佳实践 这种问题我最喜欢了，我相信你在写并发代码来提升性能的时候也会遵循某些最佳实践。以下三条最佳实践我觉得大多数Java程序员都应该遵循： 给你的线程起个有意义的名字。 这样可以方便找bug或追踪。OrderProcessor, QuoteProcessor or TradeProcessor 这种名字比 Thread-1. Thread-2 and Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。避免锁定和缩小同步的范围 锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。多用同步类少用wait 和 notify 首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的JDK中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。多用并发集合少用同步集合 这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到map，你应该首先想到用ConcurrentHashMap。我的文章Java并发集合有更详细的说明。 如何强制启动一个线程？ 这个问题就像是如何强制进行Java垃圾回收，目前还没有觉得方法，虽然你可以使用System.gc()来进行垃圾回收，但是不保证能成功。在Java里面没有办法强制启动一个线程，它是被线程调度器控制着且Java没有公布相关的API。 Java中的fork join框架是什么？ fork join框架是JDK7中出现的一款高效的工具，Java开发人员可以通过它充分利用现代服务器上的多处理器。它是专门为了那些可以递归划分成许多子模块设计的，目的是将所有可用的处理能力用来提升程序的性能。fork join框架一个巨大的优势是它使用了工作窃取算法，可以完成更多任务的工作线程可以从其它线程中窃取任务来执行。你可以查看这篇文章获得更多信息。 Java多线程中调用wait() 和 sleep()方法有什么不同？ Java程序中wait 和 sleep都会造成某种形式的暂停，它们可以满足不同的需要。wait()方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁，而sleep()方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁。你可以查看这篇文章获得更多信息。 以上就是50道热门Java多线程和并发面试题啦。我没有分享所有题的答案但给未来的阅读者提供了足够的提示和线索来寻找答案。如果你真的找不到某题的答案，联系我吧，我会加上去的。这篇文章不仅可以用来准备面试，还能检查你对多线程、并发、设计模式和竞态条件、死锁和线程安全等线程问题的理解。我打算把这篇文章的问题弄成所有Java多线程问题的大合集，但是没有你的帮助恐怖是不能完成的，你也可以跟我分享其它任何问题，包括那些你被问到却还没有找到答案的问题。这篇文章对初学者或者是经验丰富的Java开发人员都很有用，过两三年甚至五六年你再读它也会受益匪浅。它可以扩展初学者尤其有用因为这个可以扩展他们的知识面，我会不断更新这些题，大家可以在文章后面的评论中提问，分享和回答问题一起把这篇面试题完善。]]></content>
      <categories>
        <category>Java线程</category>
      </categories>
      <tags>
        <tag>面试精髓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(两到三年)Java 面试精髓]]></title>
    <url>%2F2017%2F12%2F10%2F(%E4%B8%A4%E5%88%B0%E4%B8%89%E5%B9%B4)Java%20%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%AB%93%2F</url>
    <content type="text"><![CDATA[(两到三年)Java 面试精髓Struts2框架的执行流程 ?从客户端发送请求过来,先经过前端控制器（核心过滤器）过滤器中,执行一组拦截器（一组拦截器 就会完成部分功能代码）执行目标Action, 在Action中返回一个结果视图,根据Result的配置进行页面的跳转. Struts2和Struts1没有任何联系.Struts2内核是webwork的内核. hibernate框架的理解?定义: Hibernate是一个开放源代码的对象关系映射（ORM）框架，它对JDBC进行了非常轻量级的对象封装， 使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库.可以通过对象保存到关系型数据库中,仅提供sava/get方法即可 Hibernate是一个持久层的ORM框架. Spring框架的理解?Spring是一个开源框架,核心是控制反转（IOC编程思想）和面向切面（AOP）。简单来说，Spring是一个分层的JavaSE/EEfull-stack(一站式) 轻量级开源框架 Spring的AOP的理解:通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术,利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率.可以在不修改源代码的前提下，对程序进行增强. 例如:在以前配置事务的时候,进行事务的回滚,提交等操作,配置AOP 以后可以将事务的权限交给Spring框架去管理,自动管理 SpringMVC的理解?springMvc:是一个表现层框架,就是从请求中接收传入的参数, 将处理后的结果数据返回给页面展示 基本类型:string,double,float,integer,long.boolean Mybatis的理解?MyBatis是一个优秀的持久层框架，它对jdbc的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。 Mybatis通过xml或注解的方式将要执行的各种statement（statement、preparedStatement、CallableStatement）配置起来，并通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象并返回。 #{}可以有效防止sql注入 Servlet的理解?* GET和POST区别? * GET：请求参数会显示到地址栏.GET方式有大小的限制.GET方式没有请求体 * POST：请求参数不会显示到地址栏.在请求体中.POST没有大小限制.POST方式有请求体. * 只有表单设置为method=”post”才是post请求.其他的都是get请求 生命周期:客户端第一次访问该Servlet的时候才会创建一个Servlet的对象,那么Servlet中的init方法就会执行.任何一次从客户端发送的请求,那么服务器创建一个新的线程执行Servlet中service方法为这次请求服务. service方法的内部根据请求的方式的不同调用不同doXXX的方法.当Servlet从服务器中移除或者关闭服务器的时候Servlet对象就会被销毁.destroy的方法就会执行. Struts2与SpringMVC的区别?1)springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过虑器。 2)springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。 3)Struts采用值栈存储请求和响应的数据，通过OGNL存取数据， springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。 Jsp的核心及核心标签?a) Servlet b) Core XML Database Funcations Redis什么情况下使用，redis持久化方案?a) 处理大数据量的时候 b) Redis的所有数据都是保存在内存中， Rdb：快照形式，定期把内存中当前时刻的数据保存到磁盘，redis默认支持的持久化方案 aof形式：append only file。把所有对redis数据库操作的命令，增删改操作命令，保存到文件中，数据库恢复是把所有命令执行一遍即可。 Hibernate和Mybatis的区别和优劣?a) Sql优化方面：hibernate的查询会将表中所有的字段查询出来，这一点会有性能的消耗 Mybatis的sql是手动编写的，所以可以按需求指定查询的字段，sql会更灵活，可控性更好 b) Hibernate是在JDBC上进行了一次封装 Mybatis是基于原生的JDBC，运行速度有优势 c) Mybatis mapper xml支持动态sql；Hibernate不支持 d) Hibernate与具体数据库的关联只需在xml文件中配置即可，所有hql语句与具体的数据库无关，移植性好 Mybatis项目所有的sql语句都是依赖所用的数据库的，所以不同数据库类型的支持不好 StringBuffer、StringBuilder的区别?StringBuffer、StringBuilder是容器，是可变的字符串序列，存放于堆内存。 StringBuffer是JDK1.0版本的，线程是安全的，效率比较低。StringBuilder是JDK1.5出现的，线程不安全，效率高。 说一下SOLR?solr就是一个中文搜索引擎,做完分词之后会做热度排名,核心是中文分词器,全文搜索支持,索引值指向对应的文档,相当于是一个字典,默认为collection的一个域对象,查询快,效率高. 可以在Redis里做分词之后的缓存,每次搜索一次就次数加一,里面还有一个投票容错机制,主机挂掉还有备份机,一般配置都为奇数态配置. Solr与Lucene的区别?Lucene是一个开放源代码的全文检索引擎工具包，它不是一个完整的全文检索引擎，Lucene提供了完整的查询引擎和索引引擎，目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者以Lucene为基础构建全文检索引擎。 Solr的目标是打造一款企业级的搜索引擎系统，它是一个搜索引擎服务，可以独立运行，通过Solr可以非常快速的构建企业的搜索引擎，通过Solr也可以高效的完成站内搜索功能。 什么是Redis?1) Redis的高性能是由于其将所有数据都存储在了内存中，为了使Redis在重启之后仍能保证数据不丢失，需要将数据从内存中同步到硬盘中，这一过程就是持久化。 Redis支持两种方式的持久化，一种是RDB方式，一种是AOF方式。可以单独使用其中一种或将二者结合使用。 1.1RDB持久化 RDB方式的持久化是通过快照（snapshotting）完成的，当符合一定条件时Redis会自动将内存中的数据进行快照并持久化到硬盘。 每次进行访问进行存储,如果服务器一旦崩溃,会导致数据丢失 RDB是Redis默认采用的持久化方式，在redis.conf配置文件中默认有此下配置： save 900 1 , save 300 10, save 60 10000 save 开头的一行就是持久化配置，可以配置多个条件（每行配置一个条件），每个条件之间是“或”的关系，“save 900 1”表示15分钟（900秒钟）内 至少 1个键被更改则进行快照，“save 300 10”表示5分钟（300秒）内至少10个键被更改则进行快照。 在redis.conf中： 配置dir指定 rdb快照文件的位置;配置dbfilenam指定rdb快照文件的名称 Redis启动后会读取RDB快照文件，将数据从硬盘载入到内存。根据数据量大小与结构和服务器性能不同，这个时间也不同。 通常将记录一千万个字符串类型键、大小为1GB的快照文件载入到内存中需要花费20～30秒钟。 问题总结： 通过RDB方式实现持久化，一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据。这就需要开发者根据具体的应用场合，通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能够接受的范围。如果数据很重要以至于无法承受任何损失，则可以考虑使用AOF方式进行持久化。 1.2AOF持久化 默认情况下Redis没有开启AOF（append only file）方式的持久化，访问一段存储一段,效率高. 可以通过appendonly参数开启：appendonly yes开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件 AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof，可以通过appendfilename参数修改：appendfilename appendonly.aof 2)主从复制（了解） 2.1什么是主从复制 持久化保证了即使redis服务重启也会丢失数据，因为redis服务重启后会将硬盘上持久化的数据恢复到内存中，但是当redis服务器的硬盘损坏了可能会导致数据丢失，如果通过redis的主从复制机制就可以避免这种单点故障，如下图： 说明： n主redis中的数据有两个副本（replication）即从redis1和从redis2，即使一台redis服务器宕机其它两台redis服务也可以继续提供服务。 n主redis中的数据和从redis上的数据保持实时同步，当主redis写入数据时通过主从复制机制会复制到两个从redis服务上。 n只有一个主redis，可以有多个从redis。 n主从复制不会阻塞master，在同步数据时，master 可以继续处理client 请求 n一个redis可以即是主又是从，如下图： 2.2主从配置 2.2.1主redis配置 无需特殊配置。 2.2.2从redis配置 修改从redis服务器上的redis.conf文件，添加slaveof主redisip主redis端口 上边的配置说明当前该从redis服务器所对应的主redis是192.168.101.3，端口是6379 2.3主从复制过程 2.3.1完整复制 在redis2.8版本之前主从复制过程如下图： 复制过程说明： 1、slave 服务启动，slave 会建立和master 的连接，发送sync 命令。 2、master启动一个后台进程将数据库快照保存到RDB文件中 注意：此时如果生成RDB文件过程中存在写数据操作会导致RDB文件和当前主redis数据不一致，所以此时master 主进程会开始收集写命令并缓存起来。 3、master 就发送RDB文件给slave 4、slave 将文件保存到磁盘上，然后加载到内存恢复 5、master把缓存的命令转发给slave 注意：后续master 收到的写命令都会通过开始建立的连接发送给slave。 当master 和slave 的连接断开时slave 可以自动重新建立连接。如果master 同时收到多个slave 发来的同步连接命令，只会启动一个进程来写数据库镜像，然后发送给所有slave。 完整复制的问题： 在redis2.8之前从redis每次同步都会从主redis中复制全部的数据，如果从redis是新创建的从主redis中复制全部的数据这是没有问题的，但是，如果当从redis停止运行，再启动时可能只有少部分数据和主redis不同步，此时启动redis仍然会从主redis复制全部数据，这样的性能肯定没有只复制那一小部分不同步的数据高。 2.3.2部分复制 部分复制说明： 从机连接主机后，会主动发起 PSYNC 命令，从机会提供 master的runid(机器标识，随机生成的一个串) 和 offset（数据偏移量，如果offset主从不一致则说明数据不同步），主机验证 runid 和 offset 是否有效， runid 相当于主机身份验证码，用来验证从机上一次连接的主机，如果runid验证未通过则，则进行全同步，如果验证通过则说明曾经同步过，根据offset同步部分数据。 2)redis是一个nosql(not only sql不仅仅只有sql)数据库.翻译成中文叫做非关系型型数据库. 关系型数据库:以二维表形式存储数据 非关系型数据库: 以键值对形式存储数据(key, value形式) Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库。它通过提供多种键值数据类型来适应不同场景下的存储需求， 目前为止Redis支持的键值数据类型如下： 字符串类型 散列类型 列表类型 集合类型 有序集合类型。 3)redis的应用场景 缓存（数据查询、短连接、新闻内容、商品内容等等）。（最多使用） 分布式集群架构中的session分离。 聊天室的在线好友列表。 任务队列。（秒杀、抢购、12306等等） 应用排行榜。 网站访问统计。 数据过期处理（可以精确到毫秒） redis是将数据存放到内存中,由于内容存取速度快所以redis被广泛应用在互联网项目中, redis有点:存取速度快,官方称读取速度会达到30万次每秒,写速度在10万次每秒最有,具体限制于硬件. 缺点:对持久化支持不够良好, 所以redis一般不作为数据的主数据库存储,一般配合传统的关系型数据库使用. 4) redis应用领域 分布式缓存 分布式session 保存博客或者论坛的留言回复等. 总之是用在数据量大,并发量高的情况下 谈下DUBBO?Dubbo就是资源调度和治理中心的管理工具。 调用关系说明： \0. 服务容器负责启动，加载，运行服务提供者。 \1. 服务提供者在启动时，向注册中心注册自己提供的服务。 \2. 服务消费者在启动时，向注册中心订阅自己所需的服务。 \3. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 \4. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 \5. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 解决跨域问题?JSONP–&gt;Script Tags 秒杀方案：1、把商品的数量放到redis中。 2、秒杀时使用decr命令对商品数量减一。如果不是负数说明抢到。 3、一旦返回数值变为0说明商品已售完。 ZOOKeeper?Zookeeper 作为一个分布式的服务框架，主要用来解决分布式集群中应用系统的一致性问题，它能提供基于类似于文件系统的目录节点树方式的数据存储，但是 Zookeeper 并不是用来专门存储数据的，它的作用主要是用来维护和监控你存储的数据的状态变化。 通过监控这些数据状态的变化，从而可以达到基于数据的集群管理 注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力小。使用dubbo-2.3.3以上版本，建议使用zookeeper注册中心。 Zookeeper是Apacahe Hadoop的子项目，是一个树型的目录服务，支持变更推送，适合作为Dubbo服务的注册中心，工业强度较高，可用于生产环境，并推荐使用 ActiveMQ的消息形式一种是点对点的，即一个生产者和一个消费者一一对应；可进行缓存,只允许单人登录查看 另一种是发布/订阅模式，即一个生产者产生消息并进行发送后，可以由多个消费者进行接收。无法进行缓存,支持多人访问. JMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。 StreamMessage – Java原始值的数据流 MapMessage–一套名称-值对 TextMessage–一个字符串对象 ObjectMessage–一个序列化的 Java对象 BytesMessage–一个字节的数据流 1.订单系统 1.1.功能分析 1、在购物车页面点击“去结算”按钮跳转到订单确认页面。 a)展示商品列表 b)配送地址列表 c)选择支付方式 2、展示订单确认页面之前，应该确认用户身份。 a)使用拦截器实现。 b)Cookie中取token c)取不到token跳转到登录页面 d)取到token，根据token查询用户信息。 e)如果没有用户信息，登录过期跳转到登录页面 f)取到用户信息，放行。 3、提交订单 a)生成订单 b)展示订单提交成功页面。 订单系统系统：订单确认页面、订单提交成功页面。 订单服务系统 1.1.展示订单确认页面 1.1.1.功能分析 1、在购物车页面点击“去结算”按钮跳转到订单确认页面。 2、请求的url： /order/order-cart 3、参数：没有参数。 4、购物车商品数据从cookie中取出来的。可以在订单系统中取到cookie中的购物车数据。 5、配送地址列表，需要用户登录。需要根据用户id查询收货地址列表。静态数据。 6、支付方式。静态数据。 7、返回值：逻辑视图String，展示订单确认页面。 1.1.2.Dao层、Service层（没有） 需要根据用户id查询收货地址列表。没有此功能。 1.1.3.表现层 请求的url：/order/order-cart 参数：无 业务逻辑： 从cookie中取商品列表展示到页面。 返回值：逻辑视图。 1.1.用户身份认证 在展示订单确认页面之前，需要对用户身份进行认证，要求用户必须登录。 1.1.1.功能分析 1、使用springmvc的拦截器实现。需要实现一个接口HandlerInterceptor接口。 2、业务逻辑 a)从cookie中取token。 b)没有token，需要跳转到登录页面。 c)有token。调用sso系统的服务，根据token查询用户信息。 d)如果查不到用户信息。用户登录已经过期。需要跳转到登录页面。 e)查询到用户信息。放行。 3、在springmvc.xml中配置拦截器。 1.1.2.拦截器实现 1.1.1.功能分析 1、在订单确认页面点击“提交订单”按钮生成订单。 2、请求的url：/order/create 3、参数：提交的是表单的数据。保存的数据：订单、订单明细、配送地址。 a)向tb_order中插入记录。 i.订单号需要手动生成。 要求订单号不能重复。 订单号可读性号。 可以使用redis的incr命令生成订单号。订单号需要一个初始值。 ii.Payment：表单数据 iii.payment_type：表单数据 iv.user_id：用户信息 v.buyer_nick：用户名 vi.其他字段null b)向tb_order_item订单明细表插入数据。 i.Id：使用incr生成 ii.order_id：生成的订单号 iii.其他的都是表单中的数据。 c)tb_order_shipping，订单配送信息 i.order_id：生成的订单号 ii.其他字段都是表单中的数据。 d)使用pojo接收表单的数据。 可以扩展TbOrder，在子类中添加两个属性一个是商品明细列表，一个是配送信息。 把pojo放到taotao-order-interface工程中。 业务逻辑： 1、接收表单的数据 2、生成订单id 3、向订单表插入数据。 4、向订单明细表插入数据 5、向订单物流表插入数据。 6、返回TaotaoResult。 返回值：TaotaoResult 1.1.1.Dao层 可以使用逆向工程。 1.1.2.Service层 参数：OrderInfo 单点登录单点登录就是我们是做了分布式，tomcat集群之后会有session复制的问题，影响利群数量。所以把注册登录拿出来单独做了一个单点登录系统。做的时候是用的redis，key是用uuid生成的一个token,类似于session id,是用户的唯一标识，value是用户的信息。设置了有效期是7天。然后把redis放到了cookie中，实现了cookie的二级跨域。当我们进行操作时，首先要从cookie里面取出token如果取不到，就跳到单点登录系统进行登录操作如果取到了，再看看token有没有过期，如果过期了，也是跳到单点登录系统登录一下，没过期就继续用户的操作。密码进行了加密，用Md5 HashMap 和 HashTable 的区别1）容器整体结构： HashMap的key和value都允许为null，HashMap遇到key为null的时候，调用putForNullKey方法进行处理，而对value没有处理。 Hashtable的key和value都不允许为null。Hashtable遇到null，直接返回NullPointerException。 2） 容量设定与扩容机制： HashMap默认初始化容量为 16，并且容器容量一定是2的n次方，扩容时，是以原容量 2倍 的方式 进行扩容。 Hashtable默认初始化容量为 11，扩容时，是以原容量 2倍 再加 1的方式进行扩容。即int newCapacity = (oldCapacity &lt;&lt; 1) + 1;。 3） 散列分布方式（计算存储位置）： HashMap是先将key键的hashCode经过扰动函数扰动后得到hash值，然后再利用 hash &amp; (length - 1)的方式代替取模，得到元素的存储位置。 Hashtable则是除留余数法进行计算存储位置的（因为其默认容量也不是2的n次方。所以也无法用位运算替代模运算），int index = (hash &amp; 0x7FFFFFFF) % tab.length;。 由于HashMap的容器容量一定是2的n次方，所以能使用hash &amp; (length - 1)的方式代替取模的方式计算元素的位置提高运算效率，但Hashtable的容器容量不一定是2的n次方，所以不能使用此运算方式代替。 4）线程安全（最重要）： HashMap 不是线程安全，如果想线程安全，可以通过调用synchronizedMap(Map&lt;K,V&gt; m)使其线程安全。但是使用时的运行效率会下降，所以建议使用ConcurrentHashMap容器以此达到线程安全。 Hashtable则是线程安全的，每个操作方法前都有synchronized修饰使其同步，但运行效率也不高，所以还是建议使用ConcurrentHashMap容器以此达到线程安全。 因此，Hashtable是一个遗留容器，如果我们不需要线程同步，则建议使用HashMap，如果需要线程同步，则建议使用ConcurrentHashMap。 ArrayList和LinkedList 的区别 LinkedList内部存储的是Node&lt;E&gt;，不仅要维护数据域，还要维护prev和next，如果LinkedList中的结点特别多，则LinkedList比ArrayList更占内存。 插入删除操作效率：LinkedList在做插入和删除操作时，插入或删除头部或尾部时是高效的，操作越靠近中间位置的元素时，需要遍历查找，速度相对慢一些，如果在数据量较大时，每次插入或删除时遍历查找比较费时。所以LinkedList插入与删除，慢在遍历查找，快在只需要更改相关结点的引用地址。ArrayList在做插入和删除操作时，插入或删除尾部时也一样是高效的，操作其他位置，则需要批量移动元素，所以ArrayList插入与删除，快在遍历查找，慢在需要批量移动元素。 循环遍历效率： 由于ArrayList实现了RandomAccess随机访问接口，所以使用for(int i = 0; i &lt; size; i++)遍历会比使用Iterator迭代器来遍历快 而由于LinkedList未实现RandomAccess接口，所以推荐使用Iterator迭代器来遍历数据。 因此，如果我们需要频繁在列表的中部改变插入或删除元素时，建议使用LinkedList，否则，建议使用ArrayList，因为ArrayList遍历查找元素较快，并且只需存储元素的数据域，不需要额外记录其他数据的位置信息，可以节省内存空间。]]></content>
      <categories>
        <category>Java 面试精髓</category>
      </categories>
      <tags>
        <tag>面试精髓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试感悟：工作经验java程序员应有的技能]]></title>
    <url>%2F2017%2F12%2F10%2F%E9%9D%A2%E8%AF%95%E6%84%9F%E6%82%9F%EF%BC%9A%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8Cjava%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E6%9C%89%E7%9A%84%E6%8A%80%E8%83%BD%2F</url>
    <content type="text"><![CDATA[面试感悟：工作经验java程序员应有的技能前言因为和同事有约定再加上LZ自己也喜欢做完一件事之后进行总结，因此有了这篇文章。这篇文章大部分内容都是面向整个程序员群体的，当然因为LZ本身是做Java开发的，因此有一部分内容也是专门面向咱们Java程序员的。 简单先说一下，LZ坐标杭州，13届本科毕业，算上年前在阿里巴巴B2B事业部的面试，一共有面试了有6家公司（因为LZ不想请假，因此只是每个晚上去其他公司面试，所以面试的公司比较少），其中成功的有4家，另外两家失败的原因在于： 1、阿里巴巴B2B事业部的面试，两轮技术面试都过了，最后一轮面试是对方的主管，由于听说技术面试过了基本上90%都面试成功了，所以LZ在和主管的交谈中也是毫无顾忌，说得天花乱坠，很多自己介于知道和不知道的东西都直接脱口而出了，结果多次被对方一反问就问得哑口无言。事后想来，模棱两可的答案是面试中最忌讳的，这次的失败也让LZ认真地对待后面的每一次面试 2、另外一家失败的是一家小公司，也就20来个人吧，整个团队是支付宝出来创业的，非常厉害。面试完LZ多方了解了一下，对方认为我基本功什么的都不错，但是实际项目经验还是欠缺一些，因为对方是创业型公司，需要人上手就能干活，因此我在这个时候还不是特别适合他们团队 至于其他成功的四家公司，给LZ的面试评价都挺高的貌似，但LZ也不想记流水账，因此就不一一列举每家公司的面试过程了，下面LZ主要谈谈作为一名工作三年左右的Java程序员应该具备的一些技能以及个人的一些其他感悟。 关于程序员的几个阶段每个程序员、或者说每个工作者都应该有自己的职业规划，如果看到这里的朋友没有自己的职业规划，希望你可以思考一下自己的将来。 LZ常常思考自己的未来，也从自己的思考中总结出了一些东西，作为第一部分来谈谈。LZ认为一名程序员应该有几个阶段（以下时间都算上实习期）： 第一阶段：三年 我认为三年对于程序员来说是第一个门槛，这个阶段将会淘汰掉一批不适合写代码的人。这一阶段，我们走出校园，迈入社会，成为一名程序员，正式从书本上的内容迈向真正的企业级开发。我们知道如何团队协作、如何使用项目管理工具、项目版本如何控制、我们写的代码如何测试如何在线上运行等等，积累了一定的开发经验，也对代码有了一定深入的认识，是一个比较纯粹的Coder的阶段 第二阶段：五年 五年又是区分程序员的第二个门槛。有些人在三年里，除了完成工作，在空余时间基本不会研究别的东西，这些人永远就是个Coder，年纪大一些势必被更年轻的人给顶替；有些人在三年里，除了写代码之外，还热衷于研究各种技术实现细节、看了N多好书、写一些博客、在Github上分享技术，这些人在五年后必然具备在技术上独当一面的能力并且清楚自己未来的发展方向，从一个Coder逐步走向系统分析师或是架构师，成为项目组中不可或缺的人物 第三阶段：十年 十年又是另一个门槛了，转行或是继续做一名程序员就在这个节点上。如果在前几年就抱定不转行的思路并且为之努力的话，那么在十年的这个节点上，有些人必然成长为一名对行业有着深入认识、对技术有着深入认识、能从零开始对一个产品进行分析的程序员，这样的人在公司基本担任的都是CTO、技术专家、首席架构师等最关键的职位，这对于自己绝对是一件荣耀的事，当然老板在经济上也绝不会亏待你 第一部分总结一下，我认为，随着你工作年限的增长、对生活对生命认识的深入，应当不断思考三个问题： 1、我到底适不适合当一名程序员？ 2、我到底应不应该一辈子以程序员为职业？ 3、我对编程到底持有的是一种什么样的态度，是够用就好呢还是不断研究？ 最终，明确自己的职业规划，对自己的规划负责并为之努力。 关于项目经验LZ在网上经常看到一些别的朋友有提出项目经验的问题，依照LZ面试的感觉来说，面试主要看几点：项目经验+基本技术+个人潜力（也就是值不值得培养）。 关于项目经验，我认为并发编程网的创始人方腾飞老师讲的一段话非常好： 介绍产品时面试官会考察应聘者的沟通能力和思考能力，我们大部分情况都是做产品的一个功能或一个模块，但是即使是这样，自己有没有把整个系统架构或产品搞清楚，并能介绍清楚，为什么做这个系统？这个系统的价值是什么？这个系统有哪些功能？优缺点有哪些？如果让你重新设计这个系统你会如何设计？ 我觉得这就已经足以概括了。也许你仅仅工作一年，也许你做的是项目中微不足道的模块，当然这些一定是你的劣势且无法改变，但是如何弥补这个劣势，从方老师的话中我总结几点： 1、明确你的项目到底是做什么的，有哪些功能 2、明确你的项目的整体架构，在面试的时候能够清楚地画给面试官看并且清楚地指出从哪里调用到哪里、使用什么方式调用 3、明确你的模块在整个项目中所处的位置及作用 4、明确你的模块用到了哪些技术，更好一些的可以再了解一下整个项目用到了哪些技术 在你无法改变自己的工作年限、自己的不那么有说服力的项目经验的情况下（这一定是扣分项），可以通过这种方式来一定程度上地弥补并且增进面试官对你的好感度。 关于专业技能写完项目接着写写一名3年工作经验的Java程序员应该具备的技能，这可能是Java程序员们比较关心的内容。我这里要说明一下，以下列举的内容不是都要会的东西—-但是如果你掌握得越多，最终能得到的评价、拿到的薪水势必也越高。 1、基本语法 这包括static、final、transient等关键字的作用，foreach循环的原理等等。今天面试我问你static关键字有哪些作用，如果你答出static修饰变量、修饰方法我会认为你合格，答出静态块，我会认为你不错，答出静态内部类我会认为你很好，答出静态导包我会对你很满意，因为能看出你非常热衷研究技术。 最深入的一次，LZ记得面试官直接问到了我Volatile关键字的底层实现原理（顺便插一句，面试和被面试本身就是相对的，面试官能问这个问题同时也让面试者感觉到面试官也是一个喜爱研究技术的人，增加了面试者对公司的好感，LZ最终选择的就是问了这个问题的公司），不要觉得这太吹毛求疵了—-越简单的问题越能看出一个人的水平，别人对你技术的考量绝大多数都是以深度优先、广度次之为标准的，切记。 2、集合 非常重要，也是必问的内容。基本上就是List、Map、Set，问的是各种实现类的底层实现原理，实现类的优缺点。 集合要掌握的是ArrayList、LinkedList、Hashtable、HashMap、ConcurrentHashMap、HashSet的实现原理，能流利作答，当然能掌握CopyOnWrite容器和Queue是再好不过的了。另外多说一句，ConcurrentHashMap的问题在面试中问得特别多，大概是因为这个类可以衍生出非常多的问题，关于ConcurrentHashMap，我给网友朋友们提供三点回答或者是研究方向： （1）ConcurrentHashMap的锁分段技术 （2）ConcurrentHashMap的读是否要加锁，为什么 （3）ConcurrentHashMap的迭代器是强一致性的迭代器还是弱一致性的迭代器 3、设计模式 本来以为蛮重要的一块内容，结果只在阿里巴巴B2B事业部面试的时候被问了一次，当时问的是装饰器模式。 当然咱们不能这么功利，为了面试而学习，设计模式在工作中还是非常重要、非常有用的，23种设计模式中重点研究常用的十来种就可以了，面试中关于设计模式的问答主要是三个方向： （1）你的项目中用到了哪些设计模式，如何使用 （2）知道常用设计模式的优缺点 （3）能画出常用设计模式的UML图 4、多线程 这也是必问的一块了。因为三年工作经验，所以基本上不会再问你怎么实现多线程了，会问得深入一些比如说Thread和Runnable的区别和联系、多次start一个线程会怎么样、线程有哪些状态。当然这只是最基本的，出乎意料地，几次面试几乎都被同时问到了一个问题，问法不尽相同，总结起来是这么一个意思： 假如有Thread1、Thread2、ThreaD3、Thread4四条线程分别统计C、D、E、F四个盘的大小，所有线程都统计完毕交给Thread5线程去做汇总，应当如何实现？ 聪明的网友们对这个问题是否有答案呢？不难，java.util.concurrent下就有现成的类可以使用。 另外，线程池也是比较常问的一块，常用的线程池有几种？这几种线程池之间有什么区别和联系？线程池的实现原理是怎么样的？实际一些的，会给你一些具体的场景，让你回答这种场景该使用什么样的线程池比较合适。 最后，虽然这次面试问得不多，但是多线程同步、锁这块也是重点。synchronized和ReentrantLock的区别、synchronized锁普通方法和锁静态方法、死锁的原理及排查方法等等，关于多线程，我在之前有些过文章总结过多线程的40个问题，可以参看40个Java多线程问题总结。 5、JDK源码 要想拿高工资，JDK源码不可不读。上面的内容可能还和具体场景联系起来，JDK源码就是实打实地看你平时是不是爱钻研了。LZ面试过程中被问了不少JDK源码的问题，其中最刁钻的一个问了LZ，String的hashCode()方法是怎么实现的，幸好LZ平时String源代码看得多，答了个大概。JDK源码其实没什么好总结的，纯粹看个人，总结一下比较重要的源码： （1）List、Map、Set实现类的源代码 （2）ReentrantLock、AQS的源代码 （3）AtomicInteger的实现原理，主要能说清楚CAS机制并且AtomicInteger是如何利用CAS机制实现的 （4）线程池的实现原理 （5）Object类中的方法以及每个方法的作用 这些其实要求蛮高的，LZ去年一整年基本把JDK中重要类的源代码研究了个遍，真的花费时间、花费精力，当然回头看，是值得的—-不仅仅是为了应付面试。 6、框架 老生常谈，面试必问的东西。一般来说会问你一下你们项目中使用的框架，然后给你一些场景问你用框架怎么做，比如我想要在Spring初始化bean的时候做一些事情该怎么做、想要在bean销毁的时候做一些事情该怎么做、MyBatis中$和#的区别等等，这些都比较实际了，平时积累得好、有多学习框架的使用细节自然都不成问题。 如果上面你的问题答得好，面试官往往会深入地问一些框架的实现原理。问得最多的就是Spring AOP的实现原理，当然这个很简单啦，两句话就搞定的的事儿，即使你不会准备一下就好了。LZ遇到的最变态的是让LZ画一下Spring的Bean工厂实现的UML图，当然面对这样一个有深度的问题，LZ是绝对答不出来的/(ㄒoㄒ)/~~ 7、数据库 数据库十有八九也都会问到。一些基本的像union和union all的区别、left join、几种索引及其区别就不谈了，比较重要的就是数据库性能的优化，如果对于数据库的性能优化一窍不通，那么有时间，还是建议你在面试前花一两天专门把SQL基础和SQL优化的内容准备一下。 不过数据库倒是不用担心，一家公司往往有很多部门，如果你对数据库不熟悉而基本技术又非常好，九成都是会要你的，估计会先把你放到对数据库使用不是要求非常高的部门锻炼一下。 8、数据结构和算法分析 数据结构和算法分析，对于一名程序员来说，会比不会好而且在工作中绝对能派上用场。数组、链表是基础，栈和队列深入一些但也不难，树挺重要的，比较重要的树AVL树、红黑树，可以不了解它们的具体实现，但是要知道什么是二叉查找树、什么是平衡树，AVL树和红黑树的区别。记得某次面试，某个面试官和我聊到了数据库的索引，他问我： 你知道索引使用的是哪种数据结构实现吗？ LZ答到用的Hash表吧，答错。他又问，你知道为什么要使用树吗？LZ答到因为Hash表可能会出现比较多的冲突，在千万甚至是上亿级别的数据面前，会大大增加查找的时间复杂度。而树比较稳定，基本保证最多二三十次就能找到想要的数据，对方说不完全对，最后我们还是交流了一下这个问题，我也明白了为什么要使用树，这里不说，网友朋友们觉得索引为什么要使用树来实现呢？ 至于算法分析，不会、不想研究就算了，记得某次面试对方问我，Collections.sort方法使用的是哪种排序方法，额，吐血三升。当然为了显示LZ的博学，对算法分析也有一定的研究(⊙﹏⊙)b，LZ还是硬着头皮说了一句可能是冒泡排序吧。当然答案肯定不是，有兴趣的网友朋友们可以去看一下Collections.sort方法的源代码，用的是一种叫做TimSort的排序法，也就是增强型的归并排序法。 9、Java虚拟机 出乎LZ的意料，Java虚拟机应该是很重要的一块内容，结果在这几家公司中被问到的概率几乎为0。要知道，LZ去年可是花了大量的时间去研究Java虚拟机的，光周志明老师的《深入理解Java虚拟机：JVM高级特性与最佳实践》，LZ就读了不下五遍。 言归正传，虽然Java虚拟机没问到，但我觉得还是有必要研究的，LZ就简单地列一个提纲吧，谈谈Java虚拟机中比较重要的内容： （1）Java虚拟机的内存布局 （2）GC算法及几种垃圾收集器 （3）类加载机制，也就是双亲委派模型 （4）Java内存模型 （5）happens-before规则 （6）volatile关键字使用规则 也许面试无用，但在走向大牛的路上，不可不会。 10、Web方面的一些问题 Java主要面向Web端，因此Web的一些问题也是必问的。LZ碰到过问得最多的两个问题是： 谈谈分布式Session的几种实现方式 常用的四种能答出来自然是让面试官非常满意的，另外一个常问的问题是： 讲一下Session和Cookie的区别和联系以及Session的实现原理 这两个问题之外，web.xml里面的内容是重点，Filter、Servlet、Listener，不说对它们的实现原理一清二楚吧，至少能对它们的使用知根知底。另外，一些细节的方面比如get/post的区别、forward/重定向的区别、HTTPS的实现原理也都可能会被考察到。 噢，想起来了，一致性Hash算法貌似也被问到了几次，这个LZ以前专门深入研究过并且写了两篇博文，因此问到这个问题LZ自然是答得毫不费力。文章是MemCache超详细解读和对一致性Hash算法，Java代码实现的深入研究，特别说明，LZ真的不是在为自已以前写的文章打广告啊啊啊啊啊啊。 最后，如果有兴趣有时间，建议学习、研究一下SOA和RPC，面向服务体系，大型分布式架构必备，救命良方、包治百病、屡试不爽。 关于HR面试如果你过五关斩六将，成功地通过了所有的技术面，那么恭喜你，你离升职加薪、出任CEO、迎娶白富美、走向人生巅峰又进了一步。但是还没有到谈薪资待遇的时候，最后还有一个考验：HR面试。基本所有的大公司都有这一轮的面试，不要小看HR面试，很多公司的HR对于面试者都有一票否决权的—-即使前面的面试对你的评价再高。 所以，这轮的面试也必须重视起来，HR面试主要问的是几点： 1、简历中写的过去工作经历的离职原因 2、当前公司薪资待遇 3、期望能到怎样的一家公司 4、个人未来的发展方向 我专门提一下第2点。可能有人比较排斥也不想说这个，我个人倒是持开放状态，问了就说了，当然一些的夸大还是必要的，当前公司薪资待遇多报个一千块钱完全没问题（毕竟是一家互联网公司总多多少少有些补贴啊什么的嘛）。因为这和你在新公司能拿到的薪水关系不大，新公司能拿到的薪水的决定因素是整个公司的薪资情况以及根据你的面试情况在公司的定位，都是有固定的薪资范围的。HR问这个主要也就是心里有个数并且看你是否诚信—-有些公司入职时会要求你提供最近一家单位的银行流水号。 HR面试就说到这里了，总结起来其实就是四个字：滴水不漏。整个面试过程态度积极向上，不要有任何悲观消极的态度（尤其在谈到以前公司情况的时候，即使有再多的不满），就不会有问题。 关于面试心态这个嘛，LZ其实在公司也面试过几个人，一半以上的面试者回答问题的时候都属于那种双腿发抖、声音颤抖的类型。在LZ看来这大可不必并且这还是扣分项，回答问题的时候最最基本的两个要求： 1、不紧不慢，平心静气 2、条理清晰 表达能力绝对是面试的时候重要的考察项目。咱们做的是程序员这一行，讲究的是团队协作，不是写作、画画，一支笔、一个人就行了，一个表达能力不行的程序员，要来又有什么用呢？ 除此之外，就是保持良好的心态。古语说得好，只要功夫深，铁杵磨成针，面试的成功与否，在于平时的积累，临时抱抱佛脚，看两道面试题是没有用的，只要平时足够努力，成功是水到渠成的事情，平时不怎么研究技术的，那也就是个听天由命的事情，只要充分地展示平时自己的所学就可以了。 因此在我看来，不要把面试当作面试，当做一次技术交流，把面试的心态从我要找到一份工作转变为我要通过面试去发现不足、提升自己，这样就会平和多了，即使失败也不会有太多失望的感觉。 另外，如果平时自己热衷于研究技术的朋友，真的要有自信，不要觉得别人面试你别人就比你厉害。面试官未必比你优秀，他问的问题往往都是他平时研究得比较多的问题，你一样有很多自己的研究面试官未必知道。 关于Java网上常看到一种说法：Java比较简单。某种程度上这会打击Java程序员的信心—-原来咱们平时用的是这种小儿科的玩意儿啊，在我看来这种想法大可不必，这一部分我来讲讲对于这个话题的看法。 这种说法有些片面，得分开两部分来看，我用四个自总结一下就是：易学难精。 1、易学部分 Java易学我认为有两部分的原因： （1）很多培训公司包括大四的学生找工作都会学习Java，绝大多数是因为易学。Java从C/C++发展而来，感谢前人的智慧，它消除了C/C++中最复杂和让人困惑的语法、它消除了平台的差异性、它不需要用户手动释放内存空间、它避免了Java程序员和本地语言的交互，让程序员只需要专注于语法层面和应用层面。 （2）Java作为一门面向对象的语言，在企业级开发中体现出了它无与伦比的特性，整个开发流程比较固定化、模块化，需求分析起来也相对容易。我举个自己以前的例子吧，我在大一学习C语言的时候，用C语言写了一个图书管理系统写了2000+的代码，大四学了C++之后，用面向对象的语言C++取代面向过程的语言C语言重新写了一个功能相似的图书管理系统，只写了1100行的样子，这就是面向对象的优势。 2、难精部分 接着咱们聊聊难精的部分。 Java语言的设计者帮助Java程序员做了这么多事情，这有利也有弊。有利的部分前面已经说过了，让Java易学，不过有弊的部分同样明显。假如在应用运行过程中遇到了语法层面和应用层面之外的错误，应当如何处理？比如线上环境出现内存溢出怎么办？GC时间过长怎么办？IO长时间没反应怎么办？方法抛出莫名其妙的异常怎么办？ 凡此种种，绝不是一名只会写几个if…else…的Java程序员就可以解决的，这需要大量的经历、大量的实践、大量对Java底层实现细节的研究，而这往往是最难、最考验Java程序员的部分，一些人根本就不想往深去研究，另外一些人研究了一点点就研究不下去了。 Java为什么难精？就是这个原因。除非你水平特别高，否则五年工作经验以下的Java程序员在简历上写”精通Java”绝对是一件非常愚蠢的事情。 结语文章写到这里，感觉有点像鸡汤文了，那就以最后的鸡汤作为结尾吧。 在以前博客园的一篇文章中，讲到了奔三程序员的困惑，大致说的是三十岁之后程序员要转行之类的云云，LZ在博文中留下了如下的评论： 就以这段话自勉、共勉吧。越努力、越幸运，如果你不是官二代、富二代、红二代，那么请记住：勤奋才是改变你命运的唯一捷径。]]></content>
      <categories>
        <category>工作经验java程序员应有的技能</category>
      </categories>
      <tags>
        <tag>面试精髓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedList 源码分析]]></title>
    <url>%2F2017%2F12%2F09%2FLinkedList%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[LinkedList 源码分析前言有了ArrayList，自然少不了LinkedList了。 下面我就以面试问答的形式学习我们的常用的装载容器——LinkedList（源码分析基于JDK8） 问答内容LinkedList 用来做什么，怎么使用？问：请简单介绍一下您所了解的LinkedList，它可以用来做什么，怎么使用？ 答： LinkedList底层是双向链表，同时实现了List接口和Deque接口，所以它既可以看作是一个顺序容器，也可以看作是一个队列(Queue)，同时也可以看作是一个栈(Stack)，但如果想使用栈或队列等数据结构的话，推荐使用ArrayDeque，它作为栈或队列会比LinkedList有更好的使用性能。 示例代码： 12345678910111213141516171819// 创建一个LinkedList，链表的每个节点的内存空间都是实时分配的，所以无须事先指定容器大小LinkedList&lt;String&gt; linkedList = new LinkedList&lt;String&gt;();// 往容器里面添加元素linkedList.add("张三");linkedList.add("李四");// 在张三与李四之间插入一个王五linkedList.add(1, "王五");// 在头部插入一个小三linkedList.addFirst("小三");// 获取index下标为2的元素 王五String element = linkedList.get(2);// 修改index下标为2的元素 王五 为小四linkedList.set(2, "小四");// 删除index下标为1的元素 张三String removeElement = linkedList.remove(1);// 删除第一个元素String removeFirstElement = linkedList.removeFirst();// 删除最后一个元素String removeLastElement = linkedList.removeLast(); LinkedList底层实现是双向链表，核心组成元素有：int size = 0用于记录链表长度；Node&lt;E&gt; first;用于记录头（第一个）结点（储存的是头结点的引用）；Node&lt;E&gt; last;用于记录尾（最后一个）结点（储存的是尾结点的引用）。 示例代码： 123456789101112131415161718192021public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123; // 记录链表长度 transient int size = 0; /** * Pointer to first node. 指向第一个结点 * Invariant: (first == null &amp;&amp; last == null) || * (first.prev == null &amp;&amp; first.item != null) */ transient Node&lt;E&gt; first; /** * Pointer to last node. 指向最后一个结点 * Invariant: (first == null &amp;&amp; last == null) || * (last.next == null &amp;&amp; last.item != null) */ transient Node&lt;E&gt; last;&#125; 双向链表的核心组成元素还有一个最重要的Node&lt;E&gt;，Node&lt;E&gt;包含：E item; 用于存储元素数据，Node&lt;E&gt; next; 指向当前元素的后继结点，Node&lt;E&gt; prev; 指向当前元素的前驱结点。 示例代码： 1234567891011121314151617/** * 定义LinkedList底层的结点实现 */private static class Node&lt;E&gt; &#123; E item; // 存储元素数据 Node&lt;E&gt; next;// 指向当前元素的后继结点 Node&lt;E&gt; prev;// 指向当前元素的前驱结点 /** * Node结点构造方法 */ Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element;// 存储的元素 this.next = next;// 后继结点 this.prev = prev;// 前驱结点 &#125;&#125; 双向链表底层实现，图片来自网络 上图中的head即Node first; tail即Node last; LinkedList 的操作和对应的时间复杂度。问：请分别分析一下它是如何获取元素，修改元素，新增元素与删除元素，并分析这些操作对应的时间复杂度。 答： 获取元素：LinkedList提供了三种获取元素的方法，分别是： 获取第一个元素getFirst()，获取第一个元素，直接返回Node&lt;E&gt; first指向的结点即可，所以时间复杂度为O(1)。 获取最后一个元素getLast()，获取最后一个元素，直接返回Node&lt;E&gt; last指向的结点即可，所以时间复杂度也为O(1)。 获取指定索引index位置的元素get(int index)，由于Node&lt;E&gt;结点在内存中存储的空间不是连续存储的，所以查找某一位置的结点，只能通过遍历链表的方式查找结点，因此LinkedList会先通过判断index &lt; (size &gt;&gt; 1)，size&gt;&gt;1即为size/2当前链表长度的一半，判断index的位置是在链表的前半部分还是后半部分。决定是从头部遍历查找数据还是从尾部遍历查找数据。最坏情况下，获取中间元素，则需要遍历n/2次才能获取到对应元素，所以此方法的时间复杂度为O(n)。 综上所述，LinkedList获取元素的时间复杂度为O(n)。 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 返回列表中指定位置的元素 * * @param index 指定index位置 * @return 返回指定位置的元素 * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E get(int index) &#123; // 检查index下标是否合法[0,size) checkElementIndex(index); // 遍历列表获取对应index位置的元素 return node(index).item;&#125;/** * 检查下标是否合法 */private void checkElementIndex(int index) &#123; if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;private boolean isElementIndex(int index) &#123; return index &gt;= 0 &amp;&amp; index &lt; size;&#125;/** * 返回指定位置的结点元素（重点） */Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); // 判断index位置是在链表的前半部分还是后半部分 if (index &lt; (size &gt;&gt; 1)) &#123; // 从头结点开始，从前往后遍历找到对应位置的结点元素 Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; // 从尾结点开始，从后往前遍历找到对应位置的结点元素 Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 修改元素：LinkedList提供了一种修改元素数据的方法set(int index, E element)，修改元素数据的步骤是：1.检查index索引是否合法[0,size)。2.折半查询获取对应索引元素。3.将新元素赋值，返回旧元素。由获取元素的分析可知，折半查询的时间复杂度为O(n)，故修改元素数据的时间复杂度为O(n)。 示例代码： 123456789101112131415161718/** * 修改指定位置结点的存储数据 * * @param index 指定位置 * @param element 修改的存储数据 * @return 返回未修改前的存储数据 * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E set(int index, E element) &#123; // 检查index下标是否合法[0,size) checkElementIndex(index); // 折半查询获取对应索引元素 Node&lt;E&gt; x = node(index); // 将新元素赋值，返回旧元素 E oldVal = x.item; x.item = element; return oldVal;&#125; 新增元素：LinkedList提供了四种新增元素的方法，分别是： 将指定元素插入到链表的第一个位置中addFirst(E e)，只需将头结点first指向新元素结点，将原第一结点的前驱指针指向新元素结点即可。不需要移动原数据存储位置，只需交换一下相关结点的指针域信息即可。所以时间复杂度为O(1)。 将指定元素插入到链表的最后一个位置中addLast(E e)，只需将尾结点last指向新元素结点，将原最后一个结点的后继指针指向新元素结点即可。不需要移动原数据存储位置，只需交换一下相关结点的指针域信息即可。所以时间复杂度也为O(1)。 添加元素方法add(E e) 等价于addLast(E e)。 将指定元素插入到链表的指定位置index中add(int index, E element)，需要先根据位置index调用node(index)遍历链表获取该位置的原结点，然后将新结点插入至原该位置结点的前面，不需要移动原数据存储位置，只需交换一下相关结点的指针域信息即可。所以时间复杂度也为O(1)。 综上所述，LinkedList新增元素的时间复杂度为O(1)，单纯论插入新元素，操作是非常高效的，特别是插入至头部或插入到尾部。但如果是通过索引index的方式插入，插入的位置越靠近链表中间所费时间越长，因为需要对链表进行遍历查找。 添加元素结点示意图，图片来自《大话数据结构》 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134/** * 将指定元素插入到链表的第一个位置中 * * @param e 要插入的元素 */public void addFirst(E e) &#123; linkFirst(e);&#125;/** * 将元素e作为第一个元素 */private void linkFirst(E e) &#123; // 获取原头结点 final Node&lt;E&gt; f = first; // 初始化新元素结点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); // 头指针指向新元素结点 first = newNode; // 如果是第一个元素（链表为空） if (f == null) // 将尾指针也指向新元素结点 last = newNode; else // 链表不会空 // 原头结点的前驱指针指向新结点 f.prev = newNode; // 记录链表长度的size + 1 size++; modCount++;&#125;/** * 将指定元素插入到链表的最后一个位置中 * * &lt;p&gt;此方法等同与add(E e)方法 &#123;@link #add&#125;. * * @param e 要插入的元素 */public void addLast(E e) &#123; linkLast(e);&#125;/** * 将指定元素插入到链表的最后一个位置中 * * &lt;p&gt;此方法等同与addLast(E e)方法 &#123;@link #addLast&#125;. * * @param e 要插入的元素 * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;) */public boolean add(E e) &#123; linkLast(e); return true;&#125;/** * 将元素e作为最后一个元素 */void linkLast(E e) &#123; // 获取原尾结点 final Node&lt;E&gt; l = last; // 初始化新元素结点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); // 位指针指向新元素结点 last = newNode; // 如果是第一个元素（链表为空） if (l == null) // 将头指针也指向新元素结点 first = newNode; else // 链表不会空 // 原尾结点的后继指针指向新结点 l.next = newNode; // 记录链表长度的size + 1 size++; modCount++;&#125;/** * 将指定元素插入到链表的指定位置index中 * * @param index 元素要插入的位置index * @param element 要插入的元素 * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public void add(int index, E element) &#123; // 检查插入位置是否合法[0,size] checkPositionIndex(index); // 如果插入的位置和当前链表长度相等，则直接将元素插入至链表的尾部 if (index == size) // 将元素插入至链表的尾部 linkLast(element); else //将元素插入至指定位置,node(index)先获取占有该index位置的原结点 linkBefore(element, node(index));&#125;/** * 检查位置是否合法 */private void checkPositionIndex(int index) &#123; if (!isPositionIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;/** * 检查位置是否合法 */private boolean isPositionIndex(int index) &#123; //合法位置为[0,size] return index &gt;= 0 &amp;&amp; index &lt;= size;&#125;/** * 将新元素e插入至旧元素succ前面 */void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; // 记录旧元素结点succ的前驱指针 final Node&lt;E&gt; pred = succ.prev; // 初始化新元素结点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); // 旧元素结点的前驱指针指向新元素结点(即新元素结点放至在旧元素结点的前面，取代了原本旧元素的位置) succ.prev = newNode; // 如果旧元素结点的前驱指针为空，则证明旧元素结点是头结点， // 将新元素结点插入至旧元素结点前面，所以现时新的头结点是新元素结点 if (pred == null) first = newNode; else //不是插入至头部 // 旧元素的前驱结点的后继指针指向新元素结点 pred.next = newNode; // 记录链表长度的size + 1 size++; modCount++;&#125; 删除元素：LinkedList提供了四种删除元素的方法，分别是： 删除链表中的第一个元素removeFirst()，只需将头结点first指向删除元素结点的后继结点并将其前驱结点指针信息prev清空即可。不需要移动原数据存储位置，只需操作相关结点的指针域信息即可。所以时间复杂度为O(1)。 删除链表中的最后一个元素removeLast()，只需将尾结点last指向删除元素结点的前驱结点并将其后继结点指针信息next清空即可。不需要移动原数据存储位置，只需操作相关结点的指针域信息即可，所以时间复杂度也为O(1)。 将指定位置index的元素删除remove(int index)，需要先根据位置index调用node(index)遍历链表获取该位置的原结点，然后将删除元素结点的前驱结点的next后继结点指针域指向删除元素结点的后继结点node.prev.next = node.next，删除元素结点的后继结点的prev前驱结点指针域指向删除元素结点的前驱结点即可node.next.prev = node.prev（此处可能有些绕，不太理解的同学自行学习一下双向链表的数据结构吧），不需要移动原数据存储位置，只需交换一下相关结点的指针域信息即可。所以时间复杂度也为O(1)。 删除元素结点示意图，图片来自《大话数据结构》 删除传入的Object o指定对象，比较对象是否一致通过o.equals方法比较remove(Object o)，和3.的思路基本差不多，关键是比较对象是通过o.equals方法，记住这点即可。 综上所述，LinkedList删除元素的时间复杂度为O(1)，单纯论删除元素，操作是非常高效的，特别是删除第一个结点或删除最后一个结点。但如果是通过索引index的方式或者object对象的方式删除，则需要对链表进行遍历查找对应index索引的对象或者利用equals方法判断对象。 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169/** * 删除链表中的第一个元素并返回 * * @return 链表中的第一个元素 * @throws NoSuchElementException if this list is empty */public E removeFirst() &#123; //根据头结点获取第一个元素结点 final Node&lt;E&gt; f = first; if (f == null) // 没有元素结点则抛出异常 throw new NoSuchElementException(); return unlinkFirst(f);&#125;/** * 移除第一个元素 */private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; // 记录要移除元素结点的数据域 final E element = f.item; // 记录要移除元素结点的后继结点指针 final Node&lt;E&gt; next = f.next; // 清空要删除结点的数据域和next指针域信息，以帮助垃圾回收 f.item = null; f.next = null; // help GC // 头结点指向要移除元素结点的后继结点 first = next; // 如果要移除元素结点的后继结点为空，则证明链表只有一个元素 // 所以需要将尾结点的指针信息也要清空 if (next == null) last = null; else // 将新的第一个结点的前驱结点指针信息清空 next.prev = null; // 记录链表长度的size - 1 size--; modCount++; // 返回移除元素结点的数据域 return element;&#125;/** * 删除链表中的最后一个元素并返回 * * @return 链表中的最后一个元素 * @throws NoSuchElementException if this list is empty */public E removeLast() &#123; // 根据尾结点获取最后一个元素结点 final Node&lt;E&gt; l = last; if (l == null)// 没有元素结点则抛出异常 throw new NoSuchElementException(); return unlinkLast(l);&#125;/** * 移除最后一个元素 */private E unlinkLast(Node&lt;E&gt; l) &#123; // assert l == last &amp;&amp; l != null; // 记录要移除元素结点的数据域 final E element = l.item; // 记录要移除元素结点的前驱结点指针 final Node&lt;E&gt; prev = l.prev; // 清空要删除结点的数据域和prev指针域信息，以帮助垃圾回收 l.item = null; l.prev = null; // help GC // 头结点指向要移除元素结点的前驱结点 last = prev; // 如果要移除元素结点的前驱结点为空，则证明链表只有一个元素 // 所以需要将头结点的指针信息也要清空 if (prev == null) first = null; else // 将新的最后一个结点的后继结点指针信息清空 prev.next = null; // 记录链表长度的size - 1 size--; modCount++; // 返回移除元素结点的数据域 return element;&#125;/** * 将指定位置index的元素删除 * * @param index 要删除的位置index * @return 要删除位置的原元素 * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E remove(int index) &#123; // 检查index下标是否合法[0,size) checkElementIndex(index); // 根据index进行遍历链表获取要删除的结点，再调用unlink方法进行删除 return unlink(node(index));&#125;/** * 删除传入的Object o指定对象，比较对象是否一致通过o.equals方法比较 * @param o 要删除的Object o指定对象 * @return &#123;@code true&#125; 是否存在要删除对象o */public boolean remove(Object o) &#123; // 如果删除对象为null，则遍历链表查找node.item数据域为null的结点并移除 if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; // 从头开始遍历链表，并通过equals方法逐一比较node.item是否相等 // 相等则对象一致，删除此对象。 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false;&#125;/** * 移除指定结点x */E unlink(Node&lt;E&gt; x) &#123; // assert x != null; // 记录要移除元素结点的数据域 final E element = x.item; // 记录要移除元素结点的后继结点指针 final Node&lt;E&gt; next = x.next; // 记录要移除元素结点的前驱结点指针 final Node&lt;E&gt; prev = x.prev; // 如果要移除元素结点的前驱结点为空，则证明要删除结点为第一个结点 if (prev == null) &#123; // 头结点指向要删除元素结点的后继结点 first = next; &#125; else &#123; // 要删除元素结点的前驱结点的后继指针指向要删除元素结点的后继结点 prev.next = next; // 清空要删除结点的前驱结点指针信息，以帮助GC x.prev = null; &#125; // 如果要移除元素结点的后继结点为空，则证明要删除结点为最后一个结点 if (next == null) &#123; // 尾结点指向要删除元素结点的前驱结点 last = prev; &#125; else &#123; // 要删除元素结点的后继结点的前驱指针指向要删除元素结点的前驱结点 next.prev = prev; // 清空要删除结点的后继结点指针信息，以帮助GC x.next = null; &#125; // 清空要删除元素的数据域，以帮助GC x.item = null; // 记录链表长度的size - 1 size--; modCount++; // 返回移除元素结点的数据域 return element;&#125; ArrayList和LinkedList 的区别问：那您可以比较一下ArrayList和LinkedList吗? 答： LinkedList内部存储的是Node&lt;E&gt;，不仅要维护数据域，还要维护prev和next，如果LinkedList中的结点特别多，则LinkedList比ArrayList更占内存。 插入删除操作效率：LinkedList在做插入和删除操作时，插入或删除头部或尾部时是高效的，操作越靠近中间位置的元素时，需要遍历查找，速度相对慢一些，如果在数据量较大时，每次插入或删除时遍历查找比较费时。所以LinkedList插入与删除，慢在遍历查找，快在只需要更改相关结点的引用地址。ArrayList在做插入和删除操作时，插入或删除尾部时也一样是高效的，操作其他位置，则需要批量移动元素，所以ArrayList插入与删除，快在遍历查找，慢在需要批量移动元素。 循环遍历效率： 由于ArrayList实现了RandomAccess随机访问接口，所以使用for(int i = 0; i &lt; size; i++)遍历会比使用Iterator迭代器来遍历快： 12345678for (int i=0, n=list.size(); i &lt; n; i++) &#123; list.get(i);&#125;runs faster than this loop:for (Iterator i=list.iterator(); i.hasNext(); ) &#123; i.next();&#125; 而由于LinkedList未实现RandomAccess接口，所以推荐使用Iterator迭代器来遍历数据。 因此，如果我们需要频繁在列表的中部改变插入或删除元素时，建议使用LinkedList，否则，建议使用ArrayList，因为ArrayList遍历查找元素较快，并且只需存储元素的数据域，不需要额外记录其他数据的位置信息，可以节省内存空间。 LinkedList是线程安全的吗？问：LinkedList是线程安全的吗？ 答：LinkedList不是线程安全的，如果多个线程同时对同一个LinkedList更改数据的话，会导致数据不一致或者数据污染。如果出现线程不安全的操作时，LinkedList会尽可能的抛出ConcurrentModificationException防止数据异常，当我们在对一个LinkedList进行遍历时，在遍历期间，我们是不能对LinkedList进行添加，删除等更改数据结构的操作的，否则也会抛出ConcurrentModificationException异常，此为fail-fast（快速失败）机制。从源码上分析，我们在add,remove等更改LinkedList数据时，都会导致modCount的改变，当expectedModCount != modCount时，则抛出ConcurrentModificationException。如果想要线程安全，可以考虑调用Collections.synchronizedCollection(Collection&lt;T&gt; c)方法。 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798private class ListItr implements ListIterator&lt;E&gt; &#123; private Node&lt;E&gt; lastReturned; private Node&lt;E&gt; next; private int nextIndex; private int expectedModCount = modCount; ListItr(int index) &#123; // assert isPositionIndex(index); next = (index == size) ? null : node(index); nextIndex = index; &#125; public boolean hasNext() &#123; return nextIndex &lt; size; &#125; public E next() &#123; checkForComodification(); if (!hasNext()) throw new NoSuchElementException(); lastReturned = next; next = next.next; nextIndex++; return lastReturned.item; &#125; public boolean hasPrevious() &#123; return nextIndex &gt; 0; &#125; public E previous() &#123; checkForComodification(); if (!hasPrevious()) throw new NoSuchElementException(); lastReturned = next = (next == null) ? last : next.prev; nextIndex--; return lastReturned.item; &#125; public int nextIndex() &#123; return nextIndex; &#125; public int previousIndex() &#123; return nextIndex - 1; &#125; public void remove() &#123; checkForComodification(); if (lastReturned == null) throw new IllegalStateException(); Node&lt;E&gt; lastNext = lastReturned.next; unlink(lastReturned); if (next == lastReturned) next = lastNext; else nextIndex--; lastReturned = null; expectedModCount++; &#125; public void set(E e) &#123; if (lastReturned == null) throw new IllegalStateException(); checkForComodification(); lastReturned.item = e; &#125; public void add(E e) &#123; checkForComodification(); lastReturned = null; if (next == null) linkLast(e); else linkBefore(e, next); nextIndex++; expectedModCount++; &#125; public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); while (modCount == expectedModCount &amp;&amp; nextIndex &lt; size) &#123; action.accept(next.item); lastReturned = next; next = next.next; nextIndex++; &#125; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125; 总结LinkedList的结论已在第三个问题中展现了一部分了，所以不再重复说明了，我以面试问答的形式和大家一同学习了LinkedList，由于没有时间画图，可能此次没有ArrayList说的那么清楚，如果大家有看不懂的地方，请自行看一下关于链表的数据结构吧。如果此文对你有帮助，麻烦点个喜欢，谢谢各位。]]></content>
      <categories>
        <category>LinkedList</category>
      </categories>
      <tags>
        <tag>基础数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap 的详细分析]]></title>
    <url>%2F2017%2F12%2F09%2FHashMap%20%E7%9A%84%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[HashMap 的详细分析前言这次我和大家一起学习HashMap，HashMap我们在工作中经常会使用，而且面试中也很频繁会问到，因为它里面蕴含着很多知识点，可以很好的考察个人基础。但一个这么重要的东西，我为什么没有在一开始就去学习它呢，因为它是由多种基础的数据结构和一些代码设计思想组成的。我们要学习了这些基础，再学习HashMap，这样我们才能更好的去理解它。古人云：无欲速，无见小利。欲速则不达，见小利则大事不成。 HashMap其实就是ArrayList和LinkedList的数据结构加上hashCode和equals方法的思想设计出来的。没有理解上述说的知识点的同学可以翻开我过往的文章记录。 下面我就以面试问答的形式学习我们的——HashMap（源码分析基于JDK8，辅以JDK7），问答内容只是对HashMap的一个总结归纳，因为现时已经有大牛把HashMap通俗易懂的剖析了一遍，我学习HashMap也是主要通过这篇文章学习的，强烈推荐：美团点评技术团队的Java 8系列之重新认识HashMap 问答内容HashMap 的主要用途问：HashMap有用过吗？您能给我说说他的主要用途吗？ 答： 有用过，我在平常工作中经常会用到HashMap这种数据结构，HashMap是基于Map接口实现的一种键-值对&lt;key,value&gt;的存储结构，允许null值，同时非有序，非同步(即线程不安全)。HashMap的底层实现是数组 + 链表 + 红黑树（JDK1.8增加了红黑树部分）。它存储和查找数据时，是根据键key的hashCode的值计算出具体的存储位置。HashMap最多只允许一条记录的键key为null，HashMap增删改查等常规操作都有不错的执行效率，是ArrayList和LinkedList等数据结构的一种折中实现。 示例代码： 12345678910111213141516171819202122232425262728293031323334// 创建一个HashMap，如果没有指定初始大小，默认底层hash表数组的大小为16HashMap&lt;String, String&gt; hashMap = new HashMap&lt;String, String&gt;();// 往容器里面添加元素hashMap.put("小明", "好帅");hashMap.put("老王", "坑爹货");hashMap.put("老铁", "没毛病");hashMap.put("掘金", "好地方");hashMap.put("王五", "别搞事");// 获取key为小明的元素 好帅String element = hashMap.get("小明");// value : 好帅System.out.println(element);// 移除key为王五的元素String removeElement = hashMap.remove("王五");// value : 别搞事System.out.println(removeElement);// 修改key为小明的元素的值value 为 其实有点丑hashMap.replace("小明", "其实有点丑");// &#123;老铁=没毛病, 小明=其实有点丑, 老王=坑爹货, 掘金=好地方&#125;System.out.println(hashMap);// 通过put方法也可以达到修改对应元素的值的效果hashMap.put("小明", "其实还可以啦,开玩笑的");// &#123;老铁=没毛病, 小明=其实还可以啦,开玩笑的, 老王=坑爹货, 掘金=好地方&#125;System.out.println(hashMap);// 判断key为老王的元素是否存在(捉奸老王)boolean isExist = hashMap.containsKey("老王");// true , 老王竟然来搞事System.out.println(isExist);// 判断是否有 value = "坑爹货" 的人boolean isHasSomeOne = hashMap.containsValue("坑爹货");// true 老王是坑爹货System.out.println(isHasSomeOne);// 查看这个容器里面还有几个家伙 value : 4System.out.println(hashMap.size()); HashMap的底层实现是数组 + 链表 + 红黑树（JDK1.8增加了红黑树部分），核心组成元素有： int size;用于记录HashMap实际存储元素的个数； float loadFactor;负载因子（默认是0.75，此属性后面详细解释）。 int threshold;下一次扩容时的阈值，达到阈值便会触发扩容机制resize（阈值 threshold = 容器容量 capacity * 负载因子 load factor）。也就是说，在容器定义好容量之后，负载因子越大，所能容纳的键值对元素个数就越多。 Node&lt;K,V&gt;[] table; 底层数组，充当哈希表的作用，用于存储对应hash位置的元素Node&lt;K,V&gt;，此数组长度总是2的N次幂。（具体原因后面详细解释） 示例代码： 12345678910111213141516171819202122232425262728293031323334public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;····· /* ---------------- Fields -------------- */ /** * 哈希表，在第一次使用到时进行初始化，重置大小是必要的操作， * 当分配容量时，长度总是2的N次幂。 */ transient Node&lt;K,V&gt;[] table; /** * 实际存储的key - value 键值对 个数 */ transient int size; /** * 下一次扩容时的阈值 * (阈值 threshold = 容器容量 capacity * 负载因子 load factor). * @serial */ int threshold; /** * 哈希表的负载因子 * * @serial */ final float loadFactor;·····&#125; 其中Node&lt;K,V&gt;[] table;哈希表存储的核心元素是Node&lt;K,V&gt;,Node&lt;K,V&gt;包含： final int hash;元素的哈希值，决定元素存储在Node&lt;K,V&gt;[] table;哈希表中的位置。由final修饰可知，当hash的值确定后，就不能再修改。 final K key; 键，由final修饰可知，当key的值确定后，就不能再修改。 V value; 值 Node&lt;K,V&gt; next; 记录下一个元素结点(单链表结构，用于解决hash冲突) 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 定义HashMap存储元素结点的底层实现 */static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash;//元素的哈希值 由final修饰可知，当hash的值确定后，就不能再修改 final K key;// 键，由final修饰可知，当key的值确定后，就不能再修改 V value; // 值 Node&lt;K,V&gt; next; // 记录下一个元素结点(单链表结构，用于解决hash冲突) /** * Node结点构造方法 */ Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash;//元素的哈希值 this.key = key;// 键 this.value = value; // 值 this.next = next;// 记录下一个元素结点 &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + "=" + value; &#125; /** * 为Node重写hashCode方法，值为：key的hashCode 异或 value的hashCode * 运算作用就是将2个hashCode的二进制中，同一位置相同的值为0，不同的为1。 */ public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; /** * 修改某一元素的值 */ public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; /** * 为Node重写equals方法 */ public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125; hashMap内存结构图 - 图片来自于《美团点评技术团队文章》 HashMap 常用操作的底层实现原理问：您能说说HashMap常用操作的底层实现原理吗？如存储put(K key, V value)，查找get(Object key)，删除remove(Object key)，修改replace(K key, V value)等操作。 答： 调用put(K key, V value)操作添加key-value键值对时，进行了如下操作： 判断哈希表Node&lt;K,V&gt;[] table是否为空或者null，是则执行resize()方法进行扩容。 根据插入的键值key的hash值，通过(n - 1) &amp; hash当前元素的hash值 &amp; hash表长度 - 1（实际就是 hash值 % hash表长度） 计算出存储位置table[i]。如果存储位置没有元素存放，则将新增结点存储在此位置table[i]。 如果存储位置已经有键值对元素存在，则判断该位置元素的hash值和key值是否和当前操作元素一致，一致则证明是修改value操作，覆盖value即可。 当前存储位置即有元素，又不和当前操作元素一致，则证明此位置table[i]已经发生了hash冲突，则通过判断头结点是否是treeNode，如果是treeNode则证明此位置的结构是红黑树，已红黑树的方式新增结点。 如果不是红黑树，则证明是单链表，将新增结点插入至链表的最后位置，随后判断当前链表长度是否 大于等于 8，是则将当前存储位置的链表转化为红黑树。遍历过程中如果发现key已经存在，则直接覆盖value。 插入成功后，判断当前存储键值对的数量 大于 阈值threshold 是则扩容。 hashMap put方法执行流程图- 图片来自于《美团点评技术团队文章》 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/** * 添加key-value键值对 * * @param key 键 * @param value 值 * @return 如果原本存在此key，则返回旧的value值，如果是新增的key- * value，则返回nulll */public V put(K key, V value) &#123; //实际调用putVal方法进行添加 key-value 键值对操作 return putVal(hash(key), key, value, false, true);&#125;/** * 根据key 键 的 hashCode 通过 “扰动函数” 生成对应的 hash值 * 经过此操作后，使每一个key对应的hash值生成的更均匀， * 减少元素之间的碰撞几率（后面详细说明） */static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;/** * 添加key-value键值对的实际调用方法（重点） * * @param hash key 键的hash值 * @param key 键 * @param value 值 * @param onlyIfAbsent 此值如果是true, 则如果此key已存在value，则不执 * 行修改操作 * @param evict 此值如果是false，哈希表是在初始化模式 * @return 返回原本的旧值, 如果是新增，则返回null */final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; // 用于记录当前的hash表 Node&lt;K,V&gt;[] tab; // 用于记录当前的链表结点 Node&lt;K,V&gt; p; // n用于记录hash表的长度，i用于记录当前操作索引index int n, i; // 当前hash表为空 if ((tab = table) == null || (n = tab.length) == 0) // 初始化hash表，并把初始化后的hash表长度值赋值给n n = (tab = resize()).length; // 1）通过 (n - 1) &amp; hash 当前元素的hash值 &amp; hash表长度 - 1 // 2）确定当前元素的存储位置，此运算等价于 当前元素的hash值 % hash表的长度 // 3）计算出的存储位置没有元素存在 if ((p = tab[i = (n - 1) &amp; hash]) == null) // 4) 则新建一个Node结点，在该位置存储此元素 tab[i] = newNode(hash, key, value, null); else &#123; // 当前存储位置已经有元素存在了(不考虑是修改的情况的话，就代表发生hash冲突了) // 用于存放新增结点 Node&lt;K,V&gt; e; // 用于临时存在某个key值 K k; // 1)如果当前位置已存在元素的hash值和新增元素的hash值相等 // 2)并且key也相等，则证明是同一个key元素，想执行修改value操作 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p;// 将当前结点引用赋值给e else if (p instanceof TreeNode) // 如果当前结点是树结点 // 则证明当前位置的链表已变成红黑树结构，则已红黑树结点结构新增元素 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123;// 排除上述情况，则证明已发生hash冲突，并hash冲突位置现时的结构是单链表结构 for (int binCount = 0; ; ++binCount) &#123; //遍历单链表，将新元素结点放置此链表的最后一位 if ((e = p.next) == null) &#123; // 将新元素结点放在此链表的最后一位 p.next = newNode(hash, key, value, null); // 新增结点后，当前结点数量是否大于等于 阈值 8 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st // 大于等于8则将链表转换成红黑树 treeifyBin(tab, hash); break; &#125; // 如果链表中已经存在对应的key，则覆盖value if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // 已存在对应key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) //如果允许修改，则修改value为新值 e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 当前存储键值对的数量 大于 阈值 是则扩容 if (++size &gt; threshold) // 重置hash大小，将旧hash表的数据逐一复制到新的hash表中（后面详细讲解） resize(); afterNodeInsertion(evict); // 返回null，则证明是新增操作，而不是修改操作 return null;&#125; 调用get(Object key)操作根据键key查找对应的key-value键值对时，进行了如下操作： 1.先调用 hash(key)方法计算出 key 的 hash值 2.根据查找的键值key的hash值，通过(n - 1) &amp; hash当前元素的hash值 &amp; hash表长度 - 1（实际就是 hash值 % hash表长度） 计算出存储位置table[i]，判断存储位置是否有元素存在 。 如果存储位置有元素存放，则首先比较头结点元素，如果头结点的key的hash值 和 要获取的key的hash值相等，并且 头结点的key本身 和要获取的 key 相等，则返回该位置的头结点。 如果存储位置没有元素存放，则返回null。 3.如果存储位置有元素存放，但是头结点元素不是要查找的元素，则需要遍历该位置进行查找。 4.先判断头结点是否是treeNode，如果是treeNode则证明此位置的结构是红黑树，以红色树的方式遍历查找该结点，没有则返回null。 5.如果不是红黑树，则证明是单链表。遍历单链表，逐一比较链表结点，链表结点的key的hash值 和 要获取的key的hash值相等，并且 链表结点的key本身 和要获取的 key 相等，则返回该结点，遍历结束仍未找到对应key的结点，则返回null。 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * 返回指定 key 所映射的 value 值 * 或者 返回 null 如果容器里不存在对应的key * * 更确切地讲，如果此映射包含一个满足 (key==null ? k==null :key.equals(k)) * 的从 k 键到 v 值的映射关系， * 则此方法返回 v；否则返回 null。（最多只能有一个这样的映射关系。） * * 返回 null 值并不一定 表明该映射不包含该键的映射关系； * 也可能该映射将该键显示地映射为 null。可使用containsKey操作来区分这两种情况。 * * @see #put(Object, Object) */public V get(Object key) &#123; Node&lt;K,V&gt; e; // 1.先调用 hash(key)方法计算出 key 的 hash值 // 2.随后调用getNode方法获取对应key所映射的value值 return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;/** * 获取哈希表结点的方法实现 * * @param hash key 键的hash值 * @param key 键 * @return 返回对应的结点，如果结点不存在，则返回null */final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; // 用于记录当前的hash表 Node&lt;K,V&gt;[] tab; // first用于记录对应hash位置的第一个结点，e充当工作结点的作用 Node&lt;K,V&gt; first, e; // n用于记录hash表的长度 int n; // 用于临时存放Key K k; // 通过 (n - 1) &amp; hash 当前元素的hash值 &amp; hash表长度 - 1 // 判断当前元素的存储位置是否有元素存在 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123;//元素存在的情况 // 如果头结点的key的hash值 和 要获取的key的hash值相等 // 并且 头结点的key本身 和要获取的 key 相等 if (first.hash == hash &amp;&amp; // always check first node 总是检查头结点 ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) // 返回该位置的头结点 return first; if ((e = first.next) != null) &#123;// 头结点不相等 if (first instanceof TreeNode) // 如果当前结点是树结点 // 则证明当前位置的链表已变成红黑树结构 // 通过红黑树结点的方式获取对应key结点 return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123;// 当前位置不是红黑树，则证明是单链表 // 遍历单链表，逐一比较链表结点 // 链表结点的key的hash值 和 要获取的key的hash值相等 // 并且 链表结点的key本身 和要获取的 key 相等 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) // 找到对应的结点则返回 return e; &#125; while ((e = e.next) != null); &#125; &#125; // 通过上述查找均无找到，则返回null return null;&#125; 调用remove(Object key)操作根据键key删除对应的key-value键值对时，进行了如下操作： 1.先调用 hash(key)方法计算出 key 的 hash值 2.根据查找的键值key的hash值，通过(n - 1) &amp; hash当前元素的hash值 &amp; hash表长度 - 1（实际就是 hash值 % hash表长度） 计算出存储位置table[i]，判断存储位置是否有元素存在 。 如果存储位置有元素存放，则首先比较头结点元素，如果头结点的key的hash值 和 要获取的key的hash值相等，并且 头结点的key本身 和要获取的 key 相等，则该位置的头结点即为要删除的结点，记录此结点至变量node中。 如果存储位置没有元素存放，则没有找到对应要删除的结点，则返回null。 3.如果存储位置有元素存放，但是头结点元素不是要删除的元素，则需要遍历该位置进行查找。 4.先判断头结点是否是treeNode，如果是treeNode则证明此位置的结构是红黑树，以红色树的方式遍历查找并删除该结点，没有则返回null。 5.如果不是红黑树，则证明是单链表。遍历单链表，逐一比较链表结点，链表结点的key的hash值 和 要获取的key的hash值相等，并且 链表结点的key本身 和要获取的 key 相等，则此为要删除的结点，记录此结点至变量node中，遍历结束仍未找到对应key的结点，则返回null。 6.如果找到要删除的结点node，则判断是否需要比较value也是否一致，如果value值一致或者不需要比较value值，则执行删除结点操作，删除操作根据不同的情况与结构进行不同的处理。 如果当前结点是树结点，则证明当前位置的链表已变成红黑树结构，通过红黑树结点的方式删除对应结点。 如果不是红黑树，则证明是单链表。如果要删除的是头结点，则当前存储位置table[i]的头结点指向删除结点的下一个结点。 如果要删除的结点不是头结点，则将要删除的结点的后继结点node.next赋值给要删除结点的前驱结点的next域，即p.next = node.next;。 7.HashMap当前存储键值对的数量 - 1，并返回删除结点。 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * 从此映射中移除指定键的映射关系（如果存在）。 * * @param key 其映射关系要从映射中移除的键 * @return 与 key 关联的旧值；如果 key 没有任何映射关系，则返回 null。 * （返回 null 还可能表示该映射之前将 null 与 key 关联。） */public V remove(Object key) &#123; Node&lt;K,V&gt; e; // 1.先调用 hash(key)方法计算出 key 的 hash值 // 2.随后调用removeNode方法删除对应key所映射的结点 return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125;/** * 删除哈希表结点的方法实现 * * @param hash 键的hash值 * @param key 键 * @param value 用于比较的value值，当matchValue 是 true时才有效, 否则忽略 * @param matchValue 如果是 true 只有当value相等时才会移除 * @param movable 如果是 false当执行移除操作时，不删除其他结点 * @return 返回删除结点node，不存在则返回null */final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; // 用于记录当前的hash表 Node&lt;K,V&gt;[] tab; // 用于记录当前的链表结点 Node&lt;K,V&gt; p; // n用于记录hash表的长度，index用于记录当前操作索引index int n, index; // 通过 (n - 1) &amp; hash 当前元素的hash值 &amp; hash表长度 - 1 // 判断当前元素的存储位置是否有元素存在 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123;// 元素存在的情况 // node 用于记录找到的结点，e为工作结点 Node&lt;K,V&gt; node = null, e; K k; V v; // 如果头结点的key的hash值 和 要获取的key的hash值相等 // 并且 头结点的key本身 和要获取的 key 相等 // 则证明此头结点就是要删除的结点 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) // 记录要删除的结点的引用地址至node中 node = p; else if ((e = p.next) != null) &#123;// 头结点不相等 if (p instanceof TreeNode)// 如果当前结点是树结点 // 则证明当前位置的链表已变成红黑树结构 // 通过红黑树结点的方式获取对应key结点 // 记录要删除的结点的引用地址至node中 node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123;// 当前位置不是红黑树，则证明是单链表 do &#123; // 遍历单链表，逐一比较链表结点 // 链表结点的key的hash值 和 要获取的key的hash值相等 // 并且 链表结点的key本身 和要获取的 key 相等 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; // 找到则记录要删除的结点的引用地址至node中，中断遍历 node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; // 如果找到要删除的结点，则判断是否需要比较value也是否一致 if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; // value值一致或者不需要比较value值，则执行删除结点操作 if (node instanceof TreeNode) // 如果当前结点是树结点 // 则证明当前位置的链表已变成红黑树结构 // 通过红黑树结点的方式删除对应结点 ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); else if (node == p) // node 和 p相等，则证明删除的是头结点 // 当前存储位置的头结点指向删除结点的下一个结点 tab[index] = node.next; else // 删除的不是头结点 // p是删除结点node的前驱结点，p的next改为记录要删除结点node的后继结点 p.next = node.next; ++modCount; // 当前存储键值对的数量 - 1 --size; afterNodeRemoval(node); // 返回删除结点 return node; &#125; &#125; // 不存在要删除的结点，则返回null return null;&#125; 调用replace(K key, V value)操作根据键key查找对应的key-value键值对，随后替换对应的值value，进行了如下操作： 先调用 hash(key)方法计算出 key 的 hash值 随后调用getNode方法获取对应key所映射的value值 。 记录元素旧值，将新值赋值给元素，返回元素旧值，如果没有找到元素，则返回null。 示例代码： 123456789101112131415161718192021222324/** * 替换指定 key 所映射的 value 值 * * @param key 对应要替换value值元素的key键 * @param value 要替换对应元素的新value值 * @return 返回原本的旧值，如果没有找到key对应的元素，则返回null * @since 1.8 JDK1.8新增方法 */public V replace(K key, V value) &#123; Node&lt;K,V&gt; e; // 1.先调用 hash(key)方法计算出 key 的 hash值 // 2.随后调用getNode方法获取对应key所映射的value值 if ((e = getNode(hash(key), key)) != null) &#123;// 如果找到对应的元素 // 元素旧值 V oldValue = e.value; // 将新值赋值给元素 e.value = value; afterNodeAccess(e); // 返回元素旧值 return oldValue; &#125; // 没有找到元素，则返回null return null;&#125; HashMap 若要新增的这个元素存在了或hash冲突了怎么办问 1：您上面说，存放一个元素时，先计算它的hash值确定它的存储位置，然后再把这个元素放到对应的位置上，那万一这个位置上面已经有元素存在呢，新增的这个元素怎么办？ 问 2：hash冲突（或者叫hash碰撞）是什么？为什么会出现这种现象，如何解决hash冲突？ 答： hash冲突： 当我们调用put(K key, V value)操作添加key-value键值对，这个key-value键值对存放在的位置是通过扰动函数(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)计算键key的hash值。随后将 这个hash值 % 模上 哈希表Node&lt;K,V&gt;[] table的长度 得到具体的存放位置。所以put(K key, V value)多个元素，是有可能计算出相同的存放位置。此现象就是hash冲突或者叫hash碰撞。 例子如下：元素 A 的hash值 为 9，元素 B 的hash值 为 17。哈希表Node&lt;K,V&gt;[] table的长度为8。则元素 A 的存放位置为9 % 8 = 1，元素 B 的存放位置为17 % 8 = 1。两个元素的存放位置均为table[1]，发生了hash冲突。 hash冲突的避免：既然会发生hash冲突，我们就应该想办法避免此现象的发生，解决这个问题最关键就是如果生成元素的hash值。Java是使用“扰动函数”生成元素的hash值。 示例代码： 123456789101112131415161718/** * JDK 7 的 hash方法 */ final int hash(int h) &#123; h ^= k.hashCode(); h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125;/** * JDK 8 的 hash方法 */ static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; Java7做了4次16位右位移异或混合，Java 8中这步已经简化了，只做一次16位右位移异或混合，而不是四次，但原理是不变的。例子如下： 扰动函数执行例子 - 图片来自于《知乎》 右位移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。 上述扰动函数的解释参考自：JDK 源码中 HashMap 的 hash 方法原理是什么？ hash冲突解决：解决hash冲突的方法有很多，常见的有：开发定址法，再散列法，链地址法，公共溢出区法（详细说明请查看我的文章JAVA基础-自问自答学hashCode和equals）。HashMap是使用链地址法解决hash冲突的，当有冲突元素放进来时，会将此元素插入至此位置链表的最后一位，形成单链表。但是由于是单链表的缘故，每当通过hash % length找到该位置的元素时，均需要从头遍历链表，通过逐一比较hash值，找到对应元素。如果此位置元素过多，造成链表过长，遍历时间会大大增加，最坏情况下的时间复杂度为O(N)，造成查找效率过低。所以当存在位置的链表长度 大于等于 8 时，HashMap会将链表 转变为 红黑树，红黑树最坏情况下的时间复杂度为O(logn)。以此提高查找效率。 HashMap 的容量为什么一定要是2的n次方问：HashMap的容量为什么一定要是2的n次方？ 答： 因为调用put(K key, V value)操作添加key-value键值对时，具体确定此元素的位置是通过 hash值 % 模上 哈希表Node&lt;K,V&gt;[] table的长度 hash % length 计算的。但是”模”运算的消耗相对较大，通过位运算h &amp; (length-1)也可以得到取模后的存放位置，而位运算的运行效率高，但只有length的长度是2的n次方时，h &amp; (length-1) 才等价于 h % length。 而且当数组长度为2的n次幂的时候，不同的key算出的index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。 例子： hash &amp; (length-1)运算过程.jpg 上图中，左边两组的数组长度是16（2的4次方），右边两组的数组长度是15。两组的hash值均为8和9。 当数组长度是15时，当它们和1110进行&amp;与运算（相同为1，不同为0）时，计算的结果都是1000，所以他们都会存放在相同的位置table[8]中，这样就发生了hash冲突，那么查询时就要遍历链表，逐一比较hash值，降低了查询的效率。 同时，我们可以发现，当数组长度为15的时候，hash值均会与14（1110）进行&amp;与运算，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率。 所以，HashMap的容量是2的n次方，有利于提高计算元素存放位置时的效率，也降低了hash冲突的几率。因此，我们使用HashMap存储大量数据的时候，最好先预先指定容器的大小为2的n次方，即使我们不指定为2的n次方，HashMap也会把容器的大小设置成最接近设置数的2的n次方，如，设置HashMap的大小为 7 ，则HashMap会将容器大小设置成最接近7的一个2的n次方数，此值为 8 。 上述回答参考自：深入理解HashMap 示例代码： 12345678910111213/** * 返回一个比指定数cap大的，并且大小是2的n次方的数 * Returns a power of two size for the given target capacity. */static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; HashMap 的负载因子是什么，有什么作用问：HashMap的负载因子是什么，有什么作用？ 答：负载因子表示哈希表空间的使用程度（或者说是哈希表空间的利用率）。 例子如下：底层哈希表Node&lt;K,V&gt;[] table的容量大小capacity为 16，负载因子load factor为 0.75，则当存储的元素个数size = capacity 16 * load factor 0.75等于 12 时，则会触发HashMap的扩容机制，调用resize()方法进行扩容。 当负载因子越大，则HashMap的装载程度就越高。也就是能容纳更多的元素，元素多了，发生hash碰撞的几率就会加大，从而链表就会拉长，此时的查询效率就会降低。 当负载因子越小，则链表中的数据量就越稀疏，此时会对空间造成浪费，但是此时查询效率高。 我们可以在创建HashMap 时根据实际需要适当地调整load factor 的值；如果程序比较关心空间开销、内存比较紧张，可以适当地增加负载因子；如果程序比较关心时间开销，内存比较宽裕则可以适当的减少负载因子。通常情况下，默认负载因子 (0.75) 在时间和空间成本上寻求一种折衷，程序员无需改变负载因子的值。 因此，如果我们在初始化HashMap时，就预估知道需要装载key-value键值对的容量size，我们可以通过size / load factor 计算出我们需要初始化的容量大小initialCapacity，这样就可以避免HashMap因为存放的元素达到阈值threshold而频繁调用resize()方法进行扩容。从而保证了较好的性能。 HashMap 和 HashTable 的区别问：您能说说HashMap和HashTable的区别吗？ 答：HashMap和HashTable有如下区别： 1）容器整体结构： HashMap的key和value都允许为null，HashMap遇到key为null的时候，调用putForNullKey方法进行处理，而对value没有处理。 Hashtable的key和value都不允许为null。Hashtable遇到null，直接返回NullPointerException。 2） 容量设定与扩容机制： HashMap默认初始化容量为 16，并且容器容量一定是2的n次方，扩容时，是以原容量 2倍 的方式 进行扩容。 Hashtable默认初始化容量为 11，扩容时，是以原容量 2倍 再加 1的方式进行扩容。即int newCapacity = (oldCapacity &lt;&lt; 1) + 1;。 3） 散列分布方式（计算存储位置）： HashMap是先将key键的hashCode经过扰动函数扰动后得到hash值，然后再利用 hash &amp; (length - 1)的方式代替取模，得到元素的存储位置。 Hashtable则是除留余数法进行计算存储位置的（因为其默认容量也不是2的n次方。所以也无法用位运算替代模运算），int index = (hash &amp; 0x7FFFFFFF) % tab.length;。 由于HashMap的容器容量一定是2的n次方，所以能使用hash &amp; (length - 1)的方式代替取模的方式计算元素的位置提高运算效率，但Hashtable的容器容量不一定是2的n次方，所以不能使用此运算方式代替。 4）线程安全（最重要）： HashMap 不是线程安全，如果想线程安全，可以通过调用synchronizedMap(Map&lt;K,V&gt; m)使其线程安全。但是使用时的运行效率会下降，所以建议使用ConcurrentHashMap容器以此达到线程安全。 Hashtable则是线程安全的，每个操作方法前都有synchronized修饰使其同步，但运行效率也不高，所以还是建议使用ConcurrentHashMap容器以此达到线程安全。 因此，Hashtable是一个遗留容器，如果我们不需要线程同步，则建议使用HashMap，如果需要线程同步，则建议使用ConcurrentHashMap。 此处不再对Hashtable的源码进行逐一分析了，如果想深入了解的同学，可以参考此文章Hashtable源码剖析 HashMap 在多线程下如何处理，啥时会发生线程不安全问：您说HashMap不是线程安全的，那如果多线程下，它是如何处理的？并且什么情况下会发生线程不安全的情况？ 答： HashMap不是线程安全的，如果多个线程同时对同一个HashMap更改数据的话，会导致数据不一致或者数据污染。如果出现线程不安全的操作时，HashMap会尽可能的抛出ConcurrentModificationException防止数据异常，当我们在对一个HashMap进行遍历时，在遍历期间，我们是不能对HashMap进行添加，删除等更改数据的操作的，否则也会抛出ConcurrentModificationException异常，此为fail-fast（快速失败）机制。从源码上分析，我们在put,remove等更改HashMap数据时，都会导致modCount的改变，当expectedModCount != modCount时，则抛出ConcurrentModificationException。如果想要线程安全，可以考虑使用ConcurrentHashMap。 而且，在多线程下操作HashMap，由于存在扩容机制，当HashMap调用resize()进行自动扩容时，可能会导致死循环的发生。 由于时间关系，我暂不带着大家一起去分析resize()方法导致死循环发生的现象造成原因了，迟点有空我会再补充上去，请见谅，大家可以参考如下文章： Java 8系列之重新认识HashMap 谈谈HashMap线程不安全的体现 使用 HashMap ，选取什么对象作为 key 键比较好问：我们在使用HashMap时，选取什么对象作为key键比较好，为什么？ 答： 可变对象：指创建后自身状态能改变的对象。换句话说，可变对象是该对象在创建后它的哈希值可能被改变。 我们在使用HashMap时，最好选择不可变对象作为key。例如String，Integer等不可变类型作为key是非常明智的。 如果key对象是可变的，那么key的哈希值就可能改变。在HashMap中可变对象作为Key会造成数据丢失。因为我们再进行hash &amp; (length - 1)取模运算计算位置查找对应元素时，位置可能已经发生改变，导致数据丢失。 详细例子说明请参考：危险！在HashMap中将可变对象用作Key 总结 HashMap是基于Map接口实现的一种键-值对&lt;key,value&gt;的存储结构，允许null值，同时非有序，非同步(即线程不安全)。HashMap的底层实现是数组 + 链表 + 红黑树（JDK1.8增加了红黑树部分）。 HashMap定位元素位置是通过键key经过扰动函数扰动后得到hash值，然后再通过hash &amp; (length - 1)代替取模的方式进行元素定位的。 HashMap是使用链地址法解决hash冲突的，当有冲突元素放进来时，会将此元素插入至此位置链表的最后一位，形成单链表。当存在位置的链表长度 大于等于 8 时，HashMap会将链表 转变为 红黑树，以此提高查找效率。 HashMap的容量是2的n次方，有利于提高计算元素存放位置时的效率，也降低了hash冲突的几率。因此，我们使用HashMap存储大量数据的时候，最好先预先指定容器的大小为2的n次方，即使我们不指定为2的n次方，HashMap也会把容器的大小设置成最接近设置数的2的n次方，如，设置HashMap的大小为 7 ，则HashMap会将容器大小设置成最接近7的一个2的n次方数，此值为 8 。 HashMap的负载因子表示哈希表空间的使用程度（或者说是哈希表空间的利用率）。当负载因子越大，则HashMap的装载程度就越高。也就是能容纳更多的元素，元素多了，发生hash碰撞的几率就会加大，从而链表就会拉长，此时的查询效率就会降低。当负载因子越小，则链表中的数据量就越稀疏，此时会对空间造成浪费，但是此时查询效率高。 HashMap不是线程安全的，Hashtable则是线程安全的。但Hashtable是一个遗留容器，如果我们不需要线程同步，则建议使用HashMap，如果需要线程同步，则建议使用ConcurrentHashMap。 在多线程下操作HashMap，由于存在扩容机制，当HashMap调用resize()进行自动扩容时，可能会导致死循环的发生。 我们在使用HashMap时，最好选择不可变对象作为key。例如String，Integer等不可变类型作为key是非常明智的。 由于最近工作较忙，也有拖延症发作的问题，所以文章迟迟未能完成发布，现时完成的文章其实对我而言，也不算太好，但还是打算先发出来让大家看看，一起学习学习，看有什么不好的地方，我再慢慢改进，如果此文对你有帮助，请给个赞，谢谢大家。 参考文章Java 8系列之重新认识HashMapJDK 源码中 HashMap 的 hash 方法原理是什么？深入理解HashMapHashMap负载因子Hashtable源码剖析危险！在HashMap中将可变对象用作Key谈谈HashMap线程不安全的体现]]></content>
      <categories>
        <category>HashMap</category>
      </categories>
      <tags>
        <tag>基础数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList 源码分析]]></title>
    <url>%2F2017%2F12%2F09%2FArrayList%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[ArrayList 源码分析 前言以面试问答的形式学习我们的最常用的装载容器——ArrayList（源码分析基于JDK8） 问答内容ArrayList是什么，可以用来干嘛？问：ArrayList有用过吗？它是一个什么东西？可以用来干嘛？ 答：有用过，ArrayList就是数组列表，主要用来装载数据，当我们装载的是基本类型的数据int,long,boolean,short,byte...的时候我们只能存储他们对应的包装类，它的主要底层实现是数组Object[] elementData。与它类似的是LinkedList，和LinkedList相比，它的查找和访问元素的速度较快，但新增，删除的速度较慢。 示例代码： 12345678910// 创建一个ArrayList，如果没有指定初始大小，默认容器大小为10ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();// 往容器里面添加元素arrayList.add("张三");arrayList.add("李四");arrayList.add("王五");// 获取index下标为0的元素 张三String element = arrayList.get(0);// 删除index下标为1的元素 李四String removeElement = arrayList.remove(1); ArrayList底层实现示意图 ArrayList中不断添加数据会有什么问题吗？问：您说它的底层实现是数组，但是数组的大小是定长的，如果我们不断的往里面添加数据的话，不会有问题吗？ 答：ArrayList可以通过构造方法在初始化的时候指定底层数组的大小。 通过无参构造方法的方式ArrayList()初始化，则赋值底层数组Object[] elementData为一个默认空数组Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}所以数组容量为0，只有真正对数据进行添加add时，才分配默认DEFAULT_CAPACITY = 10的初始容量。示例代码： 12345678910111213141516// 定义ArrayList默认容量为10private static final int DEFAULT_CAPACITY = 10;// 空数组，当调用无参构造方法时默认复制这个空数组private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;// 真正保存数据的底层数组transient Object[] elementData; // ArrayList的实际元素数量private int size;public ArrayList() &#123; // 无参构造方法默认为空数组 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 通过指定容量初始大小的构造方法方式ArrayList(int initialCapacity)初始化，则赋值底层数组Object[] elementData为指定大小的数组this.elementData = new Object[initialCapacity];示例代码： 12345678910111213private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;// 通过构造方法出入指定的容量来设置默认底层数组大小 public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125;&#125; 当我们添加的元素数量已经达到底层数组Object[] elementData的上限时，我们再往ArrayList元素，则会触发ArrayList的自动扩容机制，ArrayList会通过位运算int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);以1.5倍的方式初始化一个新的数组（如初始化数组大小为10，则扩容后的数组大小为15），然后使用Arrays.copyOf(elementData, newCapacity);方法将原数据的数据逐一复制到新数组上面去，以此达到ArrayList扩容的效果。虽然，Arrays.copyOf(elementData, newCapacity);方法最终调用的是native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)是一个底层方法，效率还算可以，但如果我们在知道ArrayList想装多少个元素的情况下，却没有指定容器大小，则就会导致ArrayList频繁触发扩容机制，频繁进行底层数组之间的数据复制，大大降低使用效率。示例代码： 123456789101112131415161718192021222324252627282930313233public boolean add(E e) &#123; //确保底层数组容量，如果容量不足，则扩容 ensureCapacityInternal(size + 1); elementData[size++] = e; return true;&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // 容量不足，则调用grow方法进行扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;/** * 扩容方法(重点) */private void grow(int minCapacity) &#123; // 获得原容量大小 int oldCapacity = elementData.length; // 新容量为原容量的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 再判断新容量是否已足够，如果扩容后仍然不足够，则复制为最小容量长度 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // 判断是否超过最大长度限制 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // 将原数组的数据复制至新数组， ArrayList的底层数组引用指向新数组 // 如果数据量很大，重复扩容，则会影响效率 elementData = Arrays.copyOf(elementData, newCapacity);&#125; 因此，在我们使用ArrayList的时候，如果知道最终的存储容量capacity，则应该在初始化的时候就指定ArrayList的容量ArrayList(int initialCapacity)，如果初始化时无法预知装载容量，但在使用过程中，得知最终容量，我们可以通过调用ensureCapacity(int minCapacity)方法来指定ArrayList的容量，并且，如果我们在使用途中，如果确定容量大小，但是由于之前每次扩容都扩充50%，所以会造成一定的存储空间浪费，我们可以调用trimToSize()方法将容器最小化到存储元素容量，进而消除这些存储空间浪费。例如：我们当前存储了11个元素，我们不会再添加但是当前的ArrayList的大小为15，有4个存储空间没有被使用，则调用trimToSize()方法后，则会重新创建一个容量为11的数组Object[] elementData，将原有的11个元素复制至新数组，达到节省内存空间的效果。示例代码： 123456789101112131415161718192021222324252627/** * 将底层数组一次性指定到指定容量的大小 */public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It's already // supposed to be at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125;&#125;/** * 将容器最小化到存储元素容量 */public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125;&#125; ArrayList怎么 删除数据，为什么访问速度快，删除新增速度慢 ？问：那它是怎么样删除元素的？您上面说到ArrayList访问元素速度较快，但是新增和删除的速度较慢，为什么呢？ 答： 通过源码我们可以得知，ArrayList删除元素时，先获取对应的删除元素，然后把要删除元素对应索引index后的元素逐一往前移动1位，最后将最后一个存储元素清空并返回删除元素，以此达到删除元素的效果。 当我们通过下标的方式去访问元素时，我们假设访问一个元素所花费的时间为K，则通过下标一步到位的方式访问元素，时间则为1K，用“大O”表示法表示，则时间复杂度为O(1)。所以ArrayList的访问数据的数据是比较快的。 当我们去添加元素add(E e)时，我们是把元素添加至末尾，不需要移动元素，此时的时间复杂度为O(1)，但我们把元素添加到指定位置，最坏情况下，我们将元素添加至第一个位置add(int index, E element)，则整个ArrayList的n-1个元素都要往前移动位置，导致底层数组发生n-1次复制。通常情况下，我们说的时间复杂度都是按最坏情况度量的，此时的时间复杂度为O(n)。删除元素同理，删除最后一个元素不需要移动元素，时间复杂度为O(1)，但删除第一个元素，则需要移动n-1个元素，最坏情况下的时间复杂度也是O(n)。 所以ArrayList访问元素速度较快，但是新增和删除的速度较慢。 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 将元素添加至末尾 */public boolean add(E e) &#123; // 确保底层数组容量，如果容量不足，则扩容 ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;/** * 将元素添加至指定下标位置 */public void add(int index, E element) &#123; // 检查下标是否在合法范围内 rangeCheckForAdd(index); // 确保底层数组容量，如果容量不足，则扩容 ensureCapacityInternal(size + 1); // Increments modCount!! // 将要添加的元素下标后的元素通过复制的方式逐一往后移动，腾出对应index下标的存储位置 System.arraycopy(elementData, index, elementData, index + 1, size - index); // 将新增元素存储至指定下标索引index elementData[index] = element; // ArrayList的大小 + 1 size++;&#125;/** * 通过下标索引的方式删除元素 */public E remove(int index) &#123; // 检查下标是否在合法范围内 rangeCheck(index); modCount++; // 直接通过下标去访问底层数组的元素 E oldValue = elementData(index); // 计算数组需要移动的元素个数 int numMoved = size - index - 1; if (numMoved &gt; 0) // 将要删除的元素下标后的元素通过复制的方式逐一往前移动 System.arraycopy(elementData, index+1, elementData, index, numMoved); //将底层数组长度减1，并清空最后一个存储元素。 elementData[--size] = null; // clear to let GC do its work // 返回移除元素 return oldValue;&#125; ArrayList是线程安全的吗？问：ArrayList是线程安全的吗？ 答：ArrayList不是线程安全的，如果多个线程同时对同一个ArrayList更改数据的话，会导致数据不一致或者数据污染。如果出现线程不安全的操作时，ArrayList会尽可能的抛出ConcurrentModificationException防止数据异常，当我们在对一个ArrayList进行遍历时，在遍历期间，我们是不能对ArrayList进行添加，修改，删除等更改数据的操作的，否则也会抛出ConcurrentModificationException异常，此为fail-fast（快速失败）机制。从源码上分析，我们在add,remove,clear等更改ArrayList数据时，都会导致modCount的改变，当expectedModCount != modCount时，则抛出ConcurrentModificationException。如果想要线程安全，可以考虑使用Vector、CopyOnWriteArrayList。 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * AbstractList.Itr 的迭代器实现 */private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such //期望的modCount int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings("unchecked") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings("unchecked") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125; 总结 如果在初始化的时候知道ArrayList的初始容量，请一开始就指定容量ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(20);,如果一开始不知道容量，中途才得知，请调用list.ensureCapacity(20);来扩充容量，如果数据已经添加完毕，但仍需要保存在内存中一段时间，请调用list.trimToSize()将容器最小化到存储元素容量，进而消除这些存储空间浪费。 ArrayList是以1.5倍的容量去扩容的，如初始容量是10，则容量依次递增扩充为：15，22，33，49。扩容后把原始数据从旧数组复制至新数组中。 ArrayList访问元素速度较快，下标方式访问元素，时间复杂度为O(1)，添加与删除速度较慢，时间复杂度均为O(n)。 ArrayList不是线程安全的，但是在发生并发行为时，它会尽可能的抛出ConcurrentModificationException，此为fail-fast机制。]]></content>
      <categories>
        <category>ArrayList</category>
      </categories>
      <tags>
        <tag>基础数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven仓库理解和优先级]]></title>
    <url>%2F2017%2F09%2F03%2FMaven-Priority%2F</url>
    <content type="text"><![CDATA[5 Seven 2017 前言使用 maven 也有一段时间了，有时候在配置 repository,mirror,profile的时候，总会导致 jar 拉取不到。所以认真的分析了 maven 获取 jar 包时候的优先级。 Maven 仓库的分类仓库分类：本地仓库和远程仓库。Maven根据坐标寻找构件的时候，它先会查看本地仓库，如果本地仓库存在构件，则直接使用；如果没有，则从远程仓库查找，找到后，下载到本地。 1）本地仓库默认情况下，每个用户在自己的用户目录下都有一个路径名为.m2/repository/的仓库目录。我们也可以在 settings.xml 文件配置本地仓库的地址 2）远程仓库本地仓库好比书房，而远程仓库就像是书店。对于Maven来说，每个用户只有一个本地仓库，但是可以配置多个远程仓库。下· 我们可以在 pom 文件配置多个 repository，但是随着项目越来也多我们每次都要在 pom 文件配置比较麻烦，所以我们可以在settings 文件配置 profile （私服）。这样我们每次创建新项目的时候就可以不用配置 repository。 3）中央仓库Maven必须要知道至少一个可用的远程仓库，中央仓库就是这样一个默认的远程仓库，Maven 默认有一个 super pom 文件。maven super pom 文件位置D:\apache-maven-3.0.4\lib 下的 maven-model-builder-3.0.4.jar 中的 org/apache/maven/model/pom-4.0.0.xml12345678910111213··· 省略其他 &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Central Repository&lt;/name&gt; &lt;url&gt;https://repo.maven.apache.org/maven2&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;··· 这个时候我们就明白了，我们在 settings 文件配置一个 mirror 的 mirrorOf 为 central 的镜像就会替代 ‘中央仓库’ 的原因了。 Maven 镜像镜像（Mirroring）是冗余的一种类型，一个磁盘上的数据在另一个磁盘上存在一个完全相同的副本即为镜像。为什么配置镜像? 1.一句话，你有的我也有，你没有的我也有。（拥有远程仓库的所有 jar，包括远程仓库没有的 jar）2.还是一句话，我跑的比你快。（有时候远程仓库获取 jar 的速度可能比镜像慢，这也是为什么我们一般要配置中央仓库的原因，外国的 maven 仓库一般获取速度比较慢） 如果你配置 maven 镜像不是为了以上两点，那基本就不用配置镜像了。注意:当远程仓库被镜像匹配到的，则在获取 jar 包将从镜像仓库获取，而不是我们配置的 repository 仓库, repository 将失去作用 mirrorOf 标签mirrorOf 标签里面放置的是 repository 配置的 id,为了满足一些复杂的需求，Maven还支持更高级的镜像配置： external:* = 不在本地仓库的文件才从该镜像获取 repo,repo1 = 远程仓库 repo 和 repo1 从该镜像获取 *,!repo1 = 所有远程仓库都从该镜像获取，除 repo1 远程仓库以外 * = 所用远程仓库都从该镜像获取 私服私服是一种特殊的远程Maven仓库，它是架设在局域网内的仓库服务，私服一般被配置为互联网远程仓库的镜像，供局域网内的Maven用户使用。当Maven需要下载构件的时候，先向私服请求，如果私服上不存在该构件，则从外部的远程仓库下载，同时缓存在私服之上，然后为Maven下载请求提供下载服务，另外，对于自定义或第三方的jar可以从本地上传到私服，供局域网内其他maven用户使用。优点主要有： 1. 节省外网宽带 2. 加速Maven构建 3. 部署第三方构件：可以将公司项目的 jar 发布到私服上，方便项目与项目之间的调用 4. 提高稳定性、增强控制：原因是外网不稳定 5. 降低中央仓库的负荷：原因是中央仓库访问量太大 上面大概介绍了 Maven 仓库概念，接下来我们进入正题 Maven 仓库优先级为了方便测试，我准备了以下几个仓库 172.16.xxx.xxx 远程仓库 （私服） dev.xxx.wiki 远程仓库 （远程） localhost 仓库 是我自己在本机搭建的一个仓库 （镜像） maven.aliyun.com 中央仓库（中央） 本地仓库优先级Maven 本地仓库拥有该包，而远程、镜像、中央、私服都不包含该包。我们来看下 Maven 是怎么获取的123456789101112131415161718192021222324.......// 使用本地仓库，优先级(priority)为 10[DEBUG] Using local repository at E:\OperSource[DEBUG] Using manager EnhancedLocalRepositoryManager with priority 10.0 for E:\OperSource[INFO] Scanning for projects..........[INFO] Installing C:\Users\swipal\Desktop\abc\demo\target\demo-1.0-SNAPSHOT.jar to E:\OperSource\com\cjf\demo\1.0-SNAPSHOT\demo-1.0-SNAPSHOT.jar[DEBUG] Writing tracking file E:\OperSource\com\cjf\demo\1.0-SNAPSHOT\_remote.repositories[INFO] Installing C:\Users\swipal\Desktop\abc\demo\pom.xml to E:\OperSource\com\cjf\demo\1.0-SNAPSHOT\demo-1.0-SNAPSHOT.pom[DEBUG] Writing tracking file E:\OperSource\com\cjf\demo\1.0-SNAPSHOT\_remote.repositories[DEBUG] Installing com.cjf:demo:1.0-SNAPSHOT/maven-metadata.xml to E:\OperSource\com\cjf\demo\1.0-SNAPSHOT\maven-metadata-local.xml[DEBUG] Installing com.cjf:demo/maven-metadata.xml to E:\OperSource\com\cjf\demo\maven-metadata-local.xml[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 1.874 s[INFO] Finished at: 2017-07-07T10:37:32+08:00[INFO] Final Memory: 23M/219M[INFO] ------------------------------------------------------------------------Process finished with exit code 0 从上面可以看出 Maven 一开始就使用本地仓库，并将本地仓库的优先级定制为 10 , 最后 jar 包也在本地仓库找到，Maven 成功打包。 远程仓库优先级前面我们知道了，本地仓库的优先级是最高的，现在我们继续研究远程仓库的优先级（以下的所有例子，都默认本地仓库不拥有我们需要的包） 这一次我们默认配置 profile（私服）为 172.16.xxx.xxx 远程仓库, repository 为 dev.xxx.wiki 远程仓库,mirror 为本地 localhost 仓库，还配置了一个 mirrorOf 为 central 远程仓库为 maven.aliyun.com 的中央仓库, 以下是配置信息settings.xml 文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253······&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;localhost&lt;/id&gt; &lt;name&gt;Public Repositories&lt;/name&gt; &lt;mirrorOf&gt;foo&lt;/mirrorOf&gt; &lt;!--拦截 pom 文件配置的 repository--&gt; &lt;url&gt;http://localhost:8081/repository/maven-public/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;localhost2&lt;/id&gt; &lt;name&gt;Public Repositories&lt;/name&gt; &lt;mirrorOf&gt;foo2&lt;/mirrorOf&gt; &lt;!--配置一个拦截 foo2 的远程仓库的镜像--&gt; &lt;url&gt;http://localhost:8081/repository/maven-snapshots/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;!--覆盖 Maven 默认的配置的中央仓库--&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt;&lt;!--配置私服--&gt;&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;public&lt;/id&gt; &lt;name&gt;Public Repositories&lt;/name&gt; &lt;url&gt;http://172.16.xxx.xxx:8081/nexus/content/groups/public/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;public&lt;/id&gt; &lt;name&gt;Public Repositories&lt;/name&gt; &lt;url&gt;http://172.16.xxx.xxx:8081/nexus/content/groups/public&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/profile&gt; &lt;/profiles&gt;&lt;activeProfiles&gt; &lt;activeProfile&gt;nexus&lt;/activeProfile&gt;&lt;/activeProfiles&gt;······ pom.xml 文件 12345678910111213141516171819202122232425262728&lt;dependencies&gt; &lt;!--xxx-cif-api 存在 172.16.xxx.xxx 仓库--&gt; &lt;dependency&gt; &lt;groupId&gt;com.xxx.cif&lt;/groupId&gt; &lt;artifactId&gt;xxx-cif-api&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!--Chapter1 存在 localhost 仓库--&gt; &lt;dependency&gt; &lt;groupId&gt;com.cjf&lt;/groupId&gt; &lt;artifactId&gt;Chapter1&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;!--配置远程仓库--&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;foo&lt;/id&gt; &lt;name&gt;Public Repositories&lt;/name&gt; &lt;url&gt;http://dev.xxx.wiki:8081/nexus/content/groups/public/&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt; 以下是 Maven 拉取包的日志123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108······· 省略部分日志信息[DEBUG] Using local repository at E:\OperSource[DEBUG] Using manager EnhancedLocalRepositoryManager with priority 10.0 for E:\OperSource[INFO] Scanning for projects...// 从这里可以看出我们配置的镜像替代了我们在 pom 配置的远程仓库[DEBUG] Using mirror localhost (http://localhost:8081/repository/maven-public/) for foo (http://dev.xxx.wiki:8081/nexus/content/groups/public/).替代了默认的中央仓库[DEBUG] Using mirror alimaven (http://maven.aliyun.com/nexus/content/groups/public/) for central (https://repo.maven.apache.org/maven2).// 从这里可以看出 Maven 使用哪些 dependencies 和 plugins 的地址，我们可以看出优先级最高的是 172.16.xxx.xxx,然后就是 localhost 最后才是 maven.aliyun.com// 注意：alimaven (http://maven.aliyun.com/nexus/content/groups/public/, default, releases) 从这里可以看出中央仓库只能获取 releases 包，所有的 snapshots 包都不从中央仓库获取。（可以看前面 central 的配置信息）[DEBUG] === PROJECT BUILD PLAN ================================================[DEBUG] Project: com.cjf:demo:1.0-SNAPSHOT[DEBUG] Dependencies (collect): [][DEBUG] Dependencies (resolve): [compile, runtime, test][DEBUG] Repositories (dependencies): [public (http://172.16.xxx.xxx:8081/nexus/content/groups/public/, default, releases+snapshots), localhost (http://localhost:8081/repository/maven-public/, default, releases+snapshots), alimaven (http://maven.aliyun.com/nexus/content/groups/public/, default, releases)][DEBUG] Repositories (plugins) : [public (http://172.16.xxx.xxx:8081/nexus/content/groups/public, default, releases+snapshots), alimaven (http://maven.aliyun.com/nexus/content/groups/public/, default, releases)][DEBUG] =======================================================================// 寻找本地是否有 maven-metadata.xml 配置文件 ，从这里可以看出寻找不到（后面会详细讲该文件作用）[DEBUG] Could not find metadata com.xxx.cif:xxx-cif-api:0.0.1-SNAPSHOT/maven-metadata.xml in local (E:\OperSource)// 由于寻找不到 Maven 只能从我们配置的远程仓库寻找，由于 Maven 也不知道那个仓库才有，所以同时寻找两个仓库[DEBUG] Using transporter WagonTransporter with priority -1.0 for http://172.16.xxx.xxx:8081/nexus/content/groups/public/[DEBUG] Using transporter WagonTransporter with priority -1.0 for http://localhost:8081/repository/maven-public/[DEBUG] Using connector BasicRepositoryConnector with priority 0.0 for http://localhost:8081/repository/maven-public/[DEBUG] Using connector BasicRepositoryConnector with priority 0.0 for http://172.16.xxx.xxx:8081/nexus/content/groups/public/Downloading: http://172.16.xxx.xxx:8081/nexus/content/groups/public/com/xxx/cif/xxx-cif-api/0.0.1-SNAPSHOT/maven-metadata.xmlDownloading: http://localhost:8081/repository/maven-public/com/xxx/cif/xxx-cif-api/0.0.1-SNAPSHOT/maven-metadata.xml[DEBUG] Writing tracking file E:\OperSource\com\xxx\cif\xxx-cif-api\0.0.1-SNAPSHOT\resolver-status.properties// 从这里可以看出在 172.16.xxx.xxx 找到 xxx-cif-api 的 maven-metadata.xml 文件并下载下来Downloaded: http://172.16.xxx.xxx:8081/nexus/content/groups/public/com/xxx/cif/xxx-cif-api/0.0.1-SNAPSHOT/maven-metadata.xml (781 B at 7.0 KB/sec)// 追踪文件，resolver-status.properties 配置了 jar 包下载地址和时间[DEBUG] Writing tracking file E:\OperSource\com\xxx\cif\xxx-cif-api\0.0.1-SNAPSHOT\resolver-status.properties[DEBUG] Could not find metadata com.xxx.cif:xxx-cif-api:0.0.1-SNAPSHOT/maven-metadata.xml in localhost (http://localhost:8081/repository/maven-public/)// 在 localhost 远程仓库寻找不到 xxx-cif-api 的 maven-metadata.xml[DEBUG] Could not find metadata com.xxx.cif:xxx-cif-api:0.0.1-SNAPSHOT/maven-metadata.xml in local (E:\OperSource)// 跳过的远程请求 [DEBUG] Skipped remote request for com.xxx.cif:xxx-cif-api:0.0.1-SNAPSHOT/maven-metadata.xml, already updated during this session.[DEBUG] Skipped remote request for com.xxx.cif:xxx-cif-api:0.0.1-SNAPSHOT/maven-metadata.xml, already updated during this session.// 默认以后获取 xxx-cif-api 的时候将不在从 localhost 寻找了，除非强制获取才会再次从 localhost 寻找这个包[DEBUG] Failure to find com.xxx.cif:xxx-cif-api:0.0.1-SNAPSHOT/maven-metadata.xml in http://localhost:8081/repository/maven-public/ was cached in the local repository, resolution will not be reattempted until the update interval of localhost has elapsed or updates are forced// 将 172.16.xxx.xxx 优先级升为 0 ，并下载 xxx-cif-api 的 pom 文件[DEBUG] Using transporter WagonTransporter with priority -1.0 for http://172.16.xxx.xxx:8081/nexus/content/groups/public/[DEBUG] Using connector BasicRepositoryConnector with priority 0.0 for http://172.16.xxx.xxx:8081/nexus/content/groups/public/Downloading: http://172.16.xxx.xxx:8081/nexus/content/groups/public/com/xxx/cif/xxx-cif-api/0.0.1-SNAPSHOT/xxx-cif-api-0.0.1-20170515.040917-89.pomDownloaded: http://172.16.xxx.xxx:8081/nexus/content/groups/public/com/xxx/cif/xxx-cif-api/0.0.1-SNAPSHOT/xxx-cif-api-0.0.1-20170515.040917-89.pom (930 B at 82.6 KB/sec)// _remote.repositories 记录的以后使用那个远程仓库获取 （ps:这个文件作用我要不是很清楚作用，以上观点是自己推测出来的。）[DEBUG] Writing tracking file E:\OperSource\com\xxx\cif\xxx-cif-api\0.0.1-SNAPSHOT\_remote.repositories[DEBUG] Writing tracking file E:\OperSource\com\xxx\cif\xxx-cif-api\0.0.1-SNAPSHOT\xxx-cif-api-0.0.1-20170515.040917-89.pom.lastUpdated// 后面获取 Chapter1 包的流程跟 com.xxx.cif 是一样的，不过最后是在 localhost 寻找到而已，所以这分日志就不贴出来了。// 最后在下载包的时候，都到对应的仓库下载[DEBUG] Using transporter WagonTransporter with priority -1.0 for http://172.16.xxx.xxx:8081/nexus/content/groups/public/[DEBUG] Using connector BasicRepositoryConnector with priority 0.0 for http://172.16.xxx.xxx:8081/nexus/content/groups/public/Downloading: http://172.16.xxx.xxx:8081/nexus/content/groups/public/com/xxx/cif/xxx-cif-api/0.0.1-SNAPSHOT/xxx-cif-api-0.0.1-20170515.040917-89.jarDownloading: http://172.16.xxx.xxx:8081/nexus/content/groups/public/com/xxx/util/xxx-util/0.0.1-SNAPSHOT/xxx-util-0.0.1-20170514.091041-31.jarDownloaded: http://172.16.xxx.xxx:8081/nexus/content/groups/public/com/xxx/util/xxx-util/0.0.1-SNAPSHOT/xxx-util-0.0.1-20170514.091041-31.jar (26 KB at 324.2 KB/sec)Downloaded: http://172.16.xxx.xxx:8081/nexus/content/groups/public/com/xxx/cif/xxx-cif-api/0.0.1-SNAPSHOT/xxx-cif-api-0.0.1-20170515.040917-89.jar (68 KB at 756.6 KB/sec)[DEBUG] Writing tracking file E:\OperSource\com\xxx\cif\xxx-cif-api\0.0.1-SNAPSHOT\_remote.repositories[DEBUG] Writing tracking file E:\OperSource\com\xxx\cif\xxx-cif-api\0.0.1-SNAPSHOT\xxx-cif-api-0.0.1-20170515.040917-89.jar.lastUpdated[DEBUG] Writing tracking file E:\OperSource\com\xxx\util\xxx-util\0.0.1-SNAPSHOT\_remote.repositories[DEBUG] Writing tracking file E:\OperSource\com\xxx\util\xxx-util\0.0.1-SNAPSHOT\xxx-util-0.0.1-20170514.091041-31.jar.lastUpdated[DEBUG] Using transporter WagonTransporter with priority -1.0 for http://localhost:8081/repository/maven-public/[DEBUG] Using connector BasicRepositoryConnector with priority 0.0 for http://localhost:8081/repository/maven-public/Downloading: http://localhost:8081/repository/maven-public/com/cjf/Chapter1/0.0.1-SNAPSHOT/Chapter1-0.0.1-20170708.092339-1.jarDownloaded: http://localhost:8081/repository/maven-public/com/cjf/Chapter1/0.0.1-SNAPSHOT/Chapter1-0.0.1-20170708.092339-1.jar (8 KB at 167.0 KB/sec)[DEBUG] Writing tracking file E:\OperSource\com\cjf\Chapter1\0.0.1-SNAPSHOT\_remote.repositories[DEBUG] Writing tracking file E:\OperSource\com\cjf\Chapter1\0.0.1-SNAPSHOT\Chapter1-0.0.1-20170708.092339-1.jar.lastUpdated[INFO] Installing C:\Users\swipal\Desktop\abc\demo\target\demo-1.0-SNAPSHOT.jar to E:\OperSource\com\cjf\demo\1.0-SNAPSHOT\demo-1.0-SNAPSHOT.jar[DEBUG] Writing tracking file E:\OperSource\com\cjf\demo\1.0-SNAPSHOT\_remote.repositories[INFO] Installing C:\Users\swipal\Desktop\abc\demo\pom.xml to E:\OperSource\com\cjf\demo\1.0-SNAPSHOT\demo-1.0-SNAPSHOT.pom[DEBUG] Writing tracking file E:\OperSource\com\cjf\demo\1.0-SNAPSHOT\_remote.repositories[DEBUG] Installing com.cjf:demo:1.0-SNAPSHOT/maven-metadata.xml to E:\OperSource\com\cjf\demo\1.0-SNAPSHOT\maven-metadata-local.xml[DEBUG] Installing com.cjf:demo/maven-metadata.xml to E:\OperSource\com\cjf\demo\maven-metadata-local.xml[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 10.549 s[INFO] Finished at: 2017-07-09T18:13:20+08:00[INFO] Final Memory: 26M/219M[INFO] ------------------------------------------------------------------------······· 好了，看了这么多的配置文件信息和日志信息，我们也总结一下 Maven 远程仓库优先级了。 主要有以下几点：1.从日志信息我们得出这几种maven仓库的优先级别为 本地仓库 &gt; 私服 （profile）&gt; 远程仓库（repository）和 镜像 （mirror） &gt; 中央仓库 （central） 2.镜像是一个特殊的配置，其实镜像等同与远程仓库，没有匹配远程仓库的镜像就毫无作用（如 foo2）。3.总结上面所说的，Maven 仓库的优先级就是 私服和远程仓库 的对比，没有其它的仓库类型。为什么这么说是因为，镜像等同远程，而中央其实也是 maven super xml 配置的一个repository 的一个而且。所以 maven 仓库真正的优先级为 本地仓库 &gt; 私服（profile）&gt; 远程仓库（repository） maven-metadata.xml 文件Maven Repository Metadata 可用于表示： 1. 一个没有版本的工件：它提供有关该工件的可用版本的信息 2. 快照伪像：它提供有关快照的精确信息 3. 包含Maven插件工件的组：它提供了有关此组中可用插件的信息。 元数据文件名是： 远程存储库中的 maven-metadata.xml， maven-metadata- &lt;repo-id&gt;.xml在本地存储库中，用于具有repo-id标识符的存储库中的元标记。 以上是 Maven 官网对该文件的解释。 作用问题：有时候我们更新最新包的时候，会发现最新的包被拉取下来的，但是项目使用的包还是旧的包。所以我们要分析下是什么原因导致的。 首先我们先大概的了解下 maven-metadata.xml 文件。1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;metadata modelVersion="1.1.0"&gt; &lt;groupId&gt;com.cjf&lt;/groupId&gt; &lt;artifactId&gt;Chapter1&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;versioning&gt; &lt;snapshot&gt; &lt;!--当前版本下的最新快照信息--&gt; &lt;timestamp&gt;20170710.071727&lt;/timestamp&gt; &lt;!--快照的时间戳--&gt; &lt;buildNumber&gt;6&lt;/buildNumber&gt; &lt;!--构件号--&gt; &lt;/snapshot&gt; &lt;lastUpdated&gt;20170710071727&lt;/lastUpdated&gt;&lt;!--metadata文件被更新的时间--&gt; &lt;snapshotVersions&gt; &lt;snapshotVersion&gt; &lt;!--当前版本下可用的子快照版本信息--&gt; &lt;extension&gt;jar&lt;/extension&gt; &lt;value&gt;0.0.1-20170710.071727-6&lt;/value&gt;&lt;!--子快照版本的信息--&gt; &lt;updated&gt;20170710071727&lt;/updated&gt; &lt;!--这个子快照版本的更新时间--&gt; &lt;/snapshotVersion&gt; &lt;snapshotVersion&gt; &lt;extension&gt;pom&lt;/extension&gt; &lt;value&gt;0.0.1-20170710.071727-6&lt;/value&gt; &lt;updated&gt;20170710071727&lt;/updated&gt; &lt;/snapshotVersion&gt; &lt;/snapshotVersions&gt; &lt;/versioning&gt;&lt;/metadata&gt; 其中 lastUpdated 是最中要的一个属性，Maven 更新工程的 jar包时，会比较 lastUpdated 时间戳值，哪个值更大，就以哪个文件为准。 接下来我们看下 Maven 为我们生成了那些文件我们可以看到 maven-metadata.xml 一共有三个 1. maven-metadata-local.xml 本地的元数据, Maven install 的时候就会生成。 2. maven-metadata-snapshots.xml Maven deploy 时会生成 3. maven-metadata-localhost.xml 远程仓库获取的时候生成 (repository 的 id = localhost) 以上的文件其实都是 Maven 的过渡文件而已 例如 maven-metadata-snapshots 就是 Maven deploy 先从远程仓库对应包的 maven-metadata.xml 下载下来，然后修改快照信息后在上传到远程仓库上。 例如 maven-metadata-localhost 的作用是在 Maven 在拉取包的时候，会先跟本地 maven-metadata-local 比较下 lastUpdated 时间戳值，值大用哪个。如果是 Mavne 强制更新 的时候(没有强制更新是不会) 会下载远程的 maven-metadata.xml 比较远程，本地，和之前远程保存下来的 maven-metadata 文件。 所以有时候 maven 库上的 jar 包已经更新，而我们总是拉取不到 maven 的包原因就是本地的 maven-metadata-local 的 lastUpdated 比较大。 我们验证下 Maven deploy 例子123456789101112131415161718192021222324[INFO] --- maven-deploy-plugin:2.8.2:deploy (default-deploy) @ Chapter1 ---// 先从远程下载快照 maven-metadata.xmlDownloading: http://localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/0.0.1-SNAPSHOT/maven-metadata.xmlDownloaded: http://localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/0.0.1-SNAPSHOT/maven-metadata.xml (768 B at 3.3 KB/sec)// 将项目的 jar 和 pom 文件更新到远程仓库Uploading: http://localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/0.0.1-SNAPSHOT/Chapter1-0.0.1-20170710.121310-15.jarUploaded: http://localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/0.0.1-SNAPSHOT/Chapter1-0.0.1-20170710.121310-15.jar (8 KB at 14.1 KB/sec)Uploading: http://localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/0.0.1-SNAPSHOT/Chapter1-0.0.1-20170710.121310-15.pomUploaded: http://localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/0.0.1-SNAPSHOT/Chapter1-0.0.1-20170710.121310-15.pom (2 KB at 2.0 KB/sec)Downloading: http://localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/maven-metadata.xmlDownloaded: http://localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/maven-metadata.xml (275 B at 1.6 KB/sec)// 上传 maven-metadata.xml 到远程仓库Uploading: http://localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/0.0.1-SNAPSHOT/maven-metadata.xmlUploaded: http://localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/0.0.1-SNAPSHOT/maven-metadata.xml (768 B at 1.0 KB/sec)Uploading: http://localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/maven-metadata.xmlUploaded: http://localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/maven-metadata.xml (275 B at 0.4 KB/sec)[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 5.231 s[INFO] Finished at: 2017-07-10T20:13:13+08:00[INFO] Final Memory: 19M/226M[INFO] ------------------------------------------------------------------------ 总结原本以为两天就写好这篇文章，在自己理清思路的时候总是被自己绕晕了。比如在 Nexus 的 Central 配置的中央仓库获取，和 maven-metadata.xml 是如何比较的。 如果以上文章有误，等博客的评论系统搭建起来后欢迎大家指认出来。]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LogBack 使用]]></title>
    <url>%2F2017%2F09%2F03%2FLogback%2F</url>
    <content type="text"><![CDATA[26 Seven 2017 前言之前项目一直使用 logback ,现在大概写下了 logback 基础配置。 简介LogBack是一个日志框架，它是Log4j作者Ceki的又一个日志组件。 LogBack,Slf4j,Log4j之间的关系 slf4j是The Simple Logging Facade for Java的简称，是一个简单日志门面抽象框架，它本身只提供了日志Facade API和一个简单的日志类实现，一般常配合Log4j，LogBack，java.util.logging使用。Slf4j作为应用层的Log接入时，程序可以根据实际应用场景动态调整底层的日志实现框架(Log4j/LogBack/JdkLog…)； LogBack和Log4j都是开源日记工具库，LogBack是Log4j的改良版本，比Log4j拥有更多的特性，同时也带来很大性能提升。 LogBack官方建议配合Slf4j使用，这样可以灵活地替换底层日志框架。 LogBack的结构LogBack分为3个组件，logback-core, logback-classic 和 logback-access。其中logback-core提供了LogBack的核心功能，是另外两个组件的基础。logback-classic则实现了Slf4j的API，所以当想配合Slf4j使用时，则需要引入这个包。logback-access是为了集成Servlet环境而准备的，可提供HTTP-access的日志接口。 Log的行为级别：OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL从下向上，当选择了其中一个级别，则该级别向下的行为是不会被打印出来。举个例子，当选择了INFO级别，则INFO以下的行为则不会被打印出来。 获取 Logger 对象 我们先从获取 logger 对象开始1Logger logger = LoggerFactory.getLogger(xxx.class.getName()); LoggerFactory 是 slf4j 的日志工厂，获取 logger 方法就来自这里。123456以下代码摘自：org.slf4j.LoggerFactorypublic static Logger getLogger(String name) &#123; ILoggerFactory iLoggerFactory = getILoggerFactory(); return iLoggerFactory.getLogger(name);&#125; 这个方法里面有分为两个过程。第一个过程是获取ILoggerFactory，就是真正的日志工厂。第二个过程就是从真正的日志工厂中获取logger。接下来我们看下到底是怎么获取的12345678910111213141516171819202122232425262728以下代码摘自：org.slf4j.LoggerFactorypublic static ILoggerFactory getILoggerFactory() &#123;if (INITIALIZATION_STATE == UNINITIALIZED) &#123; INITIALIZATION_STATE = ONGOING_INITIALIZATION; // 第一次调用会去加载 StaticLoggerBinder.class 文件来决定 LoggerFactory 的实现类 // （补充下：不同日志包下都有 StaticLoggerBinder 这个类文件，这个会决定 LoggerFactory 初始化那种类型的日志） performInitialization();&#125;// INITIALIZATION_STATE 值判断是否有加载初始化过 ILoggerFactory 实例。switch (INITIALIZATION_STATE) &#123; case SUCCESSFUL_INITIALIZATION: // 返回对应的 ILoggerFactory 实例 return StaticLoggerBinder.getSingleton().getLoggerFactory(); case NOP_FALLBACK_INITIALIZATION: // 当加载不到一个 StaticLoggerBinder 时，会走这里 // 返回一个 NOPLoggerFactory 实例 return NOP_FALLBACK_FACTORY; case FAILED_INITIALIZATION: // 初始化异常 throw new IllegalStateException(UNSUCCESSFUL_INIT_MSG); case ONGOING_INITIALIZATION: // support re-entrant behavior. // See also http://bugzilla.slf4j.org/show_bug.cgi?id=106 return TEMP_FACTORY;&#125;throw new IllegalStateException("Unreachable code");&#125; 接下来我们来看下是怎么加载 StaticLoggerBinder.class 文件的 1234567891011121314151617181920212223242526272829303132333435以下代码摘自：org.slf4j.LoggerFactory private final static void bind() &#123; try &#123; // 加载 StaticLoggerBinder Set staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet(); reportMultipleBindingAmbiguity(staticLoggerBinderPathSet); // 最后会随机选择一个StaticLoggerBinder.class来创建一个单例 StaticLoggerBinder.getSingleton(); // 改变 INITIALIZATION_STATE 值，表示成功初始化 Factory。 // 并且以后在获取 Logger 的时候并不会再次加载该方法 INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION; reportActualBinding(staticLoggerBinderPathSet); emitSubstituteLoggerWarning(); &#125; catch (NoClassDefFoundError ncde) &#123; String msg = ncde.getMessage(); if (messageContainsOrgSlf4jImplStaticLoggerBinder(msg)) &#123; // 加载不到 StaticLoggerBinder 文件 INITIALIZATION_STATE = NOP_FALLBACK_INITIALIZATION; &#125; else &#123; failedBinding(ncde); throw ncde; &#125; &#125; catch (java.lang.NoSuchMethodError nsme) &#123; String msg = nsme.getMessage(); if (msg != null &amp;&amp; msg.indexOf("org.slf4j.impl.StaticLoggerBinder.getSingleton()") != -1) &#123; // 初始化异常 INITIALIZATION_STATE = FAILED_INITIALIZATION; &#125; throw nsme; &#125; catch (Exception e) &#123; failedBinding(e); throw new IllegalStateException("Unexpected initialization failure", e); &#125; &#125; 加载 StaticLoggerBinder.class12345678910111213141516以下代码摘自：org.slf4j.LoggerFactory.findPossibleStaticLoggerBinderPathSetprivate static String STATIC_LOGGER_BINDER_PATH = "org/slf4j/impl/StaticLoggerBinder.class";···if (loggerFactoryClassLoader == null) &#123; paths = ClassLoader.getSystemResources(STATIC_LOGGER_BINDER_PATH); &#125; else &#123; paths = loggerFactoryClassLoader .getResources(STATIC_LOGGER_BINDER_PATH); &#125; while (paths.hasMoreElements()) &#123; URL path = (URL) paths.nextElement(); staticLoggerBinderPathSet.add(path); &#125;··· 当项目中存在多个StaticLoggerBinder.class文件时，运行项目会出现以下日志：（这里获取的规则就近原则，如果在 maven 先配置 slf4j 而后面在配置 logback，则这里初始化的是 slf4j）12345SLF4J: Class path contains multiple SLF4J bindings.SLF4J: Found binding in [jar:file:/E:/OperSource/org/slf4j/slf4j-log4j12/1.7.12/slf4j-log4j12-1.7.12.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: Found binding in [jar:file:/E:/OperSource/ch/qos/logback/logback-classic/1.1.3/logback-classic-1.1.3.jar!/org/slf4j/impl/StaticLoggerBinder.class]SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.SLF4J: Actual binding is of type [org.slf4j.impl.Log4jLoggerFactory] 返回实例123以下代码摘自：org.slf4j.LoggerFactory.getILoggerFactoryStaticLoggerBinder.getSingleton().getLoggerFactory(); LogBack 配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;configuration scan="true" scanPeriod="60 seconds" debug="false"&gt; &lt;!-- 项目名称配置 --&gt; &lt;contextName&gt;example&lt;/contextName&gt; &lt;!-- 属性 --&gt; &lt;property name="APP_Name" value="example" /&gt; &lt;!-- 统一的时间格式，用于日志头输出 --&gt; &lt;timestamp key="timeStyle" datePattern="yyyy-MM-dd HH:mm:ss.SSS"/&gt; &lt;!--配置控制台输出,开发环境有--&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- encoder 默认配置为PatternLayoutEncoder --&gt; &lt;encoder&gt; &lt;pattern&gt;[%d&#123;timeStyle&#125;] [%cn] %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--文件输出配置--&gt; &lt;appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;file&gt;../logs/$&#123;APP_Name&#125;_run.log&lt;/file&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy"&gt; &lt;fileNamePattern&gt;../logs/$&#123;APP_Name&#125;_run.%i.log.zip&lt;/fileNamePattern&gt; &lt;minIndex&gt;1&lt;/minIndex&gt; &lt;maxIndex&gt;10&lt;/maxIndex&gt; &lt;/rollingPolicy&gt; &lt;triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"&gt; &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt; &lt;/triggeringPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;[%d&#123;timeStyle&#125;] [%cn] %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name="BUSINESS_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;file&gt;../logs/$&#123;APP_Name&#125;_business.log&lt;/file&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy"&gt; &lt;fileNamePattern&gt;../logs/$&#123;APP_Name&#125;_business.%i.business.zip&lt;/fileNamePattern&gt; &lt;minIndex&gt;1&lt;/minIndex&gt; &lt;maxIndex&gt;10&lt;/maxIndex&gt; &lt;/rollingPolicy&gt; &lt;triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"&gt; &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt; &lt;/triggeringPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;[%d&#123;timeStyle&#125;] [%cn] %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt;&lt;!-- 只打印错误日志 --&gt; &lt;level&gt;WARE&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 异步输出 --&gt; &lt;appender name="ASYNC" class="ch.qos.logback.classic.AsyncAppender"&gt; &lt;!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 --&gt; &lt;discardingThreshold&gt;0&lt;/discardingThreshold&gt; &lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为256 --&gt; &lt;queueSize&gt;256&lt;/queueSize&gt; &lt;!-- 添加附加的appender,最多只能添加一个 --&gt; &lt;appender-ref ref="FILE"/&gt; &lt;/appender&gt; &lt;appender name="BUSINESS_ASYNC" class="ch.qos.logback.classic.AsyncAppender"&gt; &lt;!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 --&gt; &lt;discardingThreshold&gt;0&lt;/discardingThreshold&gt; &lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为256 --&gt; &lt;queueSize&gt;256&lt;/queueSize&gt; &lt;!-- 添加附加的appender,最多只能添加一个 --&gt; &lt;appender-ref ref="BUSINESS_FILE"/&gt; &lt;/appender&gt; &lt;!-- 为数据库开启显示sql --&gt; &lt;logger name="com.cjf.example.repository" level="DEBUG"&gt;&lt;/logger&gt; &lt;logger name="com.cjf" level="INFO"&gt;&lt;/logger&gt; &lt;!--日志的root目录，用于定位日志输出级别--&gt; &lt;root level="INFO"&gt; &lt;appender-ref ref="ASYNC"/&gt; &lt;appender-ref ref="STDOUT"/&gt; &lt;/root&gt;&lt;/configuration&gt; 上面就是一个常用的日志配置模版，下面就从跟节点来解析每个节点 1.configurationscan：当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。scanPeriod：监测配置文件是否有修改的时间间隔，默认 60s。debug：是否打印 logback 内部日志，默认 false.2.contextName 项目名称logger 上下文容器名称，默认 ‘default’，用于区分不同应用程序的记录。（可以在日志输出的时候将项目名称打印处理方便系统间交互 比如上面配置的 %cn）3.property 设置变量定义变量后，可以使${}来使用变量。4.timestamp 设置时间戳格式key:标识此 的名字；datePattern：设置将当前时间（解析配置文件的时间）转换为字符串的模式，遵循Java.txt.SimpleDateFormat的格式。5.logger用来设置某一个包或者具体的某一个类的日志打印级别、以及指定。仅有一个name属性，一个可选的level和一个可选的addtivity属性。name: 用来指定受此loger约束的某一个包或者具体的某一个类。level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。如果未设置此属性，那么当前loger将会继承上级的级别。addtivity:是否向上级loger传递打印信息。默认是true。loger可以包含零个或多个appender-ref元素，标识这个appender将会添加到这个loger。6.root也是 loger 元素，但是它是根 loger。只有一个 level 属性，应为已经被命名为 “root”.root 可以包含零个或多个 appender-ref 元素，标识这个 appender 将会添加到这个 loger。 什么是 Appender？logback 将日志记录事件写入到名为 appender 的组件的任务,不同 appender 决定了日志的记录方式。appender 有多种实现的方式，下面简单介绍几种比较常用的配置。 更多详情请参考官方文档 ConsoleAppender把日志添加到控制台，有以下子节点： encoder：对日志进行格式化 target：字符串 System.out 或者 System.err ，默认 System.out; withJansi：日志彩色输出 例如123456789101112&lt;configuration&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder&gt; &lt;pattern&gt;[%d&#123;timeStyle&#125;] [%cn] %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="DEBUG"&gt; &lt;appender-ref ref="STDOUT" /&gt; &lt;/root&gt; &lt;/configuration&gt; RollingFileAppender滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件。file：被写入的文件名，可以是相对目录，也可以是绝对目录，如果上级目录不存在会自动创建，没有默认值。append：如果是 true，日志被追加到文件结尾，如果是 false，清空现存文件，默认是true。encoder：对记录事件进行格式化。rollingPolicy：当发生滚动时，决定 RollingFileAppender 的行为，涉及文件移动和重命名。triggeringPolicy：告知 RollingFileAppender 合适激活滚动。prudent：当为true时，不支持FixedWindowRollingPolicy。支持TimeBasedRollingPolicy，但是有两个限制，1不支持也不允许文件压缩，2不能设置file属性，必须留空。 rollingPolicy 有两种类型，分别是 TimeBasedRollingPolicy，FixedWindowRollingPolicy。 例如 TimeBasedRollingPolicy 配置123456789101112&lt;!--输出到文件--&gt;&lt;appender name="file" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;file&gt;$&#123;log.path&#125;&lt;/file&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;logback.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt;&lt;/appender&gt; fileNamePattern 定义了日志的切分方式——把每一天的日志归档到一个文件中maxHistory 表示只保留最近30天的日志，以防止日志填满整个磁盘空间。totalSizeCap 用来指定日志文件的上限大小，例如设置为1GB的话，那么到了这个值，就会删除旧的日志。 例如 FixedWindowRollingPolicy 配置1234567891011121314&lt;appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;file&gt;../logs/$&#123;APP_Name&#125;_run.log&lt;/file&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy"&gt; &lt;fileNamePattern&gt;../logs/$&#123;APP_Name&#125;_run.%i.log.zip&lt;/fileNamePattern&gt; &lt;minIndex&gt;1&lt;/minIndex&gt; &lt;maxIndex&gt;10&lt;/maxIndex&gt; &lt;/rollingPolicy&gt; &lt;triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"&gt; &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt; &lt;/triggeringPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;[%d&#123;timeStyle&#125;] [%cn] %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt;&lt;/appender&gt; 这里多了一个 SizeBasedTriggeringPolicy 触发机制，但 log 文件大于 10MB 的时候，就开始执行 rolling。minIndex 和 maxIndex 表示保存日志数量，但大于 maxIndex 的时候，会开始删除旧的日志。 必须包含“%i”例如，假设最小值和最大值分别为1和2，命名模式为mylog%i.log,会产生归档文件mylog1.log和mylog2.log。还可以指定文件压缩选项，例如，mylog%i.log.gz或者 没有log%i.log.zip AsyncAppender 异步输出这里就不写了，可以参考文章。 总结由于没有深入去了解 logback ,许多内容都是网上摘来的，写文章的时候也很费劲。思路不清晰。]]></content>
      <categories>
        <category>LogBack</category>
      </categories>
      <tags>
        <tag>LogBack</tag>
      </tags>
  </entry>
</search>