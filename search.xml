<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[(两到三年)Java 面试精髓]]></title>
      <url>/2017/12/10/(%E4%B8%A4%E5%88%B0%E4%B8%89%E5%B9%B4)Java%20%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%AB%93/</url>
      <content type="html"><![CDATA[<h1 id="两到三年-Java-面试精髓"><a href="#两到三年-Java-面试精髓" class="headerlink" title="(两到三年)Java 面试精髓"></a>(两到三年)Java 面试精髓</h1><h2 id="Struts2框架的执行流程"><a href="#Struts2框架的执行流程" class="headerlink" title="Struts2框架的执行流程 ?"></a>Struts2框架的执行流程 ?</h2><p>从客户端发送请求过来,先经过前端控制器（核心过滤器）过滤器中,执行一组拦截器（一组拦截器 就会完成部分功能代码）执行目标Action,</p>
<p>在Action中返回一个结果视图,根据Result的配置进行页面的跳转.</p>
<p>Struts2和Struts1没有任何联系.Struts2内核是webwork的内核.</p>
<h2 id="hibernate框架的理解"><a href="#hibernate框架的理解" class="headerlink" title="hibernate框架的理解?"></a>hibernate框架的理解?</h2><p>定义:</p>
<p>Hibernate是一个开放源代码的对象关系映射（ORM）框架，它对JDBC进行了非常轻量级的对象封装，</p>
<p>使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库.可以通过对象保存到关系型数据库中,仅提供sava/get方法即可</p>
<p>Hibernate是一个持久层的ORM框架.</p>
<h2 id="Spring框架的理解"><a href="#Spring框架的理解" class="headerlink" title="Spring框架的理解?"></a>Spring框架的理解?</h2><p>Spring是一个开源框架,核心是控制反转（IOC编程思想）和面向切面（AOP）。简单来说，Spring是一个分层的JavaSE/EEfull-stack(一站式) 轻量级开源框架</p>
<p>Spring的AOP的理解:通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术,利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率.可以在不修改源代码的前提下，对程序进行增强.</p>
<p>例如:在以前配置事务的时候,进行事务的回滚,提交等操作,配置AOP 以后可以将事务的权限交给Spring框架去管理,自动管理</p>
<h2 id="SpringMVC的理解"><a href="#SpringMVC的理解" class="headerlink" title="SpringMVC的理解?"></a>SpringMVC的理解?</h2><p>springMvc:是一个表现层框架,就是从请求中接收传入的参数,</p>
<p>将处理后的结果数据返回给页面展示</p>
<p>基本类型:string,double,float,integer,long.boolean</p>
<h2 id="Mybatis的理解"><a href="#Mybatis的理解" class="headerlink" title="Mybatis的理解?"></a>Mybatis的理解?</h2><p>MyBatis是一个优秀的持久层框架，它对jdbc的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。</p>
<p>Mybatis通过xml或注解的方式将要执行的各种statement（statement、preparedStatement、CallableStatement）配置起来，并通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象并返回。</p>
<p>#{}可以有效防止sql注入</p>
<h2 id="Servlet的理解"><a href="#Servlet的理解" class="headerlink" title="Servlet的理解?"></a>Servlet的理解?</h2><p>* GET和POST区别?</p>
<p>* GET：请求参数会显示到地址栏.GET方式有大小的限制.GET方式没有请求体</p>
<p>* POST：请求参数不会显示到地址栏.在请求体中.POST没有大小限制.POST方式有请求体.</p>
<p>* 只有表单设置为method=”post”才是post请求.其他的都是get请求</p>
<p>生命周期:客户端第一次访问该Servlet的时候才会创建一个Servlet的对象,那么Servlet中的init方法就会执行.任何一次从客户端发送的请求,那么服务器创建一个新的线程执行Servlet中service方法为这次请求服务.</p>
<p>service方法的内部根据请求的方式的不同调用不同doXXX的方法.当Servlet从服务器中移除或者关闭服务器的时候Servlet对象就会被销毁.destroy的方法就会执行.</p>
<h2 id="Struts2与SpringMVC的区别"><a href="#Struts2与SpringMVC的区别" class="headerlink" title="Struts2与SpringMVC的区别?"></a>Struts2与SpringMVC的区别?</h2><p>1)springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过虑器。</p>
<p>2)springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。</p>
<p>3)Struts采用值栈存储请求和响应的数据，通过OGNL存取数据， springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。</p>
<h2 id="Jsp的核心及核心标签"><a href="#Jsp的核心及核心标签" class="headerlink" title="Jsp的核心及核心标签?"></a>Jsp的核心及核心标签?</h2><p>a) Servlet</p>
<p>b) Core XML Database Funcations</p>
<h2 id="Redis什么情况下使用，redis持久化方案"><a href="#Redis什么情况下使用，redis持久化方案" class="headerlink" title="Redis什么情况下使用，redis持久化方案?"></a>Redis什么情况下使用，redis持久化方案?</h2><p>a) 处理大数据量的时候</p>
<p>b) Redis的所有数据都是保存在内存中，</p>
<p>Rdb：快照形式，定期把内存中当前时刻的数据保存到磁盘，redis默认支持的持久化方案</p>
<p>aof形式：append only file。把所有对redis数据库操作的命令，增删改操作命令，保存到文件中，数据库恢复是把所有命令执行一遍即可。</p>
<h2 id="Hibernate和Mybatis的区别和优劣"><a href="#Hibernate和Mybatis的区别和优劣" class="headerlink" title="Hibernate和Mybatis的区别和优劣?"></a>Hibernate和Mybatis的区别和优劣?</h2><p>a) Sql优化方面：hibernate的查询会将表中所有的字段查询出来，这一点会有性能的消耗</p>
<p>Mybatis的sql是手动编写的，所以可以按需求指定查询的字段，sql会更灵活，可控性更好</p>
<p>b) Hibernate是在JDBC上进行了一次封装</p>
<p>Mybatis是基于原生的JDBC，运行速度有优势</p>
<p>c) Mybatis mapper xml支持动态sql；Hibernate不支持</p>
<p>d) Hibernate与具体数据库的关联只需在xml文件中配置即可，所有hql语句与具体的数据库无关，移植性好</p>
<p>Mybatis项目所有的sql语句都是依赖所用的数据库的，所以不同数据库类型的支持不好</p>
<h2 id="StringBuffer、StringBuilder的区别"><a href="#StringBuffer、StringBuilder的区别" class="headerlink" title="StringBuffer、StringBuilder的区别?"></a>StringBuffer、StringBuilder的区别?</h2><p>StringBuffer、StringBuilder是容器，是可变的字符串序列，存放于堆内存。</p>
<p>StringBuffer是JDK1.0版本的，线程是安全的，效率比较低。StringBuilder是JDK1.5出现的，线程不安全，效率高。</p>
<h2 id="说一下SOLR"><a href="#说一下SOLR" class="headerlink" title="说一下SOLR?"></a>说一下SOLR?</h2><p>solr就是一个中文搜索引擎,做完分词之后会做热度排名,核心是中文分词器,全文搜索支持,索引值指向对应的文档,相当于是一个字典,默认为collection的一个域对象,查询快,效率高.</p>
<p>可以在Redis里做分词之后的缓存,每次搜索一次就次数加一,里面还有一个投票容错机制,主机挂掉还有备份机,一般配置都为奇数态配置.</p>
<h2 id="Solr与Lucene的区别"><a href="#Solr与Lucene的区别" class="headerlink" title="Solr与Lucene的区别?"></a>Solr与Lucene的区别?</h2><p>Lucene是一个开放源代码的全文检索引擎工具包，它不是一个完整的全文检索引擎，Lucene提供了完整的查询引擎和索引引擎，目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者以Lucene为基础构建全文检索引擎。</p>
<p>Solr的目标是打造一款企业级的搜索引擎系统，它是一个搜索引擎服务，可以独立运行，通过Solr可以非常快速的构建企业的搜索引擎，通过Solr也可以高效的完成站内搜索功能。</p>
<h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis?"></a>什么是Redis?</h2><p>1) Redis的高性能是由于其将所有数据都存储在了内存中，为了使Redis在重启之后仍能保证数据不丢失，需要将数据从内存中同步到硬盘中，这一过程就是持久化。</p>
<p>Redis支持两种方式的持久化，一种是RDB方式，一种是AOF方式。可以单独使用其中一种或将二者结合使用。</p>
<p>1.1RDB持久化</p>
<p>RDB方式的持久化是通过快照（snapshotting）完成的，当符合一定条件时Redis会自动将内存中的数据进行快照并持久化到硬盘。</p>
<p>每次进行访问进行存储,如果服务器一旦崩溃,会导致数据丢失</p>
<p>RDB是Redis默认采用的持久化方式，在redis.conf配置文件中默认有此下配置：</p>
<p>save 900 1 , save 300 10, save 60 10000</p>
<p>save 开头的一行就是持久化配置，可以配置多个条件（每行配置一个条件），每个条件之间是“或”的关系，“save 900 1”表示15分钟（900秒钟）内</p>
<p>至少</p>
<p>1个键被更改则进行快照，“save 300 10”表示5分钟（300秒）内至少10个键被更改则进行快照。</p>
<p>在redis.conf中：</p>
<p>配置dir指定</p>
<p>rdb快照文件的位置;配置dbfilenam指定rdb快照文件的名称</p>
<p>Redis启动后会读取RDB快照文件，将数据从硬盘载入到内存。根据数据量大小与结构和服务器性能不同，这个时间也不同。</p>
<p>通常将记录一千万个字符串类型键、大小为1GB的快照文件载入到内存中需要花费20～30秒钟。</p>
<p>问题总结：</p>
<p>通过RDB方式实现持久化，一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据。这就需要开发者根据具体的应用场合，通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能够接受的范围。如果数据很重要以至于无法承受任何损失，则可以考虑使用AOF方式进行持久化。</p>
<p>1.2AOF持久化</p>
<p>默认情况下Redis没有开启AOF（append only file）方式的持久化，访问一段存储一段,效率高.</p>
<p>可以通过appendonly参数开启：appendonly yes开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件</p>
<p>AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof，可以通过appendfilename参数修改：appendfilename appendonly.aof</p>
<p>2)主从复制（了解）</p>
<p>2.1什么是主从复制</p>
<p>持久化保证了即使redis服务重启也会丢失数据，因为redis服务重启后会将硬盘上持久化的数据恢复到内存中，但是当redis服务器的硬盘损坏了可能会导致数据丢失，如果通过redis的主从复制机制就可以避免这种单点故障，如下图：</p>
<p>说明：</p>
<p>n主redis中的数据有两个副本（replication）即从redis1和从redis2，即使一台redis服务器宕机其它两台redis服务也可以继续提供服务。</p>
<p>n主redis中的数据和从redis上的数据保持实时同步，当主redis写入数据时通过主从复制机制会复制到两个从redis服务上。</p>
<p>n只有一个主redis，可以有多个从redis。</p>
<p>n主从复制不会阻塞master，在同步数据时，master 可以继续处理client 请求</p>
<p>n一个redis可以即是主又是从，如下图：</p>
<p>2.2主从配置</p>
<p>2.2.1主redis配置</p>
<p>无需特殊配置。</p>
<p>2.2.2从redis配置</p>
<p>修改从redis服务器上的redis.conf文件，添加slaveof主redisip主redis端口</p>
<p>上边的配置说明当前该从redis服务器所对应的主redis是192.168.101.3，端口是6379</p>
<p>2.3主从复制过程</p>
<p>2.3.1完整复制</p>
<p>在redis2.8版本之前主从复制过程如下图：</p>
<p>复制过程说明：</p>
<p>1、slave 服务启动，slave 会建立和master 的连接，发送sync 命令。</p>
<p>2、master启动一个后台进程将数据库快照保存到RDB文件中</p>
<p>注意：此时如果生成RDB文件过程中存在写数据操作会导致RDB文件和当前主redis数据不一致，所以此时master 主进程会开始收集写命令并缓存起来。</p>
<p>3、master 就发送RDB文件给slave</p>
<p>4、slave 将文件保存到磁盘上，然后加载到内存恢复</p>
<p>5、master把缓存的命令转发给slave</p>
<p>注意：后续master 收到的写命令都会通过开始建立的连接发送给slave。</p>
<p>当master 和slave 的连接断开时slave 可以自动重新建立连接。如果master 同时收到多个slave 发来的同步连接命令，只会启动一个进程来写数据库镜像，然后发送给所有slave。</p>
<p>完整复制的问题：</p>
<p>在redis2.8之前从redis每次同步都会从主redis中复制全部的数据，如果从redis是新创建的从主redis中复制全部的数据这是没有问题的，但是，如果当从redis停止运行，再启动时可能只有少部分数据和主redis不同步，此时启动redis仍然会从主redis复制全部数据，这样的性能肯定没有只复制那一小部分不同步的数据高。</p>
<p>2.3.2部分复制</p>
<p>部分复制说明：</p>
<p>从机连接主机后，会主动发起 PSYNC 命令，从机会提供 master的runid(机器标识，随机生成的一个串) 和 offset（数据偏移量，如果offset主从不一致则说明数据不同步），主机验证 runid 和 offset 是否有效， runid 相当于主机身份验证码，用来验证从机上一次连接的主机，如果runid验证未通过则，则进行全同步，如果验证通过则说明曾经同步过，根据offset同步部分数据。</p>
<p>2)redis是一个nosql(not only sql不仅仅只有sql)数据库.翻译成中文叫做非关系型型数据库.</p>
<p>关系型数据库:以二维表形式存储数据</p>
<p>非关系型数据库: 以键值对形式存储数据(key, value形式)</p>
<p>Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库。它通过提供多种键值数据类型来适应不同场景下的存储需求，</p>
<p>目前为止Redis支持的键值数据类型如下：</p>
<p>字符串类型</p>
<p>散列类型</p>
<p>列表类型</p>
<p>集合类型</p>
<p>有序集合类型。</p>
<p>3)redis的应用场景</p>
<p>缓存（数据查询、短连接、新闻内容、商品内容等等）。（最多使用）</p>
<p>分布式集群架构中的session分离。</p>
<p>聊天室的在线好友列表。</p>
<p>任务队列。（秒杀、抢购、12306等等）</p>
<p>应用排行榜。</p>
<p>网站访问统计。</p>
<p>数据过期处理（可以精确到毫秒）</p>
<p>redis是将数据存放到内存中,由于内容存取速度快所以redis被广泛应用在互联网项目中,</p>
<p>redis有点:存取速度快,官方称读取速度会达到30万次每秒,写速度在10万次每秒最有,具体限制于硬件.</p>
<p>缺点:对持久化支持不够良好,</p>
<p>所以redis一般不作为数据的主数据库存储,一般配合传统的关系型数据库使用.</p>
<p>4) redis应用领域</p>
<p>分布式缓存</p>
<p>分布式session</p>
<p>保存博客或者论坛的留言回复等.</p>
<p>总之是用在数据量大,并发量高的情况下</p>
<h2 id="谈下DUBBO"><a href="#谈下DUBBO" class="headerlink" title="谈下DUBBO?"></a>谈下DUBBO?</h2><p>Dubbo就是资源调度和治理中心的管理工具。</p>
<p>调用关系说明：</p>
<p>\0. 服务容器负责启动，加载，运行服务提供者。</p>
<p>\1. 服务提供者在启动时，向注册中心注册自己提供的服务。</p>
<p>\2. 服务消费者在启动时，向注册中心订阅自己所需的服务。</p>
<p>\3. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</p>
<p>\4. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>
<p>\5. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p>
<h2 id="解决跨域问题"><a href="#解决跨域问题" class="headerlink" title="解决跨域问题?"></a>解决跨域问题?</h2><p>JSONP–&gt;Script Tags</p>
<h2 id="秒杀方案："><a href="#秒杀方案：" class="headerlink" title="秒杀方案："></a>秒杀方案：</h2><p>1、把商品的数量放到redis中。</p>
<p>2、秒杀时使用decr命令对商品数量减一。如果不是负数说明抢到。</p>
<p>3、一旦返回数值变为0说明商品已售完。</p>
<h2 id="ZOOKeeper"><a href="#ZOOKeeper" class="headerlink" title="ZOOKeeper?"></a>ZOOKeeper?</h2><p>Zookeeper 作为一个分布式的服务框架，主要用来解决分布式集群中应用系统的一致性问题，它能提供基于类似于文件系统的目录节点树方式的数据存储，但是 Zookeeper 并不是用来专门存储数据的，它的作用主要是用来维护和监控你存储的数据的状态变化。</p>
<p>通过监控这些数据状态的变化，从而可以达到基于数据的集群管理</p>
<p>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力小。使用dubbo-2.3.3以上版本，建议使用zookeeper注册中心。</p>
<p>Zookeeper是Apacahe Hadoop的子项目，是一个树型的目录服务，支持变更推送，适合作为Dubbo服务的注册中心，工业强度较高，可用于生产环境，并推荐使用</p>
<h2 id="ActiveMQ的消息形式"><a href="#ActiveMQ的消息形式" class="headerlink" title="ActiveMQ的消息形式"></a>ActiveMQ的消息形式</h2><p>一种是点对点的，即一个生产者和一个消费者一一对应；可进行缓存,只允许单人登录查看</p>
<p>另一种是发布/订阅模式，即一个生产者产生消息并进行发送后，可以由多个消费者进行接收。无法进行缓存,支持多人访问.</p>
<p>JMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。</p>
<p>StreamMessage – Java原始值的数据流</p>
<p>MapMessage–一套名称-值对</p>
<p>TextMessage–一个字符串对象</p>
<p>ObjectMessage–一个序列化的 Java对象</p>
<p>BytesMessage–一个字节的数据流</p>
<p>1.订单系统</p>
<p>1.1.功能分析</p>
<p>1、在购物车页面点击“去结算”按钮跳转到订单确认页面。</p>
<p>a)展示商品列表</p>
<p>b)配送地址列表</p>
<p>c)选择支付方式</p>
<p>2、展示订单确认页面之前，应该确认用户身份。</p>
<p>a)使用拦截器实现。</p>
<p>b)Cookie中取token</p>
<p>c)取不到token跳转到登录页面</p>
<p>d)取到token，根据token查询用户信息。</p>
<p>e)如果没有用户信息，登录过期跳转到登录页面</p>
<p>f)取到用户信息，放行。</p>
<p>3、提交订单</p>
<p>a)生成订单</p>
<p>b)展示订单提交成功页面。</p>
<p>订单系统系统：订单确认页面、订单提交成功页面。</p>
<p>订单服务系统</p>
<p>1.1.展示订单确认页面</p>
<p>1.1.1.功能分析</p>
<p>1、在购物车页面点击“去结算”按钮跳转到订单确认页面。</p>
<p>2、请求的url：</p>
<p>/order/order-cart</p>
<p>3、参数：没有参数。</p>
<p>4、购物车商品数据从cookie中取出来的。可以在订单系统中取到cookie中的购物车数据。</p>
<p>5、配送地址列表，需要用户登录。需要根据用户id查询收货地址列表。静态数据。</p>
<p>6、支付方式。静态数据。</p>
<p>7、返回值：逻辑视图String，展示订单确认页面。</p>
<p>1.1.2.Dao层、Service层（没有）</p>
<p>需要根据用户id查询收货地址列表。没有此功能。</p>
<p>1.1.3.表现层</p>
<p>请求的url：/order/order-cart</p>
<p>参数：无</p>
<p>业务逻辑：</p>
<p>从cookie中取商品列表展示到页面。</p>
<p>返回值：逻辑视图。</p>
<p>1.1.用户身份认证</p>
<p>在展示订单确认页面之前，需要对用户身份进行认证，要求用户必须登录。</p>
<p>1.1.1.功能分析</p>
<p>1、使用springmvc的拦截器实现。需要实现一个接口HandlerInterceptor接口。</p>
<p>2、业务逻辑</p>
<p>a)从cookie中取token。</p>
<p>b)没有token，需要跳转到登录页面。</p>
<p>c)有token。调用sso系统的服务，根据token查询用户信息。</p>
<p>d)如果查不到用户信息。用户登录已经过期。需要跳转到登录页面。</p>
<p>e)查询到用户信息。放行。</p>
<p>3、在springmvc.xml中配置拦截器。</p>
<p>1.1.2.拦截器实现</p>
<p>1.1.1.功能分析</p>
<p>1、在订单确认页面点击“提交订单”按钮生成订单。</p>
<p>2、请求的url：/order/create</p>
<p>3、参数：提交的是表单的数据。保存的数据：订单、订单明细、配送地址。</p>
<p>a)向tb_order中插入记录。</p>
<p>i.订单号需要手动生成。</p>
<p>要求订单号不能重复。</p>
<p>订单号可读性号。</p>
<p>可以使用redis的incr命令生成订单号。订单号需要一个初始值。</p>
<p>ii.Payment：表单数据</p>
<p>iii.payment_type：表单数据</p>
<p>iv.user_id：用户信息</p>
<p>v.buyer_nick：用户名</p>
<p>vi.其他字段null</p>
<p>b)向tb_order_item订单明细表插入数据。</p>
<p>i.Id：使用incr生成</p>
<p>ii.order_id：生成的订单号</p>
<p>iii.其他的都是表单中的数据。</p>
<p>c)tb_order_shipping，订单配送信息</p>
<p>i.order_id：生成的订单号</p>
<p>ii.其他字段都是表单中的数据。</p>
<p>d)使用pojo接收表单的数据。</p>
<p>可以扩展TbOrder，在子类中添加两个属性一个是商品明细列表，一个是配送信息。</p>
<p>把pojo放到taotao-order-interface工程中。</p>
<p>业务逻辑：</p>
<p>1、接收表单的数据</p>
<p>2、生成订单id</p>
<p>3、向订单表插入数据。</p>
<p>4、向订单明细表插入数据</p>
<p>5、向订单物流表插入数据。</p>
<p>6、返回TaotaoResult。</p>
<p>返回值：TaotaoResult</p>
<p>1.1.1.Dao层</p>
<p>可以使用逆向工程。</p>
<p>1.1.2.Service层</p>
<p>参数：OrderInfo</p>
<h2 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h2><p>单点登录就是我们是做了分布式，tomcat集群之后会有session复制的问题，影响利群数量。所以把注册登录拿出来单独做了一个单点登录系统。做的时候是用的redis，key是用uuid生成的一个token,类似于session id,是用户的唯一标识，value是用户的信息。设置了有效期是7天。然后把redis放到了cookie中，实现了cookie的二级跨域。当我们进行操作时，首先要从cookie里面取出token如果取不到，就跳到单点登录系统进行登录操作如果取到了，再看看token有没有过期，如果过期了，也是跳到单点登录系统登录一下，没过期就继续用户的操作。密码进行了加密，用Md5</p>
]]></content>
      
        <categories>
            
            <category> Java 面试精髓 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试精髓 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面试感悟：工作经验java程序员应有的技能]]></title>
      <url>/2017/12/10/%E9%9D%A2%E8%AF%95%E6%84%9F%E6%82%9F%EF%BC%9A%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8Cjava%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E6%9C%89%E7%9A%84%E6%8A%80%E8%83%BD/</url>
      <content type="html"><![CDATA[<h1 id="面试感悟：工作经验java程序员应有的技能"><a href="#面试感悟：工作经验java程序员应有的技能" class="headerlink" title="面试感悟：工作经验java程序员应有的技能"></a>面试感悟：工作经验java程序员应有的技能</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为和同事有约定再加上LZ自己也喜欢做完一件事之后进行总结，因此有了这篇文章。这篇文章大部分内容都是面向整个<a href="http://www.codeceo.com/" target="_blank" rel="external">程序员</a>群体的，当然因为LZ本身是做Java开发的，因此有一部分内容也是专门面向咱们Java程序员的。</p>
<p>简单先说一下，LZ坐标杭州，13届本科毕业，算上年前在阿里巴巴B2B事业部的面试，一共有面试了有6家公司（因为LZ不想请假，因此只是每个晚上去其他公司面试，所以面试的公司比较少），其中成功的有4家，另外两家失败的原因在于：</p>
<p>1、阿里巴巴B2B事业部的面试，两轮技术面试都过了，最后一轮面试是对方的主管，由于听说技术面试过了基本上90%都面试成功了，所以LZ在和主管的交谈中也是毫无顾忌，说得天花乱坠，很多自己介于知道和不知道的东西都直接脱口而出了，结果多次被对方一反问就问得哑口无言。事后想来，模棱两可的答案是面试中最忌讳的，这次的失败也让LZ认真地对待后面的每一次面试</p>
<p>2、另外一家失败的是一家小公司，也就20来个人吧，整个团队是支付宝出来创业的，非常厉害。面试完LZ多方了解了一下，对方认为我基本功什么的都不错，但是实际项目经验还是欠缺一些，因为对方是创业型公司，需要人上手就能干活，因此我在这个时候还不是特别适合他们团队</p>
<p>至于其他成功的四家公司，给LZ的面试评价都挺高的貌似，但LZ也不想记流水账，因此就不一一列举每家公司的面试过程了，下面LZ主要谈谈作为一名工作三年左右的Java程序员应该具备的一些技能以及个人的一些其他感悟。</p>
<h2 id="关于程序员的几个阶段"><a href="#关于程序员的几个阶段" class="headerlink" title="关于程序员的几个阶段"></a>关于程序员的几个阶段</h2><p>每个程序员、或者说每个工作者都应该有自己的职业规划，如果看到这里的朋友没有自己的职业规划，希望你可以思考一下自己的将来。</p>
<p>LZ常常思考自己的未来，也从自己的思考中总结出了一些东西，作为第一部分来谈谈。LZ认为一名程序员应该有几个阶段（以下时间都算上实习期）：</p>
<p>第一阶段：三年</p>
<p>我认为三年对于程序员来说是第一个门槛，这个阶段将会淘汰掉一批不适合写代码的人。这一阶段，我们走出校园，迈入社会，成为一名程序员，正式从书本上的内容迈向真正的企业级开发。我们知道如何团队协作、如何使用项目管理工具、项目版本如何控制、我们写的代码如何测试如何在线上运行等等，积累了一定的开发经验，也对代码有了一定深入的认识，是一个比较纯粹的Coder的阶段</p>
<p>第二阶段：五年</p>
<p>五年又是区分程序员的第二个门槛。有些人在三年里，除了完成工作，在空余时间基本不会研究别的东西，这些人永远就是个Coder，年纪大一些势必被更年轻的人给顶替；有些人在三年里，除了写代码之外，还热衷于研究各种技术实现细节、看了N多好书、写一些博客、在Github上分享技术，这些人在五年后必然具备在技术上独当一面的能力并且清楚自己未来的发展方向，从一个Coder逐步走向系统分析师或是架构师，成为项目组中不可或缺的人物</p>
<p>第三阶段：十年</p>
<p>十年又是另一个门槛了，转行或是继续做一名程序员就在这个节点上。如果在前几年就抱定不转行的思路并且为之努力的话，那么在十年的这个节点上，有些人必然成长为一名对行业有着深入认识、对技术有着深入认识、能从零开始对一个产品进行分析的程序员，这样的人在公司基本担任的都是CTO、技术专家、首席架构师等最关键的职位，这对于自己绝对是一件荣耀的事，当然老板在经济上也绝不会亏待你</p>
<p>第一部分总结一下，我认为，随着你工作年限的增长、对生活对生命认识的深入，应当不断思考三个问题：</p>
<p>1、我到底适不适合当一名程序员？</p>
<p>2、我到底应不应该一辈子以程序员为职业？</p>
<p>3、我对编程到底持有的是一种什么样的态度，是够用就好呢还是不断研究？</p>
<p>最终，明确自己的职业规划，对自己的规划负责并为之努力。</p>
<h2 id="关于项目经验"><a href="#关于项目经验" class="headerlink" title="关于项目经验"></a>关于项目经验</h2><p>LZ在网上经常看到一些别的朋友有提出项目经验的问题，依照LZ面试的感觉来说，面试主要看几点：项目经验+基本技术+个人潜力（也就是值不值得培养）。</p>
<p>关于项目经验，我认为并发编程网的创始人方腾飞老师讲的一段话非常好：</p>
<blockquote>
<p>介绍产品时面试官会考察应聘者的沟通能力和思考能力，我们大部分情况都是做产品的一个功能或一个模块，但是即使是这样，自己有没有把整个系统架构或产品搞清楚，并能介绍清楚，为什么做这个系统？这个系统的价值是什么？这个系统有哪些功能？优缺点有哪些？如果让你重新设计这个系统你会如何设计？</p>
</blockquote>
<p>我觉得这就已经足以概括了。也许你仅仅工作一年，也许你做的是项目中微不足道的模块，当然这些一定是你的劣势且无法改变，但是如何弥补这个劣势，从方老师的话中我总结几点：</p>
<p>1、明确你的项目到底是做什么的，有哪些功能</p>
<p>2、明确你的项目的整体架构，在面试的时候能够清楚地画给面试官看并且清楚地指出从哪里调用到哪里、使用什么方式调用</p>
<p>3、明确你的模块在整个项目中所处的位置及作用</p>
<p>4、明确你的模块用到了哪些技术，更好一些的可以再了解一下整个项目用到了哪些技术</p>
<p>在你无法改变自己的工作年限、自己的不那么有说服力的项目经验的情况下（这一定是扣分项），可以通过这种方式来一定程度上地弥补并且增进面试官对你的好感度。</p>
<h2 id="关于专业技能"><a href="#关于专业技能" class="headerlink" title="关于专业技能"></a>关于专业技能</h2><p>写完项目接着写写一名3年工作经验的Java程序员应该具备的技能，这可能是Java程序员们比较关心的内容。我这里要说明一下，以下列举的内容不是都要会的东西—-但是如果你掌握得越多，最终能得到的评价、拿到的薪水势必也越高。</p>
<p>1、基本语法</p>
<p>这包括static、final、transient等关键字的作用，foreach循环的原理等等。今天面试我问你static关键字有哪些作用，如果你答出static修饰变量、修饰方法我会认为你合格，答出静态块，我会认为你不错，答出静态内部类我会认为你很好，答出静态导包我会对你很满意，因为能看出你非常热衷研究技术。</p>
<p>最深入的一次，LZ记得面试官直接问到了我<a href="http://www.codeceo.com/article/java-volatile-var.html" target="_blank" rel="external">Volatile</a>关键字的底层实现原理（顺便插一句，面试和被面试本身就是相对的，面试官能问这个问题同时也让面试者感觉到面试官也是一个喜爱研究技术的人，增加了面试者对公司的好感，LZ最终选择的就是问了这个问题的公司），不要觉得这太吹毛求疵了—-越简单的问题越能看出一个人的水平，别人对你技术的考量绝大多数都是以深度优先、广度次之为标准的，切记。</p>
<p>2、集合</p>
<p>非常重要，也是必问的内容。基本上就是List、Map、Set，问的是各种实现类的底层实现原理，实现类的优缺点。</p>
<p>集合要掌握的是ArrayList、LinkedList、Hashtable、HashMap、ConcurrentHashMap、HashSet的实现原理，能流利作答，当然能掌握CopyOnWrite容器和Queue是再好不过的了。另外多说一句，ConcurrentHashMap的问题在面试中问得特别多，大概是因为这个类可以衍生出非常多的问题，关于ConcurrentHashMap，我给网友朋友们提供三点回答或者是研究方向：</p>
<p>（1）ConcurrentHashMap的锁分段技术</p>
<p>（2）ConcurrentHashMap的读是否要加锁，为什么</p>
<p>（3）ConcurrentHashMap的迭代器是强一致性的迭代器还是弱一致性的迭代器</p>
<p>3、<a href="http://www.codeceo.com/article/category/develop/design-patterns" target="_blank" rel="external">设计模式</a></p>
<p>本来以为蛮重要的一块内容，结果只在阿里巴巴B2B事业部面试的时候被问了一次，当时问的是装饰器模式。</p>
<p>当然咱们不能这么功利，为了面试而学习，设计模式在工作中还是非常重要、非常有用的，23种设计模式中重点研究常用的十来种就可以了，面试中关于设计模式的问答主要是三个方向：</p>
<p>（1）你的项目中用到了哪些设计模式，如何使用</p>
<p>（2）知道常用设计模式的优缺点</p>
<p>（3）能画出常用设计模式的UML图</p>
<p>4、多线程</p>
<p>这也是必问的一块了。因为三年工作经验，所以基本上不会再问你怎么实现多线程了，会问得深入一些比如说Thread和Runnable的区别和联系、多次start一个线程会怎么样、线程有哪些状态。当然这只是最基本的，出乎意料地，几次面试几乎都被同时问到了一个问题，问法不尽相同，总结起来是这么一个意思：</p>
<blockquote>
<p>假如有Thread1、Thread2、Threa<a href="http://www.codeceo.com/article/javascript-d3-js.html" target="_blank" rel="external">D3</a>、Thread4四条线程分别统计C、D、E、F四个盘的大小，所有线程都统计完毕交给Thread5线程去做汇总，应当如何实现？</p>
</blockquote>
<p>聪明的网友们对这个问题是否有答案呢？不难，java.util.concurrent下就有现成的类可以使用。</p>
<p>另外，线程池也是比较常问的一块，常用的线程池有几种？这几种线程池之间有什么区别和联系？线程池的实现原理是怎么样的？实际一些的，会给你一些具体的场景，让你回答这种场景该使用什么样的线程池比较合适。</p>
<p>最后，虽然这次面试问得不多，但是多线程同步、锁这块也是重点。synchronized和ReentrantLock的区别、synchronized锁普通方法和锁静态方法、死锁的原理及排查方法等等，关于多线程，我在之前有些过文章总结过多线程的40个问题，可以参看<a href="http://www.codeceo.com/article/40-java-thread-problems.html" target="_blank" rel="external">40个Java多线程问题总结</a>。</p>
<p>5、JDK源码</p>
<p>要想拿高工资，JDK源码不可不读。上面的内容可能还和具体场景联系起来，JDK源码就是实打实地看你平时是不是爱钻研了。LZ面试过程中被问了不少JDK源码的问题，其中最刁钻的一个问了LZ，String的hashCode()方法是怎么实现的，幸好LZ平时String源代码看得多，答了个大概。JDK源码其实没什么好总结的，纯粹看个人，总结一下比较重要的源码：</p>
<p>（1）List、Map、Set实现类的源代码</p>
<p>（2）ReentrantLock、AQS的源代码</p>
<p>（3）AtomicInteger的实现原理，主要能说清楚CAS机制并且AtomicInteger是如何利用CAS机制实现的</p>
<p>（4）线程池的实现原理</p>
<p>（5）Object类中的方法以及每个方法的作用</p>
<p>这些其实要求蛮高的，LZ去年一整年基本把JDK中重要类的源代码研究了个遍，真的花费时间、花费精力，当然回头看，是值得的—-不仅仅是为了应付面试。</p>
<p>6、框架</p>
<p>老生常谈，面试必问的东西。一般来说会问你一下你们项目中使用的框架，然后给你一些场景问你用框架怎么做，比如我想要在Spring初始化bean的时候做一些事情该怎么做、想要在bean销毁的时候做一些事情该怎么做、MyBatis中$和#的区别等等，这些都比较实际了，平时积累得好、有多学习框架的使用细节自然都不成问题。</p>
<p>如果上面你的问题答得好，面试官往往会深入地问一些框架的实现原理。问得最多的就是Spring AOP的实现原理，当然这个很简单啦，两句话就搞定的的事儿，即使你不会准备一下就好了。LZ遇到的最变态的是让LZ画一下Spring的Bean工厂实现的UML图，当然面对这样一个有深度的问题，LZ是绝对答不出来的/(ㄒoㄒ)/~~</p>
<p>7、数据库</p>
<p>数据库十有八九也都会问到。一些基本的像union和union all的区别、left join、几种索引及其区别就不谈了，比较重要的就是数据库性能的优化，如果对于数据库的性能优化一窍不通，那么有时间，还是建议你在面试前花一两天专门把SQL基础和SQL优化的内容准备一下。</p>
<p>不过数据库倒是不用担心，一家公司往往有很多部门，如果你对数据库不熟悉而基本技术又非常好，九成都是会要你的，估计会先把你放到对数据库使用不是要求非常高的部门锻炼一下。</p>
<p>8、数据结构和算法分析</p>
<p>数据结构和算法分析，对于一名程序员来说，会比不会好而且在工作中绝对能派上用场。数组、链表是基础，栈和队列深入一些但也不难，树挺重要的，比较重要的树AVL树、红黑树，可以不了解它们的具体实现，但是要知道什么是二叉查找树、什么是平衡树，AVL树和红黑树的区别。记得某次面试，某个面试官和我聊到了数据库的索引，他问我：</p>
<blockquote>
<p>你知道索引使用的是哪种数据结构实现吗？</p>
</blockquote>
<p>LZ答到用的Hash表吧，答错。他又问，你知道为什么要使用树吗？LZ答到因为Hash表可能会出现比较多的冲突，在千万甚至是上亿级别的数据面前，会大大增加查找的时间复杂度。而树比较稳定，基本保证最多二三十次就能找到想要的数据，对方说不完全对，最后我们还是交流了一下这个问题，我也明白了为什么要使用树，这里不说，网友朋友们觉得索引为什么要使用树来实现呢？</p>
<p>至于算法分析，不会、不想研究就算了，记得某次面试对方问我，Collections.sort方法使用的是哪种排序方法，额，吐血三升。当然为了显示LZ的博学，对算法分析也有一定的研究(⊙﹏⊙)b，LZ还是硬着头皮说了一句可能是冒泡排序吧。当然答案肯定不是，有兴趣的网友朋友们可以去看一下Collections.sort方法的源代码，用的是一种叫做TimSort的排序法，也就是增强型的归并排序法。</p>
<p>9、Java虚拟机</p>
<p>出乎LZ的意料，Java虚拟机应该是很重要的一块内容，结果在这几家公司中被问到的概率几乎为0。要知道，LZ去年可是花了大量的时间去研究Java虚拟机的，光周志明老师的《深入理解Java虚拟机：JVM高级特性与最佳实践》，LZ就读了不下五遍。</p>
<p>言归正传，虽然Java虚拟机没问到，但我觉得还是有必要研究的，LZ就简单地列一个提纲吧，谈谈Java虚拟机中比较重要的内容：</p>
<p>（1）Java虚拟机的内存布局</p>
<p>（2）GC算法及几种垃圾收集器</p>
<p>（3）类加载机制，也就是双亲委派模型</p>
<p>（4）Java内存模型</p>
<p>（5）happens-before规则</p>
<p>（6）volatile关键字使用规则</p>
<p>也许面试无用，但在走向大牛的路上，不可不会。</p>
<p>10、Web方面的一些问题</p>
<p>Java主要面向Web端，因此Web的一些问题也是必问的。LZ碰到过问得最多的两个问题是：</p>
<blockquote>
<p>谈谈分布式Session的几种实现方式</p>
</blockquote>
<p>常用的四种能答出来自然是让面试官非常满意的，另外一个常问的问题是：</p>
<blockquote>
<p>讲一下Session和Cookie的区别和联系以及Session的实现原理</p>
</blockquote>
<p>这两个问题之外，web.xml里面的内容是重点，Filter、Servlet、Listener，不说对它们的实现原理一清二楚吧，至少能对它们的使用知根知底。另外，一些细节的方面比如get/post的区别、forward/重定向的区别、HTTPS的实现原理也都可能会被考察到。</p>
<p>噢，想起来了，一致性Hash算法貌似也被问到了几次，这个LZ以前专门深入研究过并且写了两篇博文，因此问到这个问题LZ自然是答得毫不费力。文章是<a href="http://www.codeceo.com/article/memcache-usage-learn.html" target="_blank" rel="external">MemCache超详细解读</a>和对<a href="http://www.cnblogs.com/xrq730/p/5186728.html" target="_blank" rel="external">一致性Hash算法，Java代码实现的深入研究</a>，特别说明，LZ真的不是在为自已以前写的文章打广告啊啊啊啊啊啊。</p>
<p>最后，如果有兴趣有时间，建议学习、研究一下SOA和RPC，面向服务体系，大型分布式架构必备，救命良方、包治百病、屡试不爽。</p>
<h2 id="关于HR面试"><a href="#关于HR面试" class="headerlink" title="关于HR面试"></a>关于HR面试</h2><p>如果你过五关斩六将，成功地通过了所有的技术面，那么恭喜你，你离升职加薪、出任CEO、迎娶白富美、走向人生巅峰又进了一步。但是还没有到谈薪资待遇的时候，最后还有一个考验：HR面试。基本所有的大公司都有这一轮的面试，不要小看HR面试，很多公司的HR对于面试者都有一票否决权的—-即使前面的面试对你的评价再高。</p>
<p>所以，这轮的面试也必须重视起来，HR面试主要问的是几点：</p>
<p>1、简历中写的过去工作经历的离职原因</p>
<p>2、当前公司薪资待遇</p>
<p>3、期望能到怎样的一家公司</p>
<p>4、个人未来的发展方向</p>
<p>我专门提一下第2点。可能有人比较排斥也不想说这个，我个人倒是持开放状态，问了就说了，当然一些的夸大还是必要的，当前公司薪资待遇多报个一千块钱完全没问题（毕竟是一家互联网公司总多多少少有些补贴啊什么的嘛）。因为这和你在新公司能拿到的薪水关系不大，新公司能拿到的薪水的决定因素是整个公司的薪资情况以及根据你的面试情况在公司的定位，都是有固定的薪资范围的。HR问这个主要也就是心里有个数并且看你是否诚信—-有些公司入职时会要求你提供最近一家单位的银行流水号。</p>
<p>HR面试就说到这里了，总结起来其实就是四个字：滴水不漏。整个面试过程态度积极向上，不要有任何悲观消极的态度（尤其在谈到以前公司情况的时候，即使有再多的不满），就不会有问题。</p>
<h2 id="关于面试心态"><a href="#关于面试心态" class="headerlink" title="关于面试心态"></a>关于面试心态</h2><p>这个嘛，LZ其实在公司也面试过几个人，一半以上的面试者回答问题的时候都属于那种双腿发抖、声音颤抖的类型。在LZ看来这大可不必并且这还是扣分项，回答问题的时候最最基本的两个要求：</p>
<p>1、不紧不慢，平心静气</p>
<p>2、条理清晰</p>
<p>表达能力绝对是面试的时候重要的考察项目。咱们做的是程序员这一行，讲究的是团队协作，不是写作、画画，一支笔、一个人就行了，一个表达能力不行的程序员，要来又有什么用呢？</p>
<p>除此之外，就是保持良好的心态。古语说得好，只要功夫深，铁杵磨成针，面试的成功与否，在于平时的积累，临时抱抱佛脚，看两道面试题是没有用的，只要平时足够努力，成功是水到渠成的事情，平时不怎么研究技术的，那也就是个听天由命的事情，只要充分地展示平时自己的所学就可以了。</p>
<p>因此在我看来，不要把面试当作面试，当做一次技术交流，把面试的心态从我要找到一份工作转变为我要通过面试去发现不足、提升自己，这样就会平和多了，即使失败也不会有太多失望的感觉。</p>
<p>另外，如果平时自己热衷于研究技术的朋友，真的要有自信，不要觉得别人面试你别人就比你厉害。面试官未必比你优秀，他问的问题往往都是他平时研究得比较多的问题，你一样有很多自己的研究面试官未必知道。</p>
<h2 id="关于Java"><a href="#关于Java" class="headerlink" title="关于Java"></a>关于Java</h2><p>网上常看到一种说法：Java比较简单。某种程度上这会打击Java程序员的信心—-原来咱们平时用的是这种小儿科的玩意儿啊，在我看来这种想法大可不必，这一部分我来讲讲对于这个话题的看法。</p>
<p>这种说法有些片面，得分开两部分来看，我用四个自总结一下就是：易学难精。</p>
<p>1、易学部分</p>
<p>Java易学我认为有两部分的原因：</p>
<p>（1）很多培训公司包括大四的学生找工作都会学习Java，绝大多数是因为易学。Java从C/C++发展而来，感谢前人的智慧，它消除了C/C++中最复杂和让人困惑的语法、它消除了平台的差异性、它不需要用户手动释放内存空间、它避免了Java程序员和本地语言的交互，让程序员只需要专注于语法层面和应用层面。</p>
<p>（2）Java作为一门面向对象的语言，在企业级开发中体现出了它无与伦比的特性，整个开发流程比较固定化、模块化，需求分析起来也相对容易。我举个自己以前的例子吧，我在大一学习C语言的时候，用C语言写了一个图书管理系统写了2000+的代码，大四学了C++之后，用面向对象的语言C++取代面向过程的语言C语言重新写了一个功能相似的图书管理系统，只写了1100行的样子，这就是面向对象的优势。</p>
<p>2、难精部分</p>
<p>接着咱们聊聊难精的部分。</p>
<p>Java语言的设计者帮助Java程序员做了这么多事情，这有利也有弊。有利的部分前面已经说过了，让Java易学，不过有弊的部分同样明显。假如在应用运行过程中遇到了语法层面和应用层面之外的错误，应当如何处理？比如线上环境出现内存溢出怎么办？GC时间过长怎么办？IO长时间没反应怎么办？方法抛出莫名其妙的异常怎么办？</p>
<p>凡此种种，绝不是一名只会写几个if…else…的Java程序员就可以解决的，这需要大量的经历、大量的实践、大量对Java底层实现细节的研究，而这往往是最难、最考验Java程序员的部分，一些人根本就不想往深去研究，另外一些人研究了一点点就研究不下去了。</p>
<p>Java为什么难精？就是这个原因。除非你水平特别高，否则五年工作经验以下的Java程序员在简历上写”精通Java”绝对是一件非常愚蠢的事情。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>文章写到这里，感觉有点像鸡汤文了，那就以最后的鸡汤作为结尾吧。</p>
<p>在以前博客园的一篇文章中，讲到了奔三程序员的困惑，大致说的是三十岁之后程序员要转行之类的云云，LZ在博文中留下了如下的评论：</p>
<p><img src="http://static.codeceo.com/images/2016/03/0eada6b2dcac3a6a274b0196c277cea5.png" alt="img"></p>
<p>就以这段话自勉、共勉吧。越努力、越幸运，如果你不是官二代、富二代、红二代，那么请记住：勤奋才是改变你命运的唯一捷径。</p>
]]></content>
      
        <categories>
            
            <category> 工作经验java程序员应有的技能 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试精髓 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LinkedList 源码分析]]></title>
      <url>/2017/12/09/LinkedList%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="LinkedList-源码分析"><a href="#LinkedList-源码分析" class="headerlink" title="LinkedList 源码分析"></a>LinkedList 源码分析</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有了ArrayList，自然少不了LinkedList了。</p>
<p>下面我就以面试问答的形式学习我们的常用的装载容器——<code>LinkedList</code>（源码分析基于JDK8）</p>
<h1 id="问答内容"><a href="#问答内容" class="headerlink" title="问答内容"></a>问答内容</h1><h2 id="LinkedList-用来做什么，怎么使用？"><a href="#LinkedList-用来做什么，怎么使用？" class="headerlink" title="LinkedList 用来做什么，怎么使用？"></a>LinkedList 用来做什么，怎么使用？</h2><p>问：请简单介绍一下您所了解的LinkedList，它可以用来做什么，怎么使用？</p>
<p>答：</p>
<ul>
<li>LinkedList底层是双向链表，同时实现了List接口和Deque接口，所以它既可以看作是一个<strong>顺序容器</strong>，也可以看作是一个<strong>队列(Queue)</strong>，同时也可以看作是一个<strong>栈</strong>(Stack)，但如果想使用栈或队列等数据结构的话，推荐使用ArrayDeque，它作为栈或队列会比LinkedList有更好的使用性能。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个LinkedList，链表的每个节点的内存空间都是实时分配的，所以无须事先指定容器大小</span></div><div class="line">LinkedList&lt;String&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;String&gt;();</div><div class="line"><span class="comment">// 往容器里面添加元素</span></div><div class="line">linkedList.add(<span class="string">"张三"</span>);</div><div class="line">linkedList.add(<span class="string">"李四"</span>);</div><div class="line"><span class="comment">// 在张三与李四之间插入一个王五</span></div><div class="line">linkedList.add(<span class="number">1</span>, <span class="string">"王五"</span>);</div><div class="line"><span class="comment">// 在头部插入一个小三</span></div><div class="line">linkedList.addFirst(<span class="string">"小三"</span>);</div><div class="line"><span class="comment">// 获取index下标为2的元素 王五</span></div><div class="line">String element = linkedList.get(<span class="number">2</span>);</div><div class="line"><span class="comment">// 修改index下标为2的元素 王五 为小四</span></div><div class="line">linkedList.set(<span class="number">2</span>, <span class="string">"小四"</span>);</div><div class="line"><span class="comment">// 删除index下标为1的元素 张三</span></div><div class="line">String removeElement = linkedList.remove(<span class="number">1</span>);</div><div class="line"><span class="comment">// 删除第一个元素</span></div><div class="line">String removeFirstElement = linkedList.removeFirst();</div><div class="line"><span class="comment">// 删除最后一个元素</span></div><div class="line">String removeLastElement = linkedList.removeLast();</div></pre></td></tr></table></figure>
<ul>
<li>LinkedList底层实现是双向链表，核心组成元素有：<code>int size = 0</code>用于记录链表长度；<code>Node&lt;E&gt; first;</code>用于记录头（第一个）结点（储存的是头结点的引用）；<code>Node&lt;E&gt; last;</code>用于记录尾（最后一个）结点（储存的是尾结点的引用）。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</div><div class="line">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// 记录链表长度</span></div><div class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Pointer to first node. 指向第一个结点</div><div class="line">     * Invariant: (first == null &amp;&amp; last == null) ||</div><div class="line">     *            (first.prev == null &amp;&amp; first.item != null)</div><div class="line">     */</div><div class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Pointer to last node. 指向最后一个结点</div><div class="line">     * Invariant: (first == null &amp;&amp; last == null) ||</div><div class="line">     *            (last.next == null &amp;&amp; last.item != null)</div><div class="line">     */</div><div class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>双向链表的核心组成元素还有一个最重要的<code>Node&lt;E&gt;</code>，<code>Node&lt;E&gt;</code>包含：<code>E item;</code> 用于存储元素数据，<code>Node&lt;E&gt; next;</code> 指向当前元素的后继结点，<code>Node&lt;E&gt; prev;</code> 指向当前元素的前驱结点。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 定义LinkedList底层的结点实现</div><div class="line"> */</div><div class="line">private static class Node&lt;E&gt; &#123;</div><div class="line">    E item; // 存储元素数据</div><div class="line">    Node&lt;E&gt; next;// 指向当前元素的后继结点</div><div class="line">    Node&lt;E&gt; prev;// 指向当前元素的前驱结点</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Node结点构造方法</div><div class="line">     */</div><div class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</div><div class="line">        this.item = element;// 存储的元素</div><div class="line">        this.next = next;// 后继结点</div><div class="line">        this.prev = prev;// 前驱结点</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://user-gold-cdn.xitu.io/2017/8/28/8cfa61381cb1e233627e865c8cd33955?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="双向链表底层实现，图片来自网络">双向链表底层实现，图片来自网络</p>
<p>上图中的head即Node first; tail即Node last;</p>
<h2 id="LinkedList-的操作和对应的时间复杂度。"><a href="#LinkedList-的操作和对应的时间复杂度。" class="headerlink" title="LinkedList 的操作和对应的时间复杂度。"></a>LinkedList 的操作和对应的时间复杂度。</h2><p>问：请分别分析一下它是如何获取元素，修改元素，新增元素与删除元素，并分析这些操作对应的时间复杂度。</p>
<p>答：</p>
<ul>
<li>获取元素：LinkedList提供了三种获取元素的方法，分别是：</li>
</ul>
<ol>
<li>获取第一个元素<code>getFirst()</code>，获取第一个元素，直接返回<code>Node&lt;E&gt; first</code>指向的结点即可，所以时间复杂度为O(1)。</li>
<li>获取最后一个元素<code>getLast()</code>，获取最后一个元素，直接返回<code>Node&lt;E&gt; last</code>指向的结点即可，所以时间复杂度也为O(1)。</li>
<li>获取指定索引index位置的元素<code>get(int index)</code>，由于<code>Node&lt;E&gt;</code>结点在内存中存储的空间不是连续存储的，所以查找某一位置的结点，只能通过遍历链表的方式查找结点，因此LinkedList会先通过判断<code>index &lt; (size &gt;&gt; 1)</code>，<code>size&gt;&gt;1</code>即为<code>size/2</code>当前链表长度的一半，判断index的位置是在链表的前半部分还是后半部分。决定是从头部遍历查找数据还是从尾部遍历查找数据。最坏情况下，获取中间元素，则需要遍历n/2次才能获取到对应元素，所以此方法的时间复杂度为O(n)。</li>
</ol>
<ul>
<li>综上所述，LinkedList获取元素的时间复杂度为O(n)。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 返回列表中指定位置的元素</div><div class="line"> *</div><div class="line"> * @param index 指定index位置</div><div class="line"> * @return 返回指定位置的元素</div><div class="line"> * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</div><div class="line"> */</div><div class="line">public E get(int index) &#123;</div><div class="line">    // 检查index下标是否合法[0,size)</div><div class="line">    checkElementIndex(index);</div><div class="line">    // 遍历列表获取对应index位置的元素</div><div class="line">    return node(index).item;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 检查下标是否合法</div><div class="line"> */</div><div class="line">private void checkElementIndex(int index) &#123;</div><div class="line">    if (!isElementIndex(index))</div><div class="line">        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">&#125;</div><div class="line"></div><div class="line">private boolean isElementIndex(int index) &#123;</div><div class="line">    return index &gt;= 0 &amp;&amp; index &lt; size;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 返回指定位置的结点元素（重点）</div><div class="line"> */</div><div class="line">Node&lt;E&gt; node(int index) &#123;</div><div class="line">    // assert isElementIndex(index);</div><div class="line">    // 判断index位置是在链表的前半部分还是后半部分</div><div class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</div><div class="line">        // 从头结点开始，从前往后遍历找到对应位置的结点元素</div><div class="line">        Node&lt;E&gt; x = first;</div><div class="line">        for (int i = 0; i &lt; index; i++)</div><div class="line">            x = x.next;</div><div class="line">        return x;</div><div class="line">    &#125; else &#123;</div><div class="line">        // 从尾结点开始，从后往前遍历找到对应位置的结点元素</div><div class="line">        Node&lt;E&gt; x = last;</div><div class="line">        for (int i = size - 1; i &gt; index; i--)</div><div class="line">            x = x.prev;</div><div class="line">        return x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>修改元素：LinkedList提供了一种修改元素数据的方法<code>set(int index, E element)</code>，修改元素数据的步骤是：1.检查index索引是否合法[0,size)。2.折半查询获取对应索引元素。3.将新元素赋值，返回旧元素。由获取元素的分析可知，折半查询的时间复杂度为O(n)，故修改元素数据的时间复杂度为O(n)。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 修改指定位置结点的存储数据</div><div class="line"> *</div><div class="line"> * @param index 指定位置</div><div class="line"> * @param element 修改的存储数据</div><div class="line"> * @return 返回未修改前的存储数据</div><div class="line"> * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</div><div class="line"> */</div><div class="line">public E set(int index, E element) &#123;</div><div class="line">    // 检查index下标是否合法[0,size)</div><div class="line">    checkElementIndex(index);</div><div class="line">    // 折半查询获取对应索引元素</div><div class="line">    Node&lt;E&gt; x = node(index);</div><div class="line">    // 将新元素赋值，返回旧元素</div><div class="line">    E oldVal = x.item;</div><div class="line">    x.item = element;</div><div class="line">    return oldVal;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>新增元素：LinkedList提供了四种新增元素的方法，分别是：</li>
</ul>
<ol>
<li>将指定元素插入到链表的第一个位置中<code>addFirst(E e)</code>，只需将头结点<code>first</code>指向新元素结点，将原第一结点的前驱指针指向新元素结点即可。不需要移动原数据存储位置，只需交换一下相关结点的指针域信息即可。所以时间复杂度为O(1)。</li>
<li>将指定元素插入到链表的最后一个位置中<code>addLast(E e)</code>，只需将尾结点<code>last</code>指向新元素结点，将原最后一个结点的后继指针指向新元素结点即可。不需要移动原数据存储位置，只需交换一下相关结点的指针域信息即可。所以时间复杂度也为O(1)。</li>
<li>添加元素方法<code>add(E e)</code> 等价于<code>addLast(E e)</code>。</li>
<li>将指定元素插入到链表的指定位置index中<code>add(int index, E element)</code>，需要先根据位置index调用<code>node(index)</code>遍历链表获取该位置的原结点，然后将新结点插入至原该位置结点的前面，不需要移动原数据存储位置，只需交换一下相关结点的指针域信息即可。所以时间复杂度也为O(1)。</li>
</ol>
<ul>
<li>综上所述，LinkedList新增元素的时间复杂度为O(1)，单纯论插入新元素，操作是非常高效的，特别是插入至头部或插入到尾部。但如果是通过索引index的方式插入，插入的位置越靠近链表中间所费时间越长，因为需要对链表进行遍历查找。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2017/8/28/373537715b40c9830bbc6f5de35dc6d3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="添加元素结点示意图，图片来自《大话数据结构》">添加元素结点示意图，图片来自《大话数据结构》</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 将指定元素插入到链表的第一个位置中</div><div class="line"> *</div><div class="line"> * @param e 要插入的元素</div><div class="line"> */</div><div class="line">public void addFirst(E e) &#123;</div><div class="line">    linkFirst(e);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 将元素e作为第一个元素</div><div class="line"> */</div><div class="line">private void linkFirst(E e) &#123;</div><div class="line">    // 获取原头结点</div><div class="line">    final Node&lt;E&gt; f = first;</div><div class="line">    // 初始化新元素结点</div><div class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);</div><div class="line">    // 头指针指向新元素结点</div><div class="line">    first = newNode;</div><div class="line">    // 如果是第一个元素（链表为空）</div><div class="line">    if (f == null)</div><div class="line">        // 将尾指针也指向新元素结点</div><div class="line">        last = newNode;</div><div class="line">    else // 链表不会空</div><div class="line">        // 原头结点的前驱指针指向新结点</div><div class="line">        f.prev = newNode;</div><div class="line">    // 记录链表长度的size + 1</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 将指定元素插入到链表的最后一个位置中</div><div class="line"> *</div><div class="line"> * &lt;p&gt;此方法等同与add(E e)方法 &#123;@link #add&#125;.</div><div class="line"> *</div><div class="line"> * @param e 要插入的元素</div><div class="line"> */</div><div class="line">public void addLast(E e) &#123;</div><div class="line">    linkLast(e);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 将指定元素插入到链表的最后一个位置中</div><div class="line"> *</div><div class="line"> * &lt;p&gt;此方法等同与addLast(E e)方法  &#123;@link #addLast&#125;.</div><div class="line"> *</div><div class="line"> * @param e 要插入的元素</div><div class="line"> * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;)</div><div class="line"> */</div><div class="line">public boolean add(E e) &#123;</div><div class="line">    linkLast(e);</div><div class="line">    return true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 将元素e作为最后一个元素</div><div class="line"> */</div><div class="line">void linkLast(E e) &#123;</div><div class="line">    // 获取原尾结点</div><div class="line">    final Node&lt;E&gt; l = last;</div><div class="line">    // 初始化新元素结点</div><div class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</div><div class="line">    // 位指针指向新元素结点</div><div class="line">    last = newNode;</div><div class="line">    // 如果是第一个元素（链表为空）</div><div class="line">    if (l == null)</div><div class="line">        // 将头指针也指向新元素结点</div><div class="line">        first = newNode;</div><div class="line">    else // 链表不会空</div><div class="line">        // 原尾结点的后继指针指向新结点</div><div class="line">        l.next = newNode;</div><div class="line">    // 记录链表长度的size + 1</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 将指定元素插入到链表的指定位置index中</div><div class="line"> *</div><div class="line"> * @param index 元素要插入的位置index</div><div class="line"> * @param element 要插入的元素</div><div class="line"> * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</div><div class="line"> */</div><div class="line">public void add(int index, E element) &#123;</div><div class="line">    // 检查插入位置是否合法[0,size]</div><div class="line">    checkPositionIndex(index);</div><div class="line">    // 如果插入的位置和当前链表长度相等，则直接将元素插入至链表的尾部</div><div class="line">    if (index == size)</div><div class="line">        // 将元素插入至链表的尾部</div><div class="line">        linkLast(element);</div><div class="line">    else</div><div class="line">        //将元素插入至指定位置,node(index)先获取占有该index位置的原结点</div><div class="line">        linkBefore(element, node(index));</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 检查位置是否合法</div><div class="line"> */</div><div class="line">private void checkPositionIndex(int index) &#123;</div><div class="line">    if (!isPositionIndex(index))</div><div class="line">        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 检查位置是否合法</div><div class="line"> */</div><div class="line">private boolean isPositionIndex(int index) &#123;</div><div class="line">    //合法位置为[0,size]</div><div class="line">    return index &gt;= 0 &amp;&amp; index &lt;= size;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 将新元素e插入至旧元素succ前面</div><div class="line"> */</div><div class="line">void linkBefore(E e, Node&lt;E&gt; succ) &#123;</div><div class="line">    // assert succ != null;</div><div class="line">    // 记录旧元素结点succ的前驱指针</div><div class="line">    final Node&lt;E&gt; pred = succ.prev;</div><div class="line">    // 初始化新元素结点</div><div class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);</div><div class="line">    // 旧元素结点的前驱指针指向新元素结点(即新元素结点放至在旧元素结点的前面，取代了原本旧元素的位置)</div><div class="line">    succ.prev = newNode;</div><div class="line">    // 如果旧元素结点的前驱指针为空，则证明旧元素结点是头结点，</div><div class="line">    // 将新元素结点插入至旧元素结点前面，所以现时新的头结点是新元素结点</div><div class="line">    if (pred == null)</div><div class="line">        first = newNode;</div><div class="line">    else //不是插入至头部</div><div class="line">        // 旧元素的前驱结点的后继指针指向新元素结点</div><div class="line">        pred.next = newNode;</div><div class="line">    // 记录链表长度的size + 1</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>删除元素：LinkedList提供了四种删除元素的方法，分别是：</li>
</ul>
<ol>
<li>删除链表中的第一个元素<code>removeFirst()</code>，只需将头结点<code>first</code>指向删除元素结点的后继结点并将其前驱结点指针信息<code>prev</code>清空即可。不需要移动原数据存储位置，只需操作相关结点的指针域信息即可。所以时间复杂度为O(1)。</li>
<li>删除链表中的最后一个元素<code>removeLast()</code>，只需将尾结点<code>last</code>指向删除元素结点的前驱结点并将其后继结点指针信息<code>next</code>清空即可。不需要移动原数据存储位置，只需操作相关结点的指针域信息即可，所以时间复杂度也为O(1)。</li>
<li>将指定位置index的元素删除<code>remove(int index)</code>，需要先根据位置index调用<code>node(index)</code>遍历链表获取该位置的原结点，然后将删除元素结点的前驱结点的<code>next</code>后继结点指针域指向删除元素结点的后继结点<code>node.prev.next = node.next</code>，删除元素结点的后继结点的<code>prev</code>前驱结点指针域指向删除元素结点的前驱结点即可<code>node.next.prev = node.prev</code>（此处可能有些绕，不太理解的同学自行学习一下双向链表的数据结构吧），不需要移动原数据存储位置，只需交换一下相关结点的指针域信息即可。所以时间复杂度也为O(1)。</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2017/8/28/f85573ac41422b664bdd69d0b9e25a66?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="删除元素结点示意图，图片来自《大话数据结构》">删除元素结点示意图，图片来自《大话数据结构》</p>
<ol>
<li>删除传入的Object o指定对象，比较对象是否一致通过o.equals方法比较<code>remove(Object o)</code>，和3.的思路基本差不多，关键是比较对象是通过o.equals方法，记住这点即可。</li>
</ol>
<ul>
<li>综上所述，LinkedList删除元素的时间复杂度为O(1)，单纯论删除元素，操作是非常高效的，特别是删除第一个结点或删除最后一个结点。但如果是通过索引index的方式或者object对象的方式删除，则需要对链表进行遍历查找对应index索引的对象或者利用equals方法判断对象。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 删除链表中的第一个元素并返回</div><div class="line"> *</div><div class="line"> * @return 链表中的第一个元素</div><div class="line"> * @throws NoSuchElementException if this list is empty</div><div class="line"> */</div><div class="line">public E removeFirst() &#123;</div><div class="line">    //根据头结点获取第一个元素结点</div><div class="line">    final Node&lt;E&gt; f = first;</div><div class="line">    if (f == null) // 没有元素结点则抛出异常</div><div class="line">        throw new NoSuchElementException();</div><div class="line">    return unlinkFirst(f);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 移除第一个元素</div><div class="line"> */</div><div class="line">private E unlinkFirst(Node&lt;E&gt; f) &#123;</div><div class="line">    // assert f == first &amp;&amp; f != null;</div><div class="line">    // 记录要移除元素结点的数据域</div><div class="line">    final E element = f.item;</div><div class="line">    // 记录要移除元素结点的后继结点指针</div><div class="line">    final Node&lt;E&gt; next = f.next;</div><div class="line">    // 清空要删除结点的数据域和next指针域信息，以帮助垃圾回收</div><div class="line">    f.item = null;</div><div class="line">    f.next = null; // help GC</div><div class="line">    // 头结点指向要移除元素结点的后继结点</div><div class="line">    first = next;</div><div class="line">    // 如果要移除元素结点的后继结点为空，则证明链表只有一个元素</div><div class="line">    // 所以需要将尾结点的指针信息也要清空</div><div class="line">    if (next == null)</div><div class="line">        last = null;</div><div class="line">    else</div><div class="line">        // 将新的第一个结点的前驱结点指针信息清空</div><div class="line">        next.prev = null;</div><div class="line">    // 记录链表长度的size - 1</div><div class="line">    size--;</div><div class="line">    modCount++;</div><div class="line">    // 返回移除元素结点的数据域</div><div class="line">    return element;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 删除链表中的最后一个元素并返回</div><div class="line"> *</div><div class="line"> * @return 链表中的最后一个元素</div><div class="line"> * @throws NoSuchElementException if this list is empty</div><div class="line"> */</div><div class="line">public E removeLast() &#123;</div><div class="line">    // 根据尾结点获取最后一个元素结点</div><div class="line">    final Node&lt;E&gt; l = last;</div><div class="line">    if (l == null)// 没有元素结点则抛出异常</div><div class="line">        throw new NoSuchElementException();</div><div class="line">    return unlinkLast(l);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> * 移除最后一个元素</div><div class="line"> */</div><div class="line">private E unlinkLast(Node&lt;E&gt; l) &#123;</div><div class="line">    // assert l == last &amp;&amp; l != null;</div><div class="line">    // 记录要移除元素结点的数据域</div><div class="line">    final E element = l.item;</div><div class="line">    // 记录要移除元素结点的前驱结点指针</div><div class="line">    final Node&lt;E&gt; prev = l.prev;</div><div class="line">    // 清空要删除结点的数据域和prev指针域信息，以帮助垃圾回收</div><div class="line">    l.item = null;</div><div class="line">    l.prev = null; // help GC</div><div class="line">    // 头结点指向要移除元素结点的前驱结点</div><div class="line">    last = prev;</div><div class="line">    // 如果要移除元素结点的前驱结点为空，则证明链表只有一个元素</div><div class="line">    // 所以需要将头结点的指针信息也要清空</div><div class="line">    if (prev == null)</div><div class="line">        first = null;</div><div class="line">    else</div><div class="line">        // 将新的最后一个结点的后继结点指针信息清空</div><div class="line">        prev.next = null;</div><div class="line">    // 记录链表长度的size - 1</div><div class="line">    size--;</div><div class="line">    modCount++;</div><div class="line">    // 返回移除元素结点的数据域</div><div class="line">    return element;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 将指定位置index的元素删除</div><div class="line"> *</div><div class="line"> * @param index 要删除的位置index</div><div class="line"> * @return 要删除位置的原元素</div><div class="line"> * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</div><div class="line"> */</div><div class="line">public E remove(int index) &#123;</div><div class="line">    // 检查index下标是否合法[0,size)</div><div class="line">    checkElementIndex(index);</div><div class="line">    // 根据index进行遍历链表获取要删除的结点，再调用unlink方法进行删除</div><div class="line">    return unlink(node(index));</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 删除传入的Object o指定对象，比较对象是否一致通过o.equals方法比较</div><div class="line"> * @param o 要删除的Object o指定对象</div><div class="line"> * @return &#123;@code true&#125; 是否存在要删除对象o</div><div class="line"> */</div><div class="line">public boolean remove(Object o) &#123;</div><div class="line">    // 如果删除对象为null，则遍历链表查找node.item数据域为null的结点并移除</div><div class="line">    if (o == null) &#123;</div><div class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</div><div class="line">            if (x.item == null) &#123;</div><div class="line">                unlink(x);</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        // 从头开始遍历链表，并通过equals方法逐一比较node.item是否相等 </div><div class="line">        // 相等则对象一致，删除此对象。</div><div class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</div><div class="line">            if (o.equals(x.item)) &#123;</div><div class="line">                unlink(x);</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> * 移除指定结点x</div><div class="line"> */</div><div class="line">E unlink(Node&lt;E&gt; x) &#123;</div><div class="line">    // assert x != null;</div><div class="line">    // 记录要移除元素结点的数据域</div><div class="line">    final E element = x.item;</div><div class="line">    // 记录要移除元素结点的后继结点指针</div><div class="line">    final Node&lt;E&gt; next = x.next;</div><div class="line">    // 记录要移除元素结点的前驱结点指针</div><div class="line">    final Node&lt;E&gt; prev = x.prev;</div><div class="line"></div><div class="line">    // 如果要移除元素结点的前驱结点为空，则证明要删除结点为第一个结点</div><div class="line">    if (prev == null) &#123;</div><div class="line">        // 头结点指向要删除元素结点的后继结点</div><div class="line">        first = next;</div><div class="line">    &#125; else &#123;</div><div class="line">        // 要删除元素结点的前驱结点的后继指针指向要删除元素结点的后继结点</div><div class="line">        prev.next = next;</div><div class="line">        // 清空要删除结点的前驱结点指针信息，以帮助GC</div><div class="line">        x.prev = null;</div><div class="line">    &#125;</div><div class="line">    // 如果要移除元素结点的后继结点为空，则证明要删除结点为最后一个结点</div><div class="line">    if (next == null) &#123;</div><div class="line">        // 尾结点指向要删除元素结点的前驱结点</div><div class="line">        last = prev;</div><div class="line">    &#125; else &#123;</div><div class="line">        // 要删除元素结点的后继结点的前驱指针指向要删除元素结点的前驱结点</div><div class="line">        next.prev = prev;</div><div class="line">        // 清空要删除结点的后继结点指针信息，以帮助GC</div><div class="line">        x.next = null;</div><div class="line">    &#125;</div><div class="line">    // 清空要删除元素的数据域，以帮助GC</div><div class="line">    x.item = null;</div><div class="line">    // 记录链表长度的size - 1</div><div class="line">    size--;</div><div class="line">    modCount++;</div><div class="line">    // 返回移除元素结点的数据域</div><div class="line">    return element;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ArrayList和LinkedList-的区别"><a href="#ArrayList和LinkedList-的区别" class="headerlink" title="ArrayList和LinkedList 的区别"></a>ArrayList和LinkedList 的区别</h2><p>问：那您可以比较一下ArrayList和LinkedList吗?</p>
<p>答：</p>
<ol>
<li>LinkedList内部存储的是<code>Node&lt;E&gt;</code>，不仅要维护数据域，还要维护<code>prev</code>和<code>next</code>，如果LinkedList中的结点特别多，则LinkedList比ArrayList更占内存。</li>
<li>插入删除操作效率：<br>LinkedList在做插入和删除操作时，插入或删除头部或尾部时是高效的，操作越靠近中间位置的元素时，需要遍历查找，速度相对慢一些，如果在数据量较大时，每次插入或删除时遍历查找比较费时。所以LinkedList插入与删除，慢在遍历查找，快在只需要更改相关结点的引用地址。<br>ArrayList在做插入和删除操作时，插入或删除尾部时也一样是高效的，操作其他位置，则需要批量移动元素，所以ArrayList插入与删除，快在遍历查找，慢在需要批量移动元素。</li>
<li>循环遍历效率：</li>
</ol>
<ul>
<li>由于ArrayList实现了<code>RandomAccess</code>随机访问接口，所以使用for(int i = 0; i &lt; size; i++)遍历会比使用Iterator迭代器来遍历快：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">for (int i=0, n=list.size(); i &lt; n; i++) &#123;     </div><div class="line">    list.get(i);</div><div class="line">&#125;</div><div class="line"></div><div class="line">runs faster than this loop:</div><div class="line">for (Iterator i=list.iterator(); i.hasNext(); ) &#123; </div><div class="line">   i.next();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>而由于LinkedList未实现<code>RandomAccess</code>接口，所以推荐使用Iterator迭代器来遍历数据。</li>
<li>因此，如果我们需要频繁在列表的中部改变插入或删除元素时，建议使用LinkedList，否则，建议使用ArrayList，因为ArrayList遍历查找元素较快，并且只需存储元素的数据域，不需要额外记录其他数据的位置信息，可以节省内存空间。</li>
</ul>
<h2 id="LinkedList是线程安全的吗？"><a href="#LinkedList是线程安全的吗？" class="headerlink" title="LinkedList是线程安全的吗？"></a>LinkedList是线程安全的吗？</h2><p>问：LinkedList是线程安全的吗？</p>
<p>答：LinkedList不是线程安全的，如果多个线程同时对同一个LinkedList更改数据的话，会导致数据不一致或者数据污染。如果出现线程不安全的操作时，LinkedList会尽可能的抛出<code>ConcurrentModificationException</code>防止数据异常，当我们在对一个LinkedList进行遍历时，在遍历期间，我们是不能对LinkedList进行添加，删除等更改数据结构的操作的，否则也会抛出<code>ConcurrentModificationException</code>异常，此为fail-fast（快速失败）机制。从源码上分析，我们在<code>add,remove</code>等更改LinkedList数据时，都会导致modCount的改变，当<code>expectedModCount != modCount</code>时，则抛出<code>ConcurrentModificationException</code>。如果想要线程安全，可以考虑调用<code>Collections.synchronizedCollection(Collection&lt;T&gt; c)</code>方法。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line">private class ListItr implements ListIterator&lt;E&gt; &#123;</div><div class="line">    private Node&lt;E&gt; lastReturned;</div><div class="line">    private Node&lt;E&gt; next;</div><div class="line">    private int nextIndex;</div><div class="line">    private int expectedModCount = modCount;</div><div class="line"></div><div class="line">    ListItr(int index) &#123;</div><div class="line">        // assert isPositionIndex(index);</div><div class="line">        next = (index == size) ? null : node(index);</div><div class="line">        nextIndex = index;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public boolean hasNext() &#123;</div><div class="line">        return nextIndex &lt; size;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public E next() &#123;</div><div class="line">        checkForComodification();</div><div class="line">        if (!hasNext())</div><div class="line">            throw new NoSuchElementException();</div><div class="line"></div><div class="line">        lastReturned = next;</div><div class="line">        next = next.next;</div><div class="line">        nextIndex++;</div><div class="line">        return lastReturned.item;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public boolean hasPrevious() &#123;</div><div class="line">        return nextIndex &gt; 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public E previous() &#123;</div><div class="line">        checkForComodification();</div><div class="line">        if (!hasPrevious())</div><div class="line">            throw new NoSuchElementException();</div><div class="line"></div><div class="line">        lastReturned = next = (next == null) ? last : next.prev;</div><div class="line">        nextIndex--;</div><div class="line">        return lastReturned.item;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int nextIndex() &#123;</div><div class="line">        return nextIndex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int previousIndex() &#123;</div><div class="line">        return nextIndex - 1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void remove() &#123;</div><div class="line">        checkForComodification();</div><div class="line">        if (lastReturned == null)</div><div class="line">            throw new IllegalStateException();</div><div class="line"></div><div class="line">        Node&lt;E&gt; lastNext = lastReturned.next;</div><div class="line">        unlink(lastReturned);</div><div class="line">        if (next == lastReturned)</div><div class="line">            next = lastNext;</div><div class="line">        else</div><div class="line">            nextIndex--;</div><div class="line">        lastReturned = null;</div><div class="line">        expectedModCount++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void set(E e) &#123;</div><div class="line">        if (lastReturned == null)</div><div class="line">            throw new IllegalStateException();</div><div class="line">        checkForComodification();</div><div class="line">        lastReturned.item = e;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void add(E e) &#123;</div><div class="line">        checkForComodification();</div><div class="line">        lastReturned = null;</div><div class="line">        if (next == null)</div><div class="line">            linkLast(e);</div><div class="line">        else</div><div class="line">            linkBefore(e, next);</div><div class="line">        nextIndex++;</div><div class="line">        expectedModCount++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;</div><div class="line">        Objects.requireNonNull(action);</div><div class="line">        while (modCount == expectedModCount &amp;&amp; nextIndex &lt; size) &#123;</div><div class="line">            action.accept(next.item);</div><div class="line">            lastReturned = next;</div><div class="line">            next = next.next;</div><div class="line">            nextIndex++;</div><div class="line">        &#125;</div><div class="line">        checkForComodification();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    final void checkForComodification() &#123;</div><div class="line">        if (modCount != expectedModCount)</div><div class="line">            throw new ConcurrentModificationException();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>LinkedList的结论已在第三个问题中展现了一部分了，所以不再重复说明了，我以面试问答的形式和大家一同学习了LinkedList，由于没有时间画图，可能此次没有ArrayList说的那么清楚，如果大家有看不懂的地方，请自行看一下关于链表的数据结构吧。如果此文对你有帮助，麻烦点个喜欢，谢谢各位。</p>
]]></content>
      
        <categories>
            
            <category> LinkedList </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础数据类型 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HashMap 的详细分析]]></title>
      <url>/2017/12/09/HashMap%20%E7%9A%84%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="HashMap-的详细分析"><a href="#HashMap-的详细分析" class="headerlink" title="HashMap 的详细分析"></a>HashMap 的详细分析</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这次我和大家一起学习<code>HashMap</code>，<code>HashMap</code>我们在工作中经常会使用，而且面试中也很频繁会问到，因为它里面蕴含着很多知识点，可以很好的考察个人基础。但一个这么重要的东西，我为什么没有在一开始就去学习它呢，因为它是由多种基础的数据结构和一些代码设计思想组成的。我们要学习了这些基础，再学习<code>HashMap</code>，这样我们才能更好的去理解它。古人云：无欲速，无见小利。欲速则不达，见小利则大事不成。</p>
<p><code>HashMap</code>其实就是<code>ArrayList</code>和<code>LinkedList</code>的数据结构加上<code>hashCode</code>和<code>equals</code>方法的思想设计出来的。没有理解上述说的知识点的同学可以翻开我过往的文章记录。</p>
<p>下面我就以面试问答的形式学习我们的——<code>HashMap</code>（源码分析基于JDK8，辅以JDK7），问答内容只是对<code>HashMap</code>的一个总结归纳，因为现时已经有大牛把<code>HashMap</code>通俗易懂的剖析了一遍，我学习<code>HashMap</code>也是主要通过这篇文章学习的，强烈推荐：美团点评技术团队的<a href="https://link.juejin.im/?target=https%3A%2F%2Ftech.meituan.com%2Fjava-hashmap.html" target="_blank" rel="external">Java 8系列之重新认识HashMap</a></p>
<h1 id="问答内容"><a href="#问答内容" class="headerlink" title="问答内容"></a>问答内容</h1><h2 id="HashMap-的主要用途"><a href="#HashMap-的主要用途" class="headerlink" title="HashMap 的主要用途"></a>HashMap 的主要用途</h2><p>问：<code>HashMap</code>有用过吗？您能给我说说他的主要用途吗？</p>
<p>答：</p>
<ul>
<li>有用过，我在平常工作中经常会用到<code>HashMap</code>这种数据结构，<code>HashMap</code>是基于<code>Map</code>接口实现的一种键-值对<code>&lt;key,value&gt;</code>的存储结构，允许<code>null</code>值，同时非有序，非同步(即线程不安全)。<code>HashMap</code>的底层实现是数组 + 链表 + 红黑树（JDK1.8增加了红黑树部分）。它存储和查找数据时，是根据键<code>key</code>的<code>hashCode</code>的值计算出具体的存储位置。<code>HashMap</code>最多只允许一条记录的键<code>key</code>为<code>null</code>，<code>HashMap</code>增删改查等常规操作都有不错的执行效率，是<code>ArrayList</code>和<code>LinkedList</code>等数据结构的一种折中实现。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个HashMap，如果没有指定初始大小，默认底层hash表数组的大小为16</span></div><div class="line">HashMap&lt;String, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</div><div class="line"><span class="comment">// 往容器里面添加元素</span></div><div class="line">hashMap.put(<span class="string">"小明"</span>, <span class="string">"好帅"</span>);</div><div class="line">hashMap.put(<span class="string">"老王"</span>, <span class="string">"坑爹货"</span>);</div><div class="line">hashMap.put(<span class="string">"老铁"</span>, <span class="string">"没毛病"</span>);</div><div class="line">hashMap.put(<span class="string">"掘金"</span>, <span class="string">"好地方"</span>);</div><div class="line">hashMap.put(<span class="string">"王五"</span>, <span class="string">"别搞事"</span>);</div><div class="line"><span class="comment">// 获取key为小明的元素 好帅</span></div><div class="line">String element = hashMap.get(<span class="string">"小明"</span>);</div><div class="line"><span class="comment">// value : 好帅</span></div><div class="line">System.out.println(element);</div><div class="line"><span class="comment">// 移除key为王五的元素</span></div><div class="line">String removeElement = hashMap.remove(<span class="string">"王五"</span>);</div><div class="line"><span class="comment">// value : 别搞事</span></div><div class="line">System.out.println(removeElement);</div><div class="line"><span class="comment">// 修改key为小明的元素的值value 为 其实有点丑</span></div><div class="line">hashMap.replace(<span class="string">"小明"</span>, <span class="string">"其实有点丑"</span>);</div><div class="line"><span class="comment">// &#123;老铁=没毛病, 小明=其实有点丑, 老王=坑爹货, 掘金=好地方&#125;</span></div><div class="line">System.out.println(hashMap);</div><div class="line"><span class="comment">// 通过put方法也可以达到修改对应元素的值的效果</span></div><div class="line">hashMap.put(<span class="string">"小明"</span>, <span class="string">"其实还可以啦,开玩笑的"</span>);</div><div class="line"><span class="comment">// &#123;老铁=没毛病, 小明=其实还可以啦,开玩笑的, 老王=坑爹货, 掘金=好地方&#125;</span></div><div class="line">System.out.println(hashMap);</div><div class="line"><span class="comment">// 判断key为老王的元素是否存在(捉奸老王)</span></div><div class="line"><span class="keyword">boolean</span> isExist = hashMap.containsKey(<span class="string">"老王"</span>);</div><div class="line"><span class="comment">// true , 老王竟然来搞事</span></div><div class="line">System.out.println(isExist);</div><div class="line"><span class="comment">// 判断是否有 value = "坑爹货" 的人</span></div><div class="line"><span class="keyword">boolean</span> isHasSomeOne = hashMap.containsValue(<span class="string">"坑爹货"</span>);</div><div class="line"><span class="comment">// true 老王是坑爹货</span></div><div class="line">System.out.println(isHasSomeOne);</div><div class="line"><span class="comment">// 查看这个容器里面还有几个家伙 value : 4</span></div><div class="line">System.out.println(hashMap.size());</div></pre></td></tr></table></figure>
<ul>
<li><code>HashMap</code>的底层实现是数组 + 链表 + 红黑树（JDK1.8增加了红黑树部分），核心组成元素有：</li>
</ul>
<ol>
<li><code>int size;</code>用于记录<code>HashMap</code>实际存储元素的个数；</li>
<li><code>float loadFactor;</code>负载因子（默认是0.75，此属性后面详细解释）。</li>
<li><code>int threshold;</code>下一次扩容时的阈值，达到阈值便会触发扩容机制<code>resize</code>（阈值 threshold = 容器容量 capacity * 负载因子 load factor）。也就是说，在容器定义好容量之后，负载因子越大，所能容纳的键值对元素个数就越多。</li>
<li><code>Node&lt;K,V&gt;[] table;</code> 底层数组，充当哈希表的作用，用于存储对应hash位置的元素<code>Node&lt;K,V&gt;</code>，此数组长度总是2的N次幂。（具体原因后面详细解释）</li>
</ol>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></div><div class="line">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> &#123;</div><div class="line">·····</div><div class="line"></div><div class="line">    <span class="comment">/* ---------------- Fields -------------- */</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 哈希表，在第一次使用到时进行初始化，重置大小是必要的操作，</div><div class="line">     * 当分配容量时，长度总是2的N次幂。</div><div class="line">     */</div><div class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 实际存储的key - value 键值对 个数</div><div class="line">     */</div><div class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 下一次扩容时的阈值 </div><div class="line">     * (阈值 threshold = 容器容量 capacity * 负载因子 load factor).</div><div class="line">     * <span class="doctag">@serial</span></div><div class="line">     */</div><div class="line">    <span class="keyword">int</span> threshold;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 哈希表的负载因子</div><div class="line">     *</div><div class="line">     * <span class="doctag">@serial</span></div><div class="line">     */</div><div class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</div><div class="line"></div><div class="line">·····</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>其中<code>Node&lt;K,V&gt;[] table;</code>哈希表存储的核心元素是<code>Node&lt;K,V&gt;</code>,<code>Node&lt;K,V&gt;</code>包含：</li>
</ul>
<ol>
<li><code>final int hash;</code>元素的哈希值，决定元素存储在<code>Node&lt;K,V&gt;[] table;</code>哈希表中的位置。由<code>final</code>修饰可知，当<code>hash</code>的值确定后，就不能再修改。</li>
<li><code>final K key;</code> 键，由<code>final</code>修饰可知，当<code>key</code>的值确定后，就不能再修改。</li>
<li><code>V value;</code> 值</li>
<li><code>Node&lt;K,V&gt; next;</code> 记录下一个元素结点(单链表结构，用于解决hash冲突)</li>
</ol>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 定义HashMap存储元素结点的底层实现</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;<span class="comment">//元素的哈希值 由final修饰可知，当hash的值确定后，就不能再修改</span></div><div class="line">    <span class="keyword">final</span> K key;<span class="comment">// 键，由final修饰可知，当key的值确定后，就不能再修改</span></div><div class="line">    V value; <span class="comment">// 值</span></div><div class="line">    Node&lt;K,V&gt; next; <span class="comment">// 记录下一个元素结点(单链表结构，用于解决hash冲突)</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Node结点构造方法</div><div class="line">     */</div><div class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</div><div class="line">        <span class="keyword">this</span>.hash = hash;<span class="comment">//元素的哈希值</span></div><div class="line">        <span class="keyword">this</span>.key = key;<span class="comment">// 键</span></div><div class="line">        <span class="keyword">this</span>.value = value; <span class="comment">// 值</span></div><div class="line">        <span class="keyword">this</span>.next = next;<span class="comment">// 记录下一个元素结点</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 为Node重写hashCode方法，值为：key的hashCode 异或 value的hashCode </div><div class="line">     * 运算作用就是将2个hashCode的二进制中，同一位置相同的值为0，不同的为1。</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 修改某一元素的值</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</div><div class="line">        V oldValue = value;</div><div class="line">        value = newValue;</div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 为Node重写equals方法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</div><div class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</div><div class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</div><div class="line">                Objects.equals(value, e.getValue()))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://user-gold-cdn.xitu.io/2017/10/19/db63a0bc793f06e3d80ba8885e91c798?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="hashMap内存结构图 - 图片来自于《美团点评技术团队文章》">hashMap内存结构图 - 图片来自于《美团点评技术团队文章》</p>
<h2 id="HashMap-常用操作的底层实现原理"><a href="#HashMap-常用操作的底层实现原理" class="headerlink" title="HashMap 常用操作的底层实现原理"></a>HashMap 常用操作的底层实现原理</h2><p>问：您能说说<code>HashMap</code>常用操作的底层实现原理吗？如存储<code>put(K key, V value)</code>，查找<code>get(Object key)</code>，删除<code>remove(Object key)</code>，修改<code>replace(K key, V value)</code>等操作。</p>
<p>答：</p>
<ul>
<li>调用<code>put(K key, V value)</code>操作添加<code>key-value</code>键值对时，进行了如下操作：</li>
</ul>
<ol>
<li>判断哈希表<code>Node&lt;K,V&gt;[] table</code>是否为空或者<code>null</code>，是则执行<code>resize()</code>方法进行扩容。</li>
<li>根据插入的键值<code>key</code>的<code>hash</code>值，通过<code>(n - 1) &amp; hash</code>当前元素的<code>hash</code>值 &amp; <code>hash</code>表长度 - 1（实际就是 <code>hash</code>值 % <code>hash</code>表长度） 计算出存储位置<code>table[i]</code>。如果存储位置没有元素存放，则将新增结点存储在此位置<code>table[i]</code>。</li>
<li>如果存储位置已经有键值对元素存在，则判断该位置元素的<code>hash</code>值和<code>key</code>值是否和当前操作元素一致，一致则证明是修改<code>value</code>操作，覆盖<code>value</code>即可。</li>
<li>当前存储位置即有元素，又不和当前操作元素一致，则证明此位置<code>table[i]</code>已经发生了hash冲突，则通过判断头结点是否是<code>treeNode</code>，如果是<code>treeNode</code>则证明此位置的结构是红黑树，已红黑树的方式新增结点。</li>
<li>如果不是红黑树，则证明是单链表，将新增结点插入至链表的最后位置，随后判断当前链表长度是否 大于等于 8，是则将当前存储位置的链表转化为红黑树。遍历过程中如果发现<code>key</code>已经存在，则直接覆盖<code>value</code>。</li>
<li>插入成功后，判断当前存储键值对的数量 大于 阈值<code>threshold</code> 是则扩容。</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2017/10/19/eb270f06461f7a70314b33b7a9cfe6ba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="hashMap put方法执行流程图- 图片来自于《美团点评技术团队文章》">hashMap put方法执行流程图- 图片来自于《美团点评技术团队文章》</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 添加key-value键值对</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> key 键</div><div class="line"> * <span class="doctag">@param</span> value 值</div><div class="line"> * <span class="doctag">@return</span> 如果原本存在此key，则返回旧的value值，如果是新增的key-     </div><div class="line"> *         value，则返回nulll</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="comment">//实际调用putVal方法进行添加 key-value 键值对操作</span></div><div class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 根据key 键 的 hashCode 通过 “扰动函数” 生成对应的 hash值</div><div class="line"> * 经过此操作后，使每一个key对应的hash值生成的更均匀，</div><div class="line"> * 减少元素之间的碰撞几率（后面详细说明）</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h;</div><div class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 添加key-value键值对的实际调用方法（重点）</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> hash key 键的hash值</div><div class="line"> * <span class="doctag">@param</span> key 键</div><div class="line"> * <span class="doctag">@param</span> value 值</div><div class="line"> * <span class="doctag">@param</span> onlyIfAbsent 此值如果是true, 则如果此key已存在value，则不执</div><div class="line"> * 行修改操作 </div><div class="line"> * <span class="doctag">@param</span> evict 此值如果是false，哈希表是在初始化模式</div><div class="line"> * <span class="doctag">@return</span> 返回原本的旧值, 如果是新增，则返回null</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line">               <span class="keyword">boolean</span> evict) &#123;</div><div class="line">    <span class="comment">// 用于记录当前的hash表</span></div><div class="line">    Node&lt;K,V&gt;[] tab; </div><div class="line">    <span class="comment">// 用于记录当前的链表结点</span></div><div class="line">    Node&lt;K,V&gt; p; </div><div class="line">    <span class="comment">// n用于记录hash表的长度，i用于记录当前操作索引index</span></div><div class="line">    <span class="keyword">int</span> n, i;</div><div class="line">    <span class="comment">// 当前hash表为空</span></div><div class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">        <span class="comment">// 初始化hash表，并把初始化后的hash表长度值赋值给n</span></div><div class="line">        n = (tab = resize()).length;</div><div class="line">    <span class="comment">// 1）通过 (n - 1) &amp; hash 当前元素的hash值 &amp; hash表长度 - 1</span></div><div class="line">    <span class="comment">// 2）确定当前元素的存储位置，此运算等价于 当前元素的hash值 % hash表的长度</span></div><div class="line">    <span class="comment">// 3）计算出的存储位置没有元素存在</span></div><div class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</div><div class="line">        <span class="comment">// 4) 则新建一个Node结点，在该位置存储此元素</span></div><div class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 当前存储位置已经有元素存在了(不考虑是修改的情况的话，就代表发生hash冲突了)</span></div><div class="line">        <span class="comment">// 用于存放新增结点</span></div><div class="line">        Node&lt;K,V&gt; e; </div><div class="line">        <span class="comment">// 用于临时存在某个key值</span></div><div class="line">        K k;</div><div class="line">        <span class="comment">// 1)如果当前位置已存在元素的hash值和新增元素的hash值相等</span></div><div class="line">        <span class="comment">// 2)并且key也相等，则证明是同一个key元素，想执行修改value操作</span></div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            e = p;<span class="comment">// 将当前结点引用赋值给e</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 如果当前结点是树结点</span></div><div class="line">            <span class="comment">// 则证明当前位置的链表已变成红黑树结构，则已红黑树结点结构新增元素</span></div><div class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line">        <span class="keyword">else</span> &#123;<span class="comment">// 排除上述情况，则证明已发生hash冲突，并hash冲突位置现时的结构是单链表结构</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">                <span class="comment">//遍历单链表，将新元素结点放置此链表的最后一位</span></div><div class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">// 将新元素结点放在此链表的最后一位</span></div><div class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                    <span class="comment">// 新增结点后，当前结点数量是否大于等于 阈值 8 </span></div><div class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                        <span class="comment">// 大于等于8则将链表转换成红黑树</span></div><div class="line">                        treeifyBin(tab, hash);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 如果链表中已经存在对应的key，则覆盖value</span></div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// 已存在对应key</span></div><div class="line">            V oldValue = e.value;</div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>) <span class="comment">//如果允许修改，则修改value为新值</span></div><div class="line">                e.value = value;</div><div class="line">            afterNodeAccess(e);</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ++modCount;</div><div class="line">    <span class="comment">// 当前存储键值对的数量 大于 阈值 是则扩容</span></div><div class="line">    <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line">       <span class="comment">// 重置hash大小，将旧hash表的数据逐一复制到新的hash表中（后面详细讲解）</span></div><div class="line">        resize();</div><div class="line">    afterNodeInsertion(evict);</div><div class="line">    <span class="comment">// 返回null，则证明是新增操作，而不是修改操作</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用<code>get(Object key)</code>操作根据键<code>key</code>查找对应的<code>key-value</code>键值对时，进行了如下操作：</li>
</ul>
<p>1.先调用 <code>hash(key)</code>方法计算出 <code>key</code> 的 <code>hash</code>值</p>
<p>2.根据查找的键值<code>key</code>的<code>hash</code>值，通过<code>(n - 1) &amp; hash</code>当前元素的<code>hash</code>值 &amp; <code>hash</code>表长度 - 1（实际就是 <code>hash</code>值 % <code>hash</code>表长度） 计算出存储位置<code>table[i]</code>，判断存储位置是否有元素存在 。</p>
<ul>
<li>如果存储位置有元素存放，则首先比较头结点元素，如果头结点的<code>key</code>的<code>hash</code>值 和 要获取的<code>key</code>的<code>hash</code>值相等，并且 头结点的<code>key</code>本身 和要获取的 <code>key</code> 相等，则返回该位置的头结点。</li>
<li>如果存储位置没有元素存放，则返回<code>null</code>。</li>
</ul>
<p>3.如果存储位置有元素存放，但是头结点元素不是要查找的元素，则需要遍历该位置进行查找。</p>
<p>4.先判断头结点是否是<code>treeNode</code>，如果是<code>treeNode</code>则证明此位置的结构是红黑树，以红色树的方式遍历查找该结点，没有则返回<code>null</code>。</p>
<p>5.如果不是红黑树，则证明是单链表。遍历单链表，逐一比较链表结点，链表结点的<code>key</code>的<code>hash</code>值 和 要获取的<code>key</code>的<code>hash</code>值相等，并且 链表结点的<code>key</code>本身 和要获取的 <code>key</code> 相等，则返回该结点，遍历结束仍未找到对应<code>key</code>的结点，则返回<code>null</code>。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 返回指定 key 所映射的 value 值</div><div class="line"> * 或者 返回 null 如果容器里不存在对应的key</div><div class="line"> *</div><div class="line"> * 更确切地讲，如果此映射包含一个满足 (key==null ? k==null :key.equals(k))</div><div class="line"> * 的从 k 键到 v 值的映射关系，</div><div class="line"> * 则此方法返回 v；否则返回 null。（最多只能有一个这样的映射关系。）</div><div class="line"> *</div><div class="line"> * 返回 null 值并不一定 表明该映射不包含该键的映射关系；</div><div class="line"> * 也可能该映射将该键显示地映射为 null。可使用containsKey操作来区分这两种情况。 </div><div class="line"> *</div><div class="line"> * <span class="doctag">@see</span> #put(Object, Object)</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    <span class="comment">// 1.先调用 hash(key)方法计算出 key 的 hash值</span></div><div class="line">    <span class="comment">// 2.随后调用getNode方法获取对应key所映射的value值</span></div><div class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 获取哈希表结点的方法实现</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> hash key 键的hash值</div><div class="line"> * <span class="doctag">@param</span> key 键</div><div class="line"> * <span class="doctag">@return</span> 返回对应的结点，如果结点不存在，则返回null</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</div><div class="line">    <span class="comment">// 用于记录当前的hash表 </span></div><div class="line">    Node&lt;K,V&gt;[] tab; </div><div class="line">    <span class="comment">// first用于记录对应hash位置的第一个结点，e充当工作结点的作用</span></div><div class="line">    Node&lt;K,V&gt; first, e; </div><div class="line">    <span class="comment">// n用于记录hash表的长度</span></div><div class="line">    <span class="keyword">int</span> n; </div><div class="line">    <span class="comment">// 用于临时存放Key</span></div><div class="line">    K k;</div><div class="line">    <span class="comment">// 通过 (n - 1) &amp; hash 当前元素的hash值 &amp; hash表长度 - 1</span></div><div class="line">    <span class="comment">// 判断当前元素的存储位置是否有元素存在 </span></div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;<span class="comment">//元素存在的情况</span></div><div class="line">       <span class="comment">// 如果头结点的key的hash值 和 要获取的key的hash值相等</span></div><div class="line">       <span class="comment">// 并且 头结点的key本身 和要获取的 key 相等</span></div><div class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node 总是检查头结点</span></div><div class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            <span class="comment">// 返回该位置的头结点</span></div><div class="line">            <span class="keyword">return</span> first;</div><div class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;<span class="comment">// 头结点不相等</span></div><div class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 如果当前结点是树结点</span></div><div class="line">                <span class="comment">// 则证明当前位置的链表已变成红黑树结构</span></div><div class="line">                <span class="comment">// 通过红黑树结点的方式获取对应key结点</span></div><div class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class="line">            <span class="keyword">do</span> &#123;<span class="comment">// 当前位置不是红黑树，则证明是单链表</span></div><div class="line">                <span class="comment">// 遍历单链表，逐一比较链表结点</span></div><div class="line">                <span class="comment">// 链表结点的key的hash值 和 要获取的key的hash值相等</span></div><div class="line">                <span class="comment">// 并且 链表结点的key本身 和要获取的 key 相等</span></div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="comment">// 找到对应的结点则返回</span></div><div class="line">                    <span class="keyword">return</span> e;</div><div class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 通过上述查找均无找到，则返回null</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用<code>remove(Object key)</code>操作根据键<code>key</code>删除对应的<code>key-value</code>键值对时，进行了如下操作：</li>
</ul>
<p>1.先调用 <code>hash(key)</code>方法计算出 <code>key</code> 的 <code>hash</code>值</p>
<p>2.根据查找的键值<code>key</code>的<code>hash</code>值，通过<code>(n - 1) &amp; hash</code>当前元素的<code>hash</code>值 &amp; <code>hash</code>表长度 - 1（实际就是 <code>hash</code>值 % <code>hash</code>表长度） 计算出存储位置<code>table[i]</code>，判断存储位置是否有元素存在 。</p>
<ul>
<li>如果存储位置有元素存放，则首先比较头结点元素，如果头结点的<code>key</code>的<code>hash</code>值 和 要获取的<code>key</code>的<code>hash</code>值相等，并且 头结点的<code>key</code>本身 和要获取的 <code>key</code> 相等，则该位置的头结点即为要删除的结点，记录此结点至变量<code>node</code>中。</li>
<li>如果存储位置没有元素存放，则没有找到对应要删除的结点，则返回<code>null</code>。</li>
</ul>
<p>3.如果存储位置有元素存放，但是头结点元素不是要删除的元素，则需要遍历该位置进行查找。</p>
<p>4.先判断头结点是否是<code>treeNode</code>，如果是<code>treeNode</code>则证明此位置的结构是红黑树，以红色树的方式遍历查找并删除该结点，没有则返回<code>null</code>。</p>
<p>5.如果不是红黑树，则证明是单链表。遍历单链表，逐一比较链表结点，链表结点的<code>key</code>的<code>hash</code>值 和 要获取的<code>key</code>的<code>hash</code>值相等，并且 链表结点的<code>key</code>本身 和要获取的 <code>key</code> 相等，则此为要删除的结点，记录此结点至变量<code>node</code>中，遍历结束仍未找到对应<code>key</code>的结点，则返回<code>null</code>。</p>
<p>6.如果找到要删除的结点<code>node</code>，则判断是否需要比较<code>value</code>也是否一致，如果<code>value</code>值一致或者不需要比较<code>value</code>值，则执行删除结点操作，删除操作根据不同的情况与结构进行不同的处理。</p>
<ul>
<li>如果当前结点是树结点，则证明当前位置的链表已变成红黑树结构，通过红黑树结点的方式删除对应结点。</li>
<li>如果不是红黑树，则证明是单链表。如果要删除的是头结点，则当前存储位置<code>table[i]</code>的头结点指向删除结点的下一个结点。</li>
<li>如果要删除的结点不是头结点，则将要删除的结点的后继结点<code>node.next</code>赋值给要删除结点的前驱结点的<code>next</code>域，即<code>p.next = node.next;</code>。</li>
</ul>
<p>7.<code>HashMap</code>当前存储键值对的数量 - 1，并返回删除结点。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 从此映射中移除指定键的映射关系（如果存在）。</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span>  key 其映射关系要从映射中移除的键</div><div class="line"> * <span class="doctag">@return</span> 与 key 关联的旧值；如果 key 没有任何映射关系，则返回 null。</div><div class="line"> *        （返回 null 还可能表示该映射之前将 null 与 key 关联。）</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    <span class="comment">// 1.先调用 hash(key)方法计算出 key 的 hash值</span></div><div class="line">    <span class="comment">// 2.随后调用removeNode方法删除对应key所映射的结点</span></div><div class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</div><div class="line">        <span class="keyword">null</span> : e.value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 删除哈希表结点的方法实现</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> hash 键的hash值</div><div class="line"> * <span class="doctag">@param</span> key 键</div><div class="line"> * <span class="doctag">@param</span> value 用于比较的value值，当matchValue 是 true时才有效, 否则忽略</div><div class="line"> * <span class="doctag">@param</span> matchValue 如果是 true 只有当value相等时才会移除</div><div class="line"> * <span class="doctag">@param</span> movable 如果是 false当执行移除操作时，不删除其他结点</div><div class="line"> * <span class="doctag">@return</span> 返回删除结点node，不存在则返回null</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></div><div class="line">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable) &#123;</div><div class="line">    <span class="comment">// 用于记录当前的hash表</span></div><div class="line">    Node&lt;K,V&gt;[] tab; </div><div class="line">    <span class="comment">// 用于记录当前的链表结点</span></div><div class="line">    Node&lt;K,V&gt; p; </div><div class="line">    <span class="comment">// n用于记录hash表的长度，index用于记录当前操作索引index</span></div><div class="line">    <span class="keyword">int</span> n, index;</div><div class="line">    <span class="comment">// 通过 (n - 1) &amp; hash 当前元素的hash值 &amp; hash表长度 - 1</span></div><div class="line">    <span class="comment">// 判断当前元素的存储位置是否有元素存在 </span></div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;<span class="comment">// 元素存在的情况</span></div><div class="line">        <span class="comment">// node 用于记录找到的结点，e为工作结点</span></div><div class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; </div><div class="line">        K k; V v;</div><div class="line">       <span class="comment">// 如果头结点的key的hash值 和 要获取的key的hash值相等</span></div><div class="line">       <span class="comment">// 并且 头结点的key本身 和要获取的 key 相等</span></div><div class="line">       <span class="comment">// 则证明此头结点就是要删除的结点</span></div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            <span class="comment">// 记录要删除的结点的引用地址至node中</span></div><div class="line">            node = p;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;<span class="comment">// 头结点不相等</span></div><div class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)<span class="comment">// 如果当前结点是树结点</span></div><div class="line">                <span class="comment">// 则证明当前位置的链表已变成红黑树结构</span></div><div class="line">                <span class="comment">// 通过红黑树结点的方式获取对应key结点</span></div><div class="line">                <span class="comment">// 记录要删除的结点的引用地址至node中</span></div><div class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</div><div class="line">            <span class="keyword">else</span> &#123;<span class="comment">// 当前位置不是红黑树，则证明是单链表</span></div><div class="line">                <span class="keyword">do</span> &#123;</div><div class="line">                    <span class="comment">// 遍历单链表，逐一比较链表结点</span></div><div class="line">                    <span class="comment">// 链表结点的key的hash值 和 要获取的key的hash值相等</span></div><div class="line">                    <span class="comment">// 并且 链表结点的key本身 和要获取的 key 相等</span></div><div class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.key) == key ||</div><div class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</div><div class="line">                        <span class="comment">// 找到则记录要删除的结点的引用地址至node中，中断遍历</span></div><div class="line">                        node = e;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                    p = e;</div><div class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 如果找到要删除的结点，则判断是否需要比较value也是否一致</span></div><div class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</div><div class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</div><div class="line">            <span class="comment">// value值一致或者不需要比较value值，则执行删除结点操作</span></div><div class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 如果当前结点是树结点</span></div><div class="line">                <span class="comment">// 则证明当前位置的链表已变成红黑树结构</span></div><div class="line">                <span class="comment">// 通过红黑树结点的方式删除对应结点</span></div><div class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p) <span class="comment">// node 和 p相等，则证明删除的是头结点</span></div><div class="line">                <span class="comment">// 当前存储位置的头结点指向删除结点的下一个结点</span></div><div class="line">                tab[index] = node.next;</div><div class="line">            <span class="keyword">else</span> <span class="comment">// 删除的不是头结点</span></div><div class="line">                <span class="comment">// p是删除结点node的前驱结点，p的next改为记录要删除结点node的后继结点</span></div><div class="line">                p.next = node.next;</div><div class="line">            ++modCount;</div><div class="line">           <span class="comment">// 当前存储键值对的数量 - 1</span></div><div class="line">            --size;</div><div class="line">            afterNodeRemoval(node);</div><div class="line">            <span class="comment">// 返回删除结点</span></div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 不存在要删除的结点，则返回null</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用<code>replace(K key, V value)</code>操作根据键<code>key</code>查找对应的<code>key-value</code>键值对，随后替换对应的值<code>value</code>，进行了如下操作：</li>
</ul>
<ol>
<li>先调用 <code>hash(key)</code>方法计算出 <code>key</code> 的 <code>hash</code>值</li>
<li>随后调用<code>getNode</code>方法获取对应<code>key</code>所映射的<code>value</code>值 。</li>
<li>记录元素旧值，将新值赋值给元素，返回元素旧值，如果没有找到元素，则返回<code>null</code>。</li>
</ol>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 替换指定 key 所映射的 value 值</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> key 对应要替换value值元素的key键</div><div class="line"> * <span class="doctag">@param</span> value 要替换对应元素的新value值</div><div class="line"> * <span class="doctag">@return</span> 返回原本的旧值，如果没有找到key对应的元素，则返回null</div><div class="line"> * <span class="doctag">@since</span> 1.8 JDK1.8新增方法</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    <span class="comment">// 1.先调用 hash(key)方法计算出 key 的 hash值</span></div><div class="line">    <span class="comment">// 2.随后调用getNode方法获取对应key所映射的value值</span></div><div class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span>) &#123;<span class="comment">// 如果找到对应的元素</span></div><div class="line">        <span class="comment">// 元素旧值</span></div><div class="line">        V oldValue = e.value;</div><div class="line">        <span class="comment">// 将新值赋值给元素</span></div><div class="line">        e.value = value;</div><div class="line">        afterNodeAccess(e);</div><div class="line">        <span class="comment">// 返回元素旧值</span></div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 没有找到元素，则返回null</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="HashMap-若要新增的这个元素存在了或hash冲突了怎么办"><a href="#HashMap-若要新增的这个元素存在了或hash冲突了怎么办" class="headerlink" title="HashMap 若要新增的这个元素存在了或hash冲突了怎么办"></a>HashMap 若要新增的这个元素存在了或hash冲突了怎么办</h2><p>问 1：您上面说，存放一个元素时，先计算它的hash值确定它的存储位置，然后再把这个元素放到对应的位置上，那万一这个位置上面已经有元素存在呢，新增的这个元素怎么办？</p>
<p>问 2：<code>hash</code>冲突（或者叫<code>hash</code>碰撞）是什么？为什么会出现这种现象，如何解决<code>hash</code>冲突？</p>
<p>答：</p>
<ul>
<li><code>hash</code>冲突： 当我们调用<code>put(K key, V value)</code>操作添加<code>key-value</code>键值对，这个<code>key-value</code>键值对存放在的位置是通过扰动函数<code>(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>计算键<code>key</code>的<code>hash</code>值。随后将 这个<code>hash</code>值 % 模上 哈希表<code>Node&lt;K,V&gt;[] table</code>的长度 得到具体的存放位置。所以<code>put(K key, V value)</code>多个元素，是有可能计算出相同的存放位置。此现象就是<code>hash</code>冲突或者叫<code>hash</code>碰撞。</li>
<li>例子如下：<br>元素 A 的<code>hash</code>值 为 9，元素 B 的<code>hash</code>值 为 17。哈希表<code>Node&lt;K,V&gt;[] table</code>的长度为8。则元素 A 的存放位置为<code>9 % 8 = 1</code>，元素 B 的存放位置为<code>17 % 8 = 1</code>。两个元素的存放位置均为<code>table[1]</code>，发生了<code>hash</code>冲突。</li>
<li><code>hash</code>冲突的避免：既然会发生<code>hash</code>冲突，我们就应该想办法避免此现象的发生，解决这个问题最关键就是如果生成元素的<code>hash</code>值。Java是使用“扰动函数”生成元素的<code>hash</code>值。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * JDK 7 的 hash方法</div><div class="line"> */</div><div class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</div><div class="line"></div><div class="line">     h ^= k.hashCode();</div><div class="line"></div><div class="line">     h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</div><div class="line">     <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * JDK 8 的 hash方法</div><div class="line"> */</div><div class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">     <span class="keyword">int</span> h;</div><div class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>Java7做了4次16位右位移异或混合，Java 8中这步已经简化了，只做一次16位右位移异或混合，而不是四次，但原理是不变的。例子如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/10/19/acf1abecfd91bdd0d465c6707dc57bfc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="扰动函数执行例子 - 图片来自于《知乎》">扰动函数执行例子 - 图片来自于《知乎》</p>
<p>右位移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。</p>
<p>上述扰动函数的解释参考自：<a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F20733617" target="_blank" rel="external">JDK 源码中 HashMap 的 hash 方法原理是什么？</a></p>
<ul>
<li><code>hash</code>冲突解决：解决<code>hash</code>冲突的方法有很多，常见的有：开发定址法，<br>再散列法，链地址法，公共溢出区法（详细说明请查看我的文章<a href="https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F59b25f825188257e7e11500c" target="_blank" rel="external">JAVA基础-自问自答学hashCode和equals</a>）。<code>HashMap</code>是使用链地址法解决<code>hash</code>冲突的，当有冲突元素放进来时，会将此元素插入至此位置链表的最后一位，形成单链表。但是由于是单链表的缘故，每当通过<code>hash % length</code>找到该位置的元素时，均需要从头遍历链表，通过逐一比较<code>hash</code>值，找到对应元素。如果此位置元素过多，造成链表过长，遍历时间会大大增加，最坏情况下的时间复杂度为<code>O(N)</code>，造成查找效率过低。所以当存在位置的链表长度 大于等于 8 时，<code>HashMap</code>会将链表 转变为 红黑树，红黑树最坏情况下的时间复杂度为<code>O(logn)</code>。以此提高查找效率。</li>
</ul>
<h2 id="HashMap-的容量为什么一定要是2的n次方"><a href="#HashMap-的容量为什么一定要是2的n次方" class="headerlink" title="HashMap 的容量为什么一定要是2的n次方"></a>HashMap 的容量为什么一定要是2的n次方</h2><p>问：<code>HashMap</code>的容量为什么一定要是2的n次方？</p>
<p>答：</p>
<ul>
<li>因为调用<code>put(K key, V value)</code>操作添加<code>key-value</code>键值对时，具体确定此元素的位置是通过 <code>hash</code>值 % 模上 哈希表<code>Node&lt;K,V&gt;[] table</code>的长度 <code>hash % length</code> 计算的。但是”模”运算的消耗相对较大，通过位运算<code>h &amp; (length-1)</code>也可以得到取模后的存放位置，而位运算的运行效率高，但只有<code>length</code>的长度是2的n次方时，<code>h &amp; (length-1)</code> 才等价于 <code>h % length</code>。</li>
<li>而且当数组长度为2的n次幂的时候，不同的key算出的index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。</li>
</ul>
<p>例子：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/10/19/c61e51c7084d9506e8a3fd4d402022d8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="hash &amp;  (length-1)运算过程.jpg">hash &amp; (length-1)运算过程.jpg</p>
<ul>
<li>上图中，左边两组的数组长度是16（2的4次方），右边两组的数组长度是15。两组的<code>hash</code>值均为8和9。</li>
<li>当数组长度是15时，当它们和<code>1110</code>进行<code>&amp;</code>与运算（相同为1，不同为0）时，计算的结果都是<code>1000</code>，所以他们都会存放在相同的位置<code>table[8]</code>中，这样就发生了<code>hash</code>冲突，那么查询时就要遍历链表，逐一比较<code>hash</code>值，降低了查询的效率。</li>
<li>同时，我们可以发现，当数组长度为15的时候，<code>hash</code>值均会与<code>14（1110）</code>进行<code>&amp;</code>与运算，那么最后一位永远是0，而<code>0001</code>，<code>0011</code>，<code>0101</code>，<code>1001</code>，<code>1011</code>，<code>0111</code>，<code>1101</code>这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率。</li>
</ul>
<ul>
<li>所以，<code>HashMap</code>的容量是2的n次方，有利于提高计算元素存放位置时的效率，也降低了<code>hash</code>冲突的几率。因此，我们使用<code>HashMap</code>存储大量数据的时候，最好先预先指定容器的大小为2的n次方，即使我们不指定为2的n次方，<code>HashMap</code>也会把容器的大小设置成最接近设置数的2的n次方，如，设置<code>HashMap</code>的大小为 7 ，则<code>HashMap</code>会将容器大小设置成最接近7的一个2的n次方数，此值为 8 。</li>
</ul>
<p>上述回答参考自：<a href="https://link.juejin.im/?target=http%3A%2F%2Fannegu.iteye.com%2Fblog%2F539465" target="_blank" rel="external">深入理解HashMap</a></p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 返回一个比指定数cap大的，并且大小是2的n次方的数</div><div class="line"> * Returns a power of two size for the given target capacity.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</div><div class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="HashMap-的负载因子是什么，有什么作用"><a href="#HashMap-的负载因子是什么，有什么作用" class="headerlink" title="HashMap 的负载因子是什么，有什么作用"></a>HashMap 的负载因子是什么，有什么作用</h2><p>问：<code>HashMap</code>的负载因子是什么，有什么作用？</p>
<p>答：负载因子表示哈希表空间的使用程度（或者说是哈希表空间的利用率）。</p>
<ul>
<li>例子如下：<br>底层哈希表<code>Node&lt;K,V&gt;[] table</code>的容量大小<code>capacity</code>为 16，负载因子<code>load factor</code>为 0.75，则当存储的元素个数<code>size = capacity 16 * load factor 0.75</code>等于 12 时，则会触发<code>HashMap</code>的扩容机制，调用<code>resize()</code>方法进行扩容。</li>
<li>当负载因子越大，则<code>HashMap</code>的装载程度就越高。也就是能容纳更多的元素，元素多了，发生<code>hash</code>碰撞的几率就会加大，从而链表就会拉长，此时的查询效率就会降低。</li>
<li>当负载因子越小，则链表中的数据量就越稀疏，此时会对空间造成浪费，但是此时查询效率高。</li>
<li>我们可以在创建<code>HashMap</code> 时根据实际需要适当地调整<code>load factor</code> 的值；如果程序比较关心空间开销、内存比较紧张，可以适当地增加负载因子；如果程序比较关心时间开销，内存比较宽裕则可以适当的减少负载因子。通常情况下，默认负载因子 (0.75) 在时间和空间成本上寻求一种折衷，程序员无需改变负载因子的值。</li>
<li>因此，如果我们在初始化<code>HashMap</code>时，就预估知道需要装载<code>key-value</code>键值对的容量<code>size</code>，我们可以通过<code>size / load factor</code> 计算出我们需要初始化的容量大小<code>initialCapacity</code>，这样就可以避免<code>HashMap</code>因为存放的元素达到阈值<code>threshold</code>而频繁调用<code>resize()</code>方法进行扩容。从而保证了较好的性能。</li>
</ul>
<h2 id="HashMap-和-HashTable-的区别"><a href="#HashMap-和-HashTable-的区别" class="headerlink" title="HashMap 和 HashTable 的区别"></a>HashMap 和 HashTable 的区别</h2><p>问：您能说说<code>HashMap</code>和<code>HashTable</code>的区别吗？</p>
<p>答：<code>HashMap</code>和<code>HashTable</code>有如下区别：</p>
<p>1）容器整体结构：</p>
<ul>
<li><code>HashMap</code>的<code>key</code>和<code>value</code>都允许为<code>null</code>，<code>HashMap</code>遇到<code>key</code>为<code>null</code>的时候，调用<code>putForNullKey</code>方法进行处理，而对<code>value</code>没有处理。</li>
<li><code>Hashtable</code>的<code>key</code>和<code>value</code>都不允许为<code>null</code>。<code>Hashtable</code>遇到<code>null</code>，直接返回<code>NullPointerException</code>。</li>
</ul>
<p>2） 容量设定与扩容机制：</p>
<ul>
<li><code>HashMap</code>默认初始化容量为 16，并且容器容量一定是2的n次方，扩容时，是以原容量 2倍 的方式 进行扩容。</li>
<li><code>Hashtable</code>默认初始化容量为 11，扩容时，是以原容量 2倍 再加 1的方式进行扩容。即<code>int newCapacity = (oldCapacity &lt;&lt; 1) + 1;</code>。</li>
</ul>
<p>3） 散列分布方式（计算存储位置）：</p>
<ul>
<li><code>HashMap</code>是先将<code>key</code>键的<code>hashCode</code>经过扰动函数扰动后得到<code>hash</code>值，然后再利用 <code>hash &amp; (length - 1)</code>的方式代替取模，得到元素的存储位置。</li>
<li><code>Hashtable</code>则是除留余数法进行计算存储位置的（因为其默认容量也不是2的n次方。所以也无法用位运算替代模运算），<code>int index = (hash &amp; 0x7FFFFFFF) % tab.length;</code>。</li>
<li>由于<code>HashMap</code>的容器容量一定是2的n次方，所以能使用<code>hash &amp; (length - 1)</code>的方式代替取模的方式计算元素的位置提高运算效率，但<code>Hashtable</code>的容器容量不一定是2的n次方，所以不能使用此运算方式代替。</li>
</ul>
<p>4）线程安全（最重要）：</p>
<ul>
<li><code>HashMap</code> 不是线程安全，如果想线程安全，可以通过调用<code>synchronizedMap(Map&lt;K,V&gt; m)</code>使其线程安全。但是使用时的运行效率会下降，所以建议使用<code>ConcurrentHashMap</code>容器以此达到线程安全。</li>
<li><code>Hashtable</code>则是线程安全的，每个操作方法前都有<code>synchronized</code>修饰使其同步，但运行效率也不高，所以还是建议使用<code>ConcurrentHashMap</code>容器以此达到线程安全。</li>
</ul>
<p>因此，<code>Hashtable</code>是一个遗留容器，如果我们不需要线程同步，则建议使用<code>HashMap</code>，如果需要线程同步，则建议使用<code>ConcurrentHashMap</code>。</p>
<p>此处不再对Hashtable的源码进行逐一分析了，如果想深入了解的同学，可以参考此文章<br><a href="https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Fchdjj%2Farticle%2Fdetails%2F38581035" target="_blank" rel="external">Hashtable源码剖析</a></p>
<h2 id="HashMap-在多线程下如何处理，啥时会发生线程不安全"><a href="#HashMap-在多线程下如何处理，啥时会发生线程不安全" class="headerlink" title="HashMap 在多线程下如何处理，啥时会发生线程不安全"></a>HashMap 在多线程下如何处理，啥时会发生线程不安全</h2><p>问：您说<code>HashMap</code>不是线程安全的，那如果多线程下，它是如何处理的？并且什么情况下会发生线程不安全的情况？</p>
<p>答：</p>
<ul>
<li><code>HashMap</code>不是线程安全的，如果多个线程同时对同一个<code>HashMap</code>更改数据的话，会导致数据不一致或者数据污染。如果出现线程不安全的操作时，<code>HashMap</code>会尽可能的抛出<code>ConcurrentModificationException</code>防止数据异常，当我们在对一个<code>HashMap</code>进行遍历时，在遍历期间，我们是不能对<code>HashMap</code>进行添加，删除等更改数据的操作的，否则也会抛出<code>ConcurrentModificationException</code>异常，此为fail-fast（快速失败）机制。从源码上分析，我们在<code>put,remove</code>等更改<code>HashMap</code>数据时，都会导致modCount的改变，当<code>expectedModCount != modCount</code>时，则抛出<code>ConcurrentModificationException</code>。如果想要线程安全，可以考虑使用<code>ConcurrentHashMap</code>。</li>
<li>而且，在多线程下操作<code>HashMap</code>，由于存在扩容机制，当<code>HashMap</code>调用<code>resize()</code>进行自动扩容时，可能会导致死循环的发生。</li>
</ul>
<p>由于时间关系，我暂不带着大家一起去分析<code>resize()</code>方法导致死循环发生的现象造成原因了，迟点有空我会再补充上去，请见谅，大家可以参考如下文章：</p>
<p><a href="https://link.juejin.im/?target=https%3A%2F%2Ftech.meituan.com%2Fjava-hashmap.html" target="_blank" rel="external">Java 8系列之重新认识HashMap</a></p>
<p><a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.importnew.com%2F22011.html" target="_blank" rel="external">谈谈HashMap线程不安全的体现</a></p>
<h2 id="使用-HashMap-，选取什么对象作为-key-键比较好"><a href="#使用-HashMap-，选取什么对象作为-key-键比较好" class="headerlink" title="使用 HashMap ，选取什么对象作为 key 键比较好"></a>使用 HashMap ，选取什么对象作为 key 键比较好</h2><p>问：我们在使用<code>HashMap</code>时，选取什么对象作为<code>key</code>键比较好，为什么？</p>
<p>答：</p>
<ul>
<li>可变对象：指创建后自身状态能改变的对象。换句话说，可变对象是该对象在创建后它的哈希值可能被改变。</li>
<li>我们在使用<code>HashMap</code>时，最好选择不可变对象作为<code>key</code>。例如<code>String</code>，<code>Integer</code>等不可变类型作为<code>key</code>是非常明智的。</li>
<li>如果<code>key</code>对象是可变的，那么<code>key</code>的哈希值就可能改变。在<code>HashMap</code>中可变对象作为Key会造成数据丢失。因为我们再进行<code>hash &amp; (length - 1)</code>取模运算计算位置查找对应元素时，位置可能已经发生改变，导致数据丢失。</li>
</ul>
<p>详细例子说明请参考：<a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.importnew.com%2F13384.html" target="_blank" rel="external">危险！在HashMap中将可变对象用作Key</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><code>HashMap</code>是基于<code>Map</code>接口实现的一种键-值对<code>&lt;key,value&gt;</code>的存储结构，允许<code>null</code>值，同时非有序，非同步(即线程不安全)。<code>HashMap</code>的底层实现是数组 + 链表 + 红黑树（JDK1.8增加了红黑树部分）。</li>
<li><code>HashMap</code>定位元素位置是通过键<code>key</code>经过扰动函数扰动后得到<code>hash</code>值，然后再通过<code>hash &amp; (length - 1)</code>代替取模的方式进行元素定位的。</li>
<li><code>HashMap</code>是使用链地址法解决<code>hash</code>冲突的，当有冲突元素放进来时，会将此元素插入至此位置链表的最后一位，形成单链表。当存在位置的链表长度 大于等于 8 时，<code>HashMap</code>会将链表 转变为 红黑树，以此提高查找效率。</li>
<li><code>HashMap</code>的容量是2的n次方，有利于提高计算元素存放位置时的效率，也降低了<code>hash</code>冲突的几率。因此，我们使用<code>HashMap</code>存储大量数据的时候，最好先预先指定容器的大小为2的n次方，即使我们不指定为2的n次方，<code>HashMap</code>也会把容器的大小设置成最接近设置数的2的n次方，如，设置<code>HashMap</code>的大小为 7 ，则<code>HashMap</code>会将容器大小设置成最接近7的一个2的n次方数，此值为 8 。</li>
<li><code>HashMap</code>的负载因子表示哈希表空间的使用程度（或者说是哈希表空间的利用率）。当负载因子越大，则<code>HashMap</code>的装载程度就越高。也就是能容纳更多的元素，元素多了，发生<code>hash</code>碰撞的几率就会加大，从而链表就会拉长，此时的查询效率就会降低。当负载因子越小，则链表中的数据量就越稀疏，此时会对空间造成浪费，但是此时查询效率高。</li>
<li><code>HashMap</code>不是线程安全的，<code>Hashtable</code>则是线程安全的。但<code>Hashtable</code>是一个遗留容器，如果我们不需要线程同步，则建议使用<code>HashMap</code>，如果需要线程同步，则建议使用<code>ConcurrentHashMap</code>。</li>
<li>在多线程下操作<code>HashMap</code>，由于存在扩容机制，当<code>HashMap</code>调用<code>resize()</code>进行自动扩容时，可能会导致死循环的发生。</li>
<li>我们在使用<code>HashMap</code>时，最好选择不可变对象作为<code>key</code>。例如<code>String</code>，<code>Integer</code>等不可变类型作为<code>key</code>是非常明智的。</li>
</ol>
<ul>
<li>由于最近工作较忙，也有拖延症发作的问题，所以文章迟迟未能完成发布，现时完成的文章其实对我而言，也不算太好，但还是打算先发出来让大家看看，一起学习学习，看有什么不好的地方，我再慢慢改进，如果此文对你有帮助，请给个赞，谢谢大家。</li>
</ul>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://link.juejin.im/?target=https%3A%2F%2Ftech.meituan.com%2Fjava-hashmap.html" target="_blank" rel="external">Java 8系列之重新认识HashMap</a><br><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F20733617" target="_blank" rel="external">JDK 源码中 HashMap 的 hash 方法原理是什么？</a><br><a href="https://link.juejin.im/?target=http%3A%2F%2Fannegu.iteye.com%2Fblog%2F539465" target="_blank" rel="external">深入理解HashMap</a><br><a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.cnblogs.com%2Fyesiamhere%2Fp%2F6653135.html" target="_blank" rel="external">HashMap负载因子</a><br><a href="https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Fchdjj%2Farticle%2Fdetails%2F38581035" target="_blank" rel="external">Hashtable源码剖析</a><br><a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.importnew.com%2F13384.html" target="_blank" rel="external">危险！在HashMap中将可变对象用作Key</a><br><a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.importnew.com%2F22011.html" target="_blank" rel="external">谈谈HashMap线程不安全的体现</a></p>
]]></content>
      
        <categories>
            
            <category> HashMap </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础数据类型 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ArrayList 源码分析]]></title>
      <url>/2017/12/09/ArrayList%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="ArrayList-源码分析"><a href="#ArrayList-源码分析" class="headerlink" title="ArrayList 源码分析"></a>ArrayList 源码分析</h1><p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171208/C88BKj3C76.png" alt="mark"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>以面试问答的形式学习我们的最常用的装载容器——<code>ArrayList</code>（源码分析基于JDK8）</p>
<h1 id="问答内容"><a href="#问答内容" class="headerlink" title="问答内容"></a>问答内容</h1><h2 id="ArrayList是什么，可以用来干嘛？"><a href="#ArrayList是什么，可以用来干嘛？" class="headerlink" title="ArrayList是什么，可以用来干嘛？"></a>ArrayList是什么，可以用来干嘛？</h2><p>问：ArrayList有用过吗？它是一个什么东西？可以用来干嘛？</p>
<p>答：有用过，ArrayList就是数组列表，主要用来装载数据，当我们装载的是基本类型的数据<code>int,long,boolean,short,byte...</code>的时候我们只能存储他们对应的包装类，它的主要底层实现是数组<code>Object[] elementData</code>。与它类似的是LinkedList，和LinkedList相比，它的查找和访问元素的速度较快，但新增，删除的速度较慢。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个ArrayList，如果没有指定初始大小，默认容器大小为10</span></div><div class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line"><span class="comment">// 往容器里面添加元素</span></div><div class="line">arrayList.add(<span class="string">"张三"</span>);</div><div class="line">arrayList.add(<span class="string">"李四"</span>);</div><div class="line">arrayList.add(<span class="string">"王五"</span>);</div><div class="line"><span class="comment">// 获取index下标为0的元素      张三</span></div><div class="line">String element = arrayList.get(<span class="number">0</span>);</div><div class="line"><span class="comment">// 删除index下标为1的元素      李四</span></div><div class="line">String removeElement = arrayList.remove(<span class="number">1</span>);</div></pre></td></tr></table></figure>
<p>ArrayList底层实现示意图</p>
<h2 id="ArrayList中不断添加数据会有什么问题吗？"><a href="#ArrayList中不断添加数据会有什么问题吗？" class="headerlink" title="ArrayList中不断添加数据会有什么问题吗？"></a>ArrayList中不断添加数据会有什么问题吗？</h2><p>问：您说它的底层实现是数组，但是数组的大小是定长的，如果我们不断的往里面添加数据的话，不会有问题吗？</p>
<p>答：ArrayList可以通过构造方法在初始化的时候指定底层数组的大小。</p>
<ul>
<li>通过无参构造方法的方式<code>ArrayList()</code>初始化，则赋值底层数组<code>Object[] elementData</code>为一个默认空数组<code>Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}</code>所以数组容量为0，只有真正对数据进行添加<code>add</code>时，才分配默认<code>DEFAULT_CAPACITY = 10</code>的初始容量。<br>示例代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义ArrayList默认容量为10</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="comment">// 空数组，当调用无参构造方法时默认复制这个空数组</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 真正保存数据的底层数组</span></div><div class="line"><span class="keyword">transient</span> Object[] elementData; </div><div class="line"></div><div class="line"><span class="comment">// ArrayList的实际元素数量</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 无参构造方法默认为空数组</span></div><div class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>通过指定容量初始大小的构造方法方式<code>ArrayList(int initialCapacity)</code>初始化，则赋值底层数组<code>Object[] elementData</code>为指定大小的数组<code>this.elementData = new Object[initialCapacity];</code><br>示例代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 通过构造方法出入指定的容量来设置默认底层数组大小 </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</div><div class="line">                                           initialCapacity);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>当我们添加的元素数量已经达到底层数组<code>Object[] elementData</code>的上限时，我们再往ArrayList元素，则会触发ArrayList的自动扩容机制，ArrayList会通过位运算<code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code>以1.5倍的方式初始化一个新的数组（如初始化数组大小为10，则扩容后的数组大小为15），然后使用<code>Arrays.copyOf(elementData, newCapacity);</code>方法将原数据的数据逐一复制到新数组上面去，以此达到ArrayList扩容的效果。虽然，<code>Arrays.copyOf(elementData, newCapacity);</code>方法最终调用的是<code>native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>是一个底层方法，效率还算可以，但如果我们在知道ArrayList想装多少个元素的情况下，却没有指定容器大小，则就会导致ArrayList频繁触发扩容机制，频繁进行底层数组之间的数据复制，大大降低使用效率。<br>示例代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="comment">//确保底层数组容量，如果容量不足，则扩容</span></div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>); </div><div class="line">    elementData[size++] = e;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line"></div><div class="line">    <span class="comment">// 容量不足，则调用grow方法进行扩容</span></div><div class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">        grow(minCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 扩容方法(重点)</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// 获得原容量大小</span></div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">    <span class="comment">// 新容量为原容量的1.5倍</span></div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</div><div class="line">    <span class="comment">// 再判断新容量是否已足够，如果扩容后仍然不足够，则复制为最小容量长度</span></div><div class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">        newCapacity = minCapacity;</div><div class="line">    <span class="comment">// 判断是否超过最大长度限制</span></div><div class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">        newCapacity = hugeCapacity(minCapacity);</div><div class="line">    <span class="comment">// 将原数组的数据复制至新数组， ArrayList的底层数组引用指向新数组</span></div><div class="line">    <span class="comment">// 如果数据量很大，重复扩容，则会影响效率</span></div><div class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>因此，在我们使用ArrayList的时候，如果知道最终的存储容量capacity，则应该在初始化的时候就指定ArrayList的容量<code>ArrayList(int initialCapacity)</code>，如果初始化时无法预知装载容量，但在使用过程中，得知最终容量，我们可以通过调用<code>ensureCapacity(int minCapacity)</code>方法来指定ArrayList的容量，并且，如果我们在使用途中，如果确定容量大小，但是由于之前每次扩容都扩充50%，所以会造成一定的存储空间浪费，我们可以调用<code>trimToSize()</code>方法将容器最小化到存储元素容量，进而消除这些存储空间浪费。例如：我们当前存储了11个元素，我们不会再添加但是当前的ArrayList的大小为15，有4个存储空间没有被使用，则调用<code>trimToSize()</code>方法后，则会重新创建一个容量为11的数组<code>Object[] elementData</code>，将原有的11个元素复制至新数组，达到节省内存空间的效果。<br>示例代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 将底层数组一次性指定到指定容量的大小</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</div><div class="line">        <span class="comment">// any size if not default element table </span></div><div class="line">         ? <span class="number">0</span></div><div class="line">        <span class="comment">// larger than default for default empty table. It's already</span></div><div class="line">        <span class="comment">// supposed to be at default size.</span></div><div class="line">        : DEFAULT_CAPACITY;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</div><div class="line">        ensureExplicitCapacity(minCapacity);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 将容器最小化到存储元素容量</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</div><div class="line">        elementData = (size == <span class="number">0</span>)</div><div class="line">          ? EMPTY_ELEMENTDATA</div><div class="line">          : Arrays.copyOf(elementData, size);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ArrayList怎么-删除数据，为什么访问速度快，删除新增速度慢-？"><a href="#ArrayList怎么-删除数据，为什么访问速度快，删除新增速度慢-？" class="headerlink" title="ArrayList怎么 删除数据，为什么访问速度快，删除新增速度慢 ？"></a>ArrayList怎么 删除数据，为什么访问速度快，删除新增速度慢 ？</h2><p>问：那它是怎么样删除元素的？您上面说到ArrayList访问元素速度较快，但是新增和删除的速度较慢，为什么呢？</p>
<p>答：</p>
<ul>
<li>通过源码我们可以得知，ArrayList删除元素时，先获取对应的删除元素，然后把要删除元素对应索引index后的元素逐一往前移动1位，最后将最后一个存储元素清空并返回删除元素，以此达到删除元素的效果。</li>
<li>当我们通过下标的方式去访问元素时，我们假设访问一个元素所花费的时间为K，则通过下标一步到位的方式访问元素，时间则为1K，用“大O”表示法表示，则时间复杂度为O(1)。所以ArrayList的访问数据的数据是比较快的。</li>
<li>当我们去添加元素<code>add(E e)</code>时，我们是把元素添加至末尾，不需要移动元素，此时的时间复杂度为O(1)，但我们把元素添加到指定位置，最坏情况下，我们将元素添加至第一个位置<code>add(int index, E element)</code>，则整个ArrayList的n-1个元素都要往前移动位置，导致底层数组发生n-1次复制。通常情况下，我们说的时间复杂度都是按最坏情况度量的，此时的时间复杂度为O(n)。删除元素同理，删除最后一个元素不需要移动元素，时间复杂度为O(1)，但删除第一个元素，则需要移动n-1个元素，最坏情况下的时间复杂度也是O(n)。</li>
<li>所以ArrayList访问元素速度较快，但是新增和删除的速度较慢。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 将元素添加至末尾</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="comment">// 确保底层数组容量，如果容量不足，则扩容</span></div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">    elementData[size++] = e;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 将元素添加至指定下标位置</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">     <span class="comment">// 检查下标是否在合法范围内</span></div><div class="line">    rangeCheckForAdd(index);</div><div class="line">    <span class="comment">// 确保底层数组容量，如果容量不足，则扩容</span></div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">    <span class="comment">// 将要添加的元素下标后的元素通过复制的方式逐一往后移动，腾出对应index下标的存储位置</span></div><div class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</div><div class="line">                     size - index);</div><div class="line">    <span class="comment">// 将新增元素存储至指定下标索引index</span></div><div class="line">    elementData[index] = element;</div><div class="line">    <span class="comment">// ArrayList的大小 + 1</span></div><div class="line">    size++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 通过下标索引的方式删除元素</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="comment">// 检查下标是否在合法范围内</span></div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    modCount++;</div><div class="line">    <span class="comment">// 直接通过下标去访问底层数组的元素</span></div><div class="line">    E oldValue = elementData(index);</div><div class="line"></div><div class="line">    <span class="comment">// 计算数组需要移动的元素个数</span></div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        <span class="comment">// 将要删除的元素下标后的元素通过复制的方式逐一往前移动</span></div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</div><div class="line">    <span class="comment">//将底层数组长度减1，并清空最后一个存储元素。</span></div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></div><div class="line">    <span class="comment">// 返回移除元素</span></div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ArrayList是线程安全的吗？"><a href="#ArrayList是线程安全的吗？" class="headerlink" title="ArrayList是线程安全的吗？"></a>ArrayList是线程安全的吗？</h2><p>问：ArrayList是线程安全的吗？</p>
<p>答：ArrayList不是线程安全的，如果多个线程同时对同一个ArrayList更改数据的话，会导致数据不一致或者数据污染。如果出现线程不安全的操作时，ArrayList会尽可能的抛出<code>ConcurrentModificationException</code>防止数据异常，当我们在对一个ArrayList进行遍历时，在遍历期间，我们是不能对ArrayList进行添加，修改，删除等更改数据的操作的，否则也会抛出<code>ConcurrentModificationException</code>异常，此为fail-fast（快速失败）机制。从源码上分析，我们在<code>add,remove,clear</code>等更改ArrayList数据时，都会导致modCount的改变，当<code>expectedModCount != modCount</code>时，则抛出<code>ConcurrentModificationException</code>。如果想要线程安全，可以考虑使用Vector、CopyOnWriteArrayList。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * AbstractList.Itr 的迭代器实现</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></div><div class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></div><div class="line">    <span class="comment">//期望的modCount</span></div><div class="line">    <span class="keyword">int</span> expectedModCount = modCount;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> cursor != size;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        checkForComodification();</div><div class="line">        <span class="keyword">int</span> i = cursor;</div><div class="line">        <span class="keyword">if</span> (i &gt;= size)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">        Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</div><div class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        cursor = i + <span class="number">1</span>;</div><div class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">        checkForComodification();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ArrayList.<span class="keyword">this</span>.remove(lastRet);</div><div class="line">            cursor = lastRet;</div><div class="line">            lastRet = -<span class="number">1</span>;</div><div class="line">            expectedModCount = modCount;</div><div class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span> </span>&#123;</div><div class="line">        Objects.requireNonNull(consumer);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = ArrayList.<span class="keyword">this</span>.size;</div><div class="line">        <span class="keyword">int</span> i = cursor;</div><div class="line">        <span class="keyword">if</span> (i &gt;= size) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">final</span> Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</div><div class="line">        <span class="keyword">if</span> (i &gt;= elementData.length) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</div><div class="line">            consumer.accept((E) elementData[i++]);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// update once at end of iteration to reduce heap write traffic</span></div><div class="line">        cursor = i;</div><div class="line">        lastRet = i - <span class="number">1</span>;</div><div class="line">        checkForComodification();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>如果在初始化的时候知道ArrayList的初始容量，请一开始就指定容量<code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(20);</code>,如果一开始不知道容量，中途才得知，请调用<code>list.ensureCapacity(20);</code>来扩充容量，如果数据已经添加完毕，但仍需要保存在内存中一段时间，请调用<code>list.trimToSize()</code>将容器最小化到存储元素容量，进而消除这些存储空间浪费。</li>
<li>ArrayList是以1.5倍的容量去扩容的，如初始容量是10，则容量依次递增扩充为：15，22，33，49。扩容后把原始数据从旧数组复制至新数组中。</li>
<li>ArrayList访问元素速度较快，下标方式访问元素，时间复杂度为O(1)，添加与删除速度较慢，时间复杂度均为O(n)。</li>
<li>ArrayList不是线程安全的，但是在发生并发行为时，它会尽可能的抛出<code>ConcurrentModificationException</code>，此为fail-fast机制。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> ArrayList </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础数据类型 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Maven仓库理解和优先级]]></title>
      <url>/2017/09/03/Maven-Priority/</url>
      <content type="html"><![CDATA[<p><img src="/images/maven-logo.png" alt="此处输入图片的描述"></p>
<p><strong>5 Seven 2017</strong></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用 maven 也有一段时间了，有时候在配置 repository,mirror,profile的时候，总会导致 jar 拉取不到。所以认真的分析了 maven 获取 jar 包时候的优先级。<br><a id="more"></a></p>
<h2 id="Maven-仓库的分类"><a href="#Maven-仓库的分类" class="headerlink" title="Maven 仓库的分类"></a>Maven 仓库的分类</h2><p>仓库分类：本地仓库和远程仓库。Maven根据坐标寻找构件的时候，它先会查看本地仓库，如果本地仓库存在构件，则直接使用；如果没有，则从远程仓库查找，找到后，下载到本地。</p>
<p>1）本地仓库<br>默认情况下，每个用户在自己的用户目录下都有一个路径名为.m2/repository/的仓库目录。我们也可以在 settings.xml 文件配置本地仓库的地址</p>
<p>2）远程仓库<br>本地仓库好比书房，而远程仓库就像是书店。对于Maven来说，每个用户只有一个本地仓库，但是可以配置多个远程仓库。<br>下·</p>
<blockquote>
<p>我们可以在 pom 文件配置多个 repository，但是随着项目越来也多我们每次都要在 pom 文件配置比较麻烦，所以我们可以在<br>settings 文件配置 profile （私服）。这样我们每次创建新项目的时候就可以不用配置 repository。</p>
</blockquote>
<p>3）中央仓库<br>Maven必须要知道至少一个可用的远程仓库，中央仓库就是这样一个默认的远程仓库，Maven 默认有一个 super pom 文件。<br>maven super pom 文件位置<br>D:\apache-maven-3.0.4\lib 下的 maven-model-builder-3.0.4.jar 中的 org/apache/maven/model/pom-4.0.0.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">··· 省略其他</div><div class="line">  <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Central Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.maven.apache.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></div><div class="line">···</div></pre></td></tr></table></figure></p>
<p>这个时候我们就明白了，我们在 settings 文件配置一个 mirror 的 mirrorOf 为 central 的镜像就会替代 ‘中央仓库’ 的原因了。</p>
<h3 id="Maven-镜像"><a href="#Maven-镜像" class="headerlink" title="Maven 镜像"></a>Maven 镜像</h3><p>镜像（Mirroring）是冗余的一种类型，一个磁盘上的数据在另一个磁盘上存在一个完全相同的副本即为镜像。<br>为什么配置镜像?</p>
<blockquote>
<p>1.一句话，你有的我也有，你没有的我也有。（拥有远程仓库的所有 jar，包括远程仓库没有的 jar）<br>2.还是一句话，我跑的比你快。（有时候远程仓库获取 jar 的速度可能比镜像慢，这也是为什么我们一般要配置中央仓库的原因，外国的 maven 仓库一般获取速度比较慢）</p>
</blockquote>
<p>如果你配置 maven 镜像不是为了以上两点，那基本就不用配置镜像了。<br><strong>注意:当远程仓库被镜像匹配到的，则在获取 jar 包将从镜像仓库获取，而不是我们配置的 repository 仓库, repository 将失去作用</strong></p>
<h4 id="mirrorOf-标签"><a href="#mirrorOf-标签" class="headerlink" title="mirrorOf 标签"></a>mirrorOf 标签</h4><p>mirrorOf 标签里面放置的是 repository 配置的 id,为了满足一些复杂的需求，Maven还支持更高级的镜像配置：</p>
<pre><code>external:* = 不在本地仓库的文件才从该镜像获取
repo,repo1 = 远程仓库 repo 和 repo1 从该镜像获取
*,!repo1 =  所有远程仓库都从该镜像获取，除 repo1 远程仓库以外
* = 所用远程仓库都从该镜像获取
</code></pre><h3 id="私服"><a href="#私服" class="headerlink" title="私服"></a>私服</h3><p>私服是一种特殊的远程Maven仓库，它是架设在局域网内的仓库服务，私服一般被配置为互联网远程仓库的镜像，供局域网内的Maven用户使用。<br>当Maven需要下载构件的时候，先向私服请求，如果私服上不存在该构件，则从外部的远程仓库下载，同时缓存在私服之上，然后为Maven下载请求提供下载服务，另外，对于自定义或第三方的jar可以从本地上传到私服，供局域网内其他maven用户使用。<br>优点主要有：</p>
<pre><code>1. 节省外网宽带
2. 加速Maven构建
3. 部署第三方构件：可以将公司项目的 jar 发布到私服上，方便项目与项目之间的调用
4. 提高稳定性、增强控制：原因是外网不稳定
5. 降低中央仓库的负荷：原因是中央仓库访问量太大
</code></pre><p><strong>上面大概介绍了 Maven 仓库概念，接下来我们进入正题</strong></p>
<h2 id="Maven-仓库优先级"><a href="#Maven-仓库优先级" class="headerlink" title="Maven 仓库优先级"></a>Maven 仓库优先级</h2><p>为了方便测试，我准备了以下几个仓库</p>
<ul>
<li>172.16.xxx.xxx  远程仓库 （私服）</li>
<li>dev.xxx.wiki 远程仓库  （远程）</li>
<li>localhost 仓库 是我自己在本机搭建的一个仓库 （镜像）</li>
<li>maven.aliyun.com 中央仓库（中央）</li>
</ul>
<h3 id="本地仓库优先级"><a href="#本地仓库优先级" class="headerlink" title="本地仓库优先级"></a>本地仓库优先级</h3><p><img src="/images/example.png" alt="此处输入图片的描述"><br>Maven 本地仓库拥有该包，而远程、镜像、中央、私服都不包含该包。我们来看下 Maven 是怎么获取的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">.......</div><div class="line"></div><div class="line"><span class="comment">// 使用本地仓库，优先级(priority)为 10</span></div><div class="line">[DEBUG] Using local repository at E:\OperSource</div><div class="line">[DEBUG] Using manager EnhancedLocalRepositoryManager with priority <span class="number">10.0</span> <span class="keyword">for</span> E:\OperSource</div><div class="line">[INFO] Scanning <span class="keyword">for</span> projects..</div><div class="line"></div><div class="line">........</div><div class="line"></div><div class="line">[INFO] Installing C:\Users\swipal\Desktop\abc\demo\target\demo-<span class="number">1.0</span>-SNAPSHOT.jar to E:\OperSource\com\cjf\demo\<span class="number">1.0</span>-SNAPSHOT\demo-<span class="number">1.0</span>-SNAPSHOT.jar</div><div class="line">[DEBUG] Writing tracking file E:\OperSource\com\cjf\demo\<span class="number">1.0</span>-SNAPSHOT\_remote.repositories</div><div class="line">[INFO] Installing C:\Users\swipal\Desktop\abc\demo\pom.xml to E:\OperSource\com\cjf\demo\<span class="number">1.0</span>-SNAPSHOT\demo-<span class="number">1.0</span>-SNAPSHOT.pom</div><div class="line">[DEBUG] Writing tracking file E:\OperSource\com\cjf\demo\<span class="number">1.0</span>-SNAPSHOT\_remote.repositories</div><div class="line">[DEBUG] Installing com.cjf:demo:<span class="number">1.0</span>-SNAPSHOT/maven-metadata.xml to E:\OperSource\com\cjf\demo\<span class="number">1.0</span>-SNAPSHOT\maven-metadata-local.xml</div><div class="line">[DEBUG] Installing com.cjf:demo/maven-metadata.xml to E:\OperSource\com\cjf\demo\maven-metadata-local.xml</div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line">[INFO] BUILD SUCCESS</div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line">[INFO] Total time: <span class="number">1.874</span> s</div><div class="line">[INFO] Finished at: <span class="number">2017</span>-<span class="number">07</span>-<span class="number">07</span>T10:<span class="number">37</span>:<span class="number">32</span>+<span class="number">08</span>:<span class="number">00</span></div><div class="line">[INFO] Final Memory: <span class="number">23</span>M/<span class="number">219</span>M</div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line"></div><div class="line">Process finished with exit code <span class="number">0</span></div></pre></td></tr></table></figure></p>
<p>从上面可以看出 Maven 一开始就使用本地仓库，并将本地仓库的优先级定制为 10 , 最后 jar 包也在本地仓库找到，Maven 成功打包。</p>
<h3 id="远程仓库优先级"><a href="#远程仓库优先级" class="headerlink" title="远程仓库优先级"></a>远程仓库优先级</h3><p>前面我们知道了，本地仓库的优先级是最高的，现在我们继续研究远程仓库的优先级（以下的所有例子，都默认本地仓库不拥有我们需要的包）</p>
<p>这一次我们默认配置 <strong>profile</strong>（私服）为 172.16.xxx.xxx 远程仓库, <strong>repository</strong> 为 dev.xxx.wiki 远程仓库,<strong>mirror</strong> 为本地 localhost 仓库，还配置了一个 <strong>mirrorOf  为 central</strong> 远程仓库为 maven.aliyun.com 的中央仓库,</p>
<p>以下是配置信息<br>settings.xml 文件<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">······</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span> </div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">mirror</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>localhost<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Public Repositories<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>   <span class="comment">&lt;!--拦截 pom 文件配置的 repository--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </div><div class="line">  <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span>  </div><div class="line">  </div><div class="line">  <span class="tag">&lt;<span class="name">mirror</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>localhost2<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Public Repositories<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>foo2<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>   <span class="comment">&lt;!--配置一个拦截 foo2 的远程仓库的镜像--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/repository/maven-snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </div><div class="line">  <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span>  </div><div class="line">  </div><div class="line">  <span class="tag">&lt;<span class="name">mirror</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>  <span class="comment">&lt;!--覆盖 Maven 默认的配置的中央仓库--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </div><div class="line">  <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span> </div><div class="line"> </div><div class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!--配置私服--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span> </div><div class="line">  <span class="tag">&lt;<span class="name">profile</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span> </div><div class="line">      <span class="tag">&lt;<span class="name">repository</span>&gt;</span> </div><div class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>public<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Public Repositories<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://172.16.xxx.xxx:8081/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </div><div class="line">      <span class="tag">&lt;/<span class="name">repository</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span> </div><div class="line">      <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span> </div><div class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>public<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Public Repositories<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://172.16.xxx.xxx:8081/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </div><div class="line">      <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span> </div><div class="line">  <span class="tag">&lt;/<span class="name">profile</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></div><div class="line"></div><div class="line">······</div></pre></td></tr></table></figure></p>
<p>pom.xml 文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!--xxx-cif-api 存在 172.16.xxx.xxx 仓库--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xxx.cif<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxx-cif-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!--Chapter1 存在 localhost 仓库--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.cjf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Chapter1<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">&lt;!--配置远程仓库--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Public Repositories<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://dev.xxx.wiki:8081/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></div></pre></td></tr></table></figure>
<p>以下是 Maven 拉取包的日志<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line">······· 省略部分日志信息</div><div class="line"></div><div class="line">[DEBUG] Using local repository at E:\OperSource</div><div class="line">[DEBUG] Using manager EnhancedLocalRepositoryManager with priority <span class="number">10.0</span> <span class="keyword">for</span> E:\OperSource</div><div class="line">[INFO] Scanning <span class="keyword">for</span> projects...</div><div class="line"></div><div class="line"><span class="comment">// 从这里可以看出我们配置的镜像替代了我们在 pom 配置的远程仓库</span></div><div class="line">[DEBUG] <span class="function">Using mirror <span class="title">localhost</span> <span class="params">(http://localhost:<span class="number">8081</span>/repository/maven-<span class="keyword">public</span>/)</span> <span class="keyword">for</span> <span class="title">foo</span> <span class="params">(http://dev.xxx.wiki:<span class="number">8081</span>/nexus/content/groups/<span class="keyword">public</span>/)</span>.</span></div><div class="line">替代了默认的中央仓库</div><div class="line">[DEBUG] Using mirror <span class="title">alimaven</span> <span class="params">(http://maven.aliyun.com/nexus/content/groups/<span class="keyword">public</span>/)</span> <span class="keyword">for</span> <span class="title">central</span> <span class="params">(https://repo.maven.apache.org/maven2)</span>.</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 从这里可以看出 Maven 使用哪些 dependencies 和 plugins 的地址，我们可以看出优先级最高的是 172.16.xxx.xxx,然后就是 localhost 最后才是 maven.aliyun.com</span></div><div class="line"></div><div class="line"><span class="comment">// 注意：alimaven (http://maven.aliyun.com/nexus/content/groups/public/, default, releases) 从这里可以看出中央仓库只能获取 releases 包，所有的 snapshots 包都不从中央仓库获取。（可以看前面 central 的配置信息）</span></div><div class="line">[DEBUG] === PROJECT BUILD PLAN ================================================</div><div class="line">[DEBUG] Project:       com.cjf:demo:<span class="number">1.0</span>-SNAPSHOT</div><div class="line">[DEBUG] Dependencies (collect): []</div><div class="line">[DEBUG] Dependencies (resolve): [compile, runtime, test]</div><div class="line"></div><div class="line">[DEBUG] Repositories (dependencies): [<span class="keyword">public</span> (http:<span class="comment">//172.16.xxx.xxx:8081/nexus/content/groups/public/, default, releases+snapshots), localhost (http://localhost:8081/repository/maven-public/, default, releases+snapshots), alimaven (http://maven.aliyun.com/nexus/content/groups/public/, default, releases)]</span></div><div class="line"></div><div class="line">[DEBUG] Repositories (plugins)     : [<span class="keyword">public</span> (http:<span class="comment">//172.16.xxx.xxx:8081/nexus/content/groups/public, default, releases+snapshots), alimaven (http://maven.aliyun.com/nexus/content/groups/public/, default, releases)]</span></div><div class="line"></div><div class="line"></div><div class="line">[DEBUG] =======================================================================</div><div class="line"><span class="comment">// 寻找本地是否有 maven-metadata.xml 配置文件 ，从这里可以看出寻找不到（后面会详细讲该文件作用）</span></div><div class="line">[DEBUG] Could not find metadata com.xxx.cif:xxx-cif-api:<span class="number">0.0</span>.1-SNAPSHOT/maven-metadata.<span class="function">xml in <span class="title">local</span> <span class="params">(E:\OperSource)</span></span></div><div class="line"></div><div class="line"><span class="comment">// 由于寻找不到 Maven 只能从我们配置的远程仓库寻找，由于 Maven 也不知道那个仓库才有，所以同时寻找两个仓库</span></div><div class="line">[DEBUG] Using transporter WagonTransporter with priority -1.0 <span class="keyword">for</span> http:<span class="comment">//172.16.xxx.xxx:8081/nexus/content/groups/public/</span></div><div class="line">[DEBUG] Using transporter WagonTransporter with priority -1.0 <span class="keyword">for</span> http:<span class="comment">//localhost:8081/repository/maven-public/</span></div><div class="line">[DEBUG] Using connector BasicRepositoryConnector with priority 0.0 <span class="keyword">for</span> http:<span class="comment">//localhost:8081/repository/maven-public/</span></div><div class="line">[DEBUG] Using connector BasicRepositoryConnector with priority 0.0 <span class="keyword">for</span> http:<span class="comment">//172.16.xxx.xxx:8081/nexus/content/groups/public/</span></div><div class="line">Downloading: http:<span class="comment">//172.16.xxx.xxx:8081/nexus/content/groups/public/com/xxx/cif/xxx-cif-api/0.0.1-SNAPSHOT/maven-metadata.xml</span></div><div class="line">Downloading: http:<span class="comment">//localhost:8081/repository/maven-public/com/xxx/cif/xxx-cif-api/0.0.1-SNAPSHOT/maven-metadata.xml</span></div><div class="line">[DEBUG] Writing tracking file E:\OperSource\com\xxx\cif\xxx-cif-api\0.0.1-SNAPSHOT\resolver-status.properties</div><div class="line"></div><div class="line"><span class="comment">// 从这里可以看出在 172.16.xxx.xxx 找到  xxx-cif-api 的 maven-metadata.xml 文件并下载下来</span></div><div class="line">Downloaded: http:<span class="comment">//172.16.xxx.xxx:8081/nexus/content/groups/public/com/xxx/cif/xxx-cif-api/0.0.1-SNAPSHOT/maven-metadata.xml (781 B at 7.0 KB/sec)</span></div><div class="line"></div><div class="line"><span class="comment">// 追踪文件，resolver-status.properties 配置了 jar 包下载地址和时间</span></div><div class="line">[DEBUG] Writing tracking file E:\OperSource\com\xxx\cif\xxx-cif-api\0.0.1-SNAPSHOT\resolver-status.properties</div><div class="line">[DEBUG] Could not find metadata com.xxx.cif:xxx-cif-api:0.0.1-SNAPSHOT/maven-metadata.xml in <span class="title">localhost</span> <span class="params">(http://localhost:<span class="number">8081</span>/repository/maven-<span class="keyword">public</span>/)</span></div><div class="line"></div><div class="line"><span class="comment">// 在 localhost 远程仓库寻找不到 xxx-cif-api 的 maven-metadata.xml</span></div><div class="line">[DEBUG] Could not find metadata com.xxx.cif:xxx-cif-api:0.0.1-SNAPSHOT/maven-metadata.xml in <span class="title">local</span> <span class="params">(E:\OperSource)</span></div><div class="line"></div><div class="line"><span class="comment">// 跳过的远程请求 </span></div><div class="line">[DEBUG] Skipped remote request <span class="keyword">for</span> com.xxx.cif:xxx-cif-api:0.0.1-SNAPSHOT/maven-metadata.xml, already updated during <span class="keyword">this</span> session.</div><div class="line">[DEBUG] Skipped remote request <span class="keyword">for</span> com.xxx.cif:xxx-cif-api:0.0.1-SNAPSHOT/maven-metadata.xml, already updated during <span class="keyword">this</span> session.</div><div class="line"></div><div class="line"><span class="comment">// 默认以后获取 xxx-cif-api 的时候将不在从 localhost 寻找了，除非强制获取才会再次从 localhost 寻找这个包</span></div><div class="line">[DEBUG] Failure to find com.xxx.cif:xxx-cif-api:0.0.1-SNAPSHOT/maven-metadata.xml in http:<span class="comment">//localhost:8081/repository/maven-public/ was cached in the local repository, resolution will not be reattempted until the update interval of localhost has elapsed or updates are forced</span></div><div class="line"></div><div class="line"><span class="comment">// 将 172.16.xxx.xxx 优先级升为 0 ，并下载 xxx-cif-api 的 pom 文件</span></div><div class="line">[DEBUG] Using transporter WagonTransporter with priority -1.0 <span class="keyword">for</span> http:<span class="comment">//172.16.xxx.xxx:8081/nexus/content/groups/public/</span></div><div class="line">[DEBUG] Using connector BasicRepositoryConnector with priority 0.0 <span class="keyword">for</span> http:<span class="comment">//172.16.xxx.xxx:8081/nexus/content/groups/public/</span></div><div class="line">Downloading: http:<span class="comment">//172.16.xxx.xxx:8081/nexus/content/groups/public/com/xxx/cif/xxx-cif-api/0.0.1-SNAPSHOT/xxx-cif-api-0.0.1-20170515.040917-89.pom</span></div><div class="line">Downloaded: http:<span class="comment">//172.16.xxx.xxx:8081/nexus/content/groups/public/com/xxx/cif/xxx-cif-api/0.0.1-SNAPSHOT/xxx-cif-api-0.0.1-20170515.040917-89.pom (930 B at 82.6 KB/sec)</span></div><div class="line"></div><div class="line"><span class="comment">// _remote.repositories 记录的以后使用那个远程仓库获取 （ps:这个文件作用我要不是很清楚作用，以上观点是自己推测出来的。）</span></div><div class="line">[DEBUG] Writing tracking file E:\OperSource\com\xxx\cif\xxx-cif-api\0.0.1-SNAPSHOT\_remote.repositories</div><div class="line">[DEBUG] Writing tracking file E:\OperSource\com\xxx\cif\xxx-cif-api\0.0.1-SNAPSHOT\xxx-cif-api-0.0.1-20170515.040917-89.pom.lastUpdated</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 后面获取 Chapter1 包的流程跟 com.xxx.cif 是一样的，不过最后是在 localhost 寻找到而已，所以这分日志就不贴出来了。</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 最后在下载包的时候，都到对应的仓库下载</span></div><div class="line">[DEBUG] Using transporter WagonTransporter with priority -1.0 <span class="keyword">for</span> http:<span class="comment">//172.16.xxx.xxx:8081/nexus/content/groups/public/</span></div><div class="line">[DEBUG] Using connector BasicRepositoryConnector with priority 0.0 <span class="keyword">for</span> http:<span class="comment">//172.16.xxx.xxx:8081/nexus/content/groups/public/</span></div><div class="line">Downloading: http:<span class="comment">//172.16.xxx.xxx:8081/nexus/content/groups/public/com/xxx/cif/xxx-cif-api/0.0.1-SNAPSHOT/xxx-cif-api-0.0.1-20170515.040917-89.jar</span></div><div class="line">Downloading: http:<span class="comment">//172.16.xxx.xxx:8081/nexus/content/groups/public/com/xxx/util/xxx-util/0.0.1-SNAPSHOT/xxx-util-0.0.1-20170514.091041-31.jar</span></div><div class="line">Downloaded: http:<span class="comment">//172.16.xxx.xxx:8081/nexus/content/groups/public/com/xxx/util/xxx-util/0.0.1-SNAPSHOT/xxx-util-0.0.1-20170514.091041-31.jar (26 KB at 324.2 KB/sec)</span></div><div class="line">Downloaded: http:<span class="comment">//172.16.xxx.xxx:8081/nexus/content/groups/public/com/xxx/cif/xxx-cif-api/0.0.1-SNAPSHOT/xxx-cif-api-0.0.1-20170515.040917-89.jar (68 KB at 756.6 KB/sec)</span></div><div class="line">[DEBUG] Writing tracking file E:\OperSource\com\xxx\cif\xxx-cif-api\0.0.1-SNAPSHOT\_remote.repositories</div><div class="line">[DEBUG] Writing tracking file E:\OperSource\com\xxx\cif\xxx-cif-api\0.0.1-SNAPSHOT\xxx-cif-api-0.0.1-20170515.040917-89.jar.lastUpdated</div><div class="line">[DEBUG] Writing tracking file E:\OperSource\com\xxx\util\xxx-util\0.0.1-SNAPSHOT\_remote.repositories</div><div class="line">[DEBUG] Writing tracking file E:\OperSource\com\xxx\util\xxx-util\0.0.1-SNAPSHOT\xxx-util-0.0.1-20170514.091041-31.jar.lastUpdated</div><div class="line">[DEBUG] Using transporter WagonTransporter with priority -1.0 <span class="keyword">for</span> http:<span class="comment">//localhost:8081/repository/maven-public/</span></div><div class="line">[DEBUG] Using connector BasicRepositoryConnector with priority 0.0 <span class="keyword">for</span> http:<span class="comment">//localhost:8081/repository/maven-public/</span></div><div class="line">Downloading: http:<span class="comment">//localhost:8081/repository/maven-public/com/cjf/Chapter1/0.0.1-SNAPSHOT/Chapter1-0.0.1-20170708.092339-1.jar</span></div><div class="line">Downloaded: http:<span class="comment">//localhost:8081/repository/maven-public/com/cjf/Chapter1/0.0.1-SNAPSHOT/Chapter1-0.0.1-20170708.092339-1.jar (8 KB at 167.0 KB/sec)</span></div><div class="line">[DEBUG] Writing tracking file E:\OperSource\com\cjf\Chapter1\0.0.1-SNAPSHOT\_remote.repositories</div><div class="line">[DEBUG] Writing tracking file E:\OperSource\com\cjf\Chapter1\0.0.1-SNAPSHOT\Chapter1-0.0.1-20170708.092339-1.jar.lastUpdated</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">[INFO] Installing C:\Users\swipal\Desktop\abc\demo\target\demo-1.0-SNAPSHOT.jar to E:\OperSource\com\cjf\demo\1.0-SNAPSHOT\demo-1.0-SNAPSHOT.jar</div><div class="line">[DEBUG] Writing tracking file E:\OperSource\com\cjf\demo\1.0-SNAPSHOT\_remote.repositories</div><div class="line">[INFO] Installing C:\Users\swipal\Desktop\abc\demo\pom.xml to E:\OperSource\com\cjf\demo\1.0-SNAPSHOT\demo-1.0-SNAPSHOT.pom</div><div class="line">[DEBUG] Writing tracking file E:\OperSource\com\cjf\demo\1.0-SNAPSHOT\_remote.repositories</div><div class="line">[DEBUG] Installing com.cjf:demo:1.0-SNAPSHOT/maven-metadata.xml to E:\OperSource\com\cjf\demo\1.0-SNAPSHOT\maven-metadata-local.xml</div><div class="line">[DEBUG] Installing com.cjf:demo/maven-metadata.xml to E:\OperSource\com\cjf\demo\maven-metadata-local.xml</div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line">[INFO] BUILD SUCCESS</div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line">[INFO] Total time: 10.549 s</div><div class="line">[INFO] Finished at: 2017-07-09T18:13:20+08:00</div><div class="line">[INFO] Final Memory: 26M/219M</div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line"></div><div class="line">·······</div></pre></td></tr></table></figure></p>
<p>好了，看了这么多的配置文件信息和日志信息，我们也总结一下 Maven 远程仓库优先级了。</p>
<p>主要有以下几点：<br>1.从日志信息我们得出这几种maven仓库的优先级别为</p>
<blockquote>
<p>本地仓库 &gt; 私服 （profile）&gt; 远程仓库（repository）和 镜像 （mirror） &gt; 中央仓库 （central）</p>
</blockquote>
<p>2.镜像是一个特殊的配置，其实镜像等同与远程仓库，没有匹配远程仓库的镜像就毫无作用（如 foo2）。<br>3.总结上面所说的，Maven 仓库的优先级就是 <strong>私服和远程仓库</strong> 的对比，没有其它的仓库类型。为什么这么说是因为，镜像等同远程，而中央其实也是 maven super xml 配置的一个repository 的一个而且。所以 maven 仓库真正的优先级为 </p>
<blockquote>
<p>本地仓库 &gt; 私服（profile）&gt; 远程仓库（repository）</p>
</blockquote>
<h2 id="maven-metadata-xml-文件"><a href="#maven-metadata-xml-文件" class="headerlink" title="maven-metadata.xml 文件"></a>maven-metadata.xml 文件</h2><p>Maven Repository Metadata 可用于表示：</p>
<pre><code>1. 一个没有版本的工件：它提供有关该工件的可用版本的信息
2. 快照伪像：它提供有关快照的精确信息
3. 包含Maven插件工件的组：它提供了有关此组中可用插件的信息。
</code></pre><p>元数据文件名是：</p>
<pre><code>远程存储库中的 maven-metadata.xml，
maven-metadata- &lt;repo-id&gt;.xml在本地存储库中，用于具有repo-id标识符的存储库中的元标记。
</code></pre><p>以上是 Maven 官网对该文件的解释。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>问题：有时候我们更新最新包的时候，会发现最新的包被拉取下来的，但是项目使用的包还是旧的包。所以我们要分析下是什么原因导致的。</p>
<p>首先我们先大概的了解下 maven-metadata.xml  文件。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">metadata</span> <span class="attr">modelVersion</span>=<span class="string">"1.1.0"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.cjf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Chapter1<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">versioning</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">snapshot</span>&gt;</span>                               <span class="comment">&lt;!--当前版本下的最新快照信息--&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">timestamp</span>&gt;</span>20170710.071727<span class="tag">&lt;/<span class="name">timestamp</span>&gt;</span> <span class="comment">&lt;!--快照的时间戳--&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">buildNumber</span>&gt;</span>6<span class="tag">&lt;/<span class="name">buildNumber</span>&gt;</span>           <span class="comment">&lt;!--构件号--&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">snapshot</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">lastUpdated</span>&gt;</span>20170710071727<span class="tag">&lt;/<span class="name">lastUpdated</span>&gt;</span><span class="comment">&lt;!--metadata文件被更新的时间--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">snapshotVersions</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">snapshotVersion</span>&gt;</span>                      <span class="comment">&lt;!--当前版本下可用的子快照版本信息--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">extension</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">extension</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>0.0.1-20170710.071727-6<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="comment">&lt;!--子快照版本的信息--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">updated</span>&gt;</span>20170710071727<span class="tag">&lt;/<span class="name">updated</span>&gt;</span>     <span class="comment">&lt;!--这个子快照版本的更新时间--&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">snapshotVersion</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">snapshotVersion</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">extension</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">extension</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>0.0.1-20170710.071727-6<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">updated</span>&gt;</span>20170710071727<span class="tag">&lt;/<span class="name">updated</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">snapshotVersion</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">snapshotVersions</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">versioning</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">metadata</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>其中 lastUpdated 是最中要的一个属性，Maven 更新工程的 jar包时，会比较 lastUpdated 时间戳值，哪个值更大，就以哪个文件为准。</p>
<p>接下来我们看下 Maven 为我们生成了那些文件<br><img src="http://orbs83j4x.bkt.clouddn.com/20170710163449.png" alt="此处输入图片的描述"><br>我们可以看到 maven-metadata.xml 一共有三个</p>
<pre><code>1. maven-metadata-local.xml 本地的元数据, Maven install 的时候就会生成。
2. maven-metadata-snapshots.xml Maven deploy 时会生成
3. maven-metadata-localhost.xml 远程仓库获取的时候生成 (repository 的 id = localhost)
</code></pre><p>以上的文件其实都是 Maven 的过渡文件而已</p>
<ol>
<li>例如 maven-metadata-snapshots 就是 Maven deploy 先从远程仓库对应包的 maven-metadata.xml 下载下来，然后修改快照信息后在上传到远程仓库上。</li>
<li>例如 maven-metadata-localhost 的作用是在 Maven 在拉取包的时候，会先跟本地 maven-metadata-local 比较下 lastUpdated 时间戳值，值大用哪个。如果是 Mavne <strong>强制更新</strong> 的时候(没有强制更新是不会) 会下载远程的 maven-metadata.xml 比较<strong>远程，本地，和之前远程保存下来的 maven-metadata 文件</strong>。</li>
</ol>
<p>所以有时候 maven 库上的 jar 包已经更新，而我们总是拉取不到 maven 的包原因就是本地的 maven-metadata-local 的 lastUpdated 比较大。</p>
<p>我们验证下 Maven deploy 例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[INFO] --- maven-deploy-plugin:<span class="number">2.8</span>.2:deploy (<span class="keyword">default</span>-deploy) @ Chapter1 ---</div><div class="line"><span class="comment">// 先从远程下载快照 maven-metadata.xml</span></div><div class="line">Downloading: http:<span class="comment">//localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/0.0.1-SNAPSHOT/maven-metadata.xml</span></div><div class="line">Downloaded: http:<span class="comment">//localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/0.0.1-SNAPSHOT/maven-metadata.xml (768 B at 3.3 KB/sec)</span></div><div class="line"><span class="comment">// 将项目的 jar 和 pom 文件更新到远程仓库</span></div><div class="line">Uploading: http:<span class="comment">//localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/0.0.1-SNAPSHOT/Chapter1-0.0.1-20170710.121310-15.jar</span></div><div class="line">Uploaded: http:<span class="comment">//localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/0.0.1-SNAPSHOT/Chapter1-0.0.1-20170710.121310-15.jar (8 KB at 14.1 KB/sec)</span></div><div class="line">Uploading: http:<span class="comment">//localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/0.0.1-SNAPSHOT/Chapter1-0.0.1-20170710.121310-15.pom</span></div><div class="line">Uploaded: http:<span class="comment">//localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/0.0.1-SNAPSHOT/Chapter1-0.0.1-20170710.121310-15.pom (2 KB at 2.0 KB/sec)</span></div><div class="line">Downloading: http:<span class="comment">//localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/maven-metadata.xml</span></div><div class="line">Downloaded: http:<span class="comment">//localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/maven-metadata.xml (275 B at 1.6 KB/sec)</span></div><div class="line"><span class="comment">// 上传  maven-metadata.xml 到远程仓库</span></div><div class="line">Uploading: http:<span class="comment">//localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/0.0.1-SNAPSHOT/maven-metadata.xml</span></div><div class="line">Uploaded: http:<span class="comment">//localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/0.0.1-SNAPSHOT/maven-metadata.xml (768 B at 1.0 KB/sec)</span></div><div class="line">Uploading: http:<span class="comment">//localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/maven-metadata.xml</span></div><div class="line">Uploaded: http:<span class="comment">//localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/maven-metadata.xml (275 B at 0.4 KB/sec)</span></div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line">[INFO] BUILD SUCCESS</div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line">[INFO] Total time: <span class="number">5.231</span> s</div><div class="line">[INFO] Finished at: <span class="number">2017</span>-<span class="number">07</span>-<span class="number">10</span>T20:<span class="number">13</span>:<span class="number">13</span>+<span class="number">08</span>:<span class="number">00</span></div><div class="line">[INFO] Final Memory: <span class="number">19</span>M/<span class="number">226</span>M</div><div class="line">[INFO] ------------------------------------------------------------------------</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>原本以为两天就写好这篇文章，在自己理清思路的时候总是被自己绕晕了。比如在 Nexus 的 Central 配置的中央仓库获取，和 maven-metadata.xml 是如何比较的。</p>
<p>如果以上文章有误，等博客的评论系统搭建起来后欢迎大家指认出来。</p>
]]></content>
      
        <categories>
            
            <category> Maven </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LogBack 使用]]></title>
      <url>/2017/09/03/Logback/</url>
      <content type="html"><![CDATA[<p><img src="https://logback.qos.ch/images/logos/lblogo.jpg" alt="此处输入图片的描述"><br><strong>26 Seven 2017</strong></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前项目一直使用 logback ,现在大概写下了 logback 基础配置。</p>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>LogBack</code>是一个日志框架，它是Log4j作者Ceki的又一个日志组件。</p>
<p><code>LogBack,Slf4j,Log4j</code>之间的关系</p>
<p>slf4j是The Simple Logging Facade for Java的简称，是一个简单日志门面抽象框架，它本身只提供了日志Facade API和一个简单的日志类实现，一般常配合<code>Log4j</code>，<code>LogBack</code>，<code>java.util.logging</code>使用。Slf4j作为应用层的Log接入时，程序可以根据实际应用场景动态调整底层的日志实现框架(Log4j/LogBack/JdkLog…)；</p>
<p>LogBack和Log4j都是开源日记工具库，LogBack是Log4j的改良版本，比Log4j拥有更多的特性，同时也带来很大性能提升。</p>
<p>LogBack官方建议配合Slf4j使用，这样可以灵活地替换底层日志框架。</p>
<p>LogBack的结构<br>LogBack分为3个组件，logback-core, logback-classic 和 logback-access。<br>其中logback-core提供了LogBack的核心功能，是另外两个组件的基础。<br>logback-classic则实现了Slf4j的API，所以当想配合Slf4j使用时，则需要引入这个包。<br>logback-access是为了集成Servlet环境而准备的，可提供HTTP-access的日志接口。</p>
<p>Log的行为级别：<br>OFF、<br>FATAL、<br>ERROR、<br>WARN、<br>INFO、<br>DEBUG、<br>ALL<br>从下向上，当选择了其中一个级别，则该级别向下的行为是不会被打印出来。<br>举个例子，当选择了INFO级别，则INFO以下的行为则不会被打印出来。</p>
<h2 id="获取-Logger-对象"><a href="#获取-Logger-对象" class="headerlink" title="获取 Logger 对象"></a>获取 Logger 对象</h2><p><img src="/images/example.png" alt="此处输入图片的描述"></p>
<p>我们先从获取 logger 对象开始<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Logger logger = LoggerFactory.getLogger(xxx.class.getName());</div></pre></td></tr></table></figure></p>
<p>LoggerFactory 是 slf4j 的日志工厂，获取 logger 方法就来自这里。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">以下代码摘自：org.slf4j.<span class="function">LoggerFactory</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getLogger</span><span class="params">(String name)</span> &#123;</div><div class="line">    ILoggerFactory iLoggerFactory = getILoggerFactory();</div><div class="line">    <span class="keyword">return</span> iLoggerFactory.getLogger(name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法里面有分为两个过程。第一个过程是获取ILoggerFactory，就是真正的日志工厂。第二个过程就是从真正的日志工厂中获取logger。<br>接下来我们看下到底是怎么获取的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">以下代码摘自：org.slf4j.<span class="function">LoggerFactory</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> ILoggerFactory <span class="title">getILoggerFactory</span><span class="params">()</span> &#123;</div><div class="line"><span class="keyword">if</span> (INITIALIZATION_STATE == UNINITIALIZED) &#123;</div><div class="line">  INITIALIZATION_STATE = ONGOING_INITIALIZATION;</div><div class="line">  <span class="comment">// 第一次调用会去加载 StaticLoggerBinder.class 文件来决定 LoggerFactory 的实现类</span></div><div class="line">  <span class="comment">// （补充下：不同日志包下都有 StaticLoggerBinder 这个类文件，这个会决定 LoggerFactory 初始化那种类型的日志）</span></div><div class="line">  performInitialization();</div><div class="line">&#125;</div><div class="line"><span class="comment">// INITIALIZATION_STATE 值判断是否有加载初始化过 ILoggerFactory 实例。</span></div><div class="line"><span class="keyword">switch</span> (INITIALIZATION_STATE) &#123;</div><div class="line">  <span class="keyword">case</span> SUCCESSFUL_INITIALIZATION:</div><div class="line">    <span class="comment">// 返回对应的 ILoggerFactory 实例</span></div><div class="line">    <span class="keyword">return</span> StaticLoggerBinder.getSingleton().getLoggerFactory();</div><div class="line">  <span class="keyword">case</span> NOP_FALLBACK_INITIALIZATION:</div><div class="line">    <span class="comment">// 当加载不到一个 StaticLoggerBinder 时，会走这里</span></div><div class="line">    <span class="comment">// 返回一个 NOPLoggerFactory 实例</span></div><div class="line">    <span class="keyword">return</span> NOP_FALLBACK_FACTORY;</div><div class="line">  <span class="keyword">case</span> FAILED_INITIALIZATION:</div><div class="line">    <span class="comment">// 初始化异常</span></div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(UNSUCCESSFUL_INIT_MSG);</div><div class="line">  <span class="keyword">case</span> ONGOING_INITIALIZATION:</div><div class="line">    <span class="comment">// support re-entrant behavior.</span></div><div class="line">    <span class="comment">// See also http://bugzilla.slf4j.org/show_bug.cgi?id=106</span></div><div class="line">    <span class="keyword">return</span> TEMP_FACTORY;</div><div class="line">&#125;</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unreachable code"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来我们来看下是怎么加载 StaticLoggerBinder.class 文件的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">以下代码摘自：org.slf4j.<span class="function">LoggerFactory</span></div><div class="line"></div><div class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span> &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">// 加载 StaticLoggerBinder</span></div><div class="line">      Set staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet();</div><div class="line">      reportMultipleBindingAmbiguity(staticLoggerBinderPathSet);</div><div class="line">      <span class="comment">// 最后会随机选择一个StaticLoggerBinder.class来创建一个单例</span></div><div class="line">      StaticLoggerBinder.getSingleton();</div><div class="line">      <span class="comment">// 改变 INITIALIZATION_STATE 值，表示成功初始化 Factory。</span></div><div class="line">      <span class="comment">// 并且以后在获取 Logger 的时候并不会再次加载该方法</span></div><div class="line">      INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION;</div><div class="line">      reportActualBinding(staticLoggerBinderPathSet);</div><div class="line">      emitSubstituteLoggerWarning();</div><div class="line">    &#125; <span class="keyword">catch</span> (NoClassDefFoundError ncde) &#123;</div><div class="line">      String msg = ncde.getMessage();</div><div class="line">      <span class="keyword">if</span> (messageContainsOrgSlf4jImplStaticLoggerBinder(msg)) &#123;</div><div class="line">        <span class="comment">// 加载不到 StaticLoggerBinder 文件</span></div><div class="line">        INITIALIZATION_STATE = NOP_FALLBACK_INITIALIZATION;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        failedBinding(ncde);</div><div class="line">        <span class="keyword">throw</span> ncde;</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (java.lang.NoSuchMethodError nsme) &#123;</div><div class="line">      String msg = nsme.getMessage();</div><div class="line">      <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.indexOf(<span class="string">"org.slf4j.impl.StaticLoggerBinder.getSingleton()"</span>) != -<span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">// 初始化异常</span></div><div class="line">        INITIALIZATION_STATE = FAILED_INITIALIZATION;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">throw</span> nsme;</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">      failedBinding(e);</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected initialization failure"</span>, e);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p> 加载 StaticLoggerBinder.class<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">以下代码摘自：org.slf4j.LoggerFactory.findPossibleStaticLoggerBinderPathSet</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> String STATIC_LOGGER_BINDER_PATH = <span class="string">"org/slf4j/impl/StaticLoggerBinder.class"</span>;</div><div class="line"></div><div class="line">···</div><div class="line"><span class="keyword">if</span> (loggerFactoryClassLoader == <span class="keyword">null</span>) &#123;</div><div class="line">    paths = ClassLoader.getSystemResources(STATIC_LOGGER_BINDER_PATH);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    paths = loggerFactoryClassLoader</div><div class="line">            .getResources(STATIC_LOGGER_BINDER_PATH);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">while</span> (paths.hasMoreElements()) &#123;</div><div class="line">    URL path = (URL) paths.nextElement();</div><div class="line">    staticLoggerBinderPathSet.add(path);</div><div class="line">  &#125;</div><div class="line">···</div></pre></td></tr></table></figure></p>
<p>当项目中存在多个StaticLoggerBinder.class文件时，运行项目会出现以下日志：<br>（这里获取的规则就近原则，如果在 maven 先配置 slf4j 而后面在配置 logback，则这里初始化的是 slf4j）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SLF4J: Class path contains multiple SLF4J bindings.</div><div class="line">SLF4J: Found binding in [jar:file:/E:/OperSource/org/slf4j/slf4j-log4j12/<span class="number">1.7</span>.12/slf4j-log4j12-<span class="number">1.7</span>.12.jar!/org/slf4j/impl/StaticLoggerBinder.class]</div><div class="line">SLF4J: Found binding in [jar:file:/E:/OperSource/ch/qos/logback/logback-classic/<span class="number">1.1</span>.3/logback-classic-<span class="number">1.1</span>.3.jar!/org/slf4j/impl/StaticLoggerBinder.class]</div><div class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#multiple_bindings for an explanation.</span></div><div class="line">SLF4J: Actual binding is of type [org.slf4j.impl.Log4jLoggerFactory]</div></pre></td></tr></table></figure></p>
<p>返回实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">以下代码摘自：org.slf4j.LoggerFactory.getILoggerFactory</div><div class="line"></div><div class="line">StaticLoggerBinder.getSingleton().getLoggerFactory();</div></pre></td></tr></table></figure></p>
<h2 id="LogBack-配置"><a href="#LogBack-配置" class="headerlink" title="LogBack 配置"></a>LogBack 配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">"true"</span> <span class="attr">scanPeriod</span>=<span class="string">"60 seconds"</span> <span class="attr">debug</span>=<span class="string">"false"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 项目名称配置 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">contextName</span>&gt;</span>example<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 属性 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"APP_Name"</span> <span class="attr">value</span>=<span class="string">"example"</span> /&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 统一的时间格式，用于日志头输出 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">timestamp</span> <span class="attr">key</span>=<span class="string">"timeStyle"</span> <span class="attr">datePattern</span>=<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>/&gt;</span></div><div class="line">    <span class="comment">&lt;!--配置控制台输出,开发环境有--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- encoder 默认配置为PatternLayoutEncoder --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;timeStyle&#125;] [%cn] %-5level %logger&#123;35&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!--文件输出配置--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"FILE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>../logs/$&#123;APP_Name&#125;_run.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.FixedWindowRollingPolicy"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>../logs/$&#123;APP_Name&#125;_run.%i.log.zip<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">minIndex</span>&gt;</span>1<span class="tag">&lt;/<span class="name">minIndex</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">maxIndex</span>&gt;</span>10<span class="tag">&lt;/<span class="name">maxIndex</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>10MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;timeStyle&#125;] [%cn] %-5level %logger&#123;35&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"BUSINESS_FILE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>../logs/$&#123;APP_Name&#125;_business.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.FixedWindowRollingPolicy"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>../logs/$&#123;APP_Name&#125;_business.%i.business.zip<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">minIndex</span>&gt;</span>1<span class="tag">&lt;/<span class="name">minIndex</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">maxIndex</span>&gt;</span>10<span class="tag">&lt;/<span class="name">maxIndex</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>10MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;timeStyle&#125;] [%cn] %-5level %logger&#123;35&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span><span class="comment">&lt;!-- 只打印错误日志 --&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>WARE<span class="tag">&lt;/<span class="name">level</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 异步输出 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"ASYNC"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.AsyncAppender"</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">discardingThreshold</span>&gt;</span>0<span class="tag">&lt;/<span class="name">discardingThreshold</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为256 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">queueSize</span>&gt;</span>256<span class="tag">&lt;/<span class="name">queueSize</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 添加附加的appender,最多只能添加一个 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"FILE"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"BUSINESS_ASYNC"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.AsyncAppender"</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">discardingThreshold</span>&gt;</span>0<span class="tag">&lt;/<span class="name">discardingThreshold</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为256 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">queueSize</span>&gt;</span>256<span class="tag">&lt;/<span class="name">queueSize</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 添加附加的appender,最多只能添加一个 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"BUSINESS_FILE"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 为数据库开启显示sql --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.cjf.example.repository"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.cjf"</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!--日志的root目录，用于定位日志输出级别--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"ASYNC"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div></pre></td></tr></table></figure>
<p>上面就是一个常用的日志配置模版，下面就从跟节点来解析每个节点</p>
<p><strong>1.configuration</strong><br>scan：当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。<br>scanPeriod：监测配置文件是否有修改的时间间隔，默认 60s。<br>debug：是否打印 logback 内部日志，默认 false.<br><strong>2.contextName</strong> 项目名称<br>logger 上下文容器名称，默认 ‘default’，用于区分不同应用程序的记录。（可以在日志输出的时候将项目名称打印处理方便系统间交互 比如上面配置的 <code>%cn</code>）<br><strong>3.property</strong> 设置变量<br>定义变量后，可以使<code>${}</code>来使用变量。<br><strong>4.timestamp</strong> 设置时间戳格式<br>key:标识此<timestamp> 的名字；datePattern：设置将当前时间（解析配置文件的时间）转换为字符串的模式，遵循Java.txt.SimpleDateFormat的格式。<br><strong>5.logger</strong><br>用来设置某一个包或者具体的某一个类的日志打印级别、以及指定<appender>。<loger>仅有一个name属性，一个可选的level和一个可选的addtivity属性。<br>name: 用来指定受此loger约束的某一个包或者具体的某一个类。<br>level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。如果未设置此属性，那么当前loger将会继承上级的级别。<br>addtivity:是否向上级loger传递打印信息。默认是true。<br>loger可以包含零个或多个appender-ref元素，标识这个appender将会添加到这个loger。<br><strong>6.root</strong><br>也是 loger 元素，但是它是根 loger。只有一个 level 属性，应为已经被命名为 <code>“root”</code>.<br>root 可以包含零个或多个 appender-ref 元素，标识这个 appender 将会添加到这个 loger。</loger></appender></timestamp></p>
<h3 id="什么是-Appender？"><a href="#什么是-Appender？" class="headerlink" title="什么是 Appender？"></a>什么是 Appender？</h3><p>logback 将日志记录事件写入到名为 appender 的组件的任务,不同 appender 决定了日志的记录方式。<br>appender 有多种实现的方式，下面简单介绍几种比较常用的配置。 <a href="https://logback.qos.ch/manual/appenders.html" target="_blank" rel="external">更多详情请参考官方文档</a></p>
<p><strong>ConsoleAppender</strong><br>把日志添加到控制台，有以下子节点：<br>  encoder：对日志进行格式化<br>  target：字符串 System.out 或者 System.err ，默认 System.out;<br>  withJansi：日志彩色输出</p>
<p>例如<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </div><div class="line">  </div><div class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span>  </div><div class="line">      <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;timeStyle&#125;] [%cn] %-5level %logger&#123;35&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span>  </div><div class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span>  </div><div class="line">  </div><div class="line">  <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span> /&gt;</span>  </div><div class="line">  <span class="tag">&lt;/<span class="name">root</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>RollingFileAppender</strong><br>滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件。<br>file：被写入的文件名，可以是相对目录，也可以是绝对目录，如果上级目录不存在会自动创建，没有默认值。<br>append：如果是 true，日志被追加到文件结尾，如果是 false，清空现存文件，默认是true。<br>encoder：对记录事件进行格式化。<br>rollingPolicy：当发生滚动时，决定 RollingFileAppender 的行为，涉及文件移动和重命名。<br>triggeringPolicy：告知 RollingFileAppender 合适激活滚动。<br>prudent：当为true时，不支持FixedWindowRollingPolicy。支持TimeBasedRollingPolicy，但是有两个限制，1不支持也不允许文件压缩，2不能设置file属性，必须留空。</p>
<p>　<br>rollingPolicy 有两种类型，分别是 TimeBasedRollingPolicy，FixedWindowRollingPolicy。</p>
<p>例如 TimeBasedRollingPolicy 配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--输出到文件--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"file"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;log.path&#125;<span class="tag">&lt;/<span class="name">file</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>logback.%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">totalSizeCap</span>&gt;</span>1GB<span class="tag">&lt;/<span class="name">totalSizeCap</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>fileNamePattern 定义了日志的切分方式——把每一天的日志归档到一个文件中<br>maxHistory 表示只保留最近30天的日志，以防止日志填满整个磁盘空间。<br>totalSizeCap 用来指定日志文件的上限大小，例如设置为1GB的话，那么到了这个值，就会删除旧的日志。</p>
<p>例如 FixedWindowRollingPolicy 配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"FILE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>../logs/$&#123;APP_Name&#125;_run.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.FixedWindowRollingPolicy"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>../logs/$&#123;APP_Name&#125;_run.%i.log.zip<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">minIndex</span>&gt;</span>1<span class="tag">&lt;/<span class="name">minIndex</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">maxIndex</span>&gt;</span>10<span class="tag">&lt;/<span class="name">maxIndex</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>10MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;timeStyle&#125;] [%cn] %-5level %logger&#123;35&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>这里多了一个 SizeBasedTriggeringPolicy 触发机制，但 log 文件大于 10MB 的时候，就开始执行 rolling。<br>minIndex 和 maxIndex 表示保存日志数量，但大于 maxIndex 的时候，会开始删除旧的日志。</p>
<blockquote>
<p>必须包含“%i”例如，假设最小值和最大值分别为1和2，命名模式为<br>mylog%i.log,会产生归档文件mylog1.log和mylog2.log。还可以指定文件压缩选项，例如，mylog%i.log.gz<br>或者 没有log%i.log.zip</p>
</blockquote>
<h3 id="AsyncAppender-异步输出"><a href="#AsyncAppender-异步输出" class="headerlink" title="AsyncAppender 异步输出"></a>AsyncAppender 异步输出</h3><p>这里就不写了，可以<a href="http://blog.csdn.net/ChenJie2000/article/details/8902727" target="_blank" rel="external">参考</a>文章。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于没有深入去了解 logback ,许多内容都是网上摘来的，写文章的时候也很费劲。思路不清晰。</p>
]]></content>
      
        <categories>
            
            <category> LogBack </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LogBack </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
