<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Sublime Text新建.vue模板并高亮]]></title>
      <url>/2018/03/11/Sublime%20Text%E6%96%B0%E5%BB%BA.vue%E6%A8%A1%E6%9D%BF%E5%B9%B6%E9%AB%98%E4%BA%AE/</url>
      <content type="html"><![CDATA[<h1 id="Sublime-Text新建-vue模板并高亮"><a href="#Sublime-Text新建-vue模板并高亮" class="headerlink" title="Sublime Text新建.vue模板并高亮"></a>Sublime Text新建.vue模板并高亮</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>下载安装新建文件模板插件 <code>SublimeTmpl</code></li>
<li>下载安装vue语法高亮插件 <code>Vue Syntax Highlight</code></li>
</ul>
<h5 id="Sublime-Text安装插件的方法有两种："><a href="#Sublime-Text安装插件的方法有两种：" class="headerlink" title="Sublime Text安装插件的方法有两种："></a>Sublime Text安装插件的方法有两种：</h5><ol>
<li>使用Sublime Text自带的安装库 <code>Package Control</code> 去安装<br>点击菜单栏的 <code>Preferences -&gt; Package Control</code> 或使用快捷键 <code>CTRL+SHIFT+P</code> 打开终端窗口，输入<code>Install</code>选择<code>Package Control: Install Package</code>来安装</li>
<li>下载直接放入包目录 <code>(Preferences / Browse Packages)</code> <code>中文:(首选项 / 包浏览器)</code> 文件夹里面<ul>
<li><a href="https://github.com/kairyou/SublimeTmpl" target="_blank" rel="external">SublimeTmpl</a></li>
<li><a href="https://github.com/vuejs/vue-syntax-highlight" target="_blank" rel="external">Vue Syntax Highlight</a></li>
</ul>
</li>
</ol>
<h2 id="创建-vue模板并让语法高亮"><a href="#创建-vue模板并让语法高亮" class="headerlink" title="创建.vue模板并让语法高亮"></a>创建.vue模板并让语法高亮</h2><p>安装完<code>Vue Syntax Highlight</code>之后，你打开<code>.vue</code>格式的文件就已经可以高亮了，我们现在来设置用快捷键直接创建<code>.vue</code>格式的文件。</p>
<h6 id="SublimeTmpl-默认只有6种语法模板："><a href="#SublimeTmpl-默认只有6种语法模板：" class="headerlink" title="SublimeTmpl 默认只有6种语法模板："></a><code>SublimeTmpl</code> 默认只有6种语法模板：</h6><ul>
<li>html <code>ctrl+alt+h</code></li>
<li>javascript <code>ctrl+alt+j</code></li>
<li>css <code>ctrl+alt+c</code></li>
<li>php <code>ctrl+alt+p</code></li>
<li>ruby <code>ctrl+alt+r</code></li>
<li>python <code>ctrl+alt+shift+p</code></li>
</ul>
<h6 id="我们现在新增创建-vue-格式的模板"><a href="#我们现在新增创建-vue-格式的模板" class="headerlink" title="我们现在新增创建 vue 格式的模板"></a>我们现在新增创建 <code>vue</code> 格式的模板</h6><ol>
<li><p>创建<code>vue</code>文件模板</p>
<ul>
<li>直接打开插件包的文件夹 <code>Preferences -&gt; Browse Packages</code></li>
</ul>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/180310/ckm0BJkjl9.png" alt="mark"></p>
<p>​</p>
<p>首选项 -&gt; 浏览程序包</p>
<p>​</p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/180310/JBE3g91b7a.png" alt="mark"></p>
<p>​</p>
<p>包文件夹</p>
<ul>
<li>打开存放模板的文件夹 <code>templates</code>，随便复制一项，改名为<code>vue.tmpl</code></li>
</ul>
<p>​</p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/180310/8mc9145hab.png" alt="mark"></p>
<p>创建vue.tmpl</p>
<ul>
<li><code>vue.tmpl</code>内容改为你想要的模板</li>
</ul>
<p>​</p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/180310/JhL8j52hdC.png" alt="mark"></p>
<p>vue.tmpl内容</p>
</li>
<li><p>修改新建菜单，增加新建<code>vue</code>选项</p>
<ul>
<li><code>SublimeTmpl</code>新建菜单默认是没有<code>vue</code>的，如图</li>
</ul>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/180310/EhKlBifH5b.png" alt="mark"></p>
<p>​</p>
<p>新建 -&gt; New File (SublimeTmpl)</p>
<ul>
<li>点击上图的 <code>Menu</code> 选项，或者打开 <code>Preferences -&gt; Package Settings -&gt; SublimeTmpl -&gt; Settings - Menu</code>，如图</li>
</ul>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/180310/aebbHgC3jG.png" alt="mark"></p>
<p>​</p>
<p>打开菜单配置项</p>
<ul>
<li>复制一项，然后粘贴修改为 <code>vue</code> 项，如图</li>
</ul>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/180310/L4hKlbbIm7.png" alt="mark"></p>
<p>​</p>
<p>新增vue项</p>
<ul>
<li>保存修改，就会在新建菜单里面出现<code>vue</code>项，如图</li>
</ul>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/180310/Fkl7AbGj6e.png" alt="mark"></p>
<p>​</p>
<p>出现vue项</p>
<ul>
<li>点击上图<code>vue</code>新建项，就会出现之前设置的模板内容，只不过没有语法高亮，并且是纯文本格式，如图</li>
</ul>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/180310/DDD66EB98b.png" alt="mark"></p>
<p>​</p>
<p>新建vue文件</p>
</li>
<li><p>模板绑定vue语法高亮</p>
<ul>
<li>打开 <code>Preferences -&gt; Package Settings -&gt; SublimeTmpl -&gt; Settings - Default</code>，如图</li>
</ul>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/180310/JCecEJgji4.png" alt="mark"></p>
<p>​</p>
<p>打开默认设置项</p>
<ul>
<li>复制一项并修改为vue，路径如下</li>
</ul>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/180310/Jgf4ef10f5.png" alt="mark"></p>
<p>​</p>
<p>绑定vue语法</p>
<ul>
<li>绑定语法关联文件路径请查看目录 <code>Sublime Text3\Data\Cache</code>，寻找vue高亮语法插件名，并打开，如图</li>
</ul>
<p>​</p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/180310/a3d1AcCf25.png" alt="mark"></p>
<p>Sublime Text3\Data\Cache目录</p>
<p>​</p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/180310/67kf30ea7f.png" alt="mark"></p>
<p>​</p>
<p>Sublime Text3\Data\Cache\vue-syntax-highlight</p>
<ul>
<li>再次菜单新建vue就语法高亮了，如图</li>
</ul>
<p>​</p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/180310/1lA8G1g1Gd.png" alt="mark"></p>
<p>新建vue文件</p>
</li>
<li><p>绑定新建<code>vue</code>文件快捷键</p>
<ul>
<li>打开 <code>Preferences -&gt; Package Settings -&gt; SublimeTmpl -&gt; Key Bindings - Default</code>，如图</li>
</ul>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/180310/CICf0f6gad.png" alt="mark"></p>
<p>​</p>
<p>打开设置快捷键文件</p>
<ul>
<li>复制一项，粘贴创建新建vue快捷键为 <code>ctrl+alt+v</code>，如图</li>
</ul>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/180310/DCDLl85ejk.png" alt="mark"></p>
<p>​</p>
<p>创建快捷键</p>
<ul>
<li>保存后，菜单新建里也有了，如图</li>
</ul>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/180310/eLF86ba49j.png" alt="mark"></p>
<p>​</p>
<p>新建文件菜单</p>
<ul>
<li>试试，完美！</li>
</ul>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/180310/f1jmIeJlka.png" alt="mark"></p>
<p>​</p>
<p>完美</p>
</li>
</ol>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p><code>Preferences -&gt; Package Settings -&gt; SublimeTmpl -&gt; Settings - Commands</code> 文件好像是配置命令的，配置方法也跟上面相同，照猫画虎即可~</p>
<h4 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h4><p>通过这种方法，其他的语言模板也可以自己去创建。</p>
]]></content>
      
        <categories>
            
            <category> Sublime Text </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 开发工具使用 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java Map 用法、遍历、排序和常用 API]]></title>
      <url>/2018/03/06/Java%20Map%20%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="Java-map-用法、遍历、排序和常用API"><a href="#Java-map-用法、遍历、排序和常用API" class="headerlink" title="Java map 用法、遍历、排序和常用API"></a>Java map 用法、遍历、排序和常用API</h1><p>java.util 中的集合类包含 Java 中某些最常用的类。最常用的集合类是 List 和 Map。</p>
<p>Map 提供了一个更通用的元素存储方法。Map 集合类用于存储元素对（称作“键”和“值”），其中每个键映射到一个值。</p>
<p>本文主要介绍java map的初始化、用法、map的四种常用的遍历方式、map的排序以及常用api。</p>
<h2 id="Map用法"><a href="#Map用法" class="headerlink" title="Map用法"></a>Map用法</h2><h3 id="类型介绍"><a href="#类型介绍" class="headerlink" title="类型介绍"></a>类型介绍</h3><p>Java 自带了各种 Map 类。这些 Map 类可归为三种类型：</p>
<ol>
<li>通用Map，用于在应用程序中管理映射，通常在 java.util 程序包中实现HashMap、Hashtable、Properties、LinkedHashMap、IdentityHashMap、TreeMap、WeakHashMap、ConcurrentHashMap</li>
<li>专用Map，通常我们不必亲自创建此类Map，而是通过某些其他类对其进行访 <strong>java.util.jar.Attributes、 javax.print.attribute.standard.PrinterStateReasons、 java.security.Provider、 java.awt.RenderingHints、 javax.swing.UIDefaults</strong></li>
<li>一个用于帮助我们实现自己的Map类的抽象类 <strong>AbstractMap</strong></li>
</ol>
<h3 id="类型区别"><a href="#类型区别" class="headerlink" title="类型区别"></a>类型区别</h3><p><strong>HashMap</strong></p>
<p>最常用的 Map ,它根据键的  HashCode  值存储数据,根据键可以直接获取它的值，具有很快的访问速度。HashMap 最多只允许一条记录的键为 Null(多条会覆盖);不允许多条记录的值为 Null。非同步的。</p>
<p><strong>TreeMap</strong></p>
<p>能够把它保存的记录根据键(key)排序,默认是按升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。TreeMap不允许key的值为null。非同步的。<br><strong>Hashtable</strong></p>
<p>与 HashMap类似,不同的是:key和value的值均不允许为null;它支持线程的同步，即任一时刻只有一个线程能写Hashtable,因此也导致了Hashtale在写入时会比较慢。<br><strong>LinkedHashMap</strong></p>
<p>保存了记录的插入顺序，在用 Iterator 遍历 LinkedHashMap 时，先得到的记录肯定是先插入的.在遍历的时候会比 HashMap 慢。key 和 value 均允许为空，非同步的。 </p>
<h2 id="四种常用Map插入与读取性能比较"><a href="#四种常用Map插入与读取性能比较" class="headerlink" title="四种常用Map插入与读取性能比较"></a>四种常用Map插入与读取性能比较</h2><h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h3><p>jdk1.7.0_80</p>
<h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><table>
<thead>
<tr>
<th></th>
<th>插入10次平均(ms)</th>
<th>读取10次平均(ms)</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>1W</td>
<td>10W</td>
<td>100W</td>
<td>1W</td>
<td>10W</td>
<td>100W</td>
</tr>
<tr>
<td>HashMap</td>
<td>56</td>
<td>261</td>
<td><strong>3030</strong></td>
<td><strong>2</strong></td>
<td>21</td>
<td>220</td>
</tr>
<tr>
<td>LinkedHashMap</td>
<td>25</td>
<td><strong>229</strong></td>
<td>3069</td>
<td><strong>2</strong></td>
<td><strong>20</strong></td>
<td><strong>216</strong></td>
</tr>
<tr>
<td>TreeMap</td>
<td>29</td>
<td>295</td>
<td>4117</td>
<td>5</td>
<td>103</td>
<td>1446</td>
</tr>
<tr>
<td>Hashtable</td>
<td><strong>24</strong></td>
<td>234</td>
<td>3275</td>
<td><strong>2</strong></td>
<td>22</td>
<td>259</td>
</tr>
</tbody>
</table>
<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> hashMapW = <span class="number">0</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> hashMapR = <span class="number">0</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> linkMapW = <span class="number">0</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> linkMapR = <span class="number">0</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> treeMapW = <span class="number">0</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> treeMapR = <span class="number">0</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> hashTableW = <span class="number">0</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> hashTableR = <span class="number">0</span>;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            Test test = <span class="keyword">new</span> Test();</div><div class="line">            test.test(<span class="number">100</span> * <span class="number">10000</span>);</div><div class="line">            System.out.println();</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        System.out.println(<span class="string">"hashMapW = "</span> + hashMapW / <span class="number">10</span>);</div><div class="line">        System.out.println(<span class="string">"hashMapR = "</span> + hashMapR / <span class="number">10</span>);</div><div class="line">        System.out.println(<span class="string">"linkMapW = "</span> + linkMapW / <span class="number">10</span>);</div><div class="line">        System.out.println(<span class="string">"linkMapR = "</span> + linkMapR / <span class="number">10</span>);</div><div class="line">        System.out.println(<span class="string">"treeMapW = "</span> + treeMapW / <span class="number">10</span>);</div><div class="line">        System.out.println(<span class="string">"treeMapR = "</span> + treeMapR / <span class="number">10</span>);</div><div class="line">        System.out.println(<span class="string">"hashTableW = "</span> + hashTableW / <span class="number">10</span>);</div><div class="line">        System.out.println(<span class="string">"hashTableR = "</span> + hashTableR / <span class="number">10</span>);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> index;</div><div class="line">        Random random = <span class="keyword">new</span> Random();</div><div class="line">        String[] key = <span class="keyword">new</span> String[size];</div><div class="line"> </div><div class="line">        <span class="comment">// HashMap 插入</span></div><div class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">            key[i] = UUID.randomUUID().toString();</div><div class="line">            map.put(key[i], UUID.randomUUID().toString());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">        hashMapW += (end - start);</div><div class="line">        System.out.println(<span class="string">"HashMap插入耗时 = "</span> + (end - start) + <span class="string">" ms"</span>);</div><div class="line"> </div><div class="line">        <span class="comment">// HashMap 读取</span></div><div class="line">        start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">            index = random.nextInt(size);</div><div class="line">            map.get(key[index]);</div><div class="line">        &#125;</div><div class="line">        end = System.currentTimeMillis();</div><div class="line">        hashMapR += (end - start);</div><div class="line">        System.out.println(<span class="string">"HashMap读取耗时 = "</span> + (end - start) + <span class="string">" ms"</span>);</div><div class="line"> </div><div class="line">        <span class="comment">// LinkedHashMap 插入</span></div><div class="line">        map = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</div><div class="line">        start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">            key[i] = UUID.randomUUID().toString();</div><div class="line">            map.put(key[i], UUID.randomUUID().toString());</div><div class="line">        &#125;</div><div class="line">        end = System.currentTimeMillis();</div><div class="line">        linkMapW += (end - start);</div><div class="line">        System.out.println(<span class="string">"LinkedHashMap插入耗时 = "</span> + (end - start) + <span class="string">" ms"</span>);</div><div class="line"> </div><div class="line">        <span class="comment">// LinkedHashMap 读取</span></div><div class="line">        start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">            index = random.nextInt(size);</div><div class="line">            map.get(key[index]);</div><div class="line">        &#125;</div><div class="line">        end = System.currentTimeMillis();</div><div class="line">        linkMapR += (end - start);</div><div class="line">        System.out.println(<span class="string">"LinkedHashMap读取耗时 = "</span> + (end - start) + <span class="string">" ms"</span>);</div><div class="line"> </div><div class="line">        <span class="comment">// TreeMap 插入</span></div><div class="line">        key = <span class="keyword">new</span> String[size];</div><div class="line">        map = <span class="keyword">new</span> TreeMap&lt;String, String&gt;();</div><div class="line">        start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">            key[i] = UUID.randomUUID().toString();</div><div class="line">            map.put(key[i], UUID.randomUUID().toString());</div><div class="line">        &#125;</div><div class="line">        end = System.currentTimeMillis();</div><div class="line">        treeMapW += (end - start);</div><div class="line">        System.out.println(<span class="string">"TreeMap插入耗时 = "</span> + (end - start) + <span class="string">" ms"</span>);</div><div class="line"> </div><div class="line">        <span class="comment">// TreeMap 读取</span></div><div class="line">        start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">            index = random.nextInt(size);</div><div class="line">            map.get(key[index]);</div><div class="line">        &#125;</div><div class="line">        end = System.currentTimeMillis();</div><div class="line">        treeMapR += (end - start);</div><div class="line">        System.out.println(<span class="string">"TreeMap读取耗时 = "</span> + (end - start) + <span class="string">" ms"</span>);</div><div class="line"> </div><div class="line">        <span class="comment">// Hashtable 插入</span></div><div class="line">        key = <span class="keyword">new</span> String[size];</div><div class="line">        map = <span class="keyword">new</span> Hashtable&lt;String, String&gt;();</div><div class="line">        start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">            key[i] = UUID.randomUUID().toString();</div><div class="line">            map.put(key[i], UUID.randomUUID().toString());</div><div class="line">        &#125;</div><div class="line">        end = System.currentTimeMillis();</div><div class="line">        hashTableW += (end - start);</div><div class="line">        System.out.println(<span class="string">"Hashtable插入耗时 = "</span> + (end - start) + <span class="string">" ms"</span>);</div><div class="line"> </div><div class="line">        <span class="comment">// Hashtable 读取</span></div><div class="line">        start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">            index = random.nextInt(size);</div><div class="line">            map.get(key[index]);</div><div class="line">        &#125;</div><div class="line">        end = System.currentTimeMillis();</div><div class="line">        hashTableR += (end - start);</div><div class="line">        System.out.println(<span class="string">"Hashtable读取耗时 = "</span> + (end - start) + <span class="string">" ms"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Map-遍历"><a href="#Map-遍历" class="headerlink" title="Map 遍历"></a>Map 遍历</h2><h3 id="初始化数据"><a href="#初始化数据" class="headerlink" title="初始化数据"></a>初始化数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</div><div class="line">map.put(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</div><div class="line">map.put(<span class="string">"key2"</span>, <span class="string">"value2"</span>);</div></pre></td></tr></table></figure>
<h3 id="增强for循环遍历"><a href="#增强for循环遍历" class="headerlink" title="增强for循环遍历"></a>增强for循环遍历</h3><p><strong>使用keySet()遍历</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Iterator&lt;String&gt; iterator = map.keySet().iterator();</div><div class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</div><div class="line">    String key = iterator.next();</div><div class="line">    System.out.println(key + <span class="string">"　："</span> + map.get(key));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>使用entrySet()遍历</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();</div><div class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</div><div class="line">    Map.Entry&lt;String, String&gt; entry = iterator.next();</div><div class="line">    System.out.println(entry.getKey() + <span class="string">"　："</span> + entry.getValue());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="迭代器遍历"><a href="#迭代器遍历" class="headerlink" title="迭代器遍历"></a>迭代器遍历</h3><p><strong>使用keySet()遍历</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Iterator&lt;String&gt; iterator = map.keySet().iterator();</div><div class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</div><div class="line">    String key = iterator.next();</div><div class="line">    System.out.println(key + <span class="string">"　："</span> + map.get(key));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>使用entrySet()遍历</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();</div><div class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</div><div class="line">    Map.Entry&lt;String, String&gt; entry = iterator.next();</div><div class="line">    System.out.println(entry.getKey() + <span class="string">"　："</span> + entry.getValue());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="HashMap四种遍历方式性能比较"><a href="#HashMap四种遍历方式性能比较" class="headerlink" title="HashMap四种遍历方式性能比较"></a>HashMap四种遍历方式性能比较</h3><p><strong>比较方式</strong></p>
<p>分别对四种遍历方式进行10W次迭代，比较用时。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> net.xsoftlab.baike;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"><span class="keyword">import</span> java.util.Map.Entry;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMap</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 初始化，10W次赋值</span></div><div class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</div><div class="line">            map.put(i, i);</div><div class="line"> </div><div class="line">        <span class="comment">/** 增强for循环，keySet迭代 */</span></div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</div><div class="line">            map.get(key);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"增强for循环，keySet迭代 -&gt; "</span> + (end - start) + <span class="string">" ms"</span>);</div><div class="line"> </div><div class="line">        <span class="comment">/** 增强for循环，entrySet迭代 */</span></div><div class="line">        start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span> (Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</div><div class="line">            entry.getKey();</div><div class="line">            entry.getValue();</div><div class="line">        &#125;</div><div class="line">        end = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"增强for循环，entrySet迭代 -&gt; "</span> + (end - start) + <span class="string">" ms"</span>);</div><div class="line"> </div><div class="line">        <span class="comment">/** 迭代器，keySet迭代 */</span></div><div class="line">        start = System.currentTimeMillis();</div><div class="line">        Iterator&lt;Integer&gt; iterator = map.keySet().iterator();</div><div class="line">        Integer key;</div><div class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</div><div class="line">            key = iterator.next();</div><div class="line">            map.get(key);</div><div class="line">        &#125;</div><div class="line">        end = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"迭代器，keySet迭代 -&gt; "</span> + (end - start) + <span class="string">" ms"</span>);</div><div class="line"> </div><div class="line">        <span class="comment">/** 迭代器，entrySet迭代 */</span></div><div class="line">        start = System.currentTimeMillis();</div><div class="line">        Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; iterator1 = map.entrySet().iterator();</div><div class="line">        Map.Entry&lt;Integer, Integer&gt; entry;</div><div class="line">        <span class="keyword">while</span> (iterator1.hasNext()) &#123;</div><div class="line">            entry = iterator1.next();</div><div class="line">            entry.getKey();</div><div class="line">            entry.getValue();</div><div class="line">        &#125;</div><div class="line">        end = System.currentTimeMillis();</div><div class="line"> </div><div class="line">        System.out.println(<span class="string">"迭代器，entrySet迭代 -&gt; "</span> + (end - start) + <span class="string">" ms"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>运行三次，比较结果</strong></p>
<p>第一次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">增强 <span class="keyword">for</span> 循环 keySet 迭代 -&gt; <span class="number">18</span>ms</div><div class="line">增强 <span class="keyword">for</span> 循环， entrySet - &gt;<span class="number">4</span>ms</div><div class="line">迭代器，keySet 迭代 - &gt;<span class="number">4</span>ms</div><div class="line">迭代器，entrySet 迭代 - &gt;<span class="number">3</span>ms</div></pre></td></tr></table></figure>
<p>第二次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">增强 <span class="keyword">for</span> 循环 keySet 迭代 -&gt; <span class="number">8</span>ms</div><div class="line">增强 <span class="keyword">for</span> 循环， entrySet - &gt;<span class="number">5</span>ms</div><div class="line">迭代器，keySet 迭代 - &gt;<span class="number">5</span>ms</div><div class="line">迭代器，entrySet 迭代 - &gt;<span class="number">4</span>ms</div></pre></td></tr></table></figure>
<p>第三次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">增强 <span class="keyword">for</span> 循环 keySet 迭代 -&gt; <span class="number">30</span>ms</div><div class="line">增强 <span class="keyword">for</span> 循环， entrySet - &gt;<span class="number">38</span>ms</div><div class="line">迭代器，keySet 迭代 - &gt;<span class="number">7</span>ms</div><div class="line">迭代器，entrySet 迭代 - &gt;<span class="number">2</span>ms</div></pre></td></tr></table></figure>
<p>平均值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">增强<span class="keyword">for</span>循环，keySet迭代 -&gt; <span class="number">31</span> ms</div><div class="line">增强<span class="keyword">for</span>循环，entrySet迭代 -&gt; <span class="number">20</span> ms</div><div class="line">迭代器，keySet迭代 -&gt; <span class="number">17</span> ms</div><div class="line">迭代器，entrySet迭代 -&gt; <span class="number">10.33</span> ms</div></pre></td></tr></table></figure>
<p>总结</p>
<ol>
<li>增强for循环使用方便，但性能较差，不适合处理超大量级的数据。</li>
<li>迭代器的遍历速度要比增强for循环快很多，是增强for循环的2倍左右。</li>
<li>使用entrySet遍历的速度要比keySet快很多，是keySet的1.5倍左右。</li>
</ol>
<h2 id="Map-排序"><a href="#Map-排序" class="headerlink" title="Map 排序"></a>Map 排序</h2><h3 id="HashMap、Hashtable、LinkedHashMap-排序"><a href="#HashMap、Hashtable、LinkedHashMap-排序" class="headerlink" title="HashMap、Hashtable、LinkedHashMap 排序"></a>HashMap、Hashtable、LinkedHashMap 排序</h3><p><strong>注：</strong></p>
<p>TreeMap 也可以使用此方法进行排序，但是更推荐下面的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</div><div class="line">map.put(<span class="string">"a"</span>, <span class="string">"c"</span>);</div><div class="line">map.put(<span class="string">"b"</span>, <span class="string">"b"</span>);</div><div class="line">map.put(<span class="string">"c"</span>, <span class="string">"a"</span>);</div><div class="line"> </div><div class="line"><span class="comment">// 通过ArrayList构造函数把map.entrySet()转换成list</span></div><div class="line">List&lt;Map.Entry&lt;String, String&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;Map.Entry&lt;String, String&gt;&gt;(map.entrySet());</div><div class="line"><span class="comment">// 通过比较器实现比较排序</span></div><div class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Map.Entry&lt;String, String&gt;&gt;() &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Map.Entry&lt;String, String&gt; mapping1, Map.Entry&lt;String, String&gt; mapping2)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mapping1.getKey().compareTo(mapping2.getKey());</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"> </div><div class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; mapping : list) &#123;</div><div class="line">    System.out.println(mapping.getKey() + <span class="string">" ："</span> + mapping.getValue());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="TreeMap排序"><a href="#TreeMap排序" class="headerlink" title="TreeMap排序"></a>TreeMap排序</h3><p>TreeMap默认按key进行升序排序，如果想改变默认的顺序，可以使用比较器:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> TreeMap&lt;String, String&gt;(<span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String obj1, String obj2)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> obj2.compareTo(obj1);<span class="comment">// 降序排序</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">map.put(<span class="string">"a"</span>, <span class="string">"c"</span>);</div><div class="line">map.put(<span class="string">"b"</span>, <span class="string">"b"</span>);</div><div class="line">map.put(<span class="string">"c"</span>, <span class="string">"a"</span>);</div><div class="line"> </div><div class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</div><div class="line">    System.out.println(key + <span class="string">" ："</span> + map.get(key));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="按value排序-通用"><a href="#按value排序-通用" class="headerlink" title="按value排序(通用)"></a>按value排序(通用)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> TreeMap&lt;String, String&gt;();</div><div class="line">        map.put(<span class="string">"a"</span>, <span class="string">"c"</span>);</div><div class="line">        map.put(<span class="string">"b"</span>, <span class="string">"b"</span>);</div><div class="line">        map.put(<span class="string">"c"</span>, <span class="string">"a"</span>);</div><div class="line"> </div><div class="line">        <span class="comment">// 通过ArrayList构造函数把map.entrySet()转换成list</span></div><div class="line">        List&lt;Map.Entry&lt;String, String&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;Map.Entry&lt;String, String&gt;&gt;(map.entrySet());</div><div class="line">        <span class="comment">// 通过比较器实现比较排序</span></div><div class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Map.Entry&lt;String, String&gt;&gt;() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Map.Entry&lt;String, String&gt; mapping1, Map.Entry&lt;String, String&gt; mapping2)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> mapping1.getValue().compareTo(mapping2.getValue());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"> </div><div class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</div><div class="line">            System.out.println(key + <span class="string">" ："</span> + map.get(key));</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><table>
<thead>
<tr>
<th>clear()</th>
<th>从 Map 中删除所有映射</th>
</tr>
</thead>
<tbody>
<tr>
<td>remove(Object key)</td>
<td>从 Map 中删除键和关联的值</td>
</tr>
<tr>
<td>put(Object key, Object value)</td>
<td>将指定值与指定键相关联</td>
</tr>
<tr>
<td>putAll(Map t)</td>
<td>将指定 Map 中的所有映射复制到此 map</td>
</tr>
<tr>
<td>entrySet()</td>
<td>返回 Map 中所包含映射的 Set 视图。Set 中的每个元素都是一个 Map.Entry 对象，可以使用 getKey() 和 getValue() 方法（还有一个 setValue() 方法）访问后者的键元素和值元素</td>
</tr>
<tr>
<td>keySet()</td>
<td>返回 Map 中所包含键的 Set 视图。删除 Set 中的元素还将删除 Map 中相应的映射（键和值）</td>
</tr>
<tr>
<td>values()</td>
<td>返回 map 中所包含值的 Collection 视图。删除 Collection 中的元素还将删除 Map 中相应的映射（键和值）</td>
</tr>
<tr>
<td>get(Object key)</td>
<td>返回与指定键关联的值</td>
</tr>
<tr>
<td>containsKey(Object key)</td>
<td>如果 Map 包含指定键的映射，则返回 true</td>
</tr>
<tr>
<td>containsValue(Object value)</td>
<td>如果此 Map 将一个或多个键映射到指定值，则返回 true</td>
</tr>
<tr>
<td>isEmpty()</td>
<td>如果 Map 不包含键-值映射，则返回 true</td>
</tr>
<tr>
<td>size()</td>
<td>返回 Map 中的键-值映射的数目</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> Map </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础数据类型 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HashMap 的源码分析]]></title>
      <url>/2018/03/06/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="JDK1-8-HashMap源码分析"><a href="#JDK1-8-HashMap源码分析" class="headerlink" title="JDK1.8 HashMap源码分析"></a>JDK1.8 HashMap源码分析</h1><p>HahsMap实现了Map接口。其继承关系如下图：<br><img src="http://img.blog.csdn.net/20170312124705054?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMTk0MzEzMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="HashMap继承关系图"> </p>
<p>HashMap有两个影响性能的重要参数：初始容量和加载因子。容量是Hash表中桶的个数，当HashMap初始化时，容量就是初始容量。加载因子是衡量hash表多满的一个指标，用来判断是否需要增加容量。当HashMap需要增加容量时，将会导致rehash操作。<br>默认情况下，0.75的加载因子在时间和空间方面提供了很好的平衡。加载因子越大，增加了空间利用率但是也增加了查询的时间。</p>
<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><h3 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h3><h4 id="JDK1-8之前的结构"><a href="#JDK1-8之前的结构" class="headerlink" title="JDK1.8之前的结构"></a>JDK1.8之前的结构</h4><p>在JDK1.7之前，HashMap采用的是数组+链表的结构，其结构图如下：<br><img src="http://img.blog.csdn.net/20160127173141337" alt="JDK1.7之前HashMap结构"><br>左边部分代表Hash表，数组的每一个元素都是一个单链表的头节点，链表是用来解决冲突的，如果不同的key映射到了数组的同一位置处，就将其放入单链表中。</p>
<h4 id="JDK1-8的结构"><a href="#JDK1-8的结构" class="headerlink" title="JDK1.8的结构"></a>JDK1.8的结构</h4><p>JDK1.8 之前的 HashMap 都采用上图的结构，都是基于一个数组和多个单链表，hash 值冲突的时候，就将对应节点以链表形式存储。如果在一个链表中查找一个节点时，将会花费 O(n) 的查找时间，会有很大的性能损失。到了JDK1.8，当同一个Hash值的节点数不小于8时，不再采用单链表形式存储，而是采用红黑树，如下图所示：<br><img src="http://img.blog.csdn.net/20160127173307041" alt="JDK1.8HashMap结构"></p>
<h3 id="Node介绍"><a href="#Node介绍" class="headerlink" title="Node介绍"></a>Node介绍</h3><p>Node是map的接口中的内部接口Map.Entry的实现类,用于存储HashMap中键值对的对象,是HashMap中非常重要的一个内部类,随便提一下,HashMap中有非常多的内部类,本文没做过多的介绍,读者可以自己翻看一下源码,因为篇幅实在太长了…在这里就简单的讲一下,大部分的内部类都是用于集合操作的,如<code>keySet</code>,<code>values</code>,<code>entrySet</code>等方法.</p>
<p>内部组成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line"><span class="comment">//key是不可变的</span></div><div class="line"><span class="keyword">final</span> K key;</div><div class="line"><span class="comment">//value</span></div><div class="line">V value;</div><div class="line"><span class="comment">//指向下一个entry对象,具体作用后面介绍</span></div><div class="line">Node&lt;K,V&gt; next;</div><div class="line"><span class="comment">//hash值</span></div><div class="line"><span class="keyword">int</span> hash;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="重要的字段"><a href="#重要的字段" class="headerlink" title="重要的字段"></a>重要的字段</h3><p>HashMap中有几个重要的字段，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//Hash表结构</span></div><div class="line"> <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</div><div class="line"></div><div class="line"> <span class="comment">//元素个数</span></div><div class="line"> <span class="keyword">transient</span> <span class="keyword">int</span> size;</div><div class="line"></div><div class="line"> <span class="comment">//确保fail-fast机制</span></div><div class="line"> <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</div><div class="line"></div><div class="line"> <span class="comment">//下一次增容前的阈值</span></div><div class="line"> <span class="keyword">int</span> threshold;</div><div class="line"></div><div class="line"> <span class="comment">//加载因子</span></div><div class="line"> <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</div><div class="line"></div><div class="line">  <span class="comment">//默认初始容量</span></div><div class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></div><div class="line"></div><div class="line"><span class="comment">//最大容量</span></div><div class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</div><div class="line"></div><div class="line"> <span class="comment">//加载因子</span></div><div class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</div><div class="line"></div><div class="line"> <span class="comment">//链表转红黑树的阈值</span></div><div class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</div></pre></td></tr></table></figure>
<h3 id="红黑树的关键参数"><a href="#红黑树的关键参数" class="headerlink" title="红黑树的关键参数"></a>红黑树的关键参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//一个桶的树化阈值</span></div><div class="line"><span class="comment">//当桶中元素个数超过这个值时，需要使用红黑树节点替换链表节点</span></div><div class="line"><span class="comment">//这个值必须为 8，要不然频繁转换效率也不高</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</div><div class="line"></div><div class="line"><span class="comment">//一个树的链表还原阈值</span></div><div class="line"><span class="comment">//当扩容时，桶中元素个数小于这个值，就会把树形的桶元素 还原（切分）为链表结构</span></div><div class="line"><span class="comment">//这个值应该比上面那个小，至少为 6，避免频繁转换</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</div><div class="line"></div><div class="line"><span class="comment">//哈希表的最小树形化容量</span></div><div class="line"><span class="comment">//当哈希表中的容量大于这个值时，表中的桶才能进行树形化</span></div><div class="line"><span class="comment">//否则桶内元素太多时会扩容，而不是树形化</span></div><div class="line"><span class="comment">//为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</div></pre></td></tr></table></figure>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>HashMap一共有4个构造方法，主要的工作就是完成容量和加载因子的赋值。Hash表都是采用的懒加载方式，当第一次插入数据时才会创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//构造方法 初始化负载因子和阈值</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</div><div class="line">                                               initialCapacity);</div><div class="line">        <span class="comment">//容量判断 </span></div><div class="line">    	<span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">            initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">    	<span class="comment">//负载银子判断</span></div><div class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</div><div class="line">                                               loadFactor);</div><div class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//为空时候使用默认分配的大小16,负载因子0.75f,默认的容量为12,当size&gt;threshold默认容量时候就会去扩容</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</div><div class="line">        putMapEntries(m, <span class="keyword">false</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="确定哈希桶数组索引位置"><a href="#确定哈希桶数组索引位置" class="headerlink" title="确定哈希桶数组索引位置"></a>确定哈希桶数组索引位置</h3><p>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过 HashMap 的数据结构是数组和链表的结合，所以我们当然希望这个 HashMap 里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用 hash 算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap 定位数组索引位置，直接决定了 hash 方法的离散性能。先看看源码的实现(方法一+方法二):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">方法一：</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;   <span class="comment">//jdk1.8 &amp; jdk1.7</span></div><div class="line">     <span class="keyword">int</span> h;</div><div class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></div><div class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></div><div class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div><div class="line">方法二：</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></div><div class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的 Hash 算法本质上就是三步：<strong>取 key 的 hashCode 值、高位运算、取模运算</strong>。</p>
<p>对于任意给定的对象，只要它的 hashCode() 返回值相同，那么程序调用方法一所计算得到的 Hash 码值总是相同的。我们首先想到的就是把 hash 值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在 HashMap 中是这样做的：调用方法二来计算该对象应该保存在  table  数组的哪个索引处。</p>
<p>这个方法非常巧妙，它通过 h &amp; (table.length -1) 来得到该对象的保存位，而 HashMap 底层数组的长度总是 2 的n 次方，这是 HashMap 在速度上的优化。当 length 总是 2 的 n 次方时，h&amp; (length-1) 运算等价于对 length 取模，也就是 h%length ，但是&amp;比%具有更高的效率。</p>
<p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p>
<p>下面举例说明下，n为table的长度。</p>
<p><img src="https://tech.meituan.com/img/java-hashmap/hashMap%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%BE%8B%E5%9B%BE.png" alt="hashMap哈希算法例图"></p>
<h3 id="添加一个元素put-K-k-V-v"><a href="#添加一个元素put-K-k-V-v" class="headerlink" title="添加一个元素put(K k,V v)"></a>添加一个元素put(K k,V v)</h3><p>HashMap 允许K和V为 null，添加一个键值对时使用 put 方法，如果之前已经存在K的键值，那么旧值将会被新值替换。实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * onlyIfAbsent 是否替换,为true时,如果存在值则替换</div><div class="line"> * evict 主要用于LinkedHashMap移除最近未使用的节点</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line">                   <span class="keyword">boolean</span> evict) &#123;</div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">        <span class="comment">//如果哈希表为空或长度为0，调用resize()方法创建哈希表</span></div><div class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">            n = (tab = resize()).length;</div><div class="line">        <span class="comment">//如果哈希表中K对应的桶为空，那么该K，V对将成为该桶的头节点</span></div><div class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</div><div class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">        <span class="comment">//该桶处已有节点，即发生了哈希冲突</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            Node&lt;K,V&gt; e; K k;</div><div class="line">            <span class="comment">//如果添加的值与头节点相同，将e指向p</span></div><div class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                e = p;</div><div class="line">            <span class="comment">//如果与头节点不同，并且该桶目前已经是红黑树状态，调用putTreeVal()方法</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line">            <span class="comment">//桶中仍是链表阶段</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//遍历，要比较是否与已有节点相同</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">                    <span class="comment">//将e指向下一个节点，如果是null，说明链表中没有相同节点，添加到链表尾部即可</span></div><div class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                        <span class="comment">//如果此时链表个数达到了8，那么需要将该桶处链表转换成红黑树，treeifyBin()方法将hash处的桶转成红黑树</span></div><div class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                            treeifyBin(tab, hash);</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//如果与已有节点相同，跳出循环</span></div><div class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    p = e;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果有重复节点，那么需要返回旧值</span></div><div class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">                V oldValue = e.value;</div><div class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">                    e.value = value;</div><div class="line">                <span class="comment">//子类实现(用于linkedHashMap)</span></div><div class="line">                afterNodeAccess(e);</div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//是一个全新节点，那么size需要+1</span></div><div class="line">        ++modCount;</div><div class="line">        <span class="comment">//如果超过了阈值，那么需要resize()扩大容量</span></div><div class="line">        <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line">            resize();</div><div class="line">        <span class="comment">//子类实现(用于linkedHashMap)</span></div><div class="line">        afterNodeInsertion(evict);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>从上面代码可以看到 putVal() 方法的流程： </p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/180306/LLFLH0iJb5.png" alt="mark"></p>
<ol>
<li>判断哈希表是否为空，如果为空，调用 resize() 方法进行创建哈希表 </li>
<li>根据 hash 值得到哈希表中桶的头节点，如果为 null ，说明是第一个节点，直接调用 newNode() 方法添加节点即可 </li>
<li>如果发生了哈希冲突，那么首先会得到头节点，比较是否相同，如果相同，则进行节点值的替换返回 </li>
<li>如果头节点不相同，但是头节点已经是 TreeNode 了，说明该桶处已经是红黑树了，那么调用 putTreeVal() 方法将该结点加入到红黑树中 </li>
<li>如果头节点不是 TreeNode，说明仍然是链表阶段，那么就需要从头开始遍历，一旦找到了相同的节点就跳出循环或者直到了链表尾部，那么将该节点插入到链表尾部 </li>
<li>如果插入到链表尾部后，链表个数达到了阈值8，那么将会将该链表转换成红黑树，调用 treeifyBin() 方法 </li>
<li>如果是新加一个数据，那么将 size+1，此时如果 size 超过了阈值，那么需要调用 resize() 方法进行扩容</li>
</ol>
<h4 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize()方法"></a>resize()方法</h4><p>下面我们一个一个分析上面提到的方法。首先是 resize() 方法，resize() 在哈希表为 null 时将会初始化，但是在已经初始化后就会进行容量扩展。下面是resize()的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 有几种情况</div><div class="line"> * 1.当为空的时候,也就是没有初始化的时候</div><div class="line"> * 2.当到达最大值时候</div><div class="line"> * 3.普通扩容时候</div><div class="line"> */</div><div class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</div><div class="line">        Node&lt;K,V&gt;[] oldTab = table;</div><div class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;<span class="comment">//旧表容量</span></div><div class="line">        <span class="keyword">int</span> oldThr = threshold;<span class="comment">//旧表与之</span></div><div class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</div><div class="line">        <span class="comment">//旧表存在</span></div><div class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</div><div class="line">             <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></div><div class="line">            <span class="comment">//旧表已经达到了最大容量，不能再大，直接返回旧表</span></div><div class="line">            <span class="comment">//大于2&lt;&lt;30 最大容量设置为2&lt;&lt;32 - 1</span></div><div class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line">                <span class="comment">//但是不移动.,没有空间移动</span></div><div class="line">                threshold = Integer.MAX_VALUE;</div><div class="line">                <span class="keyword">return</span> oldTab;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></div><div class="line">            <span class="comment">//否则，新容量为旧容量2倍，新阈值为旧阈值2倍</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果就阈值&gt;0，说明构造方法中指定了容量</span></div><div class="line">        <span class="comment">//用户自己设定了初始化大小</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)</div><div class="line">            newCap = oldThr;</div><div class="line">        <span class="comment">//初始化时没有指定阈值和容量，使用默认的容量16和阈值16*0.75=12</span></div><div class="line">        <span class="comment">//如果没使用,使用默认值初始化</span></div><div class="line">        <span class="keyword">else</span> &#123;              </div><div class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 计算新的resize上限</span></div><div class="line">    	<span class="comment">//用户自定义了map的初始化操作</span></div><div class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</div><div class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</div><div class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//更新阈值</span></div><div class="line">    	<span class="comment">//新的容量</span></div><div class="line">        threshold = newThr;</div><div class="line">        <span class="comment">//创建表,初始化或更新表</span></div><div class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</div><div class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</div><div class="line">        table = newTab;</div><div class="line">        <span class="comment">//如果属于容量扩展，rehash操作</span></div><div class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// 把每个bucket都移动到新的buckets中</span></div><div class="line">            <span class="comment">//遍历旧表</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</div><div class="line">                Node&lt;K,V&gt; e;</div><div class="line">                <span class="comment">//如果该桶处存在数据</span></div><div class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">//将旧表数据置为null，帮助gc</span></div><div class="line">                    oldTab[j] = <span class="keyword">null</span>;</div><div class="line">                    <span class="comment">//如果只有一个节点，直接在新表中赋值</span></div><div class="line">                    <span class="comment">//如果当前位置只有一个元素,直接移动到新的位置</span></div><div class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</div><div class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</div><div class="line">                    <span class="comment">//如果该节点已经为红黑树</span></div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</div><div class="line">                    <span class="comment">//如果没超过8个 是链表</span></div><div class="line">                    <span class="comment">//如果该桶处仍为链表</span></div><div class="line">                    <span class="comment">// 链表优化重hash的代码块</span></div><div class="line">                    <span class="keyword">else</span> &#123;</div><div class="line">                        </div><div class="line">                        </div><div class="line"><span class="comment">//下面这段暂时没有太明白，通过e.hash &amp; oldCap将链表分为两队，参考知乎上的一段解释 </span></div><div class="line"><span class="comment">/** </span></div><div class="line">* 把链表上的键值对按hash值分成lo和hi两串，lo串的新索引位置与原先相同[原先位 </div><div class="line">* j]，hi串的新索引位置为[原先位置j+oldCap]； </div><div class="line">* 链表的键值对加入lo还是hi串取决于 判断条件if ((e.hash &amp; oldCap) == 0)，因为* capacity是2的幂，所以oldCap为10...0的二进制形式，若判断条件为真，意味着 </div><div class="line">* oldCap为1的那位对应的hash位为0，对新索引的计算没有影响（新索引 </div><div class="line">* =hash&amp;(newCap-*1)，newCap=oldCap&lt;&lt;2）；若判断条件为假，则 oldCap为1的那位* 对应的hash位为1， </div><div class="line">* 即新索引=hash&amp;( newCap-1 )= hash&amp;( (oldCap&lt;&lt;2) - 1)，相当于多了10...0， </div><div class="line">* 即 oldCap </div><div class="line"></div><div class="line">* 例子： </div><div class="line">* 旧容量=16，二进制10000；新容量=32，二进制100000 </div><div class="line">* 旧索引的计算： </div><div class="line">* hash = xxxx xxxx xxxy xxxx </div><div class="line">* 旧容量-1 1111 </div><div class="line">* &amp;运算 xxxx </div><div class="line">* 新索引的计算： </div><div class="line">* hash = xxxx xxxx xxxy xxxx </div><div class="line">* 新容量-1 1 1111 </div><div class="line">* &amp;运算 y xxxx </div><div class="line">* 新索引 = 旧索引 + y0000，若判断条件为真，则y=0(lo串索引不变)，否则y=1(hi串 </div><div class="line">* 索引=旧索引+旧容量10000) </div><div class="line">*/  </div><div class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</div><div class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line">                        Node&lt;K,V&gt; next;</div><div class="line"><span class="comment">//此处的操作是这样子的 因为是扩容一倍的操作,所以与旧的容量进行与操作后只有两个值0 和 1</span></div><div class="line"><span class="comment">//如果是0就位置不变,如果是1就移动n+old的位置,</span></div><div class="line"><span class="comment">//个人认为这么做的好处是:</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 1.不会像之前1.7发生循环依赖的问题</div><div class="line">* 2.从概率的角度上来看可以均匀分配,(一般来说高位和低位比例差不多)</div><div class="line">* 3.提高效率</div><div class="line">*/</div><div class="line">                        <span class="keyword">do</span> &#123;</div><div class="line">                            next = e.next;</div><div class="line">                            <span class="comment">// 原索引</span></div><div class="line">                            <span class="comment">//如果和旧容量位运算后的值是0,记得当前节点和存放在链表的尾部</span></div><div class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</div><div class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</div><div class="line">                                    loHead = e;</div><div class="line">                                <span class="keyword">else</span></div><div class="line">                                    loTail.next = e;</div><div class="line">                                loTail = e;</div><div class="line">                            &#125;</div><div class="line">                            <span class="comment">//同上</span></div><div class="line">                            <span class="keyword">else</span> &#123;</div><div class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</div><div class="line">                                    hiHead = e;</div><div class="line">                                <span class="keyword">else</span></div><div class="line">                                    hiTail.next = e;</div><div class="line">                                hiTail = e;</div><div class="line">                            &#125;</div><div class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</div><div class="line">                        <span class="comment">// 原索引放到bucket里</span></div><div class="line">                        <span class="comment">//为0的还是存放在当前位置</span></div><div class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line">                            loTail.next = <span class="keyword">null</span>;</div><div class="line">                            newTab[j] = loHead;</div><div class="line">                        &#125;</div><div class="line">                        <span class="comment">// 原索引+oldCap放到bucket里</span></div><div class="line">                        <span class="comment">//为1的就放在扩容的j + oldCap那边去</span></div><div class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line">                            hiTail.next = <span class="keyword">null</span>;</div><div class="line">                            newTab[j + oldCap] = hiHead;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> newTab;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>因为不像Java8之前的HashMap有初始化操作,此处选择将初始化和扩容放在了一起,并且又增加了红黑树的概念,所以导致整个方法的判断次数非常多,也是这个方法比较庞大的主要原因.</p>
<p>值得一体的是,在扩容后重新计算位置的时候,对链表进行优化,有兴趣可以搜索一下<a href="https://link.juejin.im/?target=http%3A%2F%2Fifeve.com%2Fhashmap-infinite-loop%2F" target="_blank" rel="external">HashMap导致cpu百分之百的问题</a> 而在Java中通过巧妙的进行&amp;操作,然后获得高位是为0还是1.最终移动的位置就是低位的链表留在原地,高位的放在index+oldsize的地方就可以了,不用为每一个元素计算hash值,然后移动到对应的位置,再判断是否是链表,是否需要转换成树的操作.如下所示.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hashcode: <span class="number">1111111111111101212</span></div><div class="line">oldcap:   <span class="number">0000000000000010000</span></div></pre></td></tr></table></figure>
<p>很容易知道这个&amp;操作之后就是为0,因为oldcap都是2的倍数,只有高位为1,所以通过&amp;确认高位要比%取余高效. 此时在看一下上面的扩容操作也许就更清晰了.</p>
<p>resize()首先获取新容量以及新阈值，然后根据新容量创建新表。如果是扩容操作，则需要进行rehash操作，通过e.hash&amp;oldCap将链表分为两列，更好地均匀分布在新表中。 </p>
<h4 id="newNode-方法"><a href="#newNode-方法" class="headerlink" title="newNode()方法"></a>newNode()方法</h4><p>下面介绍一些newNode方法.就是新建一个节点.可以思考一下为什么要把newNode抽离出来?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(hash, key, value, next);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="putTreeVal-方法"><a href="#putTreeVal-方法" class="headerlink" title="putTreeVal() 方法"></a>putTreeVal() 方法</h4><p>添加节点到红黑树的方法是Java8中新添加的,需要满足链表的长度到8,才会转换成红黑树,其主要目的是防止某个下标处的链表太长,导致在找到的时候速度很慢,下面看一下实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//尝试着往树节点添加值</span></div><div class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,<span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</div><div class="line">    Class&lt;?&gt; kc = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">//找到根节点</span></div><div class="line">    TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</div><div class="line">        <span class="keyword">int</span> dir, ph; K pk;</div><div class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</div><div class="line">            dir = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</div><div class="line">            dir = <span class="number">1</span>;</div><div class="line">        <span class="comment">//存在的话直接返回,用于替换</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</div><div class="line">            <span class="keyword">return</span> p;</div><div class="line">        <span class="comment">//判断节点类型是否相同,不相同</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</div><div class="line">                  (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</div><div class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">//没有搜索过,搜索子节点,搜过了说明没有就跳过.</span></div><div class="line">            <span class="keyword">if</span> (!searched) &#123;</div><div class="line">                TreeNode&lt;K,V&gt; q, ch;</div><div class="line">                searched = <span class="keyword">true</span>;</div><div class="line">                <span class="comment">//去子节点去找</span></div><div class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;(q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">                     (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</div><div class="line">                    <span class="keyword">return</span> q;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//对比hash值,决定查找的方向</span></div><div class="line">            dir = tieBreakOrder(k, pk);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        TreeNode&lt;K,V&gt; xp = p;</div><div class="line">        <span class="comment">//找到子节点为空,就可以加进去,设置层级关系</span></div><div class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</div><div class="line">            Node&lt;K,V&gt; xpn = xp.next;</div><div class="line">            TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</div><div class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</div><div class="line">                xp.left = x;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                xp.right = x;</div><div class="line">            xp.next = x;</div><div class="line">            x.parent = x.prev = xp;</div><div class="line">            <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</div><div class="line">                ((TreeNode&lt;K,V&gt;)xpn).prev = x;</div><div class="line">            moveRootToFront(tab, balanceInsertion(root, x));</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里简单的梳理一下流程. 1.从根节点查找,找到了返回,如果没找到,找字节点 2.判断往哪个方向去查找 3.如果不存在,在子节点末端添加新节点</p>
<h4 id="split-方法"><a href="#split-方法" class="headerlink" title="split() 方法"></a>split() 方法</h4><p>树的 split() 方法,主要是扩容操作,重新结算位置需要分裂树,之前讲过,扩容会根据和旧 map 容量进行&amp;操作,移动高位为1的节点.并且验证新的节点列表是否需要重新转换成链表的形式.</p>
<p>当头节点是TreeNode时，将调用TreeNode的split方法将红黑树复制到新表中，代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</div><div class="line">            TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;<span class="comment">//就是上面的头结点e</span></div><div class="line">           <span class="comment">// 设置记录高低位的node,和链表一样都是计算高位是0还是1</span></div><div class="line">            <span class="comment">//与链表rehash时类似，将红黑树分为两部分</span></div><div class="line">            TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</div><div class="line">            TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</div><div class="line">            <span class="comment">//遍历</span></div><div class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</div><div class="line">                next = (TreeNode&lt;K,V&gt;)e.next;</div><div class="line">                e.next = <span class="keyword">null</span>;</div><div class="line">                <span class="comment">//还是和旧的容量做位运算,为0的放在lo中</span></div><div class="line">                <span class="comment">//分散规则与rehash中相同</span></div><div class="line">                <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</div><div class="line">                    <span class="comment">//判断是否为头部</span></div><div class="line">                    <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</div><div class="line">                        loHead = e;</div><div class="line">                    <span class="keyword">else</span></div><div class="line">                        loTail.next = e;</div><div class="line">                    loTail = e;</div><div class="line">                    ++lc;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//获取为1的放在hi中</span></div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</div><div class="line">                        hiHead = e;</div><div class="line">                    <span class="keyword">else</span></div><div class="line">                        hiTail.next = e;</div><div class="line">                    hiTail = e;</div><div class="line">                    ++hc;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">    		<span class="comment">//lo链表的处理</span></div><div class="line">            <span class="comment">//如果存在低端</span></div><div class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">//如果小于7,那么当做链表处理</span></div><div class="line">                <span class="comment">//如果分散后的红黑树节点小于等于6，将红黑树节点转换成链表节点</span></div><div class="line">                <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</div><div class="line">                    tab[index] = loHead.untreeify(map);</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">//转换成树</span></div><div class="line">                    tab[index] = loHead;</div><div class="line">                    <span class="comment">//将链表转换成红黑树</span></div><div class="line">                    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></div><div class="line">                        loHead.treeify(tab);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">    		<span class="comment">//同上</span></div><div class="line">            <span class="comment">//如果存在高端</span></div><div class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">//如果分散后的红黑树节点小于等于6，将红黑树节点转换成链表节点</span></div><div class="line">                <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</div><div class="line">                    tab[index + bit] = hiHead.untreeify(map);</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    tab[index + bit] = hiHead;</div><div class="line">                    <span class="comment">//将链表转换成红黑树节点</span></div><div class="line">                    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</div><div class="line">                        hiHead.treeify(tab);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"><span class="comment">//把树转换成链表</span></div><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</div><div class="line">      Node&lt;K,V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);</div><div class="line">      <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</div><div class="line">        hd = p;</div><div class="line">      <span class="keyword">else</span></div><div class="line">        tl.next = p;</div><div class="line">      tl = p;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> hd;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>TreeNode的split方法首先将头节点从头开始遍历，区分出两条单链表，再根据如果节点数小于等于6，那么将单链表的每个TreeNode转换成Node节点；否则将单链表转换成红黑树结构。<br>至此，resize()方法结束。需要注意的是rehash时，由于容量扩大一倍，本来一条链表有可能会分成两条链表，而如果将红黑树结构复制到新表时，有可能需要完成红黑树到单链表的转换。</p>
<h4 id="treeifyBin-方法"><a href="#treeifyBin-方法" class="headerlink" title="treeifyBin()方法"></a>treeifyBin()方法</h4><p>treeifyBin()方法将表中某一个桶处的单链表结果转换成红黑树结构，其实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</div><div class="line">       <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</div><div class="line">       <span class="comment">//如果哈希表不存在，或者哈希表尺寸小于64，进行resize()扩容</span></div><div class="line">       <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</div><div class="line">           resize();</div><div class="line">       <span class="comment">//如果桶处头节点不为null</span></div><div class="line">       <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line">           TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</div><div class="line">           <span class="comment">//将单链表节点转换成TreeNode结构的单链表</span></div><div class="line">           <span class="keyword">do</span> &#123;</div><div class="line">               <span class="comment">//将Node转换成TreeNode</span></div><div class="line">               TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</div><div class="line">               <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</div><div class="line">                   hd = p;</div><div class="line">               <span class="keyword">else</span> &#123;</div><div class="line">                   p.prev = tl;</div><div class="line">                   tl.next = p;</div><div class="line">               &#125;</div><div class="line">               tl = p;</div><div class="line">           &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">           <span class="comment">//调用treeify将该TreeNode结构的单链表转换成红黑树</span></div><div class="line">           <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</div><div class="line">               hd.treeify(tab);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>上述操作做了这些事:</p>
<ul>
<li>根据哈希表中元素个数确定是扩容还是树形化</li>
<li>如果是树形化<ul>
<li>遍历桶中的元素，创建相同个数的树形节点，复制内容，建立起联系</li>
<li>然后让桶第一个元素指向新建的树头结点，替换桶的链表内容为树形内容</li>
</ul>
</li>
</ul>
<h4 id="treeify-方法"><a href="#treeify-方法" class="headerlink" title="treeify() 方法"></a>treeify() 方法</h4><p>但是我们发现，之前的操作并没有设置红黑树的颜色值，现在得到的只能算是个二叉树。在 最后调用树形节点 hd.treeify(tab) 方法进行塑造红黑树，来看看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node[] tab)</span> </span>&#123;</div><div class="line">    TreeNode root = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">for</span> (TreeNode x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</div><div class="line">        next = (TreeNode)x.next;</div><div class="line">        x.left = x.right = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="comment">//头回进入循环，确定头结点，为黑色</span></div><div class="line">            x.parent = <span class="keyword">null</span>;</div><div class="line">            x.red = <span class="keyword">false</span>;</div><div class="line">            root = x;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;  <span class="comment">//后面进入循环走的逻辑，x 指向树中的某个节点</span></div><div class="line">            K k = x.key;</div><div class="line">            <span class="keyword">int</span> h = x.hash;</div><div class="line">            Class kc = <span class="keyword">null</span>;</div><div class="line">            <span class="comment">//又一个循环，从根节点开始，遍历所有节点跟当前节点 x 比较，调整位置，有点像冒泡排序</span></div><div class="line">            <span class="keyword">for</span> (TreeNode p = root;;) &#123;</div><div class="line">                <span class="keyword">int</span> dir, ph;        <span class="comment">//这个 dir </span></div><div class="line">                K pk = p.key;</div><div class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)  <span class="comment">//当比较节点的哈希值比 x 大时， dir 为 -1</span></div><div class="line">                    dir = -<span class="number">1</span>;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)  <span class="comment">//哈希值比 x 小时 dir 为 1</span></div><div class="line">                    dir = <span class="number">1</span>;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</div><div class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</div><div class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</div><div class="line">                    <span class="comment">// 如果比较节点的哈希值、 x </span></div><div class="line">                    dir = tieBreakOrder(k, pk);</div><div class="line"></div><div class="line">                    <span class="comment">//把 当前节点变成 x 的父亲</span></div><div class="line">                    <span class="comment">//如果当前比较节点的哈希值比 x 大，x 就是左孩子，否则 x 是右孩子 </span></div><div class="line">                TreeNode xp = p;</div><div class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</div><div class="line">                    x.parent = xp;</div><div class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</div><div class="line">                        xp.left = x;</div><div class="line">                    <span class="keyword">else</span></div><div class="line">                        xp.right = x;</div><div class="line">                    root = balanceInsertion(root, x);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    moveRootToFront(tab, root);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="put操作总结"><a href="#put操作总结" class="headerlink" title="put操作总结"></a>put操作总结</h3><p>当调用put插入一个键值对时，在表为空时，会创建表。如果桶为空时，直接插入节点，如果桶不为空时，则需要对当前桶中包含的结构做判断，如果已是红黑树结构，那么需要使用红黑树的插入方法；如果不是红黑树结构，则需要遍历链表，如果添加到链表后端，如果该条链表达到了8，那么需要将该链表转换成红黑树，从treeifyBin方法可以看到，当容量小于64时，不会进行红黑树转换，只会扩容。当成功新加一个桶，那么需要将尺寸和阈值进行判断，是否需要进行resize()操作。</p>
<h3 id="get-K-k-操作"><a href="#get-K-k-操作" class="headerlink" title="get(K k)操作"></a>get(K k)操作</h3><p>get(K k)根据键得到值，如果值不存在，那么返回null。其实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Node&lt;K,V&gt; e;</div><div class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//根据键的hash值和键得到对应节点</span></div><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</div><div class="line">        <span class="comment">//可以从桶中得到对应hash值的第一个节点</span></div><div class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//检查首节点，如果首节点匹配，那么直接返回首节点</span></div><div class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></div><div class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                <span class="keyword">return</span> first;</div><div class="line">            <span class="comment">//如果首节点还有后续节点</span></div><div class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">//如果首节点是红黑树节点，调用getTreeNode()方法</span></div><div class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class="line">                <span class="comment">//首节点是链表结构，从前往后遍历</span></div><div class="line">                <span class="keyword">do</span> &#123;</div><div class="line">                    <span class="comment">//一旦匹配，返回节点</span></div><div class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                        <span class="keyword">return</span> e;</div><div class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>从上面代码可以看到getNode()方法中有多种情况：<br>\1. 表为空或表的长度为0或表中不存在key对应的hash值桶，那么返回null<br>\2. 如果表中有key对应hash值的桶，得到首节点，如果首节点匹配，那么直接返回；<br>\3. 如果首节点不匹配，并且没有后续节点，那么返回null<br>\4. 如果首节点有后续节点并且首节点是TreeNode,调用getTreeNode方法寻找节点<br>\5. 如果首节点有后续节点并且是链表结构，那么从前往后遍历，一旦找到则返回节点，否则返回null</p>
<h3 id="remove-操作"><a href="#remove-操作" class="headerlink" title="remove()操作"></a>remove()操作</h3><p>remove(K k)用于根据键值删除键值对，如果哈希表中存在该键，那么返回键对应的值，否则返回null。其实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Node&lt;K,V&gt; e;</div><div class="line">        <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</div><div class="line">            <span class="keyword">null</span> : e.value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//按照hash和key删除节点，如果不存在节点，则返回null</span></div><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></div><div class="line">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable) &#123;</div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</div><div class="line">        <span class="comment">//如果哈希表不为空并且存在桶与hash值匹配,p为桶中的头节点</span></div><div class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">            (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line">            Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</div><div class="line">            <span class="comment">//case 1：如果头节点匹配</span></div><div class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                node = p;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="comment">//case2：如果头节点不匹配，且头节点是TreeNode，即桶中的结构为红黑树结构</span></div><div class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//case 3:如果头节点不匹配，且头节点是Node，即桶中的结构为链表结构，遍历链表</span></div><div class="line">                    <span class="keyword">do</span> &#123;</div><div class="line">                        <span class="comment">//一旦匹配，跳出循环</span></div><div class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                            ((k = e.key) == key ||</div><div class="line">                             (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</div><div class="line">                            node = e;</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                        &#125;</div><div class="line">                        p = e;</div><div class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//如果存在待删除节点节点</span></div><div class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</div><div class="line">                                 (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</div><div class="line">                <span class="comment">//如果节点是TreeNode，使用红黑树的方法</span></div><div class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</div><div class="line">                <span class="comment">//如果待删除节点是头节点，更改桶中的头节点即可</span></div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</div><div class="line">                    tab[index] = node.next;</div><div class="line">                <span class="comment">//在链表遍历过程中，p代表node节点的前驱节点</span></div><div class="line">                <span class="keyword">else</span></div><div class="line">                    p.next = node.next;</div><div class="line">                ++modCount;</div><div class="line">                --size;</div><div class="line">                <span class="comment">//子类实现</span></div><div class="line">                afterNodeRemoval(node);</div><div class="line">                <span class="keyword">return</span> node;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>从上面的代码可以看出，removeNode()方法首先是找到待删除的节点，如果存在待删除节点，接下来再执行删除操作。查询时流程与getNode()方法的流程类似，只不过多了在遍历链表时还需要保存前驱节点，因为后面删除时要用到（单链表结构）。删除节点时就比较简单了，三种情况三种处理方式,分别是：<br>\1. 如果待删除节点是TreeNode，那么调用removeTreeNode()方法<br>\2. 如果待删除节点是Node，并且待删除节点就是头节点，那么将头节点更改为原有节点的下一个节点就可以了<br>\3. 如果待删除节点是Node且待删除节点不是头节点，那么将遍历过程中保存的前驱节点p的后继节点设为node的后继节点就可以了</p>
<h3 id="红黑树中查找元素-getTreeNode"><a href="#红黑树中查找元素-getTreeNode" class="headerlink" title="红黑树中查找元素 getTreeNode()"></a>红黑树中查找元素 getTreeNode()</h3><p>HashMap 的查找方法是 get():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Node e;</div><div class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它通过计算指定 key 的哈希值后，调用内部方法 getNode()；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> Node <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</div><div class="line">    Node[] tab; Node first, e; <span class="keyword">int</span> n; K k;</div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></div><div class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            <span class="keyword">return</span> first;</div><div class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                <span class="keyword">return</span> ((TreeNode)first).getTreeNode(hash, key);</div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">return</span> e;</div><div class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个 getNode() 方法就是根据哈希表元素个数与哈希值求模（<code>使用的公式是 (n - 1) &amp;hash</code>）得到 key 所在的桶的头结点，如果头节点恰好是红黑树节点，就调用红黑树节点的 getTreeNode() 方法，否则就遍历链表节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> TreeNode <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>getTreeNode 方法使通过调用树形节点的 find() 方法进行查找：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//从根节点根据 哈希值和 key 进行查找</span></div><div class="line"><span class="function"><span class="keyword">final</span> TreeNode <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class kc)</span> </span>&#123;</div><div class="line">    TreeNode p = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="keyword">int</span> ph, dir; K pk;</div><div class="line">        TreeNode pl = p.left, pr = p.right, q;</div><div class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</div><div class="line">            p = pl;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</div><div class="line">            p = pr;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</div><div class="line">            <span class="keyword">return</span> p;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</div><div class="line">            p = pr;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</div><div class="line">            p = pl;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</div><div class="line">                  (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</div><div class="line">                 (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</div><div class="line">            p = (dir &lt; <span class="number">0</span>) ? pl : pr;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> q;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            p = pl;</div><div class="line">    &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于之前添加时已经保证这个树是有序的，因此查找时基本就是折半查找，效率很高。</p>
<p>这里和插入时一样，如果对比节点的哈希值和要查找的哈希值相等，就会判断 key 是否相等，相等就直接返回（也没有判断值哎）；不相等就从子树中递归查找。</p>
<h2 id="HashMap总结"><a href="#HashMap总结" class="headerlink" title="HashMap总结"></a>HashMap总结</h2><p>至此，我们分析完了HashMap的主要方法：构造器、put、get和remove。只需要明白JDK1.8的HashMap底层结构，那么就很好理解了。需要注意的是什么时候应该将链表结构转换成红黑树结构，什么时候又应该将红黑树结构重新转换成链表结构，本文没有具体解释有关红黑树的结构，但是这并不影响理解HashMap的基本原理。<br><strong>另外需要注意的是，本文的源码是基于JDK1.8的。</strong></p>
]]></content>
      
        <categories>
            
            <category> HashMap </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础数据类型 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HashMap 的扩容机制]]></title>
      <url>/2018/03/06/HashMap1.7%20%E5%92%8C%201.8%20%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E7%9A%84%E6%AF%94%E8%BE%83/</url>
      <content type="html"><![CDATA[<h1 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h1><p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p>
<p>我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> <span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   <span class="comment">//传入新的容量</span></div><div class="line"> <span class="number">2</span>     Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></div><div class="line"> <span class="number">3</span>     <span class="keyword">int</span> oldCapacity = oldTable.length;         </div><div class="line"> <span class="number">4</span>     <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></div><div class="line"> <span class="number">5</span>         threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></div><div class="line"> <span class="number">6</span>         <span class="keyword">return</span>;</div><div class="line"> <span class="number">7</span>     &#125;</div><div class="line"> <span class="number">8</span>  </div><div class="line"> <span class="number">9</span>     Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></div><div class="line"><span class="number">10</span>     transfer(newTable);                         <span class="comment">//！！将数据转移到新的Entry数组里</span></div><div class="line"><span class="number">11</span>     table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></div><div class="line"><span class="number">12</span>     threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);<span class="comment">//修改阈值</span></div><div class="line"><span class="number">13</span> &#125;</div></pre></td></tr></table></figure>
<p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> <span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>     Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></div><div class="line"> <span class="number">3</span>     <span class="keyword">int</span> newCapacity = newTable.length;</div><div class="line"> <span class="number">4</span>     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></div><div class="line"> <span class="number">5</span>         Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></div><div class="line"> <span class="number">6</span>         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">7</span>             src[j] = <span class="keyword">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></div><div class="line"> <span class="number">8</span>             <span class="keyword">do</span> &#123;</div><div class="line"> <span class="number">9</span>                 Entry&lt;K,V&gt; next = e.next;</div><div class="line"><span class="number">10</span>                 <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">//！！重新计算每个元素在数组中的位置</span></div><div class="line"><span class="number">11</span>                 e.next = newTable[i]; <span class="comment">//标记[1]</span></div><div class="line"><span class="number">12</span>                 newTable[i] = e;      <span class="comment">//将元素放在数组上</span></div><div class="line"><span class="number">13</span>                 e = next;             <span class="comment">//访问下一个Entry链上的元素</span></div><div class="line"><span class="number">14</span>             &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</div><div class="line"><span class="number">15</span>         &#125;</div><div class="line"><span class="number">16</span>     &#125;</div><div class="line"><span class="number">17</span> &#125;</div></pre></td></tr></table></figure>
<p>newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p>
<p>下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。</p>
<p><img src="https://tech.meituan.com/img/java-hashmap/jdk1.7%E6%89%A9%E5%AE%B9%E4%BE%8B%E5%9B%BE.png" alt="jdk1.7扩容例图"></p>
<p>下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p>
<p><img src="https://tech.meituan.com/img/java-hashmap/hashMap%201.8%20%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%BE%8B%E5%9B%BE1.png" alt="hashMap 1.8 哈希算法例图1"></p>
<p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p>
<p><img src="https://tech.meituan.com/img/java-hashmap/hashMap%201.8%20%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%BE%8B%E5%9B%BE2.png" alt="hashMap 1.8 哈希算法例图2"></p>
<p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p>
<p><img src="https://tech.meituan.com/img/java-hashmap/jdk1.8%20hashMap%E6%89%A9%E5%AE%B9%E4%BE%8B%E5%9B%BE.png" alt="jdk1.8 hashMap扩容例图"></p>
<p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"> <span class="number">1</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</div><div class="line"> <span class="number">2</span>     Node&lt;K,V&gt;[] oldTab = table;</div><div class="line"> <span class="number">3</span>     <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</div><div class="line"> <span class="number">4</span>     <span class="keyword">int</span> oldThr = threshold;</div><div class="line"> <span class="number">5</span>     <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</div><div class="line"> <span class="number">6</span>     <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</div><div class="line"> <span class="number">7</span>         <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></div><div class="line"> <span class="number">8</span>         <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line"> <span class="number">9</span>             threshold = Integer.MAX_VALUE;</div><div class="line"><span class="number">10</span>             <span class="keyword">return</span> oldTab;</div><div class="line"><span class="number">11</span>         &#125;</div><div class="line"><span class="number">12</span>         <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></div><div class="line"><span class="number">13</span>         <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line"><span class="number">14</span>                  oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line"><span class="number">15</span>             newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></div><div class="line"><span class="number">16</span>     &#125;</div><div class="line"><span class="number">17</span>     <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></div><div class="line"><span class="number">18</span>         newCap = oldThr;</div><div class="line"><span class="number">19</span>     <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></div><div class="line"><span class="number">20</span>         newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line"><span class="number">21</span>         newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line"><span class="number">22</span>     &#125;</div><div class="line"><span class="number">23</span>     <span class="comment">// 计算新的resize上限</span></div><div class="line"><span class="number">24</span>     <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</div><div class="line"><span class="number">25</span> </div><div class="line"><span class="number">26</span>         <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</div><div class="line"><span class="number">27</span>         newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</div><div class="line"><span class="number">28</span>                   (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</div><div class="line"><span class="number">29</span>     &#125;</div><div class="line"><span class="number">30</span>     threshold = newThr;</div><div class="line"><span class="number">31</span>     <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>，<span class="string">"unchecked"</span>&#125;)</div><div class="line"><span class="number">32</span>         Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</div><div class="line"><span class="number">33</span>     table = newTab;</div><div class="line"><span class="number">34</span>     <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">35</span>         <span class="comment">// 把每个bucket都移动到新的buckets中</span></div><div class="line"><span class="number">36</span>         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</div><div class="line"><span class="number">37</span>             Node&lt;K,V&gt; e;</div><div class="line"><span class="number">38</span>             <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">39</span>                 oldTab[j] = <span class="keyword">null</span>;</div><div class="line"><span class="number">40</span>                 <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</div><div class="line"><span class="number">41</span>                     newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</div><div class="line"><span class="number">42</span>                 <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</div><div class="line"><span class="number">43</span>                     ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</div><div class="line"><span class="number">44</span>                 <span class="keyword">else</span> &#123; <span class="comment">// 链表优化重hash的代码块</span></div><div class="line"><span class="number">45</span>                     Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</div><div class="line"><span class="number">46</span>                     Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line"><span class="number">47</span>                     Node&lt;K,V&gt; next;</div><div class="line"><span class="number">48</span>                     <span class="keyword">do</span> &#123;</div><div class="line"><span class="number">49</span>                         next = e.next;</div><div class="line"><span class="number">50</span>                         <span class="comment">// 原索引</span></div><div class="line"><span class="number">51</span>                         <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</div><div class="line"><span class="number">52</span>                             <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</div><div class="line"><span class="number">53</span>                                 loHead = e;</div><div class="line"><span class="number">54</span>                             <span class="keyword">else</span></div><div class="line"><span class="number">55</span>                                 loTail.next = e;</div><div class="line"><span class="number">56</span>                             loTail = e;</div><div class="line"><span class="number">57</span>                         &#125;</div><div class="line"><span class="number">58</span>                         <span class="comment">// 原索引+oldCap</span></div><div class="line"><span class="number">59</span>                         <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">60</span>                             <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</div><div class="line"><span class="number">61</span>                                 hiHead = e;</div><div class="line"><span class="number">62</span>                             <span class="keyword">else</span></div><div class="line"><span class="number">63</span>                                 hiTail.next = e;</div><div class="line"><span class="number">64</span>                             hiTail = e;</div><div class="line"><span class="number">65</span>                         &#125;</div><div class="line"><span class="number">66</span>                     &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</div><div class="line"><span class="number">67</span>                     <span class="comment">// 原索引放到bucket里</span></div><div class="line"><span class="number">68</span>                     <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">69</span>                         loTail.next = <span class="keyword">null</span>;</div><div class="line"><span class="number">70</span>                         newTab[j] = loHead;</div><div class="line"><span class="number">71</span>                     &#125;</div><div class="line"><span class="number">72</span>                     <span class="comment">// 原索引+oldCap放到bucket里</span></div><div class="line"><span class="number">73</span>                     <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">74</span>                         hiTail.next = <span class="keyword">null</span>;</div><div class="line"><span class="number">75</span>                         newTab[j + oldCap] = hiHead;</div><div class="line"><span class="number">76</span>                     &#125;</div><div class="line"><span class="number">77</span>                 &#125;</div><div class="line"><span class="number">78</span>             &#125;</div><div class="line"><span class="number">79</span>         &#125;</div><div class="line"><span class="number">80</span>     &#125;</div><div class="line"><span class="number">81</span>     <span class="keyword">return</span> newTab;</div><div class="line"><span class="number">82</span> &#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> HashMap </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础数据类型 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HashMap 的线程安全]]></title>
      <url>/2018/03/05/HashMap%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/</url>
      <content type="html"><![CDATA[<h1 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h1><p>在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。那么为什么说HashMap是线程不安全的，下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class HashMapInfiniteLoop &#123;  </div><div class="line"></div><div class="line">    private static HashMap&lt;Integer,String&gt; map = new HashMap&lt;Integer,String&gt;(2，0.75f);  </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        map.put(5， "C");  </div><div class="line"></div><div class="line">        new Thread("Thread1") &#123;  </div><div class="line">            public void run() &#123;  </div><div class="line">                map.put(7, "B");  </div><div class="line">                System.out.println(map);  </div><div class="line">            &#125;;  </div><div class="line">        &#125;.start();  </div><div class="line">        new Thread("Thread2") &#123;  </div><div class="line">            public void run() &#123;  </div><div class="line">                map.put(3, "A);  </div><div class="line">                System.out.println(map);  </div><div class="line">            &#125;;  </div><div class="line">        &#125;.start();        </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。</p>
<p>通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。</p>
<p><img src="https://tech.meituan.com/img/java-hashmap/jdk1.7%20hashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF%E4%BE%8B%E5%9B%BE1.png" alt="jdk1.7 hashMap死循环例图1"></p>
<p>注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。</p>
<p>线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。</p>
<p><img src="https://tech.meituan.com/img/java-hashmap/jdk1.7%20hashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF%E4%BE%8B%E5%9B%BE2.png" alt="jdk1.7 hashMap死循环例图2"></p>
<p><img src="https://tech.meituan.com/img/java-hashmap/jdk1.7%20hashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF%E4%BE%8B%E5%9B%BE3.png" alt="jdk1.7 hashMap死循环例图3"></p>
<p>e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。</p>
<p><img src="https://tech.meituan.com/img/java-hashmap/jdk1.7%20hashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF%E4%BE%8B%E5%9B%BE4.png" alt="jdk1.7 hashMap死循环例图4"></p>
<p>于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。</p>
<h1 id="JDK1-8与JDK1-7的性能对比"><a href="#JDK1-8与JDK1-7的性能对比" class="headerlink" title="JDK1.8与JDK1.7的性能对比"></a><strong>JDK1.8与JDK1.7的性能对比</strong></h1><p>HashMap中，如果key经过hash算法得出的数组索引位置全部不相同，即Hash算法非常好，那样的话，getKey方法的时间复杂度就是O(1)，如果Hash算法技术的结果碰撞非常多，假如Hash算极其差，所有的Hash算法结果得出的索引位置一样，那样所有的键值对都集中到一个桶中，或者在一个链表中，或者在一个红黑树中，时间复杂度分别为O(n)和O(lgn)。 鉴于JDK1.8做了多方面的优化，总体性能优于JDK1.7，下面我们从两个方面用例子证明这一点。</p>
<h2 id="Hash较均匀的情况"><a href="#Hash较均匀的情况" class="headerlink" title="Hash较均匀的情况"></a>Hash较均匀的情况</h2><p>为了便于测试，我们先写一个类Key，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</div><div class="line"></div><div class="line">    Key(<span class="keyword">int</span> value) &#123;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Key o)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.value, o.value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        Key key = (Key) o;</div><div class="line">        <span class="keyword">return</span> value == key.value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个类复写了equals方法，并且提供了相当好的hashCode函数，任何一个值的hashCode都不会相同，因为直接使用value当做hashcode。为了避免频繁的GC，我将不变的Key实例缓存了起来，而不是一遍一遍的创建它们。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Keys</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_KEY = <span class="number">10_000_000</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Key[] KEYS_CACHE = <span class="keyword">new</span> Key[MAX_KEY];</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_KEY; ++i) &#123;</div><div class="line">            KEYS_CACHE[i] = <span class="keyword">new</span> Key(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Key <span class="title">of</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> KEYS_CACHE[value];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在开始我们的试验，测试需要做的仅仅是，创建不同size的HashMap（1、10、100、……10000000），屏蔽了扩容的情况，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> mapSize)</span> </span>&#123;</div><div class="line"></div><div class="line">     HashMap&lt;Key, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Key,Integer&gt;(mapSize);</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mapSize; ++i) &#123;</div><div class="line">         map.put(Keys.of(i), i);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">long</span> beginTime = System.nanoTime(); <span class="comment">//获取纳秒</span></div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mapSize; i++) &#123;</div><div class="line">         map.get(Keys.of(i));</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">long</span> endTime = System.nanoTime();</div><div class="line">     System.out.println(endTime - beginTime);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">10</span>;i&lt;= <span class="number">1000</span> <span class="number">0000</span>;i*= <span class="number">10</span>)&#123;</div><div class="line">         test(i);</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>在测试中会查找不同的值，然后度量花费的时间，为了计算getKey的平均时间，我们遍历所有的get方法，计算总的时间，除以key的数量，计算一个平均值，主要用来比较，绝对值可能会受很多环境因素的影响。结果如下：</p>
<p><img src="https://tech.meituan.com/img/java-hashmap/%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%E8%A1%A81.png" alt="性能比较表1.png"></p>
<p>通过观测测试结果可知，JDK1.8的性能要高于JDK1.7 15%以上，在某些size的区域上，甚至高于100%。由于Hash算法较均匀，JDK1.8引入的红黑树效果不明显，下面我们看看Hash不均匀的的情况。</p>
<h2 id="Hash极不均匀的情况"><a href="#Hash极不均匀的情况" class="headerlink" title="Hash极不均匀的情况"></a>Hash极不均匀的情况</h2><p>假设我们又一个非常差的Key，它们所有的实例都返回相同的hashCode值。这是使用HashMap最坏的情况。代码修改如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Key implements Comparable&lt;Key&gt; &#123;</div><div class="line"></div><div class="line">    //...</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int hashCode() &#123;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>仍然执行main方法，得出的结果如下表所示：</p>
<p><img src="https://tech.meituan.com/img/java-hashmap/%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%E8%A1%A82.png" alt="性能比较表2.png"></p>
<p>从表中结果中可知，随着size的变大，JDK1.7的花费时间是增长的趋势，而JDK1.8是明显的降低趋势，并且呈现对数增长稳定。当一个链表太长的时候，HashMap会动态的将它替换成一个红黑树，这话的话会将时间复杂度从O(n)降为O(logn)。hash算法均匀和不均匀所花费的时间明显也不相同，这两种情况的相对比较，可以说明一个好的hash算法的重要性。</p>
<p>​      测试环境：处理器为2.2 GHz Intel Core i7，内存为16 GB 1600 MHz DDR3，SSD硬盘，使用默认的JVM参数，运行在64位的OS X 10.10.1上。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h1><p>(1) 扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。</p>
<p>(2) 负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。</p>
<p>(3) HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。</p>
<p>(4) JDK1.8引入红黑树大程度优化了HashMap的性能。</p>
<p>(5) 还没升级JDK1.8的，现在开始升级吧。HashMap的性能提升仅仅是JDK1.8的冰山一角。</p>
]]></content>
      
        <categories>
            
            <category> HashMap </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础数据类型 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ConcurrentHashMap 的锁定分离技术]]></title>
      <url>/2018/03/05/ConcurrentHashMap%E7%9A%84%E9%94%81%E5%88%86%E7%A6%BB%E6%8A%80%E6%9C%AF/</url>
      <content type="html"><![CDATA[<h1 id="ConcurrentHashMap的锁分离技术"><a href="#ConcurrentHashMap的锁分离技术" class="headerlink" title="ConcurrentHashMap的锁分离技术"></a>ConcurrentHashMap的锁分离技术</h1><p><img src="https://images2015.cnblogs.com/blog/756320/201603/756320-20160321173412058-376309614.png" alt="img"></p>
<p>​    对比上图，HashTable实现锁的方式是锁整个hash表，而ConcurrentHashMap的实现方式是<strong>锁桶（</strong>简单理解就是将整个hash表想象成一大缸水，现在将这大缸里的水分到了几个水桶里，hashTable每次都锁定这个大缸，而ConcurrentHashMap则每次只锁定其中一个 桶<strong>）。</strong></p>
<p>​    ConcurrentHashMap将hash表分为16个桶（默认值），诸如get,put,remove等常用操作只锁当前需要用到的桶。试想，原来 只能一个线程进入，现在却能同时16个写线程进入，并发性的提升是显而易见的。</p>
<p><img src="https://images2015.cnblogs.com/blog/756320/201603/756320-20160321174511354-2060663727.png" alt="img"></p>
<p>​    值得一提的是当对ConcurrentHashMap进行remove操作时，并不是进行简单的节点删除操作，对比上图，当对ConcurrentHashMap的一个segment也就是一个桶中的节点进行remove后，例如删除节点C，C节点实际并没有被销毁，而是将C节点前面的反转并拷贝到新的链表中，C节点后面的不需要被克隆。这样来保持并发的读线程不受并发的写线程的干扰。例如现在有一个读线程读到了A节点，写线程把C删掉了，但是看上图，读线程仍然可以继续读下去；当然，如果在删除C之前读线程读到的是D，那么更不会有影响。</p>
<p>​    根据上面所提到的ConcurrentHashMap中删除一个节点并不会立刻被读线程感受到的效果，就是传说中的<strong>弱一致性</strong>，所以ConcurrentHashMap的迭代器是弱一致性迭代器</p>
]]></content>
      
        <categories>
            
            <category> ConcurrentHashMap </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础数据类型 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基础面试题]]></title>
      <url>/2018/01/21/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="基础面试题"><a href="#基础面试题" class="headerlink" title="基础面试题"></a>基础面试题</h1><h2 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h2><p>以下各方面知识点的面试题，是为了将要出来工作的小师妹和小师弟而精心整理的。希望对你们都帮助。这些面试题都是很基础的，希望你们能够好好利用起来。有问题，或者不对的地方欢迎给我留言哈！</p>
<a id="more"></a>
<h2 id="forward-和redirect的区别"><a href="#forward-和redirect的区别" class="headerlink" title="forward 和redirect的区别"></a>forward 和redirect的区别</h2><p>forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。</p>
<p>redirect就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求，所以session,request参数都可以获取。</p>
<h2 id="int-和-Integer-有什么区别"><a href="#int-和-Integer-有什么区别" class="headerlink" title="int 和 Integer 有什么区别"></a>int 和 Integer 有什么区别</h2><p>Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int是java的原始数据类型，Integer是java为int提供的封装类。Java为每个原始类型提供了封装类。<br>原始类型封装类,booleanBoolean,charCharacter,byteByte,shortShort,intInteger,longLong,floatFloat,doubleDouble<br>引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为 null，而原始类型实例变量的缺省值与它们的类型有关</p>
<h2 id="error和exception有什么区别"><a href="#error和exception有什么区别" class="headerlink" title="error和exception有什么区别"></a>error和exception有什么区别</h2><p>error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。</p>
<h2 id="Overload和Override区别，Overloaded方法可以改变返回值的类型吗"><a href="#Overload和Override区别，Overloaded方法可以改变返回值的类型吗" class="headerlink" title="Overload和Override区别，Overloaded方法可以改变返回值的类型吗"></a>Overload和Override区别，Overloaded方法可以改变返回值的类型吗</h2><p>方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被”屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。</p>
<h2 id="java中有哪些集合，主要方法有哪些"><a href="#java中有哪些集合，主要方法有哪些" class="headerlink" title="java中有哪些集合，主要方法有哪些"></a>java中有哪些集合，主要方法有哪些</h2><p>主要有LinkedList，ArrayList，Vector等。下面是详细：<br>Collection<br>├List<br>│├LinkedList<br>│├ArrayList<br>│└Vector<br>│ └Stack<br>└Set<br>Map<br>├Hashtable<br>├HashMap<br>└WeakHashMap<br>最常用的集合类是 List 和 Map。 List 的具体实现包括 ArrayList 和 Vector，它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。 List 适用于按数值索引访问元素的情形。 Map 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作“键”和“值”）其中每个键映射到一个值。</p>
<h2 id="List、Map、Set接口，存取元素时各自特点"><a href="#List、Map、Set接口，存取元素时各自特点" class="headerlink" title="List、Map、Set接口，存取元素时各自特点"></a>List、Map、Set接口，存取元素时各自特点</h2><p>List 以特定次序来持有元素，可有重复元素。Set 无法拥有重复元素,内部排序。Map 保存key-value值，value可多值。<br>  List的遍历： List接口有size()和get()方法，用这两个方法可以实现对List的遍历。size()方法得到List中的元素个数。get()方法取得某个位置上的元素</p>
<h2 id="HashMap与HashTable的区别"><a href="#HashMap与HashTable的区别" class="headerlink" title="HashMap与HashTable的区别"></a>HashMap与HashTable的区别</h2><p>1、HashMap是非线程安全的，HashTable是线程安全的。</p>
<p>2、HashMap的键和值都允许有null值存在，而HashTable则不行。</p>
<p>3、因为线程安全的问题，HashMap效率比HashTable的要高。<br>HashMap的实现机制：<br>维护一个每个元素是一个链表的数组，而且链表中的每个节点是一个Entry[]键值对的数据结构。<br>实现了数组+链表的特性，查找快，插入删除也快。<br>对于每个key,他对应的数组索引下标是 int i = hash(key.hashcode)&amp;(len-1);<br>每个新加入的节点放在链表首，然后该新加入的节点指向原链表首</p>
<h2 id="HashMap，ConcurrentHashMap与LinkedHashMap的区别"><a href="#HashMap，ConcurrentHashMap与LinkedHashMap的区别" class="headerlink" title="HashMap，ConcurrentHashMap与LinkedHashMap的区别"></a>HashMap，ConcurrentHashMap与LinkedHashMap的区别</h2><p>ConcurrentHashMap是使用了锁分段技术技术来保证线程安全的，锁分段技术：首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问<br>ConcurrentHashMap 是在每个段（segment）中线程安全的<br>LinkedHashMap维护一个双链表，可以将里面的数据按写入的顺序读出</p>
<p>ConcurrentHashMap应用场景<br>1：ConcurrentHashMap的应用场景是高并发，但是并不能保证线程安全，而同步的HashMap和HashMap的是锁住整个容器，而加锁之后ConcurrentHashMap不需要锁住整个容器，只需要锁住对应的Segment就好了，所以可以保证高并发同步访问，提升了效率。<br>2：可以多线程写。<br>ConcurrentHashMap把HashMap分成若干个Segmenet<br>1.get时，不加锁，先定位到segment然后在找到头结点进行读取操作。而value是volatile变量，所以可以保证在竞争条件时保证读取最新的值，如果读到的value是null，则可能正在修改，那么久调用ReadValueUnderLock函数，加锁保证读到的数据是正确的。</p>
<p>2.Put时会加锁，一律添加到hash链的头部。</p>
<p>3.Remove时也会加锁，由于next是final类型不可改变，所以必须把删除的节点之前的节点都复制一遍。</p>
<p>4.ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对Hash表的不同Segment进行的修改。<br>ConcurrentHashMap的应用场景是高并发，但是并不能保证线程安全，而同步的HashMap和HashTable的是锁住整个容器，而加锁之后ConcurrentHashMap不需要锁住整个容器，只需要锁住对应的segment就好了，所以可以保证高并发同步访问，提升了效率。</p>
<h2 id="Vector和ArrayList的区别"><a href="#Vector和ArrayList的区别" class="headerlink" title="Vector和ArrayList的区别"></a>Vector和ArrayList的区别</h2><p>  首先看这两类都实现List接口，而List接口一共有三个实现类，分别是ArrayList、Vector和LinkedList。List用于存放多个元素，能够维护元素的次序，并且允许元素的重复。3个具体实现类的相关区别如下：</p>
<p>1.ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要讲已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。<br>2.Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。<br>3.LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。</p>
<h2 id="ArrayList-与-LinkedList-的不区别"><a href="#ArrayList-与-LinkedList-的不区别" class="headerlink" title="ArrayList 与 LinkedList 的不区别"></a>ArrayList 与 LinkedList 的不区别</h2><p>最明显的区别是 ArrrayList 底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。<br>1.LinkedList内部存储的是Node<e>，不仅要维护数据域，还要维护prev和next，如果LinkedList中的结点特别多，则LinkedList比ArrayList更占内存。<br>插入删除操作效率：<br>2.LinkedList在做插入和删除操作时，插入或删除头部或尾部时是高效的，操作越靠近中间位置的元素时，需要遍历查找，速度相对慢一些，如果在数据量较大时，每次插入或删除时遍历查找比较费时。所以LinkedList插入与删除，慢在遍历查找，快在只需要更改相关结点的引用地址。<br>ArrayList在做插入和删除操作时，插入或删除尾部时也一样是高效的，操作其他位置，则需要批量移动元素，所以ArrayList插入与删除，快在遍历查找，慢在需要批量移动元素。<br>3.循环遍历效率：<br>由于ArrayList实现了RandomAccess随机访问接口，所以使用for(int i = 0; i &lt; size; i++)遍历会比使用Iterator迭代器来遍历快<br>而由于LinkedList未实现RandomAccess接口，所以推荐使用Iterator迭代器来遍历数据。<br>因此，如果我们需要频繁在列表的中部改变插入或删除元素时，建议使用LinkedList，否则，建议使用ArrayList，因为ArrayList遍历查找元素较快，并且只需存储元素的数据域，不需要额外记录其他数据的位置信息，可以节省内存空间。</e></p>
<h2 id="Java-中的-LinkedList-是单向链表还是双向链表"><a href="#Java-中的-LinkedList-是单向链表还是双向链表" class="headerlink" title="Java 中的 LinkedList 是单向链表还是双向链表"></a>Java 中的 LinkedList 是单向链表还是双向链表</h2><p>是双向链表。</p>
<h2 id="String、StringBuffer、StringBuilder之间区别"><a href="#String、StringBuffer、StringBuilder之间区别" class="headerlink" title="String、StringBuffer、StringBuilder之间区别"></a>String、StringBuffer、StringBuilder之间区别</h2><p>1.三者在执行速度方面的比较：StringBuilder &gt;  StringBuffer  &gt;  String<br>2.在线程方面：StringBuilder是线程非安全的;StringBuffer是线程安全的</p>
<p>3.对于三者的使用：如果要操作少量的数据用 = String；单线程操作字符串缓冲区 下操作大量数据 = StringBuilder；多线程操作字符串缓冲区 下操作大量数据 = StringBuffer；</p>
<h2 id="Object-的常用方有哪些"><a href="#Object-的常用方有哪些" class="headerlink" title="Object 的常用方有哪些"></a>Object 的常用方有哪些</h2><p>clone()、equals()、hashCode()、notify()、notifyAll()、toString()、wait()、finalize()</p>
<h2 id="Mysql-的分页-SQL-语句"><a href="#Mysql-的分页-SQL-语句" class="headerlink" title="Mysql 的分页 SQL 语句"></a>Mysql 的分页 SQL 语句</h2><p>select * from tablename limit m,n(n是指从第m+1条开始，取n条)</p>
<h2 id="Hibernate与MyBatis的异同"><a href="#Hibernate与MyBatis的异同" class="headerlink" title="Hibernate与MyBatis的异同"></a>Hibernate与MyBatis的异同</h2><p>相同点：<br>Hibernate与MyBatis都可以是通过SessionFactoryBuider由XML配置文件生成SessionFactory，然后由SessionFactory 生成Session，最后由Session来开启执行事务和SQL语句。其中SessionFactoryBuider，SessionFactory，Session的生命周期都是差不多的。Hibernate和MyBatis都支持JDBC和JTA事务处理。<br>Mybatis优势：<br>MyBatis可以进行更为细致的SQL优化，可以减少查询字段。<br>MyBatis容易掌握，而Hibernate门槛较高。<br>Hibernate优势：<br>Hibernate的DAO层开发比MyBatis简单，Mybatis需要维护SQL和结果映射。<br>Hibernate对对象的维护和缓存要比MyBatis好，对增删改查的对象的维护要方便。<br>Hibernate数据库移植性很好，MyBatis的数据库移植性不好，不同的数据库需要写不同SQL。<br>Hibernate有更好的二级缓存机制，可以使用第三方缓存。MyBatis本身提供的缓存机制不佳。</p>
<h2 id="Hibernate与MyBatis在sql优化方面异同"><a href="#Hibernate与MyBatis在sql优化方面异同" class="headerlink" title="Hibernate与MyBatis在sql优化方面异同"></a>Hibernate与MyBatis在sql优化方面异同</h2><p>Hibernate的查询会将表中的所有字段查询出来，这一点会有性能消耗。Hibernate也可以自己写SQL来指定需要查询的字段，但这样就破坏了Hibernate开发的简洁性。<br>而Mybatis的SQL是手动编写的，所以可以按需求指定查询的字段。<br>Hibernate HQL语句的调优需要将SQL打印出来，而Hibernate的SQL被很多人嫌弃因为太丑了。<br>MyBatis的SQL是自己手动写的所以调整方便。但Hibernate具有自己的日志统计。Mybatis本身不带日志统计，使用Log4j进行日志记录。</p>
<h2 id="Hibernate与MyBatis对象管理对比"><a href="#Hibernate与MyBatis对象管理对比" class="headerlink" title="Hibernate与MyBatis对象管理对比"></a>Hibernate与MyBatis对象管理对比</h2><p>Hibernate 是完整的对象/关系映射解决方案，它提供了对象状态管理（state management）的功能，使开发者不再需要理会底层数据库系统的细节。也就是说，相对于常见的 JDBC/SQL 持久层方案中需要管理 SQL 语句，Hibernate采用了更自然的面向对象的视角来持久化 Java 应用中的数据。<br>换句话说，使用 Hibernate 的开发者应该总是关注对象的状态（state），不必考虑 SQL 语句的执行。这部分细节已经由 Hibernate 掌管妥当，只有开发者在进行系统性能调优的时候才需要进行了解。而MyBatis在这一块没有文档说明，用户需要对对象自己进行详细的管理。</p>
<h2 id="Jsp九大内置对象"><a href="#Jsp九大内置对象" class="headerlink" title="Jsp九大内置对象"></a>Jsp九大内置对象</h2><p>1.Request:   request对象主要用于客户端请求处理<br>2.Response:   response对象提供了多个方法用来处理HTTP响应，可以调用response中的方法修改ContentType中的MIME类型以及实现页面的跳转等等，<br>3.Page:  page对象有点类似于Java编程中的this指针，就是指当前JSP页面本身。page是java.lang.Object类的对象。<br>4.Session:  session是与请求有关的会话期，它是java.servlet.http.HttpSession类的对象，用来表示和存储当前页面的请求信息。<br>5.Application:  application是javax.servlet.ServletContext类对象的一个实例，用于实现用户之间的数据共享<br>6.Out:<br>7.Exception:  exception内置对象是用来处理页面出现的异常错误<br>8.Config:  config内置对象是ServletConfig类的一个实例。在Servlet初始化的时候，JSP引擎通过config向它传递信息。这种信息可以是属性名/值匹配的参数，也可以是通过ServletContext对象传递的服务器的有关信息。<br>9.pageContext:  pageContext对象是一个比较特殊的对象。它相当于页面中所有其他对象功能的最大集成者，即使用它可以访问到本页面中所有其他对象</p>
<h2 id="Comparator-与-Comparable-有什么不同"><a href="#Comparator-与-Comparable-有什么不同" class="headerlink" title="Comparator 与 Comparable 有什么不同"></a>Comparator 与 Comparable 有什么不同</h2><p>Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。</p>
<h2 id="Collection-和-Collections的区别"><a href="#Collection-和-Collections的区别" class="headerlink" title="Collection 和 Collections的区别"></a>Collection 和 Collections的区别</h2><p>Collection是集合类的上级接口，继承与他的接口主要有Set 和List.<br>Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</p>
<h2 id="线程同步的方法"><a href="#线程同步的方法" class="headerlink" title="线程同步的方法"></a>线程同步的方法</h2><p>wait():使一个线程处于等待状态，并且释放所持有的对象的lock。<br>sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。<br>notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。<br>Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。</p>
<h2 id="Volatile和Synchronized四个不同点"><a href="#Volatile和Synchronized四个不同点" class="headerlink" title="Volatile和Synchronized四个不同点"></a>Volatile和Synchronized四个不同点</h2><ol>
<li>粒度不同，前者锁对象和类，后者针对变量</li>
<li>syn阻塞，volatile线程不阻塞</li>
<li>syn保证三大特性，volatile不保证原子性</li>
<li>syn编译器优化，volatile不优化<br>volatile具备两种特性：<br>保证此变量对所有线程的可见性，指一条线程修改了这个变量的值，新值对于其他线程来说是可见的，但并不是多线程安全的。<br>禁止指令重排序优化。<br>Volatile如何保证内存可见性:<br>1.当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。<br>2.当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。<br>同步：就是一个任务的完成需要依赖另外一个任务，只有等待被依赖的任务完成后，依赖任务才能完成。<br>异步：不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，只要自己任务完成了就算完成了，被依赖的任务是否完成会通知回来。（异步的特点就是通知）。<br>打电话和发短信来比喻同步和异步操作。<br>阻塞：CPU停下来等一个慢的操作完成以后，才会接着完成其他的工作。<br>非阻塞：非阻塞就是在这个慢的执行时，CPU去做其他工作，等这个慢的完成后，CPU才会接着完成后续的操作。<br>非阻塞会造成线程切换增加，增加CPU的使用时间能不能补偿系统的切换成本需要考虑。</li>
</ol>
<h2 id="SpringMVC运行原理"><a href="#SpringMVC运行原理" class="headerlink" title="SpringMVC运行原理"></a>SpringMVC运行原理</h2><ol>
<li>客户端请求提交到DispatcherServlet</li>
<li>由DispatcherServlet控制器查询HandlerMapping，找到并分发到指定的Controller中。</li>
<li>Controller调用业务逻辑处理后，返回ModelAndView</li>
<li>DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图</li>
<li>视图负责将结果显示到客户端</li>
</ol>
<h2 id="SpringMVC与Struts2区别与比较总结"><a href="#SpringMVC与Struts2区别与比较总结" class="headerlink" title="SpringMVC与Struts2区别与比较总结"></a>SpringMVC与Struts2区别与比较总结</h2><p>1、Struts2是类级别的拦截， 一个类对应一个request上下文，SpringMVC是方法级别的拦截，一个方法对应一个request上下文，而方法同时又跟一个url对应,所以说从架构本身上SpringMVC就容易实现restful url,而struts2的架构实现起来要费劲，因为Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了。</p>
<p>2、由上边原因，SpringMVC的方法之间基本上独立的，独享request response数据，请求数据通过参数获取，处理结果通过ModelMap交回给框架，方法之间不共享变量，而Struts2搞的就比较乱，虽然方法之间也是独立的，但其所有Action变量是共享的，这不会影响程序运行，却给我们编码 读程序时带来麻烦，每次来了请求就创建一个Action，一个Action对象对应一个request上下文。<br>3、由于Struts2需要针对每个request进行封装，把request，session等servlet生命周期的变量封装成一个一个Map，供给每个Action使用，并保证线程安全，所以在原则上，是比较耗费内存的。</p>
<p>4、 拦截器实现机制上，Struts2有以自己的interceptor机制，SpringMVC用的是独立的AOP方式，这样导致Struts2的配置文件量还是比SpringMVC大。</p>
<p>5、SpringMVC的入口是servlet，而Struts2是filter（这里要指出，filter和servlet是不同的。以前认为filter是servlet的一种特殊），这就导致了二者的机制不同，这里就牵涉到servlet和filter的区别了。</p>
<p>6、SpringMVC集成了Ajax，使用非常方便，只需一个注解@ResponseBody就可以实现，然后直接返回响应文本即可，而Struts2拦截器集成了Ajax，在Action中处理时一般必须安装插件或者自己写代码集成进去，使用起来也相对不方便。</p>
<p>7、SpringMVC验证支持JSR303，处理起来相对更加灵活方便，而Struts2验证比较繁琐，感觉太烦乱。</p>
<p>8、Spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高（当然Struts2也可以通过不同的目录结构和相关配置做到SpringMVC一样的效果，但是需要xml配置的地方不少）。</p>
<p>9、 设计思想上，Struts2更加符合OOP的编程思想， SpringMVC就比较谨慎，在servlet上扩展。</p>
<p>10、SpringMVC开发效率和性能高于Struts2。<br>11、SpringMVC可以认为已经100%零配置。</p>
<h2 id="简单总结springMVC和struts2的区别"><a href="#简单总结springMVC和struts2的区别" class="headerlink" title="简单总结springMVC和struts2的区别"></a>简单总结springMVC和struts2的区别</h2><ol>
<li>springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过虑器。</li>
<li>springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。</li>
<li>Struts采用值栈存储请求和响应的数据，通过OGNL存取数据， springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。</li>
</ol>
<h2 id="SpringMvc怎么和AJAX相互调用的"><a href="#SpringMvc怎么和AJAX相互调用的" class="headerlink" title="SpringMvc怎么和AJAX相互调用的"></a>SpringMvc怎么和AJAX相互调用的</h2><p>通过Jackson框架就可以把Java里面的对象直接转化成Js可以识别的Json对象<br>具体步骤如下<br>1.加入Jackson.jar<br>2.在配置文件中配置json的映射<br>3.在接受Ajax方法里面可以直接返回Object,List等,但方法前面要加上@ResponseBody注解</p>
<h2 id="Spring有哪些优点"><a href="#Spring有哪些优点" class="headerlink" title="Spring有哪些优点"></a>Spring有哪些优点</h2><p>1.轻量级：Spring在大小和透明性方面绝对属于轻量级的，基础版本的Spring框架大约只有2MB。<br>2.控制反转(IOC)：Spring使用控制反转技术实现了松耦合。依赖被注入到对象，而不是创建或寻找依赖对象。<br>3.面向切面编程(AOP)： Spring支持面向切面编程，同时把应用的业务逻辑与系统的服务分离开来。<br>4.容器：Spring包含并管理应用程序对象的配置及生命周期。<br>5.MVC框架：Spring的web框架是一个设计优良的web MVC框架，很好的取代了一些web框架。<br>6.事务管理：Spring对下至本地业务上至全局业务(JAT)提供了统一的事务管理接口。<br>7.异常处理：Spring提供一个方便的API将特定技术的异常(由JDBC, Hibernate, 或JDO抛出)转化为一致的、Unchecked异常。</p>
<h2 id="spring-主要使用了哪些-，IOC和AOP实现原理是什么"><a href="#spring-主要使用了哪些-，IOC和AOP实现原理是什么" class="headerlink" title="spring 主要使用了哪些 ，IOC和AOP实现原理是什么"></a>spring 主要使用了哪些 ，IOC和AOP实现原理是什么</h2><p>spring主要功能有IOC，AOP，MVC等，IOC实现原理：先反射生成实例，然后调用时主动注入。AOP原理：主要使用java动态代理。</p>
<h2 id="解释AOP模块"><a href="#解释AOP模块" class="headerlink" title="解释AOP模块"></a>解释AOP模块</h2><p>AOP模块用来开发Spring应用程序中具有切面性质的部分。该模块的大部分服务由AOP Aliance提供，这就保证了Spring框架和其他AOP框架之间的互操作性。另外，该模块将元数据编程引入到了Spring。</p>
<h2 id="IoC容器是什么其优点"><a href="#IoC容器是什么其优点" class="headerlink" title="IoC容器是什么其优点"></a>IoC容器是什么其优点</h2><p>Spring IOC负责创建对象、管理对象(通过依赖注入)、整合对象、配置对象以及管理这些对象的生命周期。<br>优点:<br>IOC或依赖注入减少了应用程序的代码量。它使得应用程序的测试很简单，因为在单元测试中不再需要单例或JNDI查找机制。简单的实现以及较少的干扰机制使得松耦合得以实现。IOC容器支持勤性单例及延迟加载服务。</p>
<h2 id="Spring-的依赖注入方式有哪一些"><a href="#Spring-的依赖注入方式有哪一些" class="headerlink" title="Spring 的依赖注入方式有哪一些"></a>Spring 的依赖注入方式有哪一些</h2><p>Spring 的依赖注入可以有两种方式来完成:setter 方法注入和构造方法注入。<br>构造器依赖注入：构造器依赖注入在容器触发构造器的时候完成，该构造器有一系列的参数，每个参数代表注入的对象。<br>Setter方法依赖注入：首先容器会触发一个无参构造函数或无参静态工厂方法实例化对象，之后容器调用bean中的setter方法完成Setter方法依赖注入。</p>
<h2 id="Spring支持的事务管理类型"><a href="#Spring支持的事务管理类型" class="headerlink" title="Spring支持的事务管理类型"></a>Spring支持的事务管理类型</h2><p>Spring支持如下两种方式的事务管理：<br>编程式事务管理：这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。<br>声明式事务管理：这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者XML配置管理事务。</p>
<h2 id="ThreadLocal-线程变量副本"><a href="#ThreadLocal-线程变量副本" class="headerlink" title="ThreadLocal(线程变量副本)"></a>ThreadLocal(线程变量副本)</h2><p>Synchronized实现内存共享，ThreadLocal为每个线程维护一个本地变量。</p>
<p>采用空间换时间，它用于线程间的数据隔离，为每一个使用该变量的线程提供一个副本，每个线程都可以独立地改变自己的副本，而不会和其他线程的副本冲突。</p>
<p>ThreadLocal类中维护一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值为对应线程的变量副本。</p>
<p>ThreadLocal在Spring中发挥着巨大的作用，在管理Request作用域中的Bean、事务管理、任务调度、AOP等模块都出现了它的身影。</p>
<p>Spring中绝大部分Bean都可以声明成Singleton作用域，采用ThreadLocal进行封装，因此有状态的Bean就能够以singleton的方式在多线程中正常工作了。</p>
<h2 id="throw-和-throws-的区别"><a href="#throw-和-throws-的区别" class="headerlink" title="throw 和 throws 的区别"></a>throw 和 throws 的区别</h2><p>throw 用于抛出 java.lang.Throwable 类的一个实例化对象，意思是说你可以通过关键字 throw 抛出一个 Error 或者 一个Exception，如：</p>
<p>throw new IllegalArgumentException(“size must be multiple of 2″)</p>
<p>而throws 的作用是作为方法声明和签名的一部分，方法被抛出相应的异常以便调用者能处理。Java 中，任何未处理的受检查异常强制在 throws 子句中声明。</p>
<h2 id="final关键字的作用"><a href="#final关键字的作用" class="headerlink" title="final关键字的作用"></a>final关键字的作用</h2><p>final class    表示此类不允许有子类。<br>final virable  表示一个常量。<br>final method   表示一个方法不能被重写</p>
<h2 id="String是最基本的数据类型吗"><a href="#String是最基本的数据类型吗" class="headerlink" title="String是最基本的数据类型吗"></a>String是最基本的数据类型吗</h2><p>基本数据类型包括byte、int、char、long、float、double、boolean和short。java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类。</p>
<h2 id="synchronized和java-util-concurrent-locks-Lock的异同"><a href="#synchronized和java-util-concurrent-locks-Lock的异同" class="headerlink" title="synchronized和java.util.concurrent.locks.Lock的异同"></a>synchronized和java.util.concurrent.locks.Lock的异同</h2><p>主要相同点:<br>Lock能完成synchronized所实现的所有功能.(其它不重要)<br>主要不同点:<br>Lock有比synchronized更精确的线程语义和更好的性能(在相同点中回答此点也行)<br>synchronized会自动释放锁.而Lock一定要求程序员手工释放.并且必须在finally从句<br>中释放,如果没有答出在finally中释放不得分.就如Connection没有在finally中关闭一<br>样.连最基本的资源释放都做不好,还谈什么多线程编程.</p>
<h2 id="spring的事务有几种它的隔离级别和传播行为"><a href="#spring的事务有几种它的隔离级别和传播行为" class="headerlink" title="spring的事务有几种它的隔离级别和传播行为"></a>spring的事务有几种它的隔离级别和传播行为</h2><p>声明式事务和编程式事务<br>隔离级别：</p>
<ul>
<li>DEFAULT使用数据库默认的隔离级别</li>
<li>READ_UNCOMMITTED会出现脏读，不可重复读和幻影读问题</li>
<li>READ_COMMITTED会出现重复读和幻影读</li>
<li>REPEATABLE_READ会出现幻影读</li>
<li>SERIALIZABLE最安全，但是代价最大，性能影响极其严重<br>和传播行：</li>
<li>REQUIRED存在事务就融入该事务，不存在就创建事务</li>
<li>SUPPORTS存在事务就融入事务，不存在则不创建事务</li>
<li>MANDATORY存在事务则融入该事务，不存在，抛异常</li>
<li>REQUIRES_NEW总是创建新事务</li>
<li>NOT_SUPPORTED存在事务则挂起，一直执行非事务操作</li>
<li>NEVER总是执行非事务，如果当前存在事务则抛异常</li>
<li>NESTED嵌入式事务</li>
</ul>
<h2 id="sleep-和-wait-有什么区别"><a href="#sleep-和-wait-有什么区别" class="headerlink" title="sleep() 和 wait() 有什么区别"></a>sleep() 和 wait() 有什么区别</h2><p>最大区别是等待时wait会释放锁，而sleep会一直持有锁，wait通常用于线程时交互，sleep通常被用于暂停执行。</p>
<p>sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。<br>wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。</p>
<h2 id="多线程和同步有几种实现方法"><a href="#多线程和同步有几种实现方法" class="headerlink" title="多线程和同步有几种实现方法"></a>多线程和同步有几种实现方法</h2><p>多线程有两种实现方法，分别是继承Thread类与实现Runnable接口<br>同步的实现方面有两种，分别是synchronized,wait与notify</p>
<h2 id="启动一个线程是用run-还是start"><a href="#启动一个线程是用run-还是start" class="headerlink" title="启动一个线程是用run()还是start()"></a>启动一个线程是用run()还是start()</h2><p>启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行。run()方法可以产生必须退出的标志来停止一个线程。 </p>
<h2 id="final-finally-finalize的区别"><a href="#final-finally-finalize的区别" class="headerlink" title="final,finally,finalize的区别"></a>final,finally,finalize的区别</h2><p>final—修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载。<br>　　finally—再异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。<br>　　finalize—方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。 </p>
<h2 id="abstract-class和interface有什么区别"><a href="#abstract-class和interface有什么区别" class="headerlink" title="abstract class和interface有什么区别"></a>abstract class和interface有什么区别</h2><p>抽象类与接口的区别：<br>1.接口可以多重继承 ，抽象类不可以<br>2.接口定义方法，不给实现；而抽象类可以实现部分方法<br>3.接口中基本数据类型的数据成员，都默认为static和final，抽象类则不是<br>如果事先知道某种东西会成为基础类，那么第一个选择就是把它变成一个接口。<br>只有在必须使用方法定义或者成员变量的时候，才应考虑采用抽象类。</p>
<h2 id="Set里的元素不能重复，用-还是equals-判断"><a href="#Set里的元素不能重复，用-还是equals-判断" class="headerlink" title="Set里的元素不能重复，用==还是equals ()判断"></a>Set里的元素不能重复，用==还是equals ()判断</h2><p>Set里的元素是不能重复的，那么用iterator()方法来区分重复与否。equals()是判读两个Set是否相等。<br>equals()和==方法决定引用值是否指向同一对象equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。</p>
<h2 id="struts-框架是如何体现MVC模式"><a href="#struts-框架是如何体现MVC模式" class="headerlink" title="struts 框架是如何体现MVC模式"></a>struts 框架是如何体现MVC模式</h2><p>struts 框架为开发者提供了MVC 的3个逻辑组成部分，主要由ActionServlet、Action和strust-config.xml配置文件组成控制层，由ActionForm 来承担模型层的功能，而struts 下的视图由JSP来完成。<br>处理请求：由ActionServlet接收请求，然后根据 struts-config.xml 中的配置，类判断由于哪个Action来处理请求和由哪个ActionForm来保存数据，在通过Action的返回值来判断应该由哪个JSP来负责页面的展示，最后由 JSP 来完成结果响应。</p>
<h2 id="Hibernate-的实体存在哪几种状态"><a href="#Hibernate-的实体存在哪几种状态" class="headerlink" title="Hibernate 的实体存在哪几种状态"></a>Hibernate 的实体存在哪几种状态</h2><p>Hibernate 中的实体在它的生命周期里面，存在 3 中状态。<br>瞬时：new语句创建的实体类对象是就是瞬时状态，它一般没有id。<br>持久：存放在 Session 中的实体对象就属于持久状态，一般通过 save() 或 saveOrUpdate()等等，方法转换而来。<br>托管：实体中Session中脱离出来的时候，它的状态就属于托管状态了，尽管它具有 id 值，但已经不存在Session 中了，即使 实体中的数据发生变化也不能同步到数据库中。通过 close()、evict()等方法转化而来。</p>
<h2 id="Hibernate-的get-和load-的区别"><a href="#Hibernate-的get-和load-的区别" class="headerlink" title="Hibernate 的get()和load()的区别"></a>Hibernate 的get()和load()的区别</h2><p>Hibernate 对于 load() 方法该方法认为数据一定存在于数据，可以放心的代理来延迟加载，如果在使用过程中发现了问题，只能抛出异常，而get()方法可以不存在。</p>
<h2 id="为什么wait和notify方法要在同步块中调用"><a href="#为什么wait和notify方法要在同步块中调用" class="headerlink" title="为什么wait和notify方法要在同步块中调用"></a>为什么wait和notify方法要在同步块中调用</h2><p>主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。还有一个原因是为了避免wait和notify之间产生竞态条件。</p>
<h2 id="什么是ThreadLocal变量"><a href="#什么是ThreadLocal变量" class="headerlink" title="什么是ThreadLocal变量"></a>什么是ThreadLocal变量</h2><p>ThreadLocal是Java里一种特殊的变量。每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用ThreadLocal让SimpleDateFormat变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。线程局部变量的另一个不错的例子是ThreadLocalRandom类，它在多线程环境中减少了创建代价高昂的Random对象的个数。</p>
<h2 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h2><p>Java多线程中的死锁<br>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件：<br>互斥条件：一个资源每次只能被一个进程使用。<br>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。<br>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。<br>避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。</p>
<h2 id="Java中活锁和死锁有什么区别"><a href="#Java中活锁和死锁有什么区别" class="headerlink" title="Java中活锁和死锁有什么区别"></a>Java中活锁和死锁有什么区别</h2><p>这是上题的扩展，活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者进程的状态可以改变但是却不能继续执行。</p>
<h2 id="怎么检测一个线程是否拥有锁"><a href="#怎么检测一个线程是否拥有锁" class="headerlink" title="怎么检测一个线程是否拥有锁"></a>怎么检测一个线程是否拥有锁</h2><p>我一直不知道我们竟然可以检测一个线程是否拥有锁，直到我参加了一次电话面试。在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。</p>
<h2 id="Maven有哪些优点"><a href="#Maven有哪些优点" class="headerlink" title="Maven有哪些优点"></a>Maven有哪些优点</h2><p>优点如下：<br>简化了项目依赖管理：<br>易于上手，对于新手可能一个”mvn clean package”命令就可能满足他的工作<br>便于与持续集成工具（jenkins）整合<br>便于项目升级，无论是项目本身升级还是项目使用的依赖升级。<br>有助于多模块项目的开发，一个模块开发好后，发布到仓库，依赖该模块时可以直接从仓库更新，而不用自己去编译。<br>maven有很多插件，便于功能扩展，比如生产站点，自动发布版本等</p>
<h2 id="Maven常见的依赖范围有哪些"><a href="#Maven常见的依赖范围有哪些" class="headerlink" title="Maven常见的依赖范围有哪些"></a>Maven常见的依赖范围有哪些</h2><p>1.compile:编译依赖，默认的依赖方式，在编译（编译项目和编译测试用例），运行测试用例，运行（项目实际运行）三个阶段都有效，典型地有spring-core等jar。<br>2.test:测试依赖，只在编译测试用例和运行测试用例有效，典型地有JUnit。<br>provided:对于编译和测试有效，不会打包进发布包中，典型的例子为servlet-api,一般的web工程运行时都使用容器的servlet-api。<br>3.runtime:只在运行测试用例和实际运行时有效，典型地是jdbc驱动jar包。<br>4.system: 不从maven仓库获取该jar,而是通过systemPath指定该jar的路径。<br>5.import: 用于一个dependencyManagement对另一个dependencyManagement的继承。</p>
<h2 id="使用“Mvn-Clean-Package”进行项目打包-其过程执行了哪些动作"><a href="#使用“Mvn-Clean-Package”进行项目打包-其过程执行了哪些动作" class="headerlink" title="使用“Mvn Clean Package”进行项目打包,其过程执行了哪些动作"></a>使用“Mvn Clean Package”进行项目打包,其过程执行了哪些动作</h2><p>在这个命令中我们调用了maven的clean周期的clean阶段绑定的插件任务，以及default周期的package阶段绑定的插件任务<br>默认执行的任务有（maven的术语叫goal, 也有人翻译成目标，我这里用任务啦）：</p>
<p>maven-clean-plugin:clean-&gt;<br>maven-resources-plugin:resources-&gt;<br>maven-compile-plugin:compile-&gt;<br>mavne-resources-plugin:testResources-&gt;<br>maven-compile-plugin:testCompile-&gt;<br>maven-jar-plugin:jar</p>
<h2 id="Maven-多模块如何聚合"><a href="#Maven-多模块如何聚合" class="headerlink" title="Maven 多模块如何聚合"></a>Maven 多模块如何聚合</h2><p>配置一个打包类型为pom的聚合模块，然后在该pom中使用<module>元素声明要聚合的模块</module></p>
<h2 id="缓存框架memcache和redis的区别？项目中，怎么去选择？"><a href="#缓存框架memcache和redis的区别？项目中，怎么去选择？" class="headerlink" title="缓存框架memcache和redis的区别？项目中，怎么去选择？"></a>缓存框架memcache和redis的区别？项目中，怎么去选择？</h2><p>ehcache,memcache和redis等。</p>
<p>区别：</p>
<ol>
<li>Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等。</li>
<li>Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储。</li>
<li>虚拟内存–Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘。</li>
<li>过期策略–memcache在set时就指定，例如set key1 0 0 8,即永不过期。Redis可以通 过例如expire 设定，例如expire name 10。</li>
<li>分布式–设定memcache集群，利用magent做一主多从;redis可以做一主多从。都 可以一主一从。</li>
<li>存储数据安全–memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）。</li>
<li>灾难恢复–memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复。</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份。</li>
</ol>
<h2 id="java的原子类，实现原理是什么"><a href="#java的原子类，实现原理是什么" class="headerlink" title="java的原子类，实现原理是什么"></a>java的原子类，实现原理是什么</h2><p>采用硬件提供原子操作指令实现的，即CAS。每次调用都会先判断预期的值是否符合，才进行写操作，保证数据安全。</p>
<h2 id="数据库性能优化有哪些方法"><a href="#数据库性能优化有哪些方法" class="headerlink" title="数据库性能优化有哪些方法"></a>数据库性能优化有哪些方法</h2><p>使用explain进行优化，查看sql是否充分使用索引。避免使用in,用exist替代，字段值尽可能使用更小的值，任何对列的操作都将导致表扫描，它包括数据库函数、计算表达式等等，查询时要尽可能将操作移至等号右边。使用连接查询(join)代替子查询。</p>
<p>在表的多列字段上建立一个索引，但只有在查询这些字段的第一个字段时，索引才会被使用。</p>
<h2 id="HTTP请求方法get和post有什么区别"><a href="#HTTP请求方法get和post有什么区别" class="headerlink" title="HTTP请求方法get和post有什么区别"></a>HTTP请求方法get和post有什么区别</h2><ol>
<li>Post传输数据时，不需要在URL中显示出来，而Get方法要在URL中显示。</li>
<li>Post传输的数据量大，可以达到2M，而Get方法由于受到URL长度限制,只能传递大约1024字节.</li>
<li>Post就是为了将数据传送到服务器段,Get就是为了从服务器段取得数据.而Get之所以也能传送数据,只是用来设计告诉服务器,你到底需要什么样的数据.Post的信息作为http请求的内容，而Get是在Http头部传输的。</li>
<li>其他 HTTP 请求方法</li>
</ol>
<ul>
<li>HEAD 与 GET 相同，但只返回 HTTP 报头，不返回文档主体。</li>
<li>PUT上传指定的 URI 表示。<br> DELETE    删除指定资源。</li>
<li>OPTIONS 返回服务器支持的 HTTP 方法</li>
<li>CONNECT 把请求连接转换到透明的 TCP/IP 通道。</li>
</ul>
<h2 id="linux命令，查看某个线程，整个机器负载和文件内容快速查找的命令"><a href="#linux命令，查看某个线程，整个机器负载和文件内容快速查找的命令" class="headerlink" title="linux命令，查看某个线程，整个机器负载和文件内容快速查找的命令"></a>linux命令，查看某个线程，整个机器负载和文件内容快速查找的命令</h2><p>查看线程：ps -ef|greptomcat</p>
<p>查看负载：top</p>
<p>文件内容查找：vi  /aa test.txt 或者先打开文件，再查找: vi test.txt   /aa</p>
<h2 id="JVM内存的模型，垃圾回收的机制，如何对JVM进行调优"><a href="#JVM内存的模型，垃圾回收的机制，如何对JVM进行调优" class="headerlink" title="JVM内存的模型，垃圾回收的机制，如何对JVM进行调优"></a>JVM内存的模型，垃圾回收的机制，如何对JVM进行调优</h2><p>由栈和堆组成，栈是运行时单位，堆内存则分为年轻代、年老代、持久代等，年轻代中的对象经过几次的回收，仍然存在则被移到年老代；持久代主要是保存class,method,filed等对象。</p>
<p>sun回收机制：主要对年轻代和年老代中的存活对象进行回收，分为以下：</p>
<p>年轻代串行（Serial Copying）、年轻代并行（ParNew）、年老代串行（SerialMSC），年老代并行（Parallel Mark Sweep），年老代并发（Concurrent Mark-Sweep GC，即CMS）等等,目前CMS回收算法使用最广泛。</p>
<p>JVM调优主要是对堆内容和回收算法进行配置，需要对jdk产生的回收日志进行观察，同时通过工具（Jconsole，jProfile，VisualVM）对堆内存不断分析，这些优化是一个过程，需要不断地进行观察和维护。</p>
<h2 id="高并发时，又如何保证性能和数据正确"><a href="#高并发时，又如何保证性能和数据正确" class="headerlink" title="高并发时，又如何保证性能和数据正确"></a>高并发时，又如何保证性能和数据正确</h2><p>如果是单机内完成这些操作，那使用数据库的事务，即可轻松实现。</p>
<h2 id="分布式事务如何实现"><a href="#分布式事务如何实现" class="headerlink" title="分布式事务如何实现"></a>分布式事务如何实现</h2><p>分布式事务可以采用分布式锁进行实现，目前zookeeper就提供此锁；分布式锁需要牺牲一定性能去实现，若业务支付最终一致性，那此方法是最佳方案。如在京东下订单，过一会才会告诉你订单审核通过，而不是马上响应订单结果。</p>
<h2 id="抽象类和接口的区别，项目中如何使用它们"><a href="#抽象类和接口的区别，项目中如何使用它们" class="headerlink" title="抽象类和接口的区别，项目中如何使用它们"></a>抽象类和接口的区别，项目中如何使用它们</h2><p> 相同点：</p>
<ol>
<li>两者都是抽象类，都不能实例化。</li>
<li>interface实现类及abstractclass的子类都必须要实现已经声明的抽象方法。</li>
</ol>
<p>不同点：</p>
<ol>
<li>interface需要实现，要用implements，而abstractclass需要继承，要用extends。</li>
<li>一个类可以实现多个interface，但一个类只能继承一个abstractclass。</li>
<li>interface强调特定功能的实现，而abstractclass强调所属关系。</li>
<li>尽管interface实现类及abstrctclass的子类都必须要实现相应的抽象方法，但实现的形式不同。interface中的每一个方法都是抽象方法，都只是声明的 (declaration, 没有方法体)，实现类必须要实现。而abstractclass的子类可以有选择地实现。</li>
</ol>
<p>使用：</p>
<ol>
<li>abstract：在既需要统一的接口，又需要实例变量或缺省的方法的情况下，使用abstract;</li>
<li>​ interface：类与类之前需要特定的接口进行协调，而不在乎其如何实现。 作为能够实现特定功能的标识存在，也可以是什么接口方法都没有的纯粹标识。需要将一组类视为单一的类，而调用者只通过接口来与这组类发生联系。需要实现特定的多项功能，而这些功能之间可能完全没有任何联系。        </li>
</ol>
<h2 id="TCP通讯有几次握手，有使用过哪些socket框架"><a href="#TCP通讯有几次握手，有使用过哪些socket框架" class="headerlink" title="TCP通讯有几次握手，有使用过哪些socket框架"></a>TCP通讯有几次握手，有使用过哪些socket框架</h2><p>​         3次握手，客户端–&gt;服务端，服务端–&gt;客户端，客户端–&gt;服务端，当这些过程完成之后，才真正建立起通信。java中比较有名的socket框架有：mina,netty,都是韩国小棒子写的。</p>
<h2 id="java反射机制，反射生成类，可否访问私有变量"><a href="#java反射机制，反射生成类，可否访问私有变量" class="headerlink" title="java反射机制，反射生成类，可否访问私有变量"></a>java反射机制，反射生成类，可否访问私有变量</h2><p>​       即动态生成java的实例，可以。</p>
<p>Java反射机制是一个非常强大的功能，在很多的项目比如Spring，Mybatis都都可以看到反射的身影。通过反射机制，我们可以在运行期间获取对象的类型信息。利用这一点我们可以实现工厂模式和代理模式等设计模式，同时也可以解决java泛型擦除等令人苦恼的问题。</p>
<p>获取一个对象对应的反射类，在Java中有三种方法可以获取一个对象的反射类，</p>
<ul>
<li>通过getClass()方法</li>
<li>通过Class.forName()方法</li>
<li>使用类.class</li>
<li>通过类加载器实现，getClassLoader()</li>
</ul>
<h2 id="RPC是什么，有使用过哪些RPC框架"><a href="#RPC是什么，有使用过哪些RPC框架" class="headerlink" title="RPC是什么，有使用过哪些RPC框架"></a>RPC是什么，有使用过哪些RPC框架</h2><p>​     远程进程调用，本地机器调用远程的服务，在项目规模大到一定程度，需要使用RPC相关框架进行服务化部署。如：hessian 、webservice等</p>
<h2 id="jquery如何绑定页面某元素的点击事件"><a href="#jquery如何绑定页面某元素的点击事件" class="headerlink" title="jquery如何绑定页面某元素的点击事件"></a>jquery如何绑定页面某元素的点击事件</h2><p>​    $(“#btn”).click(function(){ …. })</p>
<h2 id="volatile实现原理"><a href="#volatile实现原理" class="headerlink" title="volatile实现原理"></a>volatile实现原理</h2><p>volatile如何保证可见性和禁止指令重排序的：</p>
<p>观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令，lock前缀指令实际上相当于一个 <strong>内存屏障</strong>（也成内存栅栏），内存屏障会提供3个功能：</p>
<ul>
<li><p>它 <strong>确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面</strong>；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p>
</li>
<li><p>它会 强制将对缓存的修改操作立即写入主存；</p>
</li>
<li><p>如果是写操作，它会导致其他CPU中对应的缓存行无效。</p>
</li>
</ul>
<h2 id="session-与-cookie-区别"><a href="#session-与-cookie-区别" class="headerlink" title="session 与 cookie 区别"></a>session 与 cookie 区别</h2><ol>
<li>cookie数据存放在客户的浏览器上，session数据放在服务器上。</li>
<li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。</li>
<li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。</li>
<li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li>
<li>所以个人建议： 将登陆信息等重要信息存放为SESSION 其他信息如果需要保留，可以放在COOKIE中</li>
</ol>
<h2 id="session-分布式处理"><a href="#session-分布式处理" class="headerlink" title="session 分布式处理"></a>session 分布式处理</h2><p>第一种：粘性session</p>
<p>粘性Session是指将用户锁定到某一个服务器上，比如上面说的例子，用户第一次请求时，负载均衡器将用户的请求转发到了A服务器上，如果负载均衡器设置了粘性Session的话，那么用户以后的每次请求都会转发到A服务器上，相当于把用户和A服务器粘到了一块，这就是粘性Session机制。</p>
<p>第二种：服务器session复制</p>
<p>原理：任何一个服务器上的session发生改变（增删改），该节点会把这个 session的所有内容序列化，然后广播给所有其它节点，不管其他服务器需不需要session，以此来保证Session同步。</p>
<p>第三种：session共享机制</p>
<p>使用分布式缓存方案比如memcached、Redis，但是要求Memcached或Redis必须是集群。</p>
<p>原理：不同的 tomcat指定访问不同的主memcached。多个Memcached之间信息是同步的，能主从备份和高可用。用户访问时首先在tomcat中创建session，然后将session复制一份放到它对应的memcahed上</p>
<p>第四种：session持久化到数据库</p>
<p>原理：就不用多说了吧，拿出一个数据库，专门用来存储session信息。保证session的持久化。 优点：服务器出现问题，session不会丢失 缺点：如果网站的访问量很大，把session存储到数据库中，会对数据库造成很大压力，还需要增加额外的开销维护数据库。</p>
<p>第五种terracotta实现session复制</p>
<p>原理：就不用多说了吧，拿出一个数据库，专门用来存储session信息。保证session的持久化。 优点：服务器出现问题，session不会丢失 缺点：如果网站的访问量很大，把session存储到数据库中，会对数据库造成很大压力，还需要增加额外的开销维护数据库。</p>
<h2 id="说说自定义注解的场景及实现"><a href="#说说自定义注解的场景及实现" class="headerlink" title="说说自定义注解的场景及实现"></a>说说自定义注解的场景及实现</h2><p>跟踪代码的依赖性，实现代替配置文件的功能。比较常见的是Spring等框架中的基于注解配置。</p>
<p>还可以生成文档常见的@See@param@return等。如@override放在方法签名，如果这个方法 并不是覆盖了超类方法，则编译时就能检查出。</p>
<p>使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节，在定义注解时，不能继承其他注解或接口。</p>
<h2 id="HashSet-和-HashMap-区别"><a href="#HashSet-和-HashMap-区别" class="headerlink" title="HashSet 和 HashMap 区别"></a>HashSet 和 HashMap 区别</h2><p> <strong>HashSet：</strong></p>
<p>HashSet实现了Set接口，它不允许集合中出现重复元素。当我们提到HashSet时，第一件事就是在将对象存储在</p>
<p>HashSet之前，要确保重写hashCode（）方法和equals（）方法，这样才能比较对象的值是否相等，确保集合中没有储存相同的对象。如果不重写上述两个方法，那么将使用下面方法默认实现：</p>
<p>public boolean add(Object obj)方法用在Set添加元素时，如果元素值重复时返回 “false”，如果添加成功则返回”true”</p>
<p><strong>HashMap：</strong></p>
<p>HashMap实现了Map接口，Map接口对键值对进行映射。Map中不允许出现重复的键（Key）。Map接口有两个基本的实现TreeMap和HashMap。TreeMap保存了对象的排列次序，而HashMap不能。HashMap可以有空的键值对（Key（null）-Value（null））HashMap是非线程安全的（非Synchronize），要想实现线程安全，那么需要调用collections类的静态方法synchronizeMap（）实现。</p>
<p>public Object put(Object Key,Object value)方法用来将元素添加到map中。</p>
<p>总结：</p>
<p>HashMap 实现了 Map 接口；存储键值对；调用put（）向map中添加元素；HashMap使用键（Key）计算Hashcode；HashMap相对于HashSet较快，因为它是使用唯一的键获取对象。</p>
<p>HashSet 实现了 Set 接口；仅存储对象；调用add（）方法向Set中添加元素；HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false；HashSet较HashMap来说比较慢。</p>
<h2 id="HashMap-的工作原理及代码实现"><a href="#HashMap-的工作原理及代码实现" class="headerlink" title="HashMap 的工作原理及代码实现"></a>HashMap 的工作原理及代码实现</h2><ol>
<li>HashMap是基于哈希表的Map接口的非同步实现，允许使用null值和null键，但不保证映射的顺序。</li>
<li>底层使用数组实现，数组中每一项是个单向链表，即数组和链表的结合体；当链表长度大于一定阈值时，链表转换为红黑树，这样减少链表查询时间。</li>
<li>HashMap在底层将key-value当成一个整体进行处理，这个整体就是一个Node对象。HashMap底层采用一个Node[]数组来保存所有的key-value对，当需要存储一个Node对象时，会根据key的hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Node时，也会根据key的hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Node。</li>
<li>HashMap进行数组扩容需要重新计算扩容后每个元素在数组中的位置，很耗性能</li>
<li>采用了Fail-Fast机制，通过一个modCount值记录修改次数，对HashMap内容的修改都将增加这个值。迭代器初始化过程中会将这个值赋给迭代器的expectedModCount，在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map，马上抛出异常</li>
</ol>
<h2 id="ConcurrentHashMap-的工作原理及代码实现"><a href="#ConcurrentHashMap-的工作原理及代码实现" class="headerlink" title="ConcurrentHashMap 的工作原理及代码实现"></a>ConcurrentHashMap 的工作原理及代码实现</h2><ol>
<li>ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。</li>
<li>它使用了多个锁来控制对hash表的不同段进行的修改，每个段其实就是一个小的hashtable，它们有自己的锁。只要多个并发发生在不同的段上，它们就可以并发进行。</li>
<li>ConcurrentHashMap在底层将key-value当成一个整体进行处理，这个整体就是一个Entry对象。Hashtable底层采用一个Entry[]数组来保存所有的key-value对，当需要存储一个Entry对象时，会根据key的hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据key的hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。</li>
<li>与HashMap不同的是，ConcurrentHashMap使用多个子Hash表，也就是段(Segment)</li>
<li>ConcurrentHashMap完全允许多个读操作并发进行，读操作并不需要加锁。如果使用传统的技术，如HashMap中的实现，如果允许可以在hash链的中间添加或删除元素，读操作不加锁将得到不一致的数据。ConcurrentHashMap实现技术是保证HashEntry几乎是不可变的。</li>
</ol>
<h2 id="ThreadLocal-原理分析"><a href="#ThreadLocal-原理分析" class="headerlink" title="ThreadLocal 原理分析"></a>ThreadLocal 原理分析</h2><p>ThreadLocal 为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。当使用 ThreadLocal 维护变量时，ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p>
<p>每个线程中都保有一个 ThreadLocalMap 的成员变量，ThreadLocalMap 内部采用 WeakReference 数组保存，数组的key即为 ThreadLocal 内部的Hash值。</p>
<h2 id="创建线程的方式及实现"><a href="#创建线程的方式及实现" class="headerlink" title="创建线程的方式及实现"></a>创建线程的方式及实现</h2><p>Java使用Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。Java可以用三种方式来创建线程，如下所示：</p>
<ol>
<li>继承Thread类创建线程</li>
<li>实现Runnable接口创建线程</li>
<li><p>使用Callable和Future创建线程</p>
<p><strong>继承Thread类创建线程</strong></p>
</li>
</ol>
<p>通过继承Thread类来创建并启动多线程的一般步骤如下</p>
<p>1】d定义Thread类的子类，并重写该类的<strong>run()</strong>方法，该方法的方法体就是线程需要完成的任务，run()方法也称为线程执行体。</p>
<p>2】创建Thread子类的实例，也就是创建了线程对象</p>
<p>3】启动线程，即调用线程的<strong>start()</strong>方法</p>
<p>代码实例</p>
<p>public class MyThread extends Thread{//继承Thread类</p>
<p>　　public void run(){</p>
<p>　　//重写run方法</p>
<p>　　}</p>
<p>}</p>
<p>public class Main {</p>
<p>　　public static void main(String[] args){</p>
<p>　　　　new MyThread().start();//创建并启动线程</p>
<p>　　}</p>
<p>}</p>
<p><strong>实现Runnable接口创建线程</strong></p>
<p>通过实现Runnable接口创建并启动线程一般步骤如下：</p>
<p>1】定义Runnable接口的实现类，一样要重写run()方法，这个run（）方法和Thread中的run()方法一样是线程的执行体</p>
<p>2】创建Runnable实现类的实例，并用这个实例作为Thread的target来创建Thread对象，这个Thread对象才是真正的线程对象</p>
<p>3】第三部依然是通过调用线程对象的start()方法来启动线程</p>
<p>代码实例：</p>
<p>public class MyThread2 implements Runnable {//实现Runnable接口</p>
<p>　　public void run(){</p>
<p>　　//重写run方法</p>
<p>　　}</p>
<p>}</p>
<p>public class Main {</p>
<p>　　public static void main(String[] args){</p>
<p>　　　　//创建并启动线程</p>
<p>　　　　MyThread2 myThread=new MyThread2();</p>
<p>　　　　Thread thread=new Thread(myThread);</p>
<p>　　　　thread().start();</p>
<p>　　　　//或者    new Thread(new MyThread2()).start();</p>
<p>　　}</p>
<p>}</p>
<p><strong>使用Callable和Future创建线程</strong></p>
<p>和Runnable接口不一样，Callable接口提供了一个call（）方法作为线程执行体，call()方法比run()方法<em>**</em>功能要强大。</p>
<p>》call()方法可以有返回值</p>
<p>》call()方法可以声明抛出异常</p>
<p>Java5提供了Future接口来代表Callable接口里call()方法的返回值，并且为Future接口提供了一个实现类FutureTask，这个实现类既实现了Future接口，还实现了Runnable接口，因此可以作为Thread类的target。在Future接口里定义了几个公共方法来控制它关联的Callable任务。</p>
<p>>boolean cancel(boolean mayInterruptIfRunning)：视图取消该Future里面关联的Callable任务</p>
<p>>V get()：返回Callable里call（）方法的返回值，调用这个方法会导致程序阻塞，必须等到子线程结束后才会得到返回值</p>
<p>>V get(long timeout,TimeUnit unit)：返回Callable里call（）方法的返回值，最多阻塞timeout时间，经过指定时间没有返回抛出TimeoutException</p>
<p>>boolean isDone()：若Callable任务完成，返回True</p>
<p>>boolean isCancelled()：如果在Callable任务正常完成前被取消，返回True</p>
<p>介绍了相关的概念之后，创建并启动有返回值的线程的步骤如下：</p>
<p>1】创建Callable接口的实现类，并实现call()方法，然后创建该实现类的实例（从java8开始可以直接使用Lambda表达式创建Callable对象）。</p>
<p>2】使用FutureTask类来包装Callable对象，该FutureTask对象封装了Callable对象的call()方法的返回值</p>
<p>3】使用FutureTask对象作为Thread对象的target创建并启动线程（因为FutureTask实现了Runnable接口）</p>
<p>4】调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p>
<p>代码实例：</p>
<p>public class Main {</p>
<p>　　public static void main(String[] args){</p>
<p>　　　MyThread3 th=new MyThread3();</p>
<p>　　　//使用Lambda表达式创建Callable对象</p>
<p>　　   //使用FutureTask类来包装Callable对象</p>
<p>　　　FutureTask<integer> future=new FutureTask<integer>(</integer></integer></p>
<p>　　　　(Callable<integer>)()-&gt;{</integer></p>
<p>　　　　　　return 5;</p>
<p>　　　　}</p>
<p>　　  );</p>
<p>　　　new Thread(task,”有返回值的线程”).start();//实质上还是以Callable对象来创建并启动线程</p>
<p>　　  try{</p>
<p>　　　　System.out.println(“子线程的返回值：”+future.get());//get()方法会阻塞，直到子线程执行结束才返回</p>
<p> 　　 }catch(Exception e){</p>
<p>　　　　ex.printStackTrace();</p>
<p>　　　}</p>
<p>　　}</p>
<p>}</p>
<p><strong>————————————–三种创建线程方法对比————————————–</strong></p>
<p>实现Runnable和实现Callable接口的方式基本相同，不过是后者执行call()方法有返回值，后者线程执行体run()方法无返回值，因此可以把这两种方式归为一种这种方式与继承Thread类的方法之间的差别如下：</p>
<p>1、线程只是实现Runnable或实现Callable接口，还可以继承其他类。</p>
<p>2、这种方式下，多个线程可以共享一个target对象，非常适合多线程处理同一份资源的情形。</p>
<p>3、但是编程稍微复杂，如果需要访问当前线程，必须调用Thread.currentThread()方法。</p>
<p>4、继承Thread类的线程类不能再继承其他父类（Java单继承决定）。</p>
<p>注：一般推荐采用实现接口的方式来创建多线程</p>
<h2 id="sleep-、join（）、yield（）有什么区别"><a href="#sleep-、join（）、yield（）有什么区别" class="headerlink" title="sleep() 、join（）、yield（）有什么区别"></a>sleep() 、join（）、yield（）有什么区别</h2><p>sleep():方法导致了程序暂停执行指定的时间，让出cpu给其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态，但不会释放“锁标志”，不推荐使用。</p>
<p>wait():在其他线程调用对象的notify或notifyAll方法前，导致当前线程等待。线程会释放掉它所占有的“锁标志”，从而使别的线程有机会抢占该锁。</p>
<p>yield():暂停当前正在执行的线程对象。yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。yield()只能使同优先级或更高优先级的线程有执行的机会。</p>
<p>join():等待调用join方法的线程结束，再继续执行。</p>
<p>sleep是针对于thread对象，wait是针对于Object对象。</p>
<h2 id="ConcurrentHashMap如何保证线程安全"><a href="#ConcurrentHashMap如何保证线程安全" class="headerlink" title="ConcurrentHashMap如何保证线程安全"></a>ConcurrentHashMap如何保证线程安全</h2><p>JDK 1.7及以前：</p>
<p>ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对hash表的不同部分进行的修改。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。</p>
<p>JDK 1.8：</p>
<p>Segment虽保留，但已经简化属性，仅仅是为了兼容旧版本。</p>
<p>插入时使用CAS算法：unsafe.compareAndSwapInt(this, valueOffset, expect, update)。 CAS(Compare And Swap)意思是如果valueOffset位置包含的值与expect值相同，则更新valueOffset位置的值为update，并返回true，否则不更新，返回false。插入时不允许key或value为null</p>
<p>与Java8的HashMap有相通之处，底层依然由“数组”+链表+红黑树；</p>
<p>底层结构存放的是TreeBin对象，而不是TreeNode对象；</p>
<p>CAS作为知名无锁算法，那ConcurrentHashMap就没用锁了么？当然不是，当hash值与链表的头结点相同还是会synchronized上锁，锁链表。</p>
<h2 id="new与newInstance-的区别"><a href="#new与newInstance-的区别" class="headerlink" title="new与newInstance()的区别"></a>new与newInstance()的区别</h2><ul>
<li>new是一个关键字，它是调用new指令创建一个对象，然后调用构造方法来初始化这个对象，可以使用带参数的构造器</li>
<li>newInstance()是Class的一个方法，在这个过程中，是先取了这个类的不带参数的构造器Constructor，然后调用构造器的newInstance方法来创建对象。</li>
<li>Class.newInstance不能带参数，如果要带参数需要取得对应的构造器，然后调用该构造器的Constructor.newInstance(Object … initargs)方法</li>
</ul>
<h2 id="JDK中用到的设计模式"><a href="#JDK中用到的设计模式" class="headerlink" title="JDK中用到的设计模式"></a>JDK中用到的设计模式</h2><ul>
<li>装饰模式：java.io</li>
<li>单例模式：Runtime类</li>
<li>简单工厂模式：Integer.valueOf方法</li>
<li>享元模式：String常量池、Integer.valueOf(int i)、Character.valueOf(char c)</li>
<li>迭代器模式：Iterator</li>
<li>职责链模式：ClassLoader的双亲委派模型</li>
<li>解释器模式：正则表达式java.util.regex.Pattern</li>
</ul>
<h2 id="hashCode-amp-amp-equals"><a href="#hashCode-amp-amp-equals" class="headerlink" title="hashCode() &amp;&amp; equals()"></a>hashCode() &amp;&amp; equals()</h2><p><code>hashcode()</code> 返回该对象的哈希码值，支持该方法是为哈希表提供一些优点，例如，<code>java.util.Hashtable</code> 提供的哈希表。</p>
<p>在 Java 应用程序执行期间，在同一对象上多次调用 <code>hashCode</code> 方法时，必须一致地返回相同的整数，前提是对象上 <code>equals</code> 比较中所用的信息没有被修改（<code>equals</code>默认返回对象地址是否相等）。如果根据 <code>equals(Object)</code>方法，两个对象是相等的，那么在两个对象中的每个对象上调用 <code>hashCode</code> 方法都必须生成相同的整数结果。</p>
<p>以下情况不是必需的：如果根据 <code>equals(java.lang.Object)</code> 方法，两个对象不相等，那么在两个对象中的任一对象上调用 <code>hashCode</code> 方法必定会生成不同的整数结果。但是，<strong>程序员应该知道，为不相等的对象生成不同整数结果可以提高哈希表的性能</strong>。</p>
<p>实际上，由 <code>Object</code> 类定义的 <code>hashCode</code> 方法确实会针对不同的对象返回不同的整数。（<strong>这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧I</strong>。）</p>
<ul>
<li><strong>hashCode的存在主要是用于查找的快捷性</strong>，如 Hashtable，HashMap等，hashCode 是用来在散列存储结构中确定对象的存储地址的；</li>
<li>如果两个对象相同，就是适用于 <code>equals(java.lang.Object)</code> 方法，那么这两个对象的 <code>hashCode</code> 一定要相同；</li>
<li>如果对象的 <code>equals</code> 方法被重写，那么对象的 <code>hashCode</code> 也尽量重写，并且产生 <code>hashCode</code>使用的对象，一定要和 <code>equals</code> 方法中使用的一致，否则就会违反上面提到的第2点；</li>
<li><strong>两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里”</strong>。</li>
</ul>
<h2 id="Object类的finalize方法的实现原理"><a href="#Object类的finalize方法的实现原理" class="headerlink" title="Object类的finalize方法的实现原理"></a>Object类的finalize方法的实现原理</h2><p>Object 类提供的实现不Finalize方法和垃圾回收器将派生的类型不标记Object终止除非它们将覆盖Finalize方法。</p>
<p>如果类型未重写Finalize方法，则垃圾回收器会将类型的每个实例的条目添加到调用终止队列中的内部结构。 终止队列中包含垃圾回收器才能回收其内存之前，必须运行其终止代码托管堆中的所有对象的条目。 然后，垃圾回收器调用Finalize在以下情况下自动的方法︰</p>
<ul>
<li>垃圾回收器发现，一个对象不可访问，除非您通过调用从终止豁免已对象后 GC.SuppressFinalize 方法。</li>
<li>在关闭应用程序域中，除非该对象是免于终止的对象。 在关闭期间，终止甚至仍是可访问的对象。</li>
</ul>
<p>Finalize将自动调用一次在给定实例中，除非的对象重新注册通过使用一种机制，如GC.ReRegisterForFinalize和GC.SuppressFinalize尚未随后调用方法。</p>
<p>Finalize操作具有以下限制︰</p>
<ul>
<li>终结器执行时的确切时间不确定。 若要确保确定性释放资源，对你的类的实例实现<strong>Close</strong>方法，或者提供IDisposable.Dispose实现。</li>
<li>两个对象的终结器不保证任何特定顺序运行即使另一个对象引用。 也就是说，如果对象 A 具有对对象 B 的引用，并且二者的终结器，对象 B 可能已经被终结的对象 A 终结器启动时。</li>
<li>终结器运行的线程未指定。</li>
</ul>
<p>Finalize方法可能无法运行完成，或可能根本不运行下列异常情况下︰</p>
<ul>
<li>如果另一个终结器会无限期阻止 （进入无限循环，尝试获取的锁，它可以永远不会获取，等等）。 运行时尝试运行终结器来完成，因为其他终结器可能不会调用终结器块如果无限期。</li>
<li>如果不提供机会清理的运行时，进程将终止。 在这种情况下，运行时的第一个通知的进程是终止的一个 DLL_PROCESS_DETACH 通知。</li>
</ul>
<p>运行时将继续完成在关闭过程的对象，仅当可终结对象数目继续减少。</p>
<p>如果Finalize或的重写Finalize引发异常，并且运行时不承载的应用程序将替代默认策略，运行时终止进程，且无活动<strong>try</strong>/<strong>finally</strong>执行块或终结器。如果终结器无法释放或销毁资源，则此行为确保处理完整性。</p>
<p><strong>实施者注意事项</strong></p>
<p>应重写Finalize类使用非托管的资源，如文件句柄或数据库必须在垃圾回收期间放弃使用它们的托管的对象时释放的连接。</p>
<h2 id="Finalizer对象什么时候会在引用队列中"><a href="#Finalizer对象什么时候会在引用队列中" class="headerlink" title="Finalizer对象什么时候会在引用队列中"></a>Finalizer对象什么时候会在引用队列中</h2><h2 id="CountDownLatch-原理"><a href="#CountDownLatch-原理" class="headerlink" title="CountDownLatch 原理"></a>CountDownLatch 原理</h2><h2 id="CyclicBarrier-原理"><a href="#CyclicBarrier-原理" class="headerlink" title="CyclicBarrier 原理"></a>CyclicBarrier 原理</h2><h2 id="Semaphore-原理"><a href="#Semaphore-原理" class="headerlink" title="Semaphore 原理"></a>Semaphore 原理</h2><h2 id="Exchanger-原理"><a href="#Exchanger-原理" class="headerlink" title="Exchanger 原理"></a>Exchanger 原理</h2><h2 id="CountDownLatch-与-CyclicBarrier-区别"><a href="#CountDownLatch-与-CyclicBarrier-区别" class="headerlink" title="CountDownLatch 与 CyclicBarrier 区别"></a>CountDownLatch 与 CyclicBarrier 区别</h2><h2 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h2><h2 id="线程池的几种方式"><a href="#线程池的几种方式" class="headerlink" title="线程池的几种方式"></a>线程池的几种方式</h2><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><h2 id="说说线程安全问题"><a href="#说说线程安全问题" class="headerlink" title="说说线程安全问题"></a>说说线程安全问题</h2><h2 id="synchronize-实现原理"><a href="#synchronize-实现原理" class="headerlink" title="synchronize 实现原理"></a>synchronize 实现原理</h2><h2 id="synchronized-与-lock-的区别"><a href="#synchronized-与-lock-的区别" class="headerlink" title="synchronized 与 lock 的区别"></a>synchronized 与 lock 的区别</h2><h2 id="CAS-乐观锁"><a href="#CAS-乐观锁" class="headerlink" title="CAS 乐观锁"></a>CAS 乐观锁</h2><h2 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h2><h2 id="乐观锁的业务场景及实现方式"><a href="#乐观锁的业务场景及实现方式" class="headerlink" title="乐观锁的业务场景及实现方式"></a>乐观锁的业务场景及实现方式</h2><p>​                                                                                                   </p>
]]></content>
      
        <categories>
            
            <category> 基础面试题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础面试题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python 的基本要素]]></title>
      <url>/2018/01/15/Python%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%B4%A0/</url>
      <content type="html"><![CDATA[<h1 id="Python-的基本要素"><a href="#Python-的基本要素" class="headerlink" title="Python 的基本要素"></a>Python 的基本要素</h1><ol>
<li>基本数据类型</li>
<li>对象引用</li>
<li>组合数据类型</li>
<li>逻辑操作符</li>
<li>控制流语句</li>
<li>算数操作符</li>
<li>输入/输出</li>
<li>函数的创建与调用</li>
</ol>
<a id="more"></a>
<h2 id="要素1：基本数据类型"><a href="#要素1：基本数据类型" class="headerlink" title="要素1：基本数据类型"></a>要素1：基本数据类型</h2><ul>
<li><p>任何数据语言都必须能够表示基本数据项目</p>
</li>
<li><p>Python 中的基本数据类型有</p>
<p>【1】Integral 类型 </p>
<p>​    （1）.整型：不可变类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">num = <span class="number">1</span> <span class="comment">#被保存在内存中，是不可变的</span></div></pre></td></tr></table></figure>
<p>​    注意：对象和变量都是不可变的</p>
<p>​    （2）.布尔型  (Ture、False) </p>
<p>​    注意：加引号 </p>
<p>【2】浮点类型</p>
<p>​    （1）. 浮点数字</p>
<p>​    （2）. 复数</p>
<p>【3】字符串</p>
<p>​    注意：在这里字符串表示的序列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">type(放任意的类型) <span class="comment"># 输出变量的类型</span></div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<h2 id="要素2：对象引用（变量）"><a href="#要素2：对象引用（变量）" class="headerlink" title="要素2：对象引用（变量）"></a>要素2：对象引用（变量）</h2><ul>
<li><p>Python 将所有数据存为内存对象</p>
</li>
<li><p>Python 中，对象事实上是只想内存对象的引用</p>
</li>
<li><p>动态类型：在任何时刻，只要需要，某个对象都可以重新引用一个不同的对象（可以是不同的数据类型）</p>
</li>
<li><p>内建函数type()用于返回给定数据项的数据类型</p>
</li>
<li><p>“=” 用于将变量名与内存中的某个对象进行绑定：如果对象事先存在，就直接绑定；否则用 “=” 创建引用的对象。</p>
<ul>
<li><img src="http://orbs83j4x.bkt.clouddn.com/blog/180113/L99LElb9dB.png" alt="mark"></li>
</ul>
</li>
<li><p>变量的命名规则</p>
<ul>
<li>只能包含字母下、数字和下划线，且不能以数字开头。</li>
<li>区分数字大小写</li>
<li>禁止使用保留字段（Python2和Python3有所不同）</li>
</ul>
</li>
<li><p>命名惯例</p>
<ul>
<li><p>一单个下划线开头的变量名称 (_x) 不会被 from model import * 语句导入</p>
</li>
<li><p>前后都有下滑线的变量名(<em>x </em>) 是系统定义的变量名称，对 Python 解释器有特殊的意义</p>
</li>
<li><p>以两个下划线开头但结尾没有下划线的变量名称(__x)是类的本地变量</p>
</li>
<li><p>交互模式下，变量名 “—” 用于保存最后表达式的结果</p>
<ul>
<li><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>+<span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(_)</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li><strong>变量名没有类型，对象才有</strong></li>
<li>变量可以指定任何类型（这是 Python 和其他语言不同的）</li>
</ul>
</li>
</ul>
<h2 id="要素3：组合数据类型"><a href="#要素3：组合数据类型" class="headerlink" title="要素3：组合数据类型"></a>要素3：组合数据类型</h2><ul>
<li><p>数据结构：通过某种方式（例如对元素进行编码）组织在一起的数据元素的集合</p>
</li>
<li><p>Python 常用的组合数据类型</p>
<ul>
<li><p>序列类型</p>
</li>
<li><p><img src="http://orbs83j4x.bkt.clouddn.com/blog/180113/57KL9DI08I.png" alt="mark"></p>
<ul>
<li><p>列表：使用[]创建，如[‘Call’,’me’,’Ishmell’,’_’]</p>
<ul>
<li><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="string">'Call'</span>,<span class="string">'me'</span>,<span class="string">'Ishmell'</span>,<span class="string">'_'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l1[<span class="number">0</span>]</div><div class="line"><span class="string">'Call'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l1[<span class="number">0</span>][<span class="number">0</span>]</div><div class="line"><span class="string">'C'</span></div></pre></td></tr></table></figure>
</li>
<li><p>注意：列表是可变的，可以在原处进行修改，且内容改变，id 不会改变</p>
</li>
<li><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(l1)</div><div class="line">[<span class="string">'Call'</span>, <span class="string">'me'</span>, <span class="string">'Ishmell'</span>, <span class="string">'_'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(l1[<span class="number">1</span>])</div><div class="line">me</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l1[<span class="number">1</span>] = <span class="string">'your'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(l1)</div><div class="line">[<span class="string">'Call'</span>, <span class="string">'your'</span>, <span class="string">'Ishmell'</span>, <span class="string">'_'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>id(l1)</div><div class="line"><span class="number">1543556324360</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l1[<span class="number">2</span>]= <span class="string">'Xshell'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(l1)</div><div class="line">[<span class="string">'Call'</span>, <span class="string">'your'</span>, <span class="string">'Xshell'</span>, <span class="string">'_'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>id(l1)</div><div class="line"><span class="number">1543556324360</span></div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
</li>
<li><p>元组：使用 () 创建，如(‘one’,’two’)</p>
<ul>
<li><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = (<span class="string">'This'</span>,<span class="string">'is'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t1[<span class="number">1</span>]</div><div class="line"><span class="string">'is'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t1[<span class="number">0</span>]</div><div class="line"><span class="string">'This'</span></div></pre></td></tr></table></figure>
</li>
<li><p>注意: 元组是不能做原处修改的，一旦修改就会引发异常</p>
</li>
</ul>
<p>​</p>
</li>
<li><p>字符串也属于序列类型</p>
<ul>
<li><p>优点：可以做字符串的切块操作</p>
</li>
<li><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">'jerry'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>name[<span class="number">0</span>]</div><div class="line"><span class="string">'j'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>name[<span class="number">0</span>:<span class="number">1</span>]</div><div class="line"><span class="string">'j'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>name[<span class="number">0</span>:<span class="number">2</span>]</div><div class="line"><span class="string">'je'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>name[:<span class="number">2</span>]</div><div class="line"><span class="string">'je'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>name[<span class="number">2</span>:]</div><div class="line"><span class="string">'rry'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>name[<span class="number">0</span>:<span class="number">4</span>]</div><div class="line"><span class="string">'jerr'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>name[<span class="number">0</span>:<span class="number">4</span>:<span class="number">2</span>]</div><div class="line"><span class="string">'jr'</span></div></pre></td></tr></table></figure>
</li>
<li><p>注意：切块本身会创建新的对象（因为字符串本身是不可用的）</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>集合类型</p>
<ul>
<li>集合（杂乱的数据）</li>
</ul>
</li>
<li><p>映射类型</p>
<ul>
<li>字典</li>
</ul>
</li>
<li><p>列表是可变序列，元组是不可变序列</p>
</li>
<li><p>Python 中，组合数据类型也是对象，因此其可以嵌套</p>
<ul>
<li>[‘hello’,’worle’,[1,2,3]]</li>
</ul>
</li>
<li><p>实质上，列表和元组并不是真正存储数据，而是存放对象引用</p>
</li>
<li><p>Python 对象可以具有其可以被调用的特定 “方法（函数）”</p>
</li>
<li><p>元组、列表以及字符串等数据类型是“有大小的”，也即，其长度可用内置函数 len() 测量</p>
</li>
</ul>
</li>
</ul>
<h2 id="要素4：逻辑操作符"><a href="#要素4：逻辑操作符" class="headerlink" title="要素4：逻辑操作符"></a>要素4：逻辑操作符</h2><ul>
<li><p>逻辑运算是任何程序设计语言的基本共能</p>
</li>
<li><p>Python 提供了4 组逻辑运算符</p>
<ul>
<li><p>身份操作符</p>
<ul>
<li><p>is:判断左端对象引用是否等于右端对象引用；也可以与Node进行；</p>
</li>
<li><p>对象引用可以不同，但是对象 所属的类型有可能是相同</p>
</li>
<li><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>name=<span class="string">"swfswf"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>test=<span class="string">"swfswf"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>type(name) <span class="keyword">is</span> type(test)</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>比较操作符号</p>
<ul>
<li>&lt;,&gt;,&lt;=,&gt;=,!=,==</li>
</ul>
</li>
<li><p>成员操作符</p>
<ul>
<li>in 或 not in :测试成员关系</li>
</ul>
</li>
<li><p>逻辑运算符</p>
<ul>
<li>and、or、not</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="要素5：控制流语句"><a href="#要素5：控制流语句" class="headerlink" title="要素5：控制流语句"></a>要素5：控制流语句</h2><ul>
<li><p>控制流语句是过程式编程语言的基本控制机制</p>
</li>
<li><p>Python 的常见控制流语句</p>
<ul>
<li><p>if</p>
<ul>
<li><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> boolean_expression1:</div><div class="line">  suite1</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> boolean_expression2:</div><div class="line">  suite2</div><div class="line">.....</div><div class="line"><span class="keyword">else</span>:</div><div class="line">  else_suite</div></pre></td></tr></table></figure>
</li>
<li><p>注意：冒号是代码块起始的标志</p>
</li>
</ul>
</li>
<li><p>while</p>
<ul>
<li><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> boolean_expression:</div><div class="line">  suite</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>for…in</p>
<ul>
<li><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> variable <span class="keyword">in</span> iterable:</div><div class="line">  suite</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>try</p>
</li>
</ul>
</li>
</ul>
<h2 id="要素6：算数操作符"><a href="#要素6：算数操作符" class="headerlink" title="要素6：算数操作符"></a>要素6：算数操作符</h2><ul>
<li>Python 提供了完整的算数操作符集</li>
<li>很多的 Python 数据类型也可以使用增强的赋值操作符，如+=、-= 等</li>
<li>同样的功能使用增强型赋值操作符的性能较好。</li>
<li>Python 的 int 类型是不可变的，因此，增强型赋值的实际过程是创建了一个新的对象来存储结果后将变量名执行了重新绑定<ul>
<li><img src="http://orbs83j4x.bkt.clouddn.com/blog/180113/lC2i9Jf2ag.png" alt="mark"> </li>
</ul>
</li>
</ul>
<h2 id="要素7：输入-输出"><a href="#要素7：输入-输出" class="headerlink" title="要素7：输入/输出"></a>要素7：输入/输出</h2><ul>
<li><p>现实中，具有实际共能的程序必须能够读取输入（如从键盘或文件中），以及产生输出，并写到终端或文件中</p>
</li>
<li><p>Python 的输入/输出</p>
<ul>
<li><p>输出</p>
<ul>
<li>Python3：print() 函数</li>
<li>Python2:  print 语句</li>
</ul>
</li>
<li><p>输入</p>
<ul>
<li><p>input()</p>
<ul>
<li><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>input(<span class="string">"plz input a num:"</span>)</div><div class="line">plz input a num:a</div><div class="line"><span class="string">'a'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>input(<span class="string">"plz input a num:"</span>)</div><div class="line">plz input a num:<span class="number">3</span></div><div class="line"><span class="string">'3'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = input(<span class="string">"plz input a num:"</span>)</div><div class="line">plz input a num:Hello</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(a)</div><div class="line">Hello</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>row_input()</p>
</li>
</ul>
</li>
<li><p>Python 解释器提供了 3 中标准的文件对象，分别为标准输入、标准输出和标准错误，它们 sys 模块中分别以 sys.stdin、sys.stdout 和 sys.stderr 形式提供</p>
</li>
<li><p>Python 的 print 语句实现打印</p>
</li>
<li><p>从技术角度来讲，print 是把一个或多个对象转化为其文本表达形式，然后发送给标准输出或另一个类似文件的流</p>
<ul>
<li><p>在 Python 中，打印与文件和流的概念联系紧密</p>
<ul>
<li>文件写入方法是把字符串写入到任意文件</li>
<li>print 默认把对象打印到 stdout 流，并添加一些自动的格式化</li>
</ul>
</li>
<li><p>实质上，print 语句只是 Python 的人性化特性的具体实现，它提供了 sys.stdout.write() 的简单接口，再加上一些默认的格式设置</p>
</li>
<li><p>print 接受一个逗号分隔的对象列表，并为行尾自动添加一个换行符，如果不需要，则在最后个元素后面添加逗号</p>
</li>
<li><p>实现格式化输出，print “String %format1%format2…”%(varialbe1,varialbe2,…….) </p>
</li>
<li><p>| 字符   | 输出格式                       |<br>| —- | ————————– |<br>| d,i  | 十进制整数或长整型                  |<br>| u    | 无符号整数或长整型                  |<br>| o    | 八进制整数或长整型                  |<br>| x    | 十六进制整数或长整型                 |<br>| X    | 十六进制整数                     |<br>| f    | 浮点数                        |<br>| e    | 浮点数                        |<br>| E    | 浮点数                        |<br>| g,G  | 指数小于-4或更高精度时使用%e或%E,否则使用%f |<br>| s    | 字符串火任意对象，格式化代码使用str()生成字符串 |<br>| r    | 同 repr() 生成的字符串            |<br>| c    | 单个字符                       |<br>| %    | 字面量%                       |</p>
<p>​</p>
</li>
<li><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>num = <span class="number">7.9</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"The num is %f"</span> %num)</div><div class="line">The num <span class="keyword">is</span> <span class="number">7.900000</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"The num is %d"</span> %num)</div><div class="line">The num <span class="keyword">is</span> <span class="number">7</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>num2 = <span class="number">9.13</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"The nums are %d and %f"</span> %(num,num2))</div><div class="line">The nums are <span class="number">7</span> <span class="keyword">and</span> <span class="number">9.130000</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"The nums are %e and %f"</span>%(num,<span class="number">3.1</span>))</div><div class="line">The nums are <span class="number">7.900000e+00</span> <span class="keyword">and</span> <span class="number">3.100000</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"The nums are %d and %f"</span>%(num,<span class="number">3.1</span>))</div><div class="line">The nums are <span class="number">7</span> <span class="keyword">and</span> <span class="number">3.100000</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">"Jerry"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"The name is %s."</span>%name)</div><div class="line">The name <span class="keyword">is</span> Jerry.</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"The name is %s."</span>%num)</div><div class="line">The name <span class="keyword">is</span> <span class="number">7.9</span>.</div></pre></td></tr></table></figure>
</li>
<li><p>注意：Python 的输出是需要转换的。 </p>
</li>
<li><p>数据转换类型：</p>
<ul>
<li><p>显示转换</p>
</li>
<li><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; num = 7.9</div><div class="line">&gt;&gt;&gt; test3 = str(num)</div><div class="line">&gt;&gt;&gt; type(test3)</div><div class="line">&lt;class 'str'&gt;</div><div class="line">&gt;&gt;&gt; type(num)</div><div class="line">&lt;class 'float'&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>隐式转换</p>
</li>
</ul>
</li>
<li><p>想知道内置有多少种类型</p>
<ul>
<li><p>python3</p>
</li>
<li><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>dir()</div><div class="line">[<span class="string">'__annotations__'</span>, <span class="string">'__builtins__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__loader__'</span>, <span class="string">'__name__'</span>, <span class="string">'__package__'</span>, <span class="string">'__spec__'</span>, <span class="string">'name'</span>, <span class="string">'num'</span>, <span class="string">'num2'</span>, <span class="string">'test3'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dir(__builtins__)</div></pre></td></tr></table></figure>
</li>
<li><p>python2</p>
</li>
<li><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;dir(builtins)</div><div class="line">[<span class="string">'__annotations__'</span>, <span class="string">'__builtins__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__loader__'</span>, <span class="string">'__name__'</span>, <span class="string">'__package__'</span>, <span class="string">'__spec__'</span>, <span class="string">'name'</span>, <span class="string">'num'</span>, <span class="string">'num2'</span>, <span class="string">'test3'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dir(__builtins__)</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>想明确一个工具怎么使用</p>
<ul>
<li><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; help(str)</div><div class="line">Help on class str in module builtins:</div><div class="line"></div><div class="line">class str(object)</div><div class="line"> |  str(object='') -&gt; str</div><div class="line"> |  str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</div><div class="line"> |  </div><div class="line"> |  Create a new string object from the given object. If encoding or</div><div class="line"> |  errors is specified, then the object must expose a data buffer</div><div class="line"> |  that will be decoded using the given encoding and error handler.</div><div class="line"> ....</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>% 后面可以使用的修饰符，（如果有只能按如下的顺序）</p>
<ul>
<li><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%[(name)][flags][width][.precision]typecode</div></pre></td></tr></table></figure>
<ul>
<li><p>位于括号中的一个属性后面的字典的键名，用于选出一个具体项</p>
</li>
<li><p>下面标志中的一个或多个</p>
<ul>
<li><p>减号（-）:表示左对齐，默认为右对齐</p>
<ul>
<li><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"The name are %+10f and %+f"</span>%(num,<span class="number">-3.1</span>))</div><div class="line">The name are  +<span class="number">7.900000</span> <span class="keyword">and</span> <span class="number">-3.100000</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"The name are %-20f and %+f"</span>%(num,<span class="number">-3.1</span>))</div><div class="line">The name are <span class="number">7.900000</span>             <span class="keyword">and</span> <span class="number">-3.100000</span></div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
</li>
<li><p>加号（+）:表示包含数字符号，整数也会带 “+”</p>
<ul>
<li><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;num=<span class="number">7.9</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"The name are %+e and %f"</span>%(num,<span class="number">3.1</span>))</div><div class="line">The name are +<span class="number">7.900000e+00</span> <span class="keyword">and</span> <span class="number">3.100000</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"The name are %+e and %+f"</span>%(num,<span class="number">3.1</span>))</div><div class="line">The name are +<span class="number">7.900000e+00</span> <span class="keyword">and</span> +<span class="number">3.100000</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"The name are %+e and %f"</span>%(num,<span class="number">-3.1</span>))</div><div class="line">The name are +<span class="number">7.900000e+00</span> <span class="keyword">and</span> <span class="number">-3.100000</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"The name are %+e and %+f"</span>%(num,<span class="number">-3.1</span>))</div><div class="line">The name are +<span class="number">7.900000e+00</span> <span class="keyword">and</span> <span class="number">-3.100000</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"The name are %f and %f"</span>%(num,<span class="number">-3.1</span>))</div><div class="line">The name are <span class="number">7.900000</span> <span class="keyword">and</span> <span class="number">-3.100000</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>零（0）:表示一个零填充</p>
</li>
</ul>
</li>
<li><p>一个指定最小宽度的数</p>
</li>
<li><p>一个小数,用于按照精度分割字段的宽度(如下例子：15指小数占15位数)</p>
<ul>
<li><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"The name are %-20.15f and %+f"</span>%(num,<span class="number">-3.1</span>))</div><div class="line">The name are <span class="number">7.900000000000000</span>    <span class="keyword">and</span> <span class="number">-3.100000</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>一个数字,指定要打印字符串中的最大字符个数，浮点数中小数点之后的位数，或者整数最小位数。</p>
</li>
<li><p>字典：kv集合（键值对集合）</p>
<ul>
<li><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d1=&#123;<span class="string">'a'</span>:<span class="number">33</span>,<span class="string">'b'</span>:<span class="number">66</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d1[<span class="string">'a'</span>]</div><div class="line"><span class="number">33</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d1=&#123;<span class="number">0</span>:<span class="number">33</span>,<span class="number">1</span>:<span class="number">66</span>&#125;	</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d1[<span class="number">0</span>]</div><div class="line"><span class="number">33</span></div></pre></td></tr></table></figure>
</li>
<li><p>注意字典也是可变对象;键可以是字符也可以是数字</p>
</li>
<li><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d=&#123;<span class="string">'x'</span>:<span class="number">32</span>,<span class="string">'y'</span>:<span class="number">27.490325</span>,<span class="string">'z'</span>:<span class="number">65</span>&#125;</div><div class="line">	</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"%(x)-10d %(y)0.3g"</span>%d)</div><div class="line">	</div><div class="line"><span class="number">32</span>         <span class="number">27.5</span></div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="要素8：函数的创建与调用"><a href="#要素8：函数的创建与调用" class="headerlink" title="要素8：函数的创建与调用"></a>要素8：函数的创建与调用</h2><ul>
<li><p>函数实现模块化编程的组件</p>
</li>
<li><p>Python 使用 def 语句定义函数</p>
<ul>
<li><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionName</span><span class="params">(arguments)</span>:</span></div><div class="line">  suite</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>函数可以参数化，通过传递不同的参数来调用。</p>
<ul>
<li><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">printName</span><span class="params">(name)</span>:</span></div><div class="line">	print(name)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>printName(<span class="string">'Tony'</span>)</div><div class="line">Tony</div></pre></td></tr></table></figure>
</li>
<li><p>注意：函数也是对象</p>
</li>
</ul>
</li>
<li><p>每个 Python 函数都有一个返回值，默认为None,也可以使用 “return value” 明确定义返回值</p>
</li>
<li><p>def 会创建一个函数对象，并同时创建一个函数的对象引用</p>
<ul>
<li><p>函数也是对象，可以存储在组合数据类型中，也可以作为参数传递给其他函数</p>
</li>
<li><p>callable() 可用于测试函数是否可调用</p>
<ul>
<li><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>callable(name)</div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>callable(printName)</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Python 有众多内置函数</p>
<ul>
<li>dir()、id()、type() 、str()、help()、len()、callable() 等等</li>
</ul>
</li>
<li><p>Python 标准库拥有众多内置模块，这些模块拥有大量的函数</p>
<ul>
<li>Python 模块实际上是包含 Python 代码的 .py 文件，其拥有自定义的函数与类及变量等</li>
<li>导入代码块使用 import 语句进行，后跟模块名称（不能指定模块文件的后缀.py）</li>
<li>导入一个模块后，可以访问其内部的任意函数、类及变量</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Python 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python 常用的内置（BIF）函数]]></title>
      <url>/2018/01/01/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h1 id="Python-常用的内置函数"><a href="#Python-常用的内置函数" class="headerlink" title="Python 常用的内置函数"></a>Python 常用的内置函数</h1><p>如果你遇到一个需求，且你认为这个需求很普遍，先想想有没有什么内置函数可以使用（BIF）。另外要记住：Python 3 包含 70 多个 BIF ，所以有大量现成的功能等着你来发现。</p>
<a id="more"></a>
<h2 id="list"><a href="#list" class="headerlink" title="list()"></a>list()</h2><p>这是一个工厂函数，创建一个新的空列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os;</div><div class="line">aTuole = (<span class="number">123</span>,<span class="string">'xyz'</span>,<span class="string">'zare'</span>,<span class="string">'abc'</span>);</div><div class="line">aList = list(aTuole);</div><div class="line">print(<span class="string">"列表元素："</span>,aList);</div></pre></td></tr></table></figure>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171229/8b4kC2eae9.png" alt="mark"></p>
<h2 id="range"><a href="#range" class="headerlink" title="range()"></a>range()</h2><p><strong>range() BIF 迭代固定次数。</strong></p>
<p>可以提供你需要的控制来迭代指定的次数，而且可以用来生成一个从 0 直到（但不包含）某个数的数字列表。</p>
<p>一下是这个 BIF 的用法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os;</div><div class="line"><span class="comment"># num 是目标标识符，会琢个赋值为 "range()" 生成的各个数字</span></div><div class="line"><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">4</span>); </div><div class="line">print(num);</div></pre></td></tr></table></figure>
<p>F5 运行程序</p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171228/mmHDibgjKc.png" alt="mark"></p>
<h2 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate()"></a>enumerate()</h2><p>创建成对数据的一个编码列表，从 0 开始</p>
<p><strong>先来做一个对比:</strong></p>
<p>法1: 使用 range() 和 len() 来实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os;</div><div class="line">aTuole = (<span class="string">'xyz'</span>,<span class="string">'zare'</span>,<span class="string">'abc'</span>);</div><div class="line">	print(i,aTuole[i]);</div></pre></td></tr></table></figure>
<p>法2:使用enumerate () 来实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os;</div><div class="line">aTuole = (<span class="string">'xyz'</span>,<span class="string">'zare'</span>,<span class="string">'abc'</span>);</div><div class="line"><span class="keyword">for</span> index,text <span class="keyword">in</span> enumerate(aTuole):</div><div class="line">	print(index,text);</div></pre></td></tr></table></figure>
<p>enumerate会将数组或列表组成一个索引序列。使我们再获取索引和索引内容的时候更加方便。</p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171229/B9fKi2g1j6.png" alt="mark"></p>
<h2 id="int"><a href="#int" class="headerlink" title="int()"></a>int()</h2><p>int()函数的作用是将一个数字或base类型的字符串转换成整数。</p>
<p>函数原型 int(x, base=10)，base缺省值为10，也就是说不指定base的值时，函数将x按十进制处理。</p>
<p><strong>注意：</strong></p>
<ul>
<li>x 可以是数字或字符串，但是base被赋值后 x 只能是字符串</li>
<li>x 作为字符串时必须是 base 类型，也就是说 x 变成数字时必须能用 base 进制表示</li>
</ul>
<p>【1】 x 是数字的情况：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int(<span class="number">2.345</span>)         <span class="comment"># 2</span></div><div class="line">int(<span class="number">2e2</span>)           <span class="comment"># 200</span></div><div class="line">int(<span class="number">23</span>, <span class="number">2</span>)         <span class="comment"># 出错，base 被赋值后函数只接收字符串</span></div></pre></td></tr></table></figure>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171229/djc6e8BJEk.png" alt="mark"></p>
<p>【2】x 是字符串的情况：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int(<span class="string">'23'</span>, <span class="number">16</span>)      <span class="comment"># 35</span></div><div class="line">int(<span class="string">'HI'</span>, <span class="number">16</span>)      <span class="comment"># 出错，HI不是个16进制数</span></div></pre></td></tr></table></figure>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171229/L8glIeA3J4.png" alt="mark"></p>
<p>【3】 base 可取值范围是 2~36，囊括了所有的英文字母(不区分大小写)，十六进制中F表示15，那么G将在二十进制中表示16，依此类推….Z在三十六进制中表示35</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int(<span class="string">'FZ'</span>, <span class="number">16</span>)      <span class="comment"># 出错，FZ不能用十六进制表示</span></div><div class="line">int(<span class="string">'FZ'</span>, <span class="number">36</span>)      <span class="comment"># 575</span></div></pre></td></tr></table></figure>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171229/14Fh4KLmBL.png" alt="mark"></p>
<p>【4】字符串 0x 可以出现在十六进制中，视作十六进制的符号，同理 0b 可以出现在二进制中，除此之外视作数字 0 和字母 x</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int(<span class="string">'0x10'</span>, <span class="number">16</span>)  <span class="comment"># 16，0x是十六进制的符号</span></div><div class="line">int(<span class="string">'0x10'</span>, <span class="number">17</span>)  <span class="comment"># 出错，'0x10'中的 x 被视作英文字母 x</span></div><div class="line">int(<span class="string">'0x10'</span>, <span class="number">36</span>)  <span class="comment"># 42804，36进制包含字母 x</span></div></pre></td></tr></table></figure>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171229/0lCmkdBd14.png" alt="mark"></p>
<h2 id="id"><a href="#id" class="headerlink" title="id()"></a>id()</h2><p>id(object)函数是返回对象object在其生命周期内位于内存中的地址，id函数的参数类型是一个对象。</p>
<p><strong>注意：</strong></p>
<p>我们需要明确一点就是在Python中一切皆<strong>对象</strong>，变量中存放的是对象的引用。这个确实有点难以理解，“一切皆对象”？对，在Python中确实是这样，包括我们之前经常用到的字符串常量，整型常量都是对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os;</div><div class="line">print(id(<span class="number">5</span>));</div><div class="line">print( id(<span class="string">'python'</span>));</div><div class="line">x=<span class="number">2</span></div><div class="line">print(id(x));</div><div class="line">y=<span class="string">'hello'</span></div><div class="line">print(id(y));</div></pre></td></tr></table></figure>
<p>这段代码的运行结果:</p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171229/kgjH35eHAd.png" alt="mark"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os;</div><div class="line">x=<span class="number">2</span></div><div class="line">print(id(<span class="number">2</span>));</div><div class="line">print(id(x)); </div><div class="line">y=<span class="string">'hello'</span></div><div class="line">print(id(<span class="string">'hello'</span>)); </div><div class="line">print(id(y));</div></pre></td></tr></table></figure>
<p>运行结果:</p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171229/B89BAdgEGe.png" alt="mark"></p>
<p><strong>结果说明:</strong>对于这个语句id(2)没有报错，就可以知道2在这里是一个对象。id(x)和id(2)的值是一样的，id(y)和id(‘hello’)的值也是一样的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">x=<span class="number">2</span>;</div><div class="line">print(id(x));</div><div class="line">y=<span class="number">2</span>;</div><div class="line">print(id(y));</div><div class="line">s=<span class="string">'hello'</span>;</div><div class="line">print(id(s));</div><div class="line">t=s;</div><div class="line">print(id(t));</div></pre></td></tr></table></figure>
<p>运行结果:</p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171229/d9i27aEKKg.png" alt="mark"></p>
<p><strong>结果说明:</strong>id(x)和id(y)的结果是相同的，id(s)和id(t)的结果也是相同的。这说明x和y指向的是同一对象，而t和s也是指向的同一对象。x=2这句让变量x指向了int类型的对象2，而y=2这句执行时，并不重新为2分配空间，而是<strong>让y直接指向了已经存在的int类型的对象2</strong>.这个很好理解，因为本身只是想给y赋一个值2，而在内存中已经存在了这样一个int类型对象2，所以就直接让y指向了已经存在的对象。这样一来<strong>不仅能达到目的，还能节约内存空间</strong>。t=s这句变量互相赋值，也相当于是让t指向了已经存在的字符串类型的对象’hello’。</p>
<p><strong>看这幅图就理解了：</strong></p>
<p>　　<img src="http://images.cnitblog.com/blog/288799/201303/15155442-4f2d077a181e4c37bc8691c2739a911f.jpg" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">x=<span class="number">2</span>;</div><div class="line">print(id(<span class="number">2</span>)); </div><div class="line">print(id(x)); </div><div class="line">x=<span class="number">3</span>;</div><div class="line">print(id(<span class="number">3</span>)); </div><div class="line">print(id(x)); </div><div class="line">L=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line">M=L;</div><div class="line">print(id(L));</div><div class="line">print(id(M)); </div><div class="line">print(id(L[<span class="number">2</span>])); </div><div class="line">L[<span class="number">0</span>]=<span class="number">2</span>;</div><div class="line">print(id(L)); </div><div class="line">print(M);</div></pre></td></tr></table></figure>
<p>运行结果:</p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171229/HDCKE684L4.png" alt="mark"></p>
<p><strong>结果分析:</strong>两次的id(x)的值不同，这个可能让人有点难以理解。注意，<strong>在Python中，单一元素的对象是不允许更改的，比如整型数据、字符串、浮点数等。</strong>x=3这句的执行过程并不是先获取x原来指向的对象的地址，再把内存中的值更改为3，而是新申请一段内存来存储对象3，再让x去指向对象3，所以两次id(x)的值不同。然而为何改变了L中的某个子元素的值后，id(L)的值没有发生改变？<strong>在Python中，复杂元素的对象是允许更改的，</strong>比如列表、字典、元组等。Python中变量存储的是对象的引用，对于列表，其id()值返回的是列表第一个子元素L[0]的存储地址。就像上面的例子，L=[1,2,3]，这里的L有三个子元素L[0]，L[1]，L[2]，L[0]、L[1]、L[2]分别指向对象1、2、3，id(L)值和对象3的存储地址相同.</p>
<p><strong>看下面这个图就明白了:</strong></p>
<p>　　<img src="http://images.cnitblog.com/blog/288799/201303/15162702-c783bec88969421ebc16950714812a06.jpg" alt="img"></p>
<p>因为L和M指向的是同一对象，所以在更改了L中子元素的值后，M也相应改变了，但是id(L)值并没有改变，因为这句L[0]=2只是让L[0]重新指向了对象2，而L[0]本身的存储地址并没有发生改变，所以id(L)的值没有改变（ id(L)的值实际等于L[0]本身的存储地址）。</p>
<h2 id="next"><a href="#next" class="headerlink" title="next()"></a>next()</h2><p>next()函数返回迭代器的下一个元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">it = iter([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>])</div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        x = next(it)</div><div class="line">        print(x); <span class="comment"># 或者 x = it.next()</span></div><div class="line">    <span class="keyword">except</span> StopIteration:</div><div class="line">        <span class="keyword">break</span></div></pre></td></tr></table></figure>
<p>运行结果:</p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171229/m4DBDAJ72h.png" alt="mark"></p>
]]></content>
      
        <categories>
            
            <category> 常用的内置（BIF）函数 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python发布包到pypi]]></title>
      <url>/2018/01/01/python%E5%8F%91%E5%B8%83%E5%8C%85%E5%88%B0pypi/</url>
      <content type="html"><![CDATA[<h1 id="python发布包到pypi"><a href="#python发布包到pypi" class="headerlink" title="python发布包到pypi"></a>python发布包到pypi</h1><p>python更新太快了，甚至连这种发布上传机制都在不断的更新，这导致网上的一些关于python发布上传到pypi的教程都过时了，按着博文操作可能会失败。</p>
<a id="more"></a>
<h2 id="pypi相关概念介绍"><a href="#pypi相关概念介绍" class="headerlink" title="pypi相关概念介绍"></a>pypi相关概念介绍</h2><h4 id="关于pypi本身"><a href="#关于pypi本身" class="headerlink" title="关于pypi本身"></a>关于pypi本身</h4><p>　　pypi是专门用于存放第三方python包的地方，你可以在这里找别人分享的模块，也可以自己分享模块给别人。可以通过easy_install或者pip进行安装。pypi针对分享提供了两个平台，一个是测试发布平台，一个是正式发布平台，我们正式发布前可以先用测试发布平台发布，看是否正确，然后再采用正式发布平台．</p>
<h4 id="关于python打包发布工具"><a href="#关于python打包发布工具" class="headerlink" title="关于python打包发布工具"></a>关于python打包发布工具</h4><p>　　python的打包安装工具也经历了很多次变化，由最早的distutils到setuptools到distribute又回到setuptools，后来还有disutils2以及distlib等，其中distutils是python标准库的一部分，它提出了采用setup.py机制安装和打包发布上传机制．setuptools(操作系统发布版本可能没有自带安装,需要自己额外安装)基于它扩展了很多功能，也是采用setup.py机制，针对安装额外提供了easy_install命令．distribute是setuptools的一个分之，后来又合并到setuptools了，所以姑且就把它看做是最新的setuptools吧！和我们打包最相关的貌似就是distutils或者setuptools，两者都可以用来打包发布并上传到pypi，后面介绍采用distutils，如果想更多的功能，比如想通过entry points扩展的一些功能，那么就要使用setuptools了．另外，还有一个工具可以用来发布到pypi，叫twine，需要额外安装．最后,需要确保自己的工具都是尽量新的,官方给出的版本参考:twine v1.8.0+ (recommended tool), setuptools 27+, or the distutils included with Python 3.4.6+,Python 3.5.3+, Python 3.6+, and 2.7.13+,升级的参考命令:</p>
<p><code>sudo -H pip install -U pip setuptools twine</code></p>
<h2 id="写一个-setup-py"><a href="#写一个-setup-py" class="headerlink" title="写一个 setup.py"></a>写一个 setup.py</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup  <span class="comment"># 从 Python 发布工具导入 setup 函数</span></div><div class="line">setup(</div><div class="line">  	  name=<span class="string">'swfswf'</span>, <span class="comment"># 要打包的模块名称</span></div><div class="line">      version=<span class="string">'1.0'</span>, </div><div class="line">      description=<span class="string">'Python Distribution Utilities'</span>,</div><div class="line">      author=<span class="string">'shenwenfang'</span>,</div><div class="line">      author_email=<span class="string">'1978626782@qq.com'</span>,</div><div class="line">      url=<span class="string">'https://swenfang.github.io/'</span>,</div><div class="line">     )</div></pre></td></tr></table></figure>
<p> 也可参阅官方文档：</p>
<ul>
<li><a href="https://docs.python.org/2/distutils/setupscript.html" target="_blank" rel="external">https://docs.python.org/2/dis…</a></li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li><p>这里只是最基本的参考例子，执行打包会报警告，说缺少一些需要的文件，比如MANIFEST.in、readme.txt等等，暂时忽略即可。正式的项目中会复杂很多，甚至需要用到setuptools来扩展。这部分可以参考其他文档</p>
</li>
<li><p><strong>为了保证效果，在打包之前我们可以验证setup.py的正确性。执行代码<code>python setup.py check</code>，输出一般是running check，如果有错误或者警告，就会在此之后显示.没有任何显示表示Distutils认可你这个setup.py文件</strong></p>
</li>
<li><p>执行 <strong><code>python setup.py sdist upload -r pypi</code></strong> 创建发布并上传,如果想先上传到测试平台，可以执行 <strong>python setup.py sdist upload -r pypitest</strong>，成功后再执行上面命令上传到正式平台。注意，这一步的配置文件里面由于pypi的发布机制更新导致有一些问题的出现。</p>
</li>
<li><p>410错误：这个是pypi上传机制变更导致的,我虽然参考的是最新的blog，但是还是过时了！！！（.pypirc的repository过时了，很多博客说的<code>repository: https://pypi.python.org/pypi</code>会导致后面步骤操作出现410错误）</p>
<p>​</p>
</li>
</ul>
<h2 id="打包发布到pypi"><a href="#打包发布到pypi" class="headerlink" title="打包发布到pypi"></a>打包发布到pypi</h2><p><strong>基本流程：</strong></p>
<ul>
<li><p>注册 pypi 账号，如果期望测试发布，同时需要注册<a href="https://testpypi.python.org/pypi?:action=register_form" target="_blank" rel="external">pypitest</a>账号（可以采用相同的用户名和密码）</p>
<p>直接通过官网注册 <a href="https://pypi.python.org/pypi?%3Aaction=register_form" target="_blank" rel="external">https://pypi.python.org/pypi?…</a>，填写用户名、密码、确认密码、邮箱，</p>
<p> 但是需要验证邮件并确认激活。</p>
</li>
<li><p>创建配置文件, 该配置文件里面记录了你的账号信息以及要发布的平台信息，参考如下配置文件创建即可</p>
<p>在自己的用户目录下新建一个空白文件命名为<code>.pypirc</code>，内容如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[distutils]</div><div class="line">index-servers=pypi</div><div class="line"></div><div class="line">[pypi]</div><div class="line">repository = https://upload.pypi.org/legacy/</div><div class="line">username = shenwenfang</div><div class="line">password = **************</div><div class="line"></div><div class="line"><span class="comment"># 如果期望测试发布，同时需要</span></div><div class="line"><span class="comment">#repository: https://test.pypi.org/legacy/</span></div><div class="line"><span class="comment">#username= your_username</span></div><div class="line"><span class="comment">#password= your_password</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/180101/jDEFKjA19C.png" alt="mark"></p>
<p><strong>相关命令：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python setup.py check <span class="comment">#验证setup.py的正确性</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python setup.py sdist upload -r pypi <span class="comment">#打包发布到pypi，返回 "Server response (200) : OK" 说明上传成功</span></div></pre></td></tr></table></figure>
<p><strong>查看上传记录：</strong></p>
<p>如果你的包已经上传成功，那么当你登录PyPI网站后应该能在右侧导航栏看到管理入口。</p>
<p><img src="https://segmentfault.com/img/remote/1460000008663129?w=230&amp;h=177" alt="img"></p>
<h2 id="测试代码块"><a href="#测试代码块" class="headerlink" title="测试代码块"></a>测试代码块</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> swfswf;</div><div class="line">swfswf.print_lol(参数<span class="number">1</span>，参数<span class="number">2.</span>..)</div></pre></td></tr></table></figure>
<h3 id="管理你的包"><a href="#管理你的包" class="headerlink" title="管理你的包"></a>管理你的包</h3><p>如果你的包已经上传成功，那么当你登录PyPI网站后应该能在右侧导航栏看到管理入口。</p>
<p><img src="https://segmentfault.com/img/remote/1460000008663129?w=230&amp;h=177" alt="img"></p>
<p>点击包名进去后你可以对你的包进行管理，当然你也可以从这里删除这个包。</p>
<h3 id="让别人使用你的包"><a href="#让别人使用你的包" class="headerlink" title="让别人使用你的包"></a>让别人使用你的包</h3><p>包发布完成后，其他人只需要使用pip就可以安装你的包文件。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install package-name</div></pre></td></tr></table></figure>
<p>如果你更新了包，别人可以可以通过<code>--update</code>参数来更新：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install package-name --update</div></pre></td></tr></table></figure>
<h2 id="可能遇到的错误"><a href="#可能遇到的错误" class="headerlink" title="可能遇到的错误"></a>可能遇到的错误</h2><ol>
<li><strong>410错误</strong>：.pypirc的repository过时了，很多博客说的<code>repository: https://pypi.python.org/pypi</code>会导致后面步骤操作出现410错误</li>
<li><strong>403错误</strong>：是因为项目和已有 的项目重名了，可以先到 <a href="https://pypi.python.org/simple/" target="_blank" rel="external">https://pypi.python.org/simple/</a> 上搜一下看看是否重名。解决的方法自然就是修改一下setup.py中setup函数中的name参数，删除之前生成的dist文件夹并重新生成，然后再upload</li>
</ol>
<p>参考文章：</p>
<p><a href="https://www.xncoding.com/2015/10/26/python/setuptools.html" target="_blank" rel="external">https://www.xncoding.com/2015/10/26/python/setuptools.html</a></p>
<p><a href="https://segmentfault.com/a/1190000008663126" target="_blank" rel="external">https://segmentfault.com/a/1190000008663126</a></p>
<p><a href="http://www.cnblogs.com/rongpmcu/p/7662821.html" target="_blank" rel="external">http://www.cnblogs.com/rongpmcu/p/7662821.html</a></p>
]]></content>
      
        <categories>
            
            <category> 发布包到pypi </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java 红黑树源码解读]]></title>
      <url>/2017/12/26/Java%20%E7%BA%A2%E9%BB%91%E6%A0%91%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
      <content type="html"><![CDATA[<h1 id="Java-红黑树源码解读"><a href="#Java-红黑树源码解读" class="headerlink" title="Java 红黑树源码解读"></a>Java 红黑树源码解读</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="红黑树的介绍"><a href="#红黑树的介绍" class="headerlink" title="红黑树的介绍"></a><strong>红黑树的介绍</strong></h3><p>红黑树(Red-Black Tree，简称R-B Tree)，它<strong>一种特殊的二叉查找树</strong>。<br>红黑树是特殊的二叉查找树，意味着它<strong>满足二叉查找树的特征:</strong></p>
<p><strong>任意一个节点所包含的键值，大于等于左孩子的键值，小于等于右孩子的键值。</strong><br>除了具备该特性之外，红黑树还包括许多额外的信息。</p>
<p>红黑树的每个节点上都有存储位表示节点的颜色，颜色是红(Red)或黑(Black)。<br>红黑树的特性:<br>【1】 <strong>每个节点或者是黑色，或者是红色。</strong><br>【2】 <strong>根节点是黑色。</strong><br>【3】 <strong>每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]</strong><br>【4】 <strong>如果一个节点是红色的，则它的子节点必须是黑色的。</strong><br>【5】 <strong>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</strong></p>
<p>关于它的特性，需要注意的是：<br>第一，特性(3)中的叶子节点，是只为空(NIL或null)的节点。<br>第二，特性(5)，<strong>确保没有一条路径会比其他路径长出俩倍</strong>。因而，红黑树是相对是接近平衡的二叉树。</p>
<p>红黑树示意图如下：</p>
<p><a href="http://images.cnitblog.com/i/497634/201403/251730074203156.jpg" target="_blank" rel="external"><img src="http://images.cnitblog.com/i/497634/201403/251730074203156.jpg" alt="img"></a></p>
<h3 id="红黑树的原理"><a href="#红黑树的原理" class="headerlink" title="红黑树的原理"></a>红黑树的原理</h3><p>在研究红黑树原理，我们可以通过以下的实例进行 debug 调试，看它的整个执行过。接着再阅读以下内容，会比较容易理解红黑的原理，才能进一步深入研究清楚。</p>
<p><strong>实例地址：<a href="https://github.com/KnIfER/RBTree-java" target="_blank" rel="external">https://github.com/KnIfER/RBTree-java</a></strong></p>
<h3 id="红黑树的实现-代码说明"><a href="#红黑树的实现-代码说明" class="headerlink" title="红黑树的实现(代码说明)"></a><strong>红黑树的实现(代码说明)</strong></h3><p>红黑树的基本操作是<strong>添加</strong>、<strong>删除</strong>和<strong>旋转</strong>。在对红黑树进行添加或删除后，会用到旋转方法。为什么呢？道理很简单，添加或删除红黑树中的节点之后，红黑树就发生了变化，可能不满足红黑树的5条性质，也就不再是一颗红黑树了，而是一颗普通的树。而通过旋转，可以使这颗树重新成为红黑树。简单点说，<strong>旋转的目的是让树保持红黑树的特性。</strong><br>旋转包括两种：<strong>左旋</strong> 和 <strong>右旋</strong>。下面分别对红黑树的基本操作进行介绍。</p>
<h4 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1. 基本定义"></a><strong>1. 基本定义</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RBTree</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> RBTNode&lt;T&gt; mRoot;    <span class="comment">// 根结点</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED   = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RBTNode</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> color;        <span class="comment">// 颜色</span></div><div class="line">        T key;                <span class="comment">// 关键字(键值)</span></div><div class="line">        RBTNode&lt;T&gt; left;    <span class="comment">// 左孩子</span></div><div class="line">        RBTNode&lt;T&gt; right;    <span class="comment">// 右孩子</span></div><div class="line">        RBTNode&lt;T&gt; parent;    <span class="comment">// 父结点</span></div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RBTNode</span><span class="params">(T key, <span class="keyword">boolean</span> color, RBTNode&lt;T&gt; parent, RBTNode&lt;T&gt; left, RBTNode&lt;T&gt; right)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.key = key;</div><div class="line">            <span class="keyword">this</span>.color = color;</div><div class="line">            <span class="keyword">this</span>.parent = parent;</div><div class="line">            <span class="keyword">this</span>.left = left;</div><div class="line">            <span class="keyword">this</span>.right = right;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>RBTree是红黑树对应的类，RBTNode是红黑树的节点类。在RBTree中包含了根节点mRoot和红黑树的相关API。<br>注意：在实现红黑树API的过程中，我重载了许多函数。重载的原因，一是因为有的API是内部接口，有的是外部接口；二是为了让结构更加清晰。</p>
<h4 id="2-左旋"><a href="#2-左旋" class="headerlink" title="2. 左旋"></a><strong>2. 左旋</strong></h4><p><a href="http://images.cnitblog.com/i/497634/201403/251733282013849.jpg" target="_blank" rel="external"><img src="http://images.cnitblog.com/i/497634/201403/251733282013849.jpg" alt="img"></a></p>
<p>对x进行左旋，意味着”将x变成一个左节点”。</p>
<p>左旋的实现代码(Java语言)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * 对红黑树的节点(x)进行左旋转</div><div class="line"> *</div><div class="line"> * 左旋示意图(对节点x进行左旋)：</div><div class="line"> *      px                              px</div><div class="line"> *     /                               /</div><div class="line"> *    x                               y                </div><div class="line"> *   /  \      --(左旋)-.           / \                #</div><div class="line"> *  lx   y                          x  ry     </div><div class="line"> *     /   \                       /  \</div><div class="line"> *    ly   ry                     lx  ly  </div><div class="line"> *</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">(RBTNode&lt;T&gt; x)</span> </span>&#123;</div><div class="line">    <span class="comment">// 设置x的右孩子为y</span></div><div class="line">    RBTNode&lt;T&gt; y = x.right;</div><div class="line"></div><div class="line">    <span class="comment">// 将 “y的左孩子” 设为 “x的右孩子”；</span></div><div class="line">    <span class="comment">// 如果y的左孩子非空，将 “x” 设为 “y的左孩子的父亲”</span></div><div class="line">    x.right = y.left;</div><div class="line">    <span class="keyword">if</span> (y.left != <span class="keyword">null</span>)</div><div class="line">        y.left.parent = x;</div><div class="line"></div><div class="line">    <span class="comment">// 将 “x的父亲” 设为 “y的父亲”</span></div><div class="line">    y.parent = x.parent;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (x.parent == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.mRoot = y;            <span class="comment">// 如果 “x的父亲” 是空节点，则将y设为根节点</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (x.parent.left == x)</div><div class="line">            x.parent.left = y;    <span class="comment">// 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">            x.parent.right = y;    <span class="comment">// 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 将 “x” 设为 “y的左孩子”</span></div><div class="line">    y.left = x;</div><div class="line">    <span class="comment">// 将 “x的父节点” 设为 “y”</span></div><div class="line">    x.parent = y;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-右旋"><a href="#3-右旋" class="headerlink" title="3. 右旋"></a><strong>3. 右旋</strong></h4><p><a href="http://images.cnitblog.com/i/497634/201403/251735527958942.jpg" target="_blank" rel="external"><img src="http://images.cnitblog.com/i/497634/201403/251735527958942.jpg" alt="img"></a></p>
<p>对y进行左旋，意味着”将y变成一个右节点”。</p>
<p>右旋的实现代码(Java语言)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * 对红黑树的节点(y)进行右旋转</div><div class="line"> *</div><div class="line"> * 右旋示意图(对节点y进行左旋)：</div><div class="line"> *            py                               py</div><div class="line"> *           /                                /</div><div class="line"> *          y                                x                  </div><div class="line"> *         /  \      --(右旋)-.            /  \                     #</div><div class="line"> *        x   ry                           lx   y  </div><div class="line"> *       / \                                   / \                   #</div><div class="line"> *      lx  rx                                rx  ry</div><div class="line"> * </div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">(RBTNode&lt;T&gt; y)</span> </span>&#123;</div><div class="line">    <span class="comment">// 设置x是当前节点的左孩子。</span></div><div class="line">    RBTNode&lt;T&gt; x = y.left;</div><div class="line"></div><div class="line">    <span class="comment">// 将 “x的右孩子” 设为 “y的左孩子”；</span></div><div class="line">    <span class="comment">// 如果"x的右孩子"不为空的话，将 “y” 设为 “x的右孩子的父亲”</span></div><div class="line">    y.left = x.right;</div><div class="line">    <span class="keyword">if</span> (x.right != <span class="keyword">null</span>)</div><div class="line">        x.right.parent = y;</div><div class="line"></div><div class="line">    <span class="comment">// 将 “y的父亲” 设为 “x的父亲”</span></div><div class="line">    x.parent = y.parent;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (y.parent == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.mRoot = x;            <span class="comment">// 如果 “y的父亲” 是空节点，则将x设为根节点</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (y == y.parent.right)</div><div class="line">            y.parent.right = x;    <span class="comment">// 如果 y是它父节点的右孩子，则将x设为“y的父节点的右孩子”</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">            y.parent.left = x;    <span class="comment">// (y是它父节点的左孩子) 将x设为“x的父节点的左孩子”</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 将 “y” 设为 “x的右孩子”</span></div><div class="line">    x.right = y;</div><div class="line"></div><div class="line">    <span class="comment">// 将 “y的父节点” 设为 “x”</span></div><div class="line">    y.parent = x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-添加"><a href="#4-添加" class="headerlink" title="4. 添加"></a><strong>4. 添加</strong></h4><p>将一个节点插入到红黑树中，需要执行哪些步骤呢？首先，将红黑树当作一颗二叉查找树，将节点插入；然后，将节点着色为红色；最后，通过”旋转和重新着色”等一系列操作来修正该树，使之重新成为一颗红黑树。详细描述如下：<br><strong>第一步: 将红黑树当作一颗二叉查找树，将节点插入。</strong><br>​       红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。此外，无论是左旋还是右旋，若旋转之前这棵树是二叉查找树，旋转之后它一定还是二叉查找树。这也就意味着，任何的旋转和重新着色操作，都不会改变它仍然是一颗二叉查找树的事实。<br>好吧？那接下来，我们就来想方设法的旋转以及重新着色，使这颗树重新成为红黑树！</p>
<p><strong>第二步：将插入的节点着色为”红色”。</strong><br>​       为什么着色成红色，而不是黑色呢？为什么呢？在回答之前，我们需要重新温习一下红黑树的特性：<br>(1) 每个节点或者是黑色，或者是红色。<br>(2) 根节点是黑色。<br>(3) 每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]<br>(4) 如果一个节点是红色的，则它的子节点必须是黑色的。<br>(5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。<br>​      将插入的节点着色为红色，不会违背”特性(5)”！少违背一条特性，就意味着我们需要处理的情况越少。接下来，就要努力的让这棵树满足其它性质即可；满足了的话，它就又是一颗红黑树了。o(∩∩)o…哈哈</p>
<p><strong>第三步: 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。</strong><br>​       第二步中，将插入节点着色为”红色”之后，不会违背”特性(5)”。那它到底会违背哪些特性呢？<br>​       对于”特性(1)”，显然不会违背了。因为我们已经将它涂成红色了。<br>​       对于”特性(2)”，显然也不会违背。在第一步中，我们是将红黑树当作二叉查找树，然后执行的插入操作。而根据二叉查找数的特点，插入操作不会改变根节点。所以，根节点仍然是黑色。<br>​       对于”特性(3)”，显然不会违背了。这里的叶子节点是指的空叶子节点，插入非空节点并不会对它们造成影响。<br>​       对于”特性(4)”，是有可能违背的！<br>​       那接下来，想办法使之”满足特性(4)”，就可以将树重新构造成红黑树了。</p>
<p>添加操作的实现代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * 将结点插入到红黑树中</div><div class="line"> *</div><div class="line"> * 参数说明：</div><div class="line"> *     node 插入的结点        // 对应《算法导论》中的node</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(RBTNode&lt;T&gt; node)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> cmp;</div><div class="line">    RBTNode&lt;T&gt; y = <span class="keyword">null</span>;</div><div class="line">    RBTNode&lt;T&gt; x = <span class="keyword">this</span>.mRoot;</div><div class="line"></div><div class="line">    <span class="comment">// 1. 将红黑树当作一颗二叉查找树，将节点添加到二叉查找树中。</span></div><div class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span>) &#123;</div><div class="line">        y = x;</div><div class="line">        cmp = node.key.compareTo(x.key);</div><div class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">            x = x.left;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            x = x.right;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    node.parent = y;</div><div class="line">    <span class="keyword">if</span> (y!=<span class="keyword">null</span>) &#123;</div><div class="line">        cmp = node.key.compareTo(y.key);</div><div class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">            y.left = node;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            y.right = node;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">this</span>.mRoot = node;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 2. 设置节点的颜色为红色</span></div><div class="line">    node.color = RED;</div><div class="line"></div><div class="line">    <span class="comment">// 3. 将它重新修正为一颗二叉查找树</span></div><div class="line">    insertFixUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* </span></div><div class="line"> * 新建结点(key)，并将其插入到红黑树中</div><div class="line"> *</div><div class="line"> * 参数说明：</div><div class="line"> *     key 插入结点的键值</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(T key)</span> </span>&#123;</div><div class="line">    RBTNode&lt;T&gt; node=<span class="keyword">new</span> RBTNode&lt;T&gt;(key,BLACK,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 如果新建结点失败，则返回。</span></div><div class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>)</div><div class="line">        insert(node);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>内部接口</strong> – insert(node)的作用是将”node”节点插入到红黑树中。<br><strong>外部接口</strong> – insert(key)的作用是将”key”添加到红黑树中。</p>
<p>添加修正操作的实现代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 红黑树插入修正函数</div><div class="line"> *</div><div class="line"> * 在向红黑树中插入节点之后(失去平衡)，再调用该函数；</div><div class="line"> * 目的是将它重新塑造成一颗红黑树。</div><div class="line"> *</div><div class="line"> * 参数说明：</div><div class="line"> *     node 插入的结点        // 对应《算法导论》中的z</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertFixUp</span><span class="params">(RBTNode&lt;T&gt; node)</span> </span>&#123;</div><div class="line">    RBTNode&lt;T&gt; parent, gparent;</div><div class="line"></div><div class="line">    <span class="comment">// 若“父节点存在，并且父节点的颜色是红色”</span></div><div class="line">    <span class="keyword">while</span> (((parent = parentOf(node))!=<span class="keyword">null</span>) &amp;&amp; isRed(parent)) &#123;</div><div class="line">        <span class="comment">// 获得祖父节点</span></div><div class="line">        gparent = parentOf(parent);</div><div class="line"></div><div class="line">        <span class="comment">//若“父节点”是“祖父节点的左孩子”</span></div><div class="line">        <span class="keyword">if</span> (parent == gparent.left) &#123;</div><div class="line">            <span class="comment">// Case 1条件：叔叔节点是红色</span></div><div class="line">            RBTNode&lt;T&gt; uncle = gparent.right;</div><div class="line">            <span class="keyword">if</span> ((uncle!=<span class="keyword">null</span>) &amp;&amp; isRed(uncle)) &#123;</div><div class="line">                setBlack(uncle);</div><div class="line">                setBlack(parent);</div><div class="line">                setRed(gparent);</div><div class="line">                node = gparent;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Case 2条件：叔叔是黑色，且当前节点是右孩子</span></div><div class="line">            <span class="keyword">if</span> (parent.right == node) &#123;</div><div class="line">                RBTNode&lt;T&gt; tmp;</div><div class="line">                leftRotate(parent);</div><div class="line">                tmp = parent;</div><div class="line">                parent = node;</div><div class="line">                node = tmp;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Case 3条件：叔叔是黑色，且当前节点是左孩子。</span></div><div class="line">            setBlack(parent);</div><div class="line">            setRed(gparent);</div><div class="line">            rightRotate(gparent);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">//若“z的父节点”是“z的祖父节点的右孩子”</span></div><div class="line">            <span class="comment">// Case 1条件：叔叔节点是红色</span></div><div class="line">            RBTNode&lt;T&gt; uncle = gparent.left;</div><div class="line">            <span class="keyword">if</span> ((uncle!=<span class="keyword">null</span>) &amp;&amp; isRed(uncle)) &#123;</div><div class="line">                setBlack(uncle);</div><div class="line">                setBlack(parent);</div><div class="line">                setRed(gparent);</div><div class="line">                node = gparent;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Case 2条件：叔叔是黑色，且当前节点是左孩子</span></div><div class="line">            <span class="keyword">if</span> (parent.left == node) &#123;</div><div class="line">                RBTNode&lt;T&gt; tmp;</div><div class="line">                rightRotate(parent);</div><div class="line">                tmp = parent;</div><div class="line">                parent = node;</div><div class="line">                node = tmp;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Case 3条件：叔叔是黑色，且当前节点是右孩子。</span></div><div class="line">            setBlack(parent);</div><div class="line">            setRed(gparent);</div><div class="line">            leftRotate(gparent);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 将根节点设为黑色</span></div><div class="line">    setBlack(<span class="keyword">this</span>.mRoot);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>insertFixUp(node)的作用是对应”上面所讲的第三步”。它是一个内部接口。</p>
<h4 id="5-删除操作"><a href="#5-删除操作" class="headerlink" title="5. 删除操作"></a><strong>5. 删除操作</strong></h4><p>将红黑树内的某一个节点删除。需要执行的操作依次是：首先，将红黑树当作一颗二叉查找树，将该节点从二叉查找树中删除；然后，通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。详细描述如下：<br><strong>第一步：将红黑树当作一颗二叉查找树，将节点删除。</strong><br>​       这和”删除常规二叉查找树中删除节点的方法是一样的”。分3种情况：<br>① 被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就OK了。<br>② 被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。<br>③ 被删除节点有两个儿子。那么，先找出它的后继节点；然后把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。在这里，后继节点相当于替身，在将后继节点的内容复制给”被删除节点”之后，再将后继节点删除。这样就巧妙的将问题转换为”删除后继节点”的情况了，下面就考虑后继节点。 在”被删除节点”有两个非空子节点的情况下，它的后继节点不可能是双子非空。既然”的后继节点”不可能双子都非空，就意味着”该节点的后继节点”要么没有儿子，要么只有一个儿子。若没有儿子，则按”情况① “进行处理；若只有一个儿子，则按”情况② “进行处理。</p>
<p><strong>第二步：通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。</strong><br>​        因为”第一步”中删除节点之后，可能会违背红黑树的特性。所以需要通过”旋转和重新着色”来修正该树，使之重新成为一棵红黑树。</p>
<p>删除操作的实现代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * 删除结点(node)，并返回被删除的结点</div><div class="line"> *</div><div class="line"> * 参数说明：</div><div class="line"> *     node 删除的结点</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(RBTNode&lt;T&gt; node)</span> </span>&#123;</div><div class="line">    RBTNode&lt;T&gt; child, parent;</div><div class="line">    <span class="keyword">boolean</span> color;</div><div class="line"></div><div class="line">    <span class="comment">// 被删除节点的"左右孩子都不为空"的情况。</span></div><div class="line">    <span class="keyword">if</span> ( (node.left!=<span class="keyword">null</span>) &amp;&amp; (node.right!=<span class="keyword">null</span>) ) &#123;</div><div class="line">        <span class="comment">// 被删节点的后继节点。(称为"取代节点")</span></div><div class="line">        <span class="comment">// 用它来取代"被删节点"的位置，然后再将"被删节点"去掉。</span></div><div class="line">        RBTNode&lt;T&gt; replace = node;</div><div class="line"></div><div class="line">        <span class="comment">// 获取后继节点</span></div><div class="line">        replace = replace.right;</div><div class="line">        <span class="keyword">while</span> (replace.left != <span class="keyword">null</span>)</div><div class="line">            replace = replace.left;</div><div class="line"></div><div class="line">        <span class="comment">// "node节点"不是根节点(只有根节点不存在父节点)</span></div><div class="line">        <span class="keyword">if</span> (parentOf(node)!=<span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (parentOf(node).left == node)</div><div class="line">                parentOf(node).left = replace;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                parentOf(node).right = replace;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// "node节点"是根节点，更新根节点。</span></div><div class="line">            <span class="keyword">this</span>.mRoot = replace;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// child是"取代节点"的右孩子，也是需要"调整的节点"。</span></div><div class="line">        <span class="comment">// "取代节点"肯定不存在左孩子！因为它是一个后继节点。</span></div><div class="line">        child = replace.right;</div><div class="line">        parent = parentOf(replace);</div><div class="line">        <span class="comment">// 保存"取代节点"的颜色</span></div><div class="line">        color = colorOf(replace);</div><div class="line"></div><div class="line">        <span class="comment">// "被删除节点"是"它的后继节点的父节点"</span></div><div class="line">        <span class="keyword">if</span> (parent == node) &#123;</div><div class="line">            parent = replace;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// child不为空</span></div><div class="line">            <span class="keyword">if</span> (child!=<span class="keyword">null</span>)</div><div class="line">                setParent(child, parent);</div><div class="line">            parent.left = child;</div><div class="line"></div><div class="line">            replace.right = node.right;</div><div class="line">            setParent(node.right, replace);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        replace.parent = node.parent;</div><div class="line">        replace.color = node.color;</div><div class="line">        replace.left = node.left;</div><div class="line">        node.left.parent = replace;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (color == BLACK)</div><div class="line">            removeFixUp(child, parent);</div><div class="line"></div><div class="line">        node = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">return</span> ;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (node.left !=<span class="keyword">null</span>) &#123;</div><div class="line">        child = node.left;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        child = node.right;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    parent = node.parent;</div><div class="line">    <span class="comment">// 保存"取代节点"的颜色</span></div><div class="line">    color = node.color;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (child!=<span class="keyword">null</span>)</div><div class="line">        child.parent = parent;</div><div class="line"></div><div class="line">    <span class="comment">// "node节点"不是根节点</span></div><div class="line">    <span class="keyword">if</span> (parent!=<span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (parent.left == node)</div><div class="line">            parent.left = child;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            parent.right = child;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">this</span>.mRoot = child;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (color == BLACK)</div><div class="line">        removeFixUp(child, parent);</div><div class="line">    node = <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* </span></div><div class="line"> * 删除结点(z)，并返回被删除的结点</div><div class="line"> *</div><div class="line"> * 参数说明：</div><div class="line"> *     tree 红黑树的根结点</div><div class="line"> *     z 删除的结点</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(T key)</span> </span>&#123;</div><div class="line">    RBTNode&lt;T&gt; node; </div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((node = search(mRoot, key)) != <span class="keyword">null</span>)</div><div class="line">        remove(node);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>内部接口</strong> – remove(node)的作用是将”node”节点插入到红黑树中。<br><strong>外部接口</strong> – remove(key)删除红黑树中键值为key的节点。</p>
<p>删除修正操作的实现代码(Java语言)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 红黑树删除修正函数</div><div class="line"> *</div><div class="line"> * 在从红黑树中删除插入节点之后(红黑树失去平衡)，再调用该函数；</div><div class="line"> * 目的是将它重新塑造成一颗红黑树。</div><div class="line"> *</div><div class="line"> * 参数说明：</div><div class="line"> *     node 待修正的节点</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeFixUp</span><span class="params">(RBTNode&lt;T&gt; node, RBTNode&lt;T&gt; parent)</span> </span>&#123;</div><div class="line">    RBTNode&lt;T&gt; other;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> ((node==<span class="keyword">null</span> || isBlack(node)) &amp;&amp; (node != <span class="keyword">this</span>.mRoot)) &#123;</div><div class="line">        <span class="keyword">if</span> (parent.left == node) &#123;</div><div class="line">            other = parent.right;</div><div class="line">            <span class="keyword">if</span> (isRed(other)) &#123;</div><div class="line">                <span class="comment">// Case 1: x的兄弟w是红色的  </span></div><div class="line">                setBlack(other);</div><div class="line">                setRed(parent);</div><div class="line">                leftRotate(parent);</div><div class="line">                other = parent.right;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> ((other.left==<span class="keyword">null</span> || isBlack(other.left)) &amp;&amp;</div><div class="line">                (other.right==<span class="keyword">null</span> || isBlack(other.right))) &#123;</div><div class="line">                <span class="comment">// Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的  </span></div><div class="line">                setRed(other);</div><div class="line">                node = parent;</div><div class="line">                parent = parentOf(node);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (other.right==<span class="keyword">null</span> || isBlack(other.right)) &#123;</div><div class="line">                    <span class="comment">// Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。  </span></div><div class="line">                    setBlack(other.left);</div><div class="line">                    setRed(other);</div><div class="line">                    rightRotate(other);</div><div class="line">                    other = parent.right;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。</span></div><div class="line">                setColor(other, colorOf(parent));</div><div class="line">                setBlack(parent);</div><div class="line">                setBlack(other.right);</div><div class="line">                leftRotate(parent);</div><div class="line">                node = <span class="keyword">this</span>.mRoot;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">            other = parent.left;</div><div class="line">            <span class="keyword">if</span> (isRed(other)) &#123;</div><div class="line">                <span class="comment">// Case 1: x的兄弟w是红色的  </span></div><div class="line">                setBlack(other);</div><div class="line">                setRed(parent);</div><div class="line">                rightRotate(parent);</div><div class="line">                other = parent.left;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> ((other.left==<span class="keyword">null</span> || isBlack(other.left)) &amp;&amp;</div><div class="line">                (other.right==<span class="keyword">null</span> || isBlack(other.right))) &#123;</div><div class="line">                <span class="comment">// Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的  </span></div><div class="line">                setRed(other);</div><div class="line">                node = parent;</div><div class="line">                parent = parentOf(node);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (other.left==<span class="keyword">null</span> || isBlack(other.left)) &#123;</div><div class="line">                    <span class="comment">// Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。  </span></div><div class="line">                    setBlack(other.right);</div><div class="line">                    setRed(other);</div><div class="line">                    leftRotate(other);</div><div class="line">                    other = parent.left;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。</span></div><div class="line">                setColor(other, colorOf(parent));</div><div class="line">                setBlack(parent);</div><div class="line">                setBlack(other.left);</div><div class="line">                rightRotate(parent);</div><div class="line">                node = <span class="keyword">this</span>.mRoot;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (node!=<span class="keyword">null</span>)</div><div class="line">        setBlack(node);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>removeFixup(node, parent)是对应”上面所讲的第三步”。它是一个内部接口。</p>
<h3 id="红黑树的Java实现-完整源码"><a href="#红黑树的Java实现-完整源码" class="headerlink" title="红黑树的Java实现(完整源码)"></a><strong>红黑树的Java实现(完整源码)</strong></h3><p>下面是红黑树实现的完整代码和相应的测试程序。<br>(1) 除了上面所说的”左旋”、”右旋”、”添加”、”删除”等基本操作之后，还实现了”遍历”、”查找”、”打印”、”最小值”、”最大值”、”创建”、”销毁”等接口。<br>(2) 函数接口大多分为内部接口和外部接口。内部接口是private函数，外部接口则是public函数。<br>(3) 测试代码中提供了”插入”和”删除”动作的检测开关。默认是关闭的，打开方法可以参考”代码中的说明”。建议在打开开关后，在草稿上自己动手绘制一下红黑树。</p>
<p>红黑树的实现文件(RBTree.java)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div><div class="line">462</div><div class="line">463</div><div class="line">464</div><div class="line">465</div><div class="line">466</div><div class="line">467</div><div class="line">468</div><div class="line">469</div><div class="line">470</div><div class="line">471</div><div class="line">472</div><div class="line">473</div><div class="line">474</div><div class="line">475</div><div class="line">476</div><div class="line">477</div><div class="line">478</div><div class="line">479</div><div class="line">480</div><div class="line">481</div><div class="line">482</div><div class="line">483</div><div class="line">484</div><div class="line">485</div><div class="line">486</div><div class="line">487</div><div class="line">488</div><div class="line">489</div><div class="line">490</div><div class="line">491</div><div class="line">492</div><div class="line">493</div><div class="line">494</div><div class="line">495</div><div class="line">496</div><div class="line">497</div><div class="line">498</div><div class="line">499</div><div class="line">500</div><div class="line">501</div><div class="line">502</div><div class="line">503</div><div class="line">504</div><div class="line">505</div><div class="line">506</div><div class="line">507</div><div class="line">508</div><div class="line">509</div><div class="line">510</div><div class="line">511</div><div class="line">512</div><div class="line">513</div><div class="line">514</div><div class="line">515</div><div class="line">516</div><div class="line">517</div><div class="line">518</div><div class="line">519</div><div class="line">520</div><div class="line">521</div><div class="line">522</div><div class="line">523</div><div class="line">524</div><div class="line">525</div><div class="line">526</div><div class="line">527</div><div class="line">528</div><div class="line">529</div><div class="line">530</div><div class="line">531</div><div class="line">532</div><div class="line">533</div><div class="line">534</div><div class="line">535</div><div class="line">536</div><div class="line">537</div><div class="line">538</div><div class="line">539</div><div class="line">540</div><div class="line">541</div><div class="line">542</div><div class="line">543</div><div class="line">544</div><div class="line">545</div><div class="line">546</div><div class="line">547</div><div class="line">548</div><div class="line">549</div><div class="line">550</div><div class="line">551</div><div class="line">552</div><div class="line">553</div><div class="line">554</div><div class="line">555</div><div class="line">556</div><div class="line">557</div><div class="line">558</div><div class="line">559</div><div class="line">560</div><div class="line">561</div><div class="line">562</div><div class="line">563</div><div class="line">564</div><div class="line">565</div><div class="line">566</div><div class="line">567</div><div class="line">568</div><div class="line">569</div><div class="line">570</div><div class="line">571</div><div class="line">572</div><div class="line">573</div><div class="line">574</div><div class="line">575</div><div class="line">576</div><div class="line">577</div><div class="line">578</div><div class="line">579</div><div class="line">580</div><div class="line">581</div><div class="line">582</div><div class="line">583</div><div class="line">584</div><div class="line">585</div><div class="line">586</div><div class="line">587</div><div class="line">588</div><div class="line">589</div><div class="line">590</div><div class="line">591</div><div class="line">592</div><div class="line">593</div><div class="line">594</div><div class="line">595</div><div class="line">596</div><div class="line">597</div><div class="line">598</div><div class="line">599</div><div class="line">600</div><div class="line">601</div><div class="line">602</div><div class="line">603</div><div class="line">604</div><div class="line">605</div><div class="line">606</div><div class="line">607</div><div class="line">608</div><div class="line">609</div><div class="line">610</div><div class="line">611</div><div class="line">612</div><div class="line">613</div><div class="line">614</div><div class="line">615</div><div class="line">616</div><div class="line">617</div><div class="line">618</div><div class="line">619</div><div class="line">620</div><div class="line">621</div><div class="line">622</div><div class="line">623</div><div class="line">624</div><div class="line">625</div><div class="line">626</div><div class="line">627</div><div class="line">628</div><div class="line">629</div><div class="line">630</div><div class="line">631</div><div class="line">632</div><div class="line">633</div><div class="line">634</div><div class="line">635</div><div class="line">636</div><div class="line">637</div><div class="line">638</div><div class="line">639</div><div class="line">640</div><div class="line">641</div><div class="line">642</div><div class="line">643</div><div class="line">644</div><div class="line">645</div><div class="line">646</div><div class="line">647</div><div class="line">648</div><div class="line">649</div><div class="line">650</div><div class="line">651</div><div class="line">652</div><div class="line">653</div><div class="line">654</div><div class="line">655</div><div class="line">656</div><div class="line">657</div><div class="line">658</div><div class="line">659</div><div class="line">660</div><div class="line">661</div><div class="line">662</div><div class="line">663</div><div class="line">664</div><div class="line">665</div><div class="line">666</div><div class="line">667</div><div class="line">668</div><div class="line">669</div><div class="line">670</div><div class="line">671</div><div class="line">672</div><div class="line">673</div><div class="line">674</div><div class="line">675</div><div class="line">676</div><div class="line">677</div><div class="line">678</div><div class="line">679</div><div class="line">680</div><div class="line">681</div><div class="line">682</div><div class="line">683</div><div class="line">684</div><div class="line">685</div><div class="line">686</div><div class="line">687</div><div class="line">688</div><div class="line">689</div><div class="line">690</div><div class="line">691</div><div class="line">692</div></pre></td><td class="code"><pre><div class="line">  <span class="number">1</span> <span class="comment">/**</span></div><div class="line">  2  * Java 语言: 红黑树</div><div class="line">  3  *</div><div class="line">  4  * <span class="doctag">@author</span> skywang</div><div class="line">  5  * <span class="doctag">@date</span> 2013/11/07</div><div class="line">  6  */</div><div class="line">  <span class="number">7</span> </div><div class="line">  <span class="number">8</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RBTree</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</div><div class="line">  <span class="number">9</span> </div><div class="line"> <span class="number">10</span>     <span class="keyword">private</span> RBTNode&lt;T&gt; mRoot;    <span class="comment">// 根结点</span></div><div class="line"> <span class="number">11</span> </div><div class="line"> <span class="number">12</span>     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED   = <span class="keyword">false</span>;</div><div class="line"> <span class="number">13</span>     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">true</span>;</div><div class="line"> <span class="number">14</span> </div><div class="line"> <span class="number">15</span>     <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RBTNode</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</div><div class="line"> <span class="number">16</span>         <span class="keyword">boolean</span> color;        <span class="comment">// 颜色</span></div><div class="line"> <span class="number">17</span>         T key;                <span class="comment">// 关键字(键值)</span></div><div class="line"> <span class="number">18</span>         RBTNode&lt;T&gt; left;    <span class="comment">// 左孩子</span></div><div class="line"> <span class="number">19</span>         RBTNode&lt;T&gt; right;    <span class="comment">// 右孩子</span></div><div class="line"> <span class="number">20</span>         RBTNode&lt;T&gt; parent;    <span class="comment">// 父结点</span></div><div class="line"> <span class="number">21</span> </div><div class="line"> <span class="number">22</span>         <span class="function"><span class="keyword">public</span> <span class="title">RBTNode</span><span class="params">(T key, <span class="keyword">boolean</span> color, RBTNode&lt;T&gt; parent, RBTNode&lt;T&gt; left, RBTNode&lt;T&gt; right)</span> </span>&#123;</div><div class="line"> <span class="number">23</span>             <span class="keyword">this</span>.key = key;</div><div class="line"> <span class="number">24</span>             <span class="keyword">this</span>.color = color;</div><div class="line"> <span class="number">25</span>             <span class="keyword">this</span>.parent = parent;</div><div class="line"> <span class="number">26</span>             <span class="keyword">this</span>.left = left;</div><div class="line"> <span class="number">27</span>             <span class="keyword">this</span>.right = right;</div><div class="line"> <span class="number">28</span>         &#125;</div><div class="line"> <span class="number">29</span> </div><div class="line"> <span class="number">30</span>         <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">31</span>             <span class="keyword">return</span> key;</div><div class="line"> <span class="number">32</span>         &#125;</div><div class="line"> <span class="number">33</span> </div><div class="line"> <span class="number">34</span>         <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">35</span>             <span class="keyword">return</span> <span class="string">""</span>+key+(<span class="keyword">this</span>.color==RED?<span class="string">"(R)"</span>:<span class="string">"B"</span>);</div><div class="line"> <span class="number">36</span>         &#125;</div><div class="line"> <span class="number">37</span>     &#125;</div><div class="line"> <span class="number">38</span> </div><div class="line"> <span class="number">39</span>     <span class="function"><span class="keyword">public</span> <span class="title">RBTree</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">40</span>         mRoot=<span class="keyword">null</span>;</div><div class="line"> <span class="number">41</span>     &#125;</div><div class="line"> <span class="number">42</span> </div><div class="line"> <span class="number">43</span>     <span class="function"><span class="keyword">private</span> RBTNode&lt;T&gt; <span class="title">parentOf</span><span class="params">(RBTNode&lt;T&gt; node)</span> </span>&#123;</div><div class="line"> <span class="number">44</span>         <span class="keyword">return</span> node!=<span class="keyword">null</span> ? node.parent : <span class="keyword">null</span>;</div><div class="line"> <span class="number">45</span>     &#125;</div><div class="line"> <span class="number">46</span>     <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">colorOf</span><span class="params">(RBTNode&lt;T&gt; node)</span> </span>&#123;</div><div class="line"> <span class="number">47</span>         <span class="keyword">return</span> node!=<span class="keyword">null</span> ? node.color : BLACK;</div><div class="line"> <span class="number">48</span>     &#125;</div><div class="line"> <span class="number">49</span>     <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(RBTNode&lt;T&gt; node)</span> </span>&#123;</div><div class="line"> <span class="number">50</span>         <span class="keyword">return</span> ((node!=<span class="keyword">null</span>)&amp;&amp;(node.color==RED)) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</div><div class="line"> <span class="number">51</span>     &#125;</div><div class="line"> <span class="number">52</span>     <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBlack</span><span class="params">(RBTNode&lt;T&gt; node)</span> </span>&#123;</div><div class="line"> <span class="number">53</span>         <span class="keyword">return</span> !isRed(node);</div><div class="line"> <span class="number">54</span>     &#125;</div><div class="line"> <span class="number">55</span>     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setBlack</span><span class="params">(RBTNode&lt;T&gt; node)</span> </span>&#123;</div><div class="line"> <span class="number">56</span>         <span class="keyword">if</span> (node!=<span class="keyword">null</span>)</div><div class="line"> <span class="number">57</span>             node.color = BLACK;</div><div class="line"> <span class="number">58</span>     &#125;</div><div class="line"> <span class="number">59</span>     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setRed</span><span class="params">(RBTNode&lt;T&gt; node)</span> </span>&#123;</div><div class="line"> <span class="number">60</span>         <span class="keyword">if</span> (node!=<span class="keyword">null</span>)</div><div class="line"> <span class="number">61</span>             node.color = RED;</div><div class="line"> <span class="number">62</span>     &#125;</div><div class="line"> <span class="number">63</span>     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setParent</span><span class="params">(RBTNode&lt;T&gt; node, RBTNode&lt;T&gt; parent)</span> </span>&#123;</div><div class="line"> <span class="number">64</span>         <span class="keyword">if</span> (node!=<span class="keyword">null</span>)</div><div class="line"> <span class="number">65</span>             node.parent = parent;</div><div class="line"> <span class="number">66</span>     &#125;</div><div class="line"> <span class="number">67</span>     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(RBTNode&lt;T&gt; node, <span class="keyword">boolean</span> color)</span> </span>&#123;</div><div class="line"> <span class="number">68</span>         <span class="keyword">if</span> (node!=<span class="keyword">null</span>)</div><div class="line"> <span class="number">69</span>             node.color = color;</div><div class="line"> <span class="number">70</span>     &#125;</div><div class="line"> <span class="number">71</span> </div><div class="line"> <span class="number">72</span>     <span class="comment">/*</span></div><div class="line"> 73      * 前序遍历"红黑树"</div><div class="line"> 74      */</div><div class="line"> <span class="number">75</span>     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(RBTNode&lt;T&gt; tree)</span> </span>&#123;</div><div class="line"> <span class="number">76</span>         <span class="keyword">if</span>(tree != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">77</span>             System.out.print(tree.key+<span class="string">" "</span>);</div><div class="line"> <span class="number">78</span>             preOrder(tree.left);</div><div class="line"> <span class="number">79</span>             preOrder(tree.right);</div><div class="line"> <span class="number">80</span>         &#125;</div><div class="line"> <span class="number">81</span>     &#125;</div><div class="line"> <span class="number">82</span> </div><div class="line"> <span class="number">83</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">84</span>         preOrder(mRoot);</div><div class="line"> <span class="number">85</span>     &#125;</div><div class="line"> <span class="number">86</span> </div><div class="line"> <span class="number">87</span>     <span class="comment">/*</span></div><div class="line"> 88      * 中序遍历"红黑树"</div><div class="line"> 89      */</div><div class="line"> <span class="number">90</span>     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(RBTNode&lt;T&gt; tree)</span> </span>&#123;</div><div class="line"> <span class="number">91</span>         <span class="keyword">if</span>(tree != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">92</span>             inOrder(tree.left);</div><div class="line"> <span class="number">93</span>             System.out.print(tree.key+<span class="string">" "</span>);</div><div class="line"> <span class="number">94</span>             inOrder(tree.right);</div><div class="line"> <span class="number">95</span>         &#125;</div><div class="line"> <span class="number">96</span>     &#125;</div><div class="line"> <span class="number">97</span> </div><div class="line"> <span class="number">98</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">99</span>         inOrder(mRoot);</div><div class="line"><span class="number">100</span>     &#125;</div><div class="line"><span class="number">101</span> </div><div class="line"><span class="number">102</span> </div><div class="line"><span class="number">103</span>     <span class="comment">/*</span></div><div class="line">104      * 后序遍历"红黑树"</div><div class="line">105      */</div><div class="line"><span class="number">106</span>     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(RBTNode&lt;T&gt; tree)</span> </span>&#123;</div><div class="line"><span class="number">107</span>         <span class="keyword">if</span>(tree != <span class="keyword">null</span>)</div><div class="line"><span class="number">108</span>         &#123;</div><div class="line"><span class="number">109</span>             postOrder(tree.left);</div><div class="line"><span class="number">110</span>             postOrder(tree.right);</div><div class="line"><span class="number">111</span>             System.out.print(tree.key+<span class="string">" "</span>);</div><div class="line"><span class="number">112</span>         &#125;</div><div class="line"><span class="number">113</span>     &#125;</div><div class="line"><span class="number">114</span> </div><div class="line"><span class="number">115</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">116</span>         postOrder(mRoot);</div><div class="line"><span class="number">117</span>     &#125;</div><div class="line"><span class="number">118</span> </div><div class="line"><span class="number">119</span> </div><div class="line"><span class="number">120</span>     <span class="comment">/*</span></div><div class="line">121      * (递归实现)查找"红黑树x"中键值为key的节点</div><div class="line">122      */</div><div class="line"><span class="number">123</span>     <span class="function"><span class="keyword">private</span> RBTNode&lt;T&gt; <span class="title">search</span><span class="params">(RBTNode&lt;T&gt; x, T key)</span> </span>&#123;</div><div class="line"><span class="number">124</span>         <span class="keyword">if</span> (x==<span class="keyword">null</span>)</div><div class="line"><span class="number">125</span>             <span class="keyword">return</span> x;</div><div class="line"><span class="number">126</span> </div><div class="line"><span class="number">127</span>         <span class="keyword">int</span> cmp = key.compareTo(x.key);</div><div class="line"><span class="number">128</span>         <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line"><span class="number">129</span>             <span class="keyword">return</span> search(x.left, key);</div><div class="line"><span class="number">130</span>         <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line"><span class="number">131</span>             <span class="keyword">return</span> search(x.right, key);</div><div class="line"><span class="number">132</span>         <span class="keyword">else</span></div><div class="line"><span class="number">133</span>             <span class="keyword">return</span> x;</div><div class="line"><span class="number">134</span>     &#125;</div><div class="line"><span class="number">135</span> </div><div class="line"><span class="number">136</span>     <span class="function"><span class="keyword">public</span> RBTNode&lt;T&gt; <span class="title">search</span><span class="params">(T key)</span> </span>&#123;</div><div class="line"><span class="number">137</span>         <span class="keyword">return</span> search(mRoot, key);</div><div class="line"><span class="number">138</span>     &#125;</div><div class="line"><span class="number">139</span> </div><div class="line"><span class="number">140</span>     <span class="comment">/*</span></div><div class="line">141      * (非递归实现)查找"红黑树x"中键值为key的节点</div><div class="line">142      */</div><div class="line"><span class="number">143</span>     <span class="function"><span class="keyword">private</span> RBTNode&lt;T&gt; <span class="title">iterativeSearch</span><span class="params">(RBTNode&lt;T&gt; x, T key)</span> </span>&#123;</div><div class="line"><span class="number">144</span>         <span class="keyword">while</span> (x!=<span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">145</span>             <span class="keyword">int</span> cmp = key.compareTo(x.key);</div><div class="line"><span class="number">146</span> </div><div class="line"><span class="number">147</span>             <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) </div><div class="line"><span class="number">148</span>                 x = x.left;</div><div class="line"><span class="number">149</span>             <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) </div><div class="line"><span class="number">150</span>                 x = x.right;</div><div class="line"><span class="number">151</span>             <span class="keyword">else</span></div><div class="line"><span class="number">152</span>                 <span class="keyword">return</span> x;</div><div class="line"><span class="number">153</span>         &#125;</div><div class="line"><span class="number">154</span> </div><div class="line"><span class="number">155</span>         <span class="keyword">return</span> x;</div><div class="line"><span class="number">156</span>     &#125;</div><div class="line"><span class="number">157</span> </div><div class="line"><span class="number">158</span>     <span class="function"><span class="keyword">public</span> RBTNode&lt;T&gt; <span class="title">iterativeSearch</span><span class="params">(T key)</span> </span>&#123;</div><div class="line"><span class="number">159</span>         <span class="keyword">return</span> iterativeSearch(mRoot, key);</div><div class="line"><span class="number">160</span>     &#125;</div><div class="line"><span class="number">161</span> </div><div class="line"><span class="number">162</span>     <span class="comment">/* </span></div><div class="line">163      * 查找最小结点：返回tree为根结点的红黑树的最小结点。</div><div class="line">164      */</div><div class="line"><span class="number">165</span>     <span class="function"><span class="keyword">private</span> RBTNode&lt;T&gt; <span class="title">minimum</span><span class="params">(RBTNode&lt;T&gt; tree)</span> </span>&#123;</div><div class="line"><span class="number">166</span>         <span class="keyword">if</span> (tree == <span class="keyword">null</span>)</div><div class="line"><span class="number">167</span>             <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"><span class="number">168</span> </div><div class="line"><span class="number">169</span>         <span class="keyword">while</span>(tree.left != <span class="keyword">null</span>)</div><div class="line"><span class="number">170</span>             tree = tree.left;</div><div class="line"><span class="number">171</span>         <span class="keyword">return</span> tree;</div><div class="line"><span class="number">172</span>     &#125;</div><div class="line"><span class="number">173</span> </div><div class="line"><span class="number">174</span>     <span class="function"><span class="keyword">public</span> T <span class="title">minimum</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">175</span>         RBTNode&lt;T&gt; p = minimum(mRoot);</div><div class="line"><span class="number">176</span>         <span class="keyword">if</span> (p != <span class="keyword">null</span>)</div><div class="line"><span class="number">177</span>             <span class="keyword">return</span> p.key;</div><div class="line"><span class="number">178</span> </div><div class="line"><span class="number">179</span>         <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"><span class="number">180</span>     &#125;</div><div class="line"><span class="number">181</span>      </div><div class="line"><span class="number">182</span>     <span class="comment">/* </span></div><div class="line">183      * 查找最大结点：返回tree为根结点的红黑树的最大结点。</div><div class="line">184      */</div><div class="line"><span class="number">185</span>     <span class="function"><span class="keyword">private</span> RBTNode&lt;T&gt; <span class="title">maximum</span><span class="params">(RBTNode&lt;T&gt; tree)</span> </span>&#123;</div><div class="line"><span class="number">186</span>         <span class="keyword">if</span> (tree == <span class="keyword">null</span>)</div><div class="line"><span class="number">187</span>             <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"><span class="number">188</span> </div><div class="line"><span class="number">189</span>         <span class="keyword">while</span>(tree.right != <span class="keyword">null</span>)</div><div class="line"><span class="number">190</span>             tree = tree.right;</div><div class="line"><span class="number">191</span>         <span class="keyword">return</span> tree;</div><div class="line"><span class="number">192</span>     &#125;</div><div class="line"><span class="number">193</span> </div><div class="line"><span class="number">194</span>     <span class="function"><span class="keyword">public</span> T <span class="title">maximum</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">195</span>         RBTNode&lt;T&gt; p = maximum(mRoot);</div><div class="line"><span class="number">196</span>         <span class="keyword">if</span> (p != <span class="keyword">null</span>)</div><div class="line"><span class="number">197</span>             <span class="keyword">return</span> p.key;</div><div class="line"><span class="number">198</span> </div><div class="line"><span class="number">199</span>         <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"><span class="number">200</span>     &#125;</div><div class="line"><span class="number">201</span> </div><div class="line"><span class="number">202</span>     <span class="comment">/* </span></div><div class="line">203      * 找结点(x)的后继结点。即，查找"红黑树中数据值大于该结点"的"最小结点"。</div><div class="line">204      */</div><div class="line"><span class="number">205</span>     <span class="function"><span class="keyword">public</span> RBTNode&lt;T&gt; <span class="title">successor</span><span class="params">(RBTNode&lt;T&gt; x)</span> </span>&#123;</div><div class="line"><span class="number">206</span>         <span class="comment">// 如果x存在右孩子，则"x的后继结点"为 "以其右孩子为根的子树的最小结点"。</span></div><div class="line"><span class="number">207</span>         <span class="keyword">if</span> (x.right != <span class="keyword">null</span>)</div><div class="line"><span class="number">208</span>             <span class="keyword">return</span> minimum(x.right);</div><div class="line"><span class="number">209</span> </div><div class="line"><span class="number">210</span>         <span class="comment">// 如果x没有右孩子。则x有以下两种可能：</span></div><div class="line"><span class="number">211</span>         <span class="comment">// (01) x是"一个左孩子"，则"x的后继结点"为 "它的父结点"。</span></div><div class="line"><span class="number">212</span>         <span class="comment">// (02) x是"一个右孩子"，则查找"x的最低的父结点，并且该父结点要具有左孩子"，找到的这个"最低的父结点"就是"x的后继结点"。</span></div><div class="line"><span class="number">213</span>         RBTNode&lt;T&gt; y = x.parent;</div><div class="line"><span class="number">214</span>         <span class="keyword">while</span> ((y!=<span class="keyword">null</span>) &amp;&amp; (x==y.right)) &#123;</div><div class="line"><span class="number">215</span>             x = y;</div><div class="line"><span class="number">216</span>             y = y.parent;</div><div class="line"><span class="number">217</span>         &#125;</div><div class="line"><span class="number">218</span> </div><div class="line"><span class="number">219</span>         <span class="keyword">return</span> y;</div><div class="line"><span class="number">220</span>     &#125;</div><div class="line"><span class="number">221</span>      </div><div class="line"><span class="number">222</span>     <span class="comment">/* </span></div><div class="line">223      * 找结点(x)的前驱结点。即，查找"红黑树中数据值小于该结点"的"最大结点"。</div><div class="line">224      */</div><div class="line"><span class="number">225</span>     <span class="function"><span class="keyword">public</span> RBTNode&lt;T&gt; <span class="title">predecessor</span><span class="params">(RBTNode&lt;T&gt; x)</span> </span>&#123;</div><div class="line"><span class="number">226</span>         <span class="comment">// 如果x存在左孩子，则"x的前驱结点"为 "以其左孩子为根的子树的最大结点"。</span></div><div class="line"><span class="number">227</span>         <span class="keyword">if</span> (x.left != <span class="keyword">null</span>)</div><div class="line"><span class="number">228</span>             <span class="keyword">return</span> maximum(x.left);</div><div class="line"><span class="number">229</span> </div><div class="line"><span class="number">230</span>         <span class="comment">// 如果x没有左孩子。则x有以下两种可能：</span></div><div class="line"><span class="number">231</span>         <span class="comment">// (01) x是"一个右孩子"，则"x的前驱结点"为 "它的父结点"。</span></div><div class="line"><span class="number">232</span>         <span class="comment">// (01) x是"一个左孩子"，则查找"x的最低的父结点，并且该父结点要具有右孩子"，找到的这个"最低的父结点"就是"x的前驱结点"。</span></div><div class="line"><span class="number">233</span>         RBTNode&lt;T&gt; y = x.parent;</div><div class="line"><span class="number">234</span>         <span class="keyword">while</span> ((y!=<span class="keyword">null</span>) &amp;&amp; (x==y.left)) &#123;</div><div class="line"><span class="number">235</span>             x = y;</div><div class="line"><span class="number">236</span>             y = y.parent;</div><div class="line"><span class="number">237</span>         &#125;</div><div class="line"><span class="number">238</span> </div><div class="line"><span class="number">239</span>         <span class="keyword">return</span> y;</div><div class="line"><span class="number">240</span>     &#125;</div><div class="line"><span class="number">241</span> </div><div class="line"><span class="number">242</span>     <span class="comment">/* </span></div><div class="line">243      * 对红黑树的节点(x)进行左旋转</div><div class="line">244      *</div><div class="line">245      * 左旋示意图(对节点x进行左旋)：</div><div class="line">246      *      px                              px</div><div class="line">247      *     /                               /</div><div class="line">248      *    x                               y                </div><div class="line">249      *   /  \      --(左旋)-.           / \                #</div><div class="line">250      *  lx   y                          x  ry     </div><div class="line">251      *     /   \                       /  \</div><div class="line">252      *    ly   ry                     lx  ly  </div><div class="line">253      *</div><div class="line">254      *</div><div class="line">255      */</div><div class="line"><span class="number">256</span>     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">(RBTNode&lt;T&gt; x)</span> </span>&#123;</div><div class="line"><span class="number">257</span>         <span class="comment">// 设置x的右孩子为y</span></div><div class="line"><span class="number">258</span>         RBTNode&lt;T&gt; y = x.right;</div><div class="line"><span class="number">259</span> </div><div class="line"><span class="number">260</span>         <span class="comment">// 将 “y的左孩子” 设为 “x的右孩子”；</span></div><div class="line"><span class="number">261</span>         <span class="comment">// 如果y的左孩子非空，将 “x” 设为 “y的左孩子的父亲”</span></div><div class="line"><span class="number">262</span>         x.right = y.left;</div><div class="line"><span class="number">263</span>         <span class="keyword">if</span> (y.left != <span class="keyword">null</span>)</div><div class="line"><span class="number">264</span>             y.left.parent = x;</div><div class="line"><span class="number">265</span> </div><div class="line"><span class="number">266</span>         <span class="comment">// 将 “x的父亲” 设为 “y的父亲”</span></div><div class="line"><span class="number">267</span>         y.parent = x.parent;</div><div class="line"><span class="number">268</span> </div><div class="line"><span class="number">269</span>         <span class="keyword">if</span> (x.parent == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">270</span>             <span class="keyword">this</span>.mRoot = y;            <span class="comment">// 如果 “x的父亲” 是空节点，则将y设为根节点</span></div><div class="line"><span class="number">271</span>         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">272</span>             <span class="keyword">if</span> (x.parent.left == x)</div><div class="line"><span class="number">273</span>                 x.parent.left = y;    <span class="comment">// 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”</span></div><div class="line"><span class="number">274</span>             <span class="keyword">else</span></div><div class="line"><span class="number">275</span>                 x.parent.right = y;    <span class="comment">// 如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”</span></div><div class="line"><span class="number">276</span>         &#125;</div><div class="line"><span class="number">277</span>         </div><div class="line"><span class="number">278</span>         <span class="comment">// 将 “x” 设为 “y的左孩子”</span></div><div class="line"><span class="number">279</span>         y.left = x;</div><div class="line"><span class="number">280</span>         <span class="comment">// 将 “x的父节点” 设为 “y”</span></div><div class="line"><span class="number">281</span>         x.parent = y;</div><div class="line"><span class="number">282</span>     &#125;</div><div class="line"><span class="number">283</span> </div><div class="line"><span class="number">284</span>     <span class="comment">/* </span></div><div class="line">285      * 对红黑树的节点(y)进行右旋转</div><div class="line">286      *</div><div class="line">287      * 右旋示意图(对节点y进行左旋)：</div><div class="line">288      *            py                               py</div><div class="line">289      *           /                                /</div><div class="line">290      *          y                                x                  </div><div class="line">291      *         /  \      --(右旋)-.            /  \                     #</div><div class="line">292      *        x   ry                           lx   y  </div><div class="line">293      *       / \                                   / \                   #</div><div class="line">294      *      lx  rx                                rx  ry</div><div class="line">295      * </div><div class="line">296      */</div><div class="line"><span class="number">297</span>     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">(RBTNode&lt;T&gt; y)</span> </span>&#123;</div><div class="line"><span class="number">298</span>         <span class="comment">// 设置x是当前节点的左孩子。</span></div><div class="line"><span class="number">299</span>         RBTNode&lt;T&gt; x = y.left;</div><div class="line"><span class="number">300</span> </div><div class="line"><span class="number">301</span>         <span class="comment">// 将 “x的右孩子” 设为 “y的左孩子”；</span></div><div class="line"><span class="number">302</span>         <span class="comment">// 如果"x的右孩子"不为空的话，将 “y” 设为 “x的右孩子的父亲”</span></div><div class="line"><span class="number">303</span>         y.left = x.right;</div><div class="line"><span class="number">304</span>         <span class="keyword">if</span> (x.right != <span class="keyword">null</span>)</div><div class="line"><span class="number">305</span>             x.right.parent = y;</div><div class="line"><span class="number">306</span> </div><div class="line"><span class="number">307</span>         <span class="comment">// 将 “y的父亲” 设为 “x的父亲”</span></div><div class="line"><span class="number">308</span>         x.parent = y.parent;</div><div class="line"><span class="number">309</span> </div><div class="line"><span class="number">310</span>         <span class="keyword">if</span> (y.parent == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">311</span>             <span class="keyword">this</span>.mRoot = x;            <span class="comment">// 如果 “y的父亲” 是空节点，则将x设为根节点</span></div><div class="line"><span class="number">312</span>         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">313</span>             <span class="keyword">if</span> (y == y.parent.right)</div><div class="line"><span class="number">314</span>                 y.parent.right = x;    <span class="comment">// 如果 y是它父节点的右孩子，则将x设为“y的父节点的右孩子”</span></div><div class="line"><span class="number">315</span>             <span class="keyword">else</span></div><div class="line"><span class="number">316</span>                 y.parent.left = x;    <span class="comment">// (y是它父节点的左孩子) 将x设为“x的父节点的左孩子”</span></div><div class="line"><span class="number">317</span>         &#125;</div><div class="line"><span class="number">318</span> </div><div class="line"><span class="number">319</span>         <span class="comment">// 将 “y” 设为 “x的右孩子”</span></div><div class="line"><span class="number">320</span>         x.right = y;</div><div class="line"><span class="number">321</span> </div><div class="line"><span class="number">322</span>         <span class="comment">// 将 “y的父节点” 设为 “x”</span></div><div class="line"><span class="number">323</span>         y.parent = x;</div><div class="line"><span class="number">324</span>     &#125;</div><div class="line"><span class="number">325</span> </div><div class="line"><span class="number">326</span>     <span class="comment">/*</span></div><div class="line">327      * 红黑树插入修正函数</div><div class="line">328      *</div><div class="line">329      * 在向红黑树中插入节点之后(失去平衡)，再调用该函数；</div><div class="line">330      * 目的是将它重新塑造成一颗红黑树。</div><div class="line">331      *</div><div class="line">332      * 参数说明：</div><div class="line">333      *     node 插入的结点        // 对应《算法导论》中的z</div><div class="line">334      */</div><div class="line"><span class="number">335</span>     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertFixUp</span><span class="params">(RBTNode&lt;T&gt; node)</span> </span>&#123;</div><div class="line"><span class="number">336</span>         RBTNode&lt;T&gt; parent, gparent;</div><div class="line"><span class="number">337</span> </div><div class="line"><span class="number">338</span>         <span class="comment">// 若“父节点存在，并且父节点的颜色是红色”</span></div><div class="line"><span class="number">339</span>         <span class="keyword">while</span> (((parent = parentOf(node))!=<span class="keyword">null</span>) &amp;&amp; isRed(parent)) &#123;</div><div class="line"><span class="number">340</span>             gparent = parentOf(parent);</div><div class="line"><span class="number">341</span> </div><div class="line"><span class="number">342</span>             <span class="comment">//若“父节点”是“祖父节点的左孩子”</span></div><div class="line"><span class="number">343</span>             <span class="keyword">if</span> (parent == gparent.left) &#123;</div><div class="line"><span class="number">344</span>                 <span class="comment">// Case 1条件：叔叔节点是红色</span></div><div class="line"><span class="number">345</span>                 RBTNode&lt;T&gt; uncle = gparent.right;</div><div class="line"><span class="number">346</span>                 <span class="keyword">if</span> ((uncle!=<span class="keyword">null</span>) &amp;&amp; isRed(uncle)) &#123;</div><div class="line"><span class="number">347</span>                     setBlack(uncle);</div><div class="line"><span class="number">348</span>                     setBlack(parent);</div><div class="line"><span class="number">349</span>                     setRed(gparent);</div><div class="line"><span class="number">350</span>                     node = gparent;</div><div class="line"><span class="number">351</span>                     <span class="keyword">continue</span>;</div><div class="line"><span class="number">352</span>                 &#125;</div><div class="line"><span class="number">353</span> </div><div class="line"><span class="number">354</span>                 <span class="comment">// Case 2条件：叔叔是黑色，且当前节点是右孩子</span></div><div class="line"><span class="number">355</span>                 <span class="keyword">if</span> (parent.right == node) &#123;</div><div class="line"><span class="number">356</span>                     RBTNode&lt;T&gt; tmp;</div><div class="line"><span class="number">357</span>                     leftRotate(parent);</div><div class="line"><span class="number">358</span>                     tmp = parent;</div><div class="line"><span class="number">359</span>                     parent = node;</div><div class="line"><span class="number">360</span>                     node = tmp;</div><div class="line"><span class="number">361</span>                 &#125;</div><div class="line"><span class="number">362</span> </div><div class="line"><span class="number">363</span>                 <span class="comment">// Case 3条件：叔叔是黑色，且当前节点是左孩子。</span></div><div class="line"><span class="number">364</span>                 setBlack(parent);</div><div class="line"><span class="number">365</span>                 setRed(gparent);</div><div class="line"><span class="number">366</span>                 rightRotate(gparent);</div><div class="line"><span class="number">367</span>             &#125; <span class="keyword">else</span> &#123;    <span class="comment">//若“z的父节点”是“z的祖父节点的右孩子”</span></div><div class="line"><span class="number">368</span>                 <span class="comment">// Case 1条件：叔叔节点是红色</span></div><div class="line"><span class="number">369</span>                 RBTNode&lt;T&gt; uncle = gparent.left;</div><div class="line"><span class="number">370</span>                 <span class="keyword">if</span> ((uncle!=<span class="keyword">null</span>) &amp;&amp; isRed(uncle)) &#123;</div><div class="line"><span class="number">371</span>                     setBlack(uncle);</div><div class="line"><span class="number">372</span>                     setBlack(parent);</div><div class="line"><span class="number">373</span>                     setRed(gparent);</div><div class="line"><span class="number">374</span>                     node = gparent;</div><div class="line"><span class="number">375</span>                     <span class="keyword">continue</span>;</div><div class="line"><span class="number">376</span>                 &#125;</div><div class="line"><span class="number">377</span> </div><div class="line"><span class="number">378</span>                 <span class="comment">// Case 2条件：叔叔是黑色，且当前节点是左孩子</span></div><div class="line"><span class="number">379</span>                 <span class="keyword">if</span> (parent.left == node) &#123;</div><div class="line"><span class="number">380</span>                     RBTNode&lt;T&gt; tmp;</div><div class="line"><span class="number">381</span>                     rightRotate(parent);</div><div class="line"><span class="number">382</span>                     tmp = parent;</div><div class="line"><span class="number">383</span>                     parent = node;</div><div class="line"><span class="number">384</span>                     node = tmp;</div><div class="line"><span class="number">385</span>                 &#125;</div><div class="line"><span class="number">386</span> </div><div class="line"><span class="number">387</span>                 <span class="comment">// Case 3条件：叔叔是黑色，且当前节点是右孩子。</span></div><div class="line"><span class="number">388</span>                 setBlack(parent);</div><div class="line"><span class="number">389</span>                 setRed(gparent);</div><div class="line"><span class="number">390</span>                 leftRotate(gparent);</div><div class="line"><span class="number">391</span>             &#125;</div><div class="line"><span class="number">392</span>         &#125;</div><div class="line"><span class="number">393</span> </div><div class="line"><span class="number">394</span>         <span class="comment">// 将根节点设为黑色</span></div><div class="line"><span class="number">395</span>         setBlack(<span class="keyword">this</span>.mRoot);</div><div class="line"><span class="number">396</span>     &#125;</div><div class="line"><span class="number">397</span> </div><div class="line"><span class="number">398</span>     <span class="comment">/* </span></div><div class="line">399      * 将结点插入到红黑树中</div><div class="line">400      *</div><div class="line">401      * 参数说明：</div><div class="line">402      *     node 插入的结点        // 对应《算法导论》中的node</div><div class="line">403      */</div><div class="line"><span class="number">404</span>     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(RBTNode&lt;T&gt; node)</span> </span>&#123;</div><div class="line"><span class="number">405</span>         <span class="keyword">int</span> cmp;</div><div class="line"><span class="number">406</span>         RBTNode&lt;T&gt; y = <span class="keyword">null</span>;</div><div class="line"><span class="number">407</span>         RBTNode&lt;T&gt; x = <span class="keyword">this</span>.mRoot;</div><div class="line"><span class="number">408</span> </div><div class="line"><span class="number">409</span>         <span class="comment">// 1. 将红黑树当作一颗二叉查找树，将节点添加到二叉查找树中。</span></div><div class="line"><span class="number">410</span>         <span class="keyword">while</span> (x != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">411</span>             y = x;</div><div class="line"><span class="number">412</span>             cmp = node.key.compareTo(x.key);</div><div class="line"><span class="number">413</span>             <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line"><span class="number">414</span>                 x = x.left;</div><div class="line"><span class="number">415</span>             <span class="keyword">else</span></div><div class="line"><span class="number">416</span>                 x = x.right;</div><div class="line"><span class="number">417</span>         &#125;</div><div class="line"><span class="number">418</span> </div><div class="line"><span class="number">419</span>         node.parent = y;</div><div class="line"><span class="number">420</span>         <span class="keyword">if</span> (y!=<span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">421</span>             cmp = node.key.compareTo(y.key);</div><div class="line"><span class="number">422</span>             <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line"><span class="number">423</span>                 y.left = node;</div><div class="line"><span class="number">424</span>             <span class="keyword">else</span></div><div class="line"><span class="number">425</span>                 y.right = node;</div><div class="line"><span class="number">426</span>         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">427</span>             <span class="keyword">this</span>.mRoot = node;</div><div class="line"><span class="number">428</span>         &#125;</div><div class="line"><span class="number">429</span> </div><div class="line"><span class="number">430</span>         <span class="comment">// 2. 设置节点的颜色为红色</span></div><div class="line"><span class="number">431</span>         node.color = RED;</div><div class="line"><span class="number">432</span> </div><div class="line"><span class="number">433</span>         <span class="comment">// 3. 将它重新修正为一颗二叉查找树</span></div><div class="line"><span class="number">434</span>         insertFixUp(node);</div><div class="line"><span class="number">435</span>     &#125;</div><div class="line"><span class="number">436</span> </div><div class="line"><span class="number">437</span>     <span class="comment">/* </span></div><div class="line">438      * 新建结点(key)，并将其插入到红黑树中</div><div class="line">439      *</div><div class="line">440      * 参数说明：</div><div class="line">441      *     key 插入结点的键值</div><div class="line">442      */</div><div class="line"><span class="number">443</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(T key)</span> </span>&#123;</div><div class="line"><span class="number">444</span>         RBTNode&lt;T&gt; node=<span class="keyword">new</span> RBTNode&lt;T&gt;(key,BLACK,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</div><div class="line"><span class="number">445</span> </div><div class="line"><span class="number">446</span>         <span class="comment">// 如果新建结点失败，则返回。</span></div><div class="line"><span class="number">447</span>         <span class="keyword">if</span> (node != <span class="keyword">null</span>)</div><div class="line"><span class="number">448</span>             insert(node);</div><div class="line"><span class="number">449</span>     &#125;</div><div class="line"><span class="number">450</span> </div><div class="line"><span class="number">451</span> </div><div class="line"><span class="number">452</span>     <span class="comment">/*</span></div><div class="line">453      * 红黑树删除修正函数</div><div class="line">454      *</div><div class="line">455      * 在从红黑树中删除插入节点之后(红黑树失去平衡)，再调用该函数；</div><div class="line">456      * 目的是将它重新塑造成一颗红黑树。</div><div class="line">457      *</div><div class="line">458      * 参数说明：</div><div class="line">459      *     node 待修正的节点</div><div class="line">460      */</div><div class="line"><span class="number">461</span>     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeFixUp</span><span class="params">(RBTNode&lt;T&gt; node, RBTNode&lt;T&gt; parent)</span> </span>&#123;</div><div class="line"><span class="number">462</span>         RBTNode&lt;T&gt; other;</div><div class="line"><span class="number">463</span> </div><div class="line"><span class="number">464</span>         <span class="keyword">while</span> ((node==<span class="keyword">null</span> || isBlack(node)) &amp;&amp; (node != <span class="keyword">this</span>.mRoot)) &#123;</div><div class="line"><span class="number">465</span>             <span class="keyword">if</span> (parent.left == node) &#123;</div><div class="line"><span class="number">466</span>                 other = parent.right;</div><div class="line"><span class="number">467</span>                 <span class="keyword">if</span> (isRed(other)) &#123;</div><div class="line"><span class="number">468</span>                     <span class="comment">// Case 1: x的兄弟w是红色的  </span></div><div class="line"><span class="number">469</span>                     setBlack(other);</div><div class="line"><span class="number">470</span>                     setRed(parent);</div><div class="line"><span class="number">471</span>                     leftRotate(parent);</div><div class="line"><span class="number">472</span>                     other = parent.right;</div><div class="line"><span class="number">473</span>                 &#125;</div><div class="line"><span class="number">474</span> </div><div class="line"><span class="number">475</span>                 <span class="keyword">if</span> ((other.left==<span class="keyword">null</span> || isBlack(other.left)) &amp;&amp;</div><div class="line"><span class="number">476</span>                     (other.right==<span class="keyword">null</span> || isBlack(other.right))) &#123;</div><div class="line"><span class="number">477</span>                     <span class="comment">// Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的  </span></div><div class="line"><span class="number">478</span>                     setRed(other);</div><div class="line"><span class="number">479</span>                     node = parent;</div><div class="line"><span class="number">480</span>                     parent = parentOf(node);</div><div class="line"><span class="number">481</span>                 &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">482</span> </div><div class="line"><span class="number">483</span>                     <span class="keyword">if</span> (other.right==<span class="keyword">null</span> || isBlack(other.right)) &#123;</div><div class="line"><span class="number">484</span>                         <span class="comment">// Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。  </span></div><div class="line"><span class="number">485</span>                         setBlack(other.left);</div><div class="line"><span class="number">486</span>                         setRed(other);</div><div class="line"><span class="number">487</span>                         rightRotate(other);</div><div class="line"><span class="number">488</span>                         other = parent.right;</div><div class="line"><span class="number">489</span>                     &#125;</div><div class="line"><span class="number">490</span>                     <span class="comment">// Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。</span></div><div class="line"><span class="number">491</span>                     setColor(other, colorOf(parent));</div><div class="line"><span class="number">492</span>                     setBlack(parent);</div><div class="line"><span class="number">493</span>                     setBlack(other.right);</div><div class="line"><span class="number">494</span>                     leftRotate(parent);</div><div class="line"><span class="number">495</span>                     node = <span class="keyword">this</span>.mRoot;</div><div class="line"><span class="number">496</span>                     <span class="keyword">break</span>;</div><div class="line"><span class="number">497</span>                 &#125;</div><div class="line"><span class="number">498</span>             &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">499</span> </div><div class="line"><span class="number">500</span>                 other = parent.left;</div><div class="line"><span class="number">501</span>                 <span class="keyword">if</span> (isRed(other)) &#123;</div><div class="line"><span class="number">502</span>                     <span class="comment">// Case 1: x的兄弟w是红色的  </span></div><div class="line"><span class="number">503</span>                     setBlack(other);</div><div class="line"><span class="number">504</span>                     setRed(parent);</div><div class="line"><span class="number">505</span>                     rightRotate(parent);</div><div class="line"><span class="number">506</span>                     other = parent.left;</div><div class="line"><span class="number">507</span>                 &#125;</div><div class="line"><span class="number">508</span> </div><div class="line"><span class="number">509</span>                 <span class="keyword">if</span> ((other.left==<span class="keyword">null</span> || isBlack(other.left)) &amp;&amp;</div><div class="line"><span class="number">510</span>                     (other.right==<span class="keyword">null</span> || isBlack(other.right))) &#123;</div><div class="line"><span class="number">511</span>                     <span class="comment">// Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的  </span></div><div class="line"><span class="number">512</span>                     setRed(other);</div><div class="line"><span class="number">513</span>                     node = parent;</div><div class="line"><span class="number">514</span>                     parent = parentOf(node);</div><div class="line"><span class="number">515</span>                 &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">516</span> </div><div class="line"><span class="number">517</span>                     <span class="keyword">if</span> (other.left==<span class="keyword">null</span> || isBlack(other.left)) &#123;</div><div class="line"><span class="number">518</span>                         <span class="comment">// Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。  </span></div><div class="line"><span class="number">519</span>                         setBlack(other.right);</div><div class="line"><span class="number">520</span>                         setRed(other);</div><div class="line"><span class="number">521</span>                         leftRotate(other);</div><div class="line"><span class="number">522</span>                         other = parent.left;</div><div class="line"><span class="number">523</span>                     &#125;</div><div class="line"><span class="number">524</span> </div><div class="line"><span class="number">525</span>                     <span class="comment">// Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。</span></div><div class="line"><span class="number">526</span>                     setColor(other, colorOf(parent));</div><div class="line"><span class="number">527</span>                     setBlack(parent);</div><div class="line"><span class="number">528</span>                     setBlack(other.left);</div><div class="line"><span class="number">529</span>                     rightRotate(parent);</div><div class="line"><span class="number">530</span>                     node = <span class="keyword">this</span>.mRoot;</div><div class="line"><span class="number">531</span>                     <span class="keyword">break</span>;</div><div class="line"><span class="number">532</span>                 &#125;</div><div class="line"><span class="number">533</span>             &#125;</div><div class="line"><span class="number">534</span>         &#125;</div><div class="line"><span class="number">535</span> </div><div class="line"><span class="number">536</span>         <span class="keyword">if</span> (node!=<span class="keyword">null</span>)</div><div class="line"><span class="number">537</span>             setBlack(node);</div><div class="line"><span class="number">538</span>     &#125;</div><div class="line"><span class="number">539</span> </div><div class="line"><span class="number">540</span>     <span class="comment">/* </span></div><div class="line">541      * 删除结点(node)，并返回被删除的结点</div><div class="line">542      *</div><div class="line">543      * 参数说明：</div><div class="line">544      *     node 删除的结点</div><div class="line">545      */</div><div class="line"><span class="number">546</span>     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(RBTNode&lt;T&gt; node)</span> </span>&#123;</div><div class="line"><span class="number">547</span>         RBTNode&lt;T&gt; child, parent;</div><div class="line"><span class="number">548</span>         <span class="keyword">boolean</span> color;</div><div class="line"><span class="number">549</span> </div><div class="line"><span class="number">550</span>         <span class="comment">// 被删除节点的"左右孩子都不为空"的情况。</span></div><div class="line"><span class="number">551</span>         <span class="keyword">if</span> ( (node.left!=<span class="keyword">null</span>) &amp;&amp; (node.right!=<span class="keyword">null</span>) ) &#123;</div><div class="line"><span class="number">552</span>             <span class="comment">// 被删节点的后继节点。(称为"取代节点")</span></div><div class="line"><span class="number">553</span>             <span class="comment">// 用它来取代"被删节点"的位置，然后再将"被删节点"去掉。</span></div><div class="line"><span class="number">554</span>             RBTNode&lt;T&gt; replace = node;</div><div class="line"><span class="number">555</span> </div><div class="line"><span class="number">556</span>             <span class="comment">// 获取后继节点</span></div><div class="line"><span class="number">557</span>             replace = replace.right;</div><div class="line"><span class="number">558</span>             <span class="keyword">while</span> (replace.left != <span class="keyword">null</span>)</div><div class="line"><span class="number">559</span>                 replace = replace.left;</div><div class="line"><span class="number">560</span> </div><div class="line"><span class="number">561</span>             <span class="comment">// "node节点"不是根节点(只有根节点不存在父节点)</span></div><div class="line"><span class="number">562</span>             <span class="keyword">if</span> (parentOf(node)!=<span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">563</span>                 <span class="keyword">if</span> (parentOf(node).left == node)</div><div class="line"><span class="number">564</span>                     parentOf(node).left = replace;</div><div class="line"><span class="number">565</span>                 <span class="keyword">else</span></div><div class="line"><span class="number">566</span>                     parentOf(node).right = replace;</div><div class="line"><span class="number">567</span>             &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">568</span>                 <span class="comment">// "node节点"是根节点，更新根节点。</span></div><div class="line"><span class="number">569</span>                 <span class="keyword">this</span>.mRoot = replace;</div><div class="line"><span class="number">570</span>             &#125;</div><div class="line"><span class="number">571</span> </div><div class="line"><span class="number">572</span>             <span class="comment">// child是"取代节点"的右孩子，也是需要"调整的节点"。</span></div><div class="line"><span class="number">573</span>             <span class="comment">// "取代节点"肯定不存在左孩子！因为它是一个后继节点。</span></div><div class="line"><span class="number">574</span>             child = replace.right;</div><div class="line"><span class="number">575</span>             parent = parentOf(replace);</div><div class="line"><span class="number">576</span>             <span class="comment">// 保存"取代节点"的颜色</span></div><div class="line"><span class="number">577</span>             color = colorOf(replace);</div><div class="line"><span class="number">578</span> </div><div class="line"><span class="number">579</span>             <span class="comment">// "被删除节点"是"它的后继节点的父节点"</span></div><div class="line"><span class="number">580</span>             <span class="keyword">if</span> (parent == node) &#123;</div><div class="line"><span class="number">581</span>                 parent = replace;</div><div class="line"><span class="number">582</span>             &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">583</span>                 <span class="comment">// child不为空</span></div><div class="line"><span class="number">584</span>                 <span class="keyword">if</span> (child!=<span class="keyword">null</span>)</div><div class="line"><span class="number">585</span>                     setParent(child, parent);</div><div class="line"><span class="number">586</span>                 parent.left = child;</div><div class="line"><span class="number">587</span> </div><div class="line"><span class="number">588</span>                 replace.right = node.right;</div><div class="line"><span class="number">589</span>                 setParent(node.right, replace);</div><div class="line"><span class="number">590</span>             &#125;</div><div class="line"><span class="number">591</span> </div><div class="line"><span class="number">592</span>             replace.parent = node.parent;</div><div class="line"><span class="number">593</span>             replace.color = node.color;</div><div class="line"><span class="number">594</span>             replace.left = node.left;</div><div class="line"><span class="number">595</span>             node.left.parent = replace;</div><div class="line"><span class="number">596</span> </div><div class="line"><span class="number">597</span>             <span class="keyword">if</span> (color == BLACK)</div><div class="line"><span class="number">598</span>                 removeFixUp(child, parent);</div><div class="line"><span class="number">599</span> </div><div class="line"><span class="number">600</span>             node = <span class="keyword">null</span>;</div><div class="line"><span class="number">601</span>             <span class="keyword">return</span> ;</div><div class="line"><span class="number">602</span>         &#125;</div><div class="line"><span class="number">603</span> </div><div class="line"><span class="number">604</span>         <span class="keyword">if</span> (node.left !=<span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">605</span>             child = node.left;</div><div class="line"><span class="number">606</span>         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">607</span>             child = node.right;</div><div class="line"><span class="number">608</span>         &#125;</div><div class="line"><span class="number">609</span> </div><div class="line"><span class="number">610</span>         parent = node.parent;</div><div class="line"><span class="number">611</span>         <span class="comment">// 保存"取代节点"的颜色</span></div><div class="line"><span class="number">612</span>         color = node.color;</div><div class="line"><span class="number">613</span> </div><div class="line"><span class="number">614</span>         <span class="keyword">if</span> (child!=<span class="keyword">null</span>)</div><div class="line"><span class="number">615</span>             child.parent = parent;</div><div class="line"><span class="number">616</span> </div><div class="line"><span class="number">617</span>         <span class="comment">// "node节点"不是根节点</span></div><div class="line"><span class="number">618</span>         <span class="keyword">if</span> (parent!=<span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">619</span>             <span class="keyword">if</span> (parent.left == node)</div><div class="line"><span class="number">620</span>                 parent.left = child;</div><div class="line"><span class="number">621</span>             <span class="keyword">else</span></div><div class="line"><span class="number">622</span>                 parent.right = child;</div><div class="line"><span class="number">623</span>         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">624</span>             <span class="keyword">this</span>.mRoot = child;</div><div class="line"><span class="number">625</span>         &#125;</div><div class="line"><span class="number">626</span> </div><div class="line"><span class="number">627</span>         <span class="keyword">if</span> (color == BLACK)</div><div class="line"><span class="number">628</span>             removeFixUp(child, parent);</div><div class="line"><span class="number">629</span>         node = <span class="keyword">null</span>;</div><div class="line"><span class="number">630</span>     &#125;</div><div class="line"><span class="number">631</span> </div><div class="line"><span class="number">632</span>     <span class="comment">/* </span></div><div class="line">633      * 删除结点(z)，并返回被删除的结点</div><div class="line">634      *</div><div class="line">635      * 参数说明：</div><div class="line">636      *     tree 红黑树的根结点</div><div class="line">637      *     z 删除的结点</div><div class="line">638      */</div><div class="line"><span class="number">639</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(T key)</span> </span>&#123;</div><div class="line"><span class="number">640</span>         RBTNode&lt;T&gt; node; </div><div class="line"><span class="number">641</span> </div><div class="line"><span class="number">642</span>         <span class="keyword">if</span> ((node = search(mRoot, key)) != <span class="keyword">null</span>)</div><div class="line"><span class="number">643</span>             remove(node);</div><div class="line"><span class="number">644</span>     &#125;</div><div class="line"><span class="number">645</span> </div><div class="line"><span class="number">646</span>     <span class="comment">/*</span></div><div class="line">647      * 销毁红黑树</div><div class="line">648      */</div><div class="line"><span class="number">649</span>     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(RBTNode&lt;T&gt; tree)</span> </span>&#123;</div><div class="line"><span class="number">650</span>         <span class="keyword">if</span> (tree==<span class="keyword">null</span>)</div><div class="line"><span class="number">651</span>             <span class="keyword">return</span> ;</div><div class="line"><span class="number">652</span> </div><div class="line"><span class="number">653</span>         <span class="keyword">if</span> (tree.left != <span class="keyword">null</span>)</div><div class="line"><span class="number">654</span>             destroy(tree.left);</div><div class="line"><span class="number">655</span>         <span class="keyword">if</span> (tree.right != <span class="keyword">null</span>)</div><div class="line"><span class="number">656</span>             destroy(tree.right);</div><div class="line"><span class="number">657</span> </div><div class="line"><span class="number">658</span>         tree=<span class="keyword">null</span>;</div><div class="line"><span class="number">659</span>     &#125;</div><div class="line"><span class="number">660</span> </div><div class="line"><span class="number">661</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">662</span>         destroy(mRoot);</div><div class="line"><span class="number">663</span>         mRoot = <span class="keyword">null</span>;</div><div class="line"><span class="number">664</span>     &#125;</div><div class="line"><span class="number">665</span> </div><div class="line"><span class="number">666</span>     <span class="comment">/*</span></div><div class="line">667      * 打印"红黑树"</div><div class="line">668      *</div><div class="line">669      * key        -- 节点的键值 </div><div class="line">670      * direction  --  0，表示该节点是根节点;</div><div class="line">671      *               -1，表示该节点是它的父结点的左孩子;</div><div class="line">672      *                1，表示该节点是它的父结点的右孩子。</div><div class="line">673      */</div><div class="line"><span class="number">674</span>     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(RBTNode&lt;T&gt; tree, T key, <span class="keyword">int</span> direction)</span> </span>&#123;</div><div class="line"><span class="number">675</span> </div><div class="line"><span class="number">676</span>         <span class="keyword">if</span>(tree != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">677</span> </div><div class="line"><span class="number">678</span>             <span class="keyword">if</span>(direction==<span class="number">0</span>)    <span class="comment">// tree是根节点</span></div><div class="line"><span class="number">679</span>                 System.out.printf(<span class="string">"%2d(B) is root\n"</span>, tree.key);</div><div class="line"><span class="number">680</span>             <span class="keyword">else</span>                <span class="comment">// tree是分支节点</span></div><div class="line"><span class="number">681</span>                 System.out.printf(<span class="string">"%2d(%s) is %2d's %6s child\n"</span>, tree.key, isRed(tree)?<span class="string">"R"</span>:<span class="string">"B"</span>, key, direction==<span class="number">1</span>?<span class="string">"right"</span> : <span class="string">"left"</span>);</div><div class="line"><span class="number">682</span> </div><div class="line"><span class="number">683</span>             print(tree.left, tree.key, -<span class="number">1</span>);</div><div class="line"><span class="number">684</span>             print(tree.right,tree.key,  <span class="number">1</span>);</div><div class="line"><span class="number">685</span>         &#125;</div><div class="line"><span class="number">686</span>     &#125;</div><div class="line"><span class="number">687</span> </div><div class="line"><span class="number">688</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">689</span>         <span class="keyword">if</span> (mRoot != <span class="keyword">null</span>)</div><div class="line"><span class="number">690</span>             print(mRoot, mRoot.key, <span class="number">0</span>);</div><div class="line"><span class="number">691</span>     &#125;</div><div class="line"><span class="number">692</span> &#125;</div></pre></td></tr></table></figure>
<p>红黑树的测试文件(RBTreeTest.java)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"> <span class="number">1</span> <span class="comment">/**</span></div><div class="line"> 2  * Java 语言: 二叉查找树</div><div class="line"> 3  *</div><div class="line"> 4  * <span class="doctag">@author</span> skywang</div><div class="line"> 5  * <span class="doctag">@date</span> 2013/11/07</div><div class="line"> 6  */</div><div class="line"> <span class="number">7</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RBTreeTest</span> </span>&#123;</div><div class="line"> <span class="number">8</span> </div><div class="line"> <span class="number">9</span>     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> a[] = &#123;<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">60</span>, <span class="number">90</span>, <span class="number">70</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">80</span>&#125;;</div><div class="line"><span class="number">10</span>     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> mDebugInsert = <span class="keyword">false</span>;    <span class="comment">// "插入"动作的检测开关(false，关闭；true，打开)</span></div><div class="line"><span class="number">11</span>     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> mDebugDelete = <span class="keyword">false</span>;    <span class="comment">// "删除"动作的检测开关(false，关闭；true，打开)</span></div><div class="line"><span class="number">12</span> </div><div class="line"><span class="number">13</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="number">14</span>         <span class="keyword">int</span> i, ilen = a.length;</div><div class="line"><span class="number">15</span>         RBTree&lt;Integer&gt; tree=<span class="keyword">new</span> RBTree&lt;Integer&gt;();</div><div class="line"><span class="number">16</span> </div><div class="line"><span class="number">17</span>         System.out.printf(<span class="string">"== 原始数据: "</span>);</div><div class="line"><span class="number">18</span>         <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;ilen; i++)</div><div class="line"><span class="number">19</span>             System.out.printf(<span class="string">"%d "</span>, a[i]);</div><div class="line"><span class="number">20</span>         System.out.printf(<span class="string">"\n"</span>);</div><div class="line"><span class="number">21</span> </div><div class="line"><span class="number">22</span>         <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;ilen; i++) &#123;</div><div class="line"><span class="number">23</span>             tree.insert(a[i]);</div><div class="line"><span class="number">24</span>             <span class="comment">// 设置mDebugInsert=true,测试"添加函数"</span></div><div class="line"><span class="number">25</span>             <span class="keyword">if</span> (mDebugInsert) &#123;</div><div class="line"><span class="number">26</span>                 System.out.printf(<span class="string">"== 添加节点: %d\n"</span>, a[i]);</div><div class="line"><span class="number">27</span>                 System.out.printf(<span class="string">"== 树的详细信息: \n"</span>);</div><div class="line"><span class="number">28</span>                 tree.print();</div><div class="line"><span class="number">29</span>                 System.out.printf(<span class="string">"\n"</span>);</div><div class="line"><span class="number">30</span>             &#125;</div><div class="line"><span class="number">31</span>         &#125;</div><div class="line"><span class="number">32</span> </div><div class="line"><span class="number">33</span>         System.out.printf(<span class="string">"== 前序遍历: "</span>);</div><div class="line"><span class="number">34</span>         tree.preOrder();</div><div class="line"><span class="number">35</span> </div><div class="line"><span class="number">36</span>         System.out.printf(<span class="string">"\n== 中序遍历: "</span>);</div><div class="line"><span class="number">37</span>         tree.inOrder();</div><div class="line"><span class="number">38</span> </div><div class="line"><span class="number">39</span>         System.out.printf(<span class="string">"\n== 后序遍历: "</span>);</div><div class="line"><span class="number">40</span>         tree.postOrder();</div><div class="line"><span class="number">41</span>         System.out.printf(<span class="string">"\n"</span>);</div><div class="line"><span class="number">42</span> </div><div class="line"><span class="number">43</span>         System.out.printf(<span class="string">"== 最小值: %s\n"</span>, tree.minimum());</div><div class="line"><span class="number">44</span>         System.out.printf(<span class="string">"== 最大值: %s\n"</span>, tree.maximum());</div><div class="line"><span class="number">45</span>         System.out.printf(<span class="string">"== 树的详细信息: \n"</span>);</div><div class="line"><span class="number">46</span>         tree.print();</div><div class="line"><span class="number">47</span>         System.out.printf(<span class="string">"\n"</span>);</div><div class="line"><span class="number">48</span> </div><div class="line"><span class="number">49</span>         <span class="comment">// 设置mDebugDelete=true,测试"删除函数"</span></div><div class="line"><span class="number">50</span>         <span class="keyword">if</span> (mDebugDelete) &#123;</div><div class="line"><span class="number">51</span>             <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;ilen; i++)</div><div class="line"><span class="number">52</span>             &#123;</div><div class="line"><span class="number">53</span>                 tree.remove(a[i]);</div><div class="line"><span class="number">54</span> </div><div class="line"><span class="number">55</span>                 System.out.printf(<span class="string">"== 删除节点: %d\n"</span>, a[i]);</div><div class="line"><span class="number">56</span>                 System.out.printf(<span class="string">"== 树的详细信息: \n"</span>);</div><div class="line"><span class="number">57</span>                 tree.print();</div><div class="line"><span class="number">58</span>                 System.out.printf(<span class="string">"\n"</span>);</div><div class="line"><span class="number">59</span>             &#125;</div><div class="line"><span class="number">60</span>         &#125;</div><div class="line"><span class="number">61</span> </div><div class="line"><span class="number">62</span>         <span class="comment">// 销毁二叉树</span></div><div class="line"><span class="number">63</span>         tree.clear();</div><div class="line"><span class="number">64</span>     &#125;</div><div class="line"><span class="number">65</span> &#125;</div></pre></td></tr></table></figure>
<h3 id="红黑树的Java测试程序"><a href="#红黑树的Java测试程序" class="headerlink" title="红黑树的Java测试程序"></a><strong>红黑树的Java测试程序</strong></h3><p>前面已经给出了红黑树的测试代码(RBTreeTest.java)，这里就不再重复说明。下面是测试程序的运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">== 原始数据: 10 40 30 60 90 70 20 50 80 </div><div class="line">== 前序遍历: 30 10 20 60 40 50 80 70 90 </div><div class="line">== 中序遍历: 10 20 30 40 50 60 70 80 90 </div><div class="line">== 后序遍历: 20 10 50 40 70 90 80 60 30 </div><div class="line">== 最小值: 10</div><div class="line">== 最大值: 90</div><div class="line">== 树的详细信息: </div><div class="line">30(B) is root</div><div class="line">10(B) is 30&apos;s   left child</div><div class="line">20(R) is 10&apos;s  right child</div><div class="line">60(R) is 30&apos;s  right child</div><div class="line">40(B) is 60&apos;s   left child</div><div class="line">50(R) is 40&apos;s  right child</div><div class="line">80(B) is 60&apos;s  right child</div><div class="line">70(R) is 80&apos;s   left child</div><div class="line">90(R) is 80&apos;s  right child</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 红黑树 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ConcurrentHashMap 源码解读]]></title>
      <url>/2017/12/26/Java%208%20ConcurrentHashMap%20%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
      <content type="html"><![CDATA[<h1 id="Java-8-ConcurrentHashMap-源码解读"><a href="#Java-8-ConcurrentHashMap-源码解读" class="headerlink" title="Java 8 ConcurrentHashMap 源码解读"></a>Java 8 ConcurrentHashMap 源码解读</h1><p> <strong>ConcurrentHashMap</strong> 当之无愧是支持并发最好的键值对（Map）集合。在日常编码中，出场率也相当之高。在jdk8中，集合类 ConcurrentHashMap 经 <em>Doug Lea</em> 大师之手，借助volatile语义以及CAS操作进行优化，使得该集合类更好地发挥出了并发的优势。与jdk7中相比，在原有段锁（Segment）的基础上，引入了数组＋链表＋红黑树的存储模型，在查询效率上花费了不少心思。</p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171214/93aB6f3iC1.png" alt="mark"></p>
<h2 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h2><p>ConcurrentHashMap内存存储结构图大致如下：</p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171214/g3HD7ABdjH.png" alt="mark"></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>1、设计首要目的：维护并发可读性（get、迭代相关）；次要目的：使空间消耗比HashMap相同或更好，且支持多线程高效率的初始插入（empty table）。</p>
<p>2、HashTable线程安全，但采用synchronized，多线程下效率低下。线程1put时，线程2无法put或get。</p>
<h3 id="阅前了解"><a href="#阅前了解" class="headerlink" title="阅前了解"></a>阅前了解</h3><p>在真正阅读 ConcurrentHashMap 源码之前，我们简单复习下关于volatile和CAS的概念，这样才能更好地帮助我们理解源码中的关键方法。</p>
<h4 id="volatile语义"><a href="#volatile语义" class="headerlink" title="volatile语义"></a>volatile语义</h4><p>java提供的关键字volatile是最轻量级的同步机制。当定义一个变量为volatile时，它就具备了三层语义： - 可见性（Visibility）：在多线程环境下，一个变量的写操作总是对其后的读取线程可见 - 原子性（Atomicity）：volatile的读/写操作具有原子性 - 有序性（Ordering）：禁止指令的重排序优化，JVM会通过插入内存屏障（Memory Barrier）指令来保证</p>
<p>就同步性能而言，大多数场景下volatile的总开销是要比锁低的。在ConcurrentHashMap的源码中，我们能看到频繁的volatile变量读取与写入。</p>
<h4 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h4><p>CAS一般被理解为<strong>原子操作</strong>。在java中，正是利用了处理器的CMPXCHG（intel）指令实现CAS操作。CAS需要接受原有期望值expected以及想要修改的新值x，只有在原有期望值与当前值相等时才会更新为x，否则为失败。在ConcurrentHashMap的方法中，大量使用CAS获取/修改互斥量，以达到多线程并发环境下的正确性。</p>
<h2 id="ConcurrentHashMap-的常量"><a href="#ConcurrentHashMap-的常量" class="headerlink" title="ConcurrentHashMap 的常量"></a>ConcurrentHashMap 的常量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// maximum_capacity table的最大容量，必须为2次幂形式</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// default_capacity table的默认初始容量，必须为2次幂形式</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// max_array_size MAX_VALUE=2^31-1=2147483647</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// default_concurrency_leve 未被用到，用来兼容之前版本</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> finalint DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// load_factor table的负载因子，当前节点数量超过 n * LOAD_FACTOR，执行扩容</span></div><div class="line"><span class="comment">// 位操作表达式为 n - (n &gt;&gt;&gt; 2)</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// treeify_threshold 针对每个桶（bin），链表转换为红黑树的节点数阈值</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 针对每个桶（bin），红黑树退化为链表的节点数阈值</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// min_treeify_capacity 最小的树的容量</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 扩容线程每次最少要迁移16个hash桶</span></div><div class="line"><span class="comment">// min_transfer_stride 在扩容中，参与的单个线程允许处理的最少table桶首节点个数</span></div><div class="line"><span class="comment">// 虽然适当添加线程，会使得整个扩容过程变快，但需要考虑多线程内存同时分配的问题</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// resize stamp bits sizeCtl 中记录 size 的 bit 数</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// max_resizers 2^15-1 参与扩容的最大线程数</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span>&lt;&lt;(<span class="number">32</span>-RESIZE_STAMP_BITS))-<span class="number">1</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 32 - 16 = 16, sizeCtl 中记录 size 大小的偏移量</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS = <span class="number">16</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 转为 nodes的hash值、标示位</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED = -<span class="number">1</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 树的根节点的 hash 值</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN = -<span class="number">2</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ReservationNode 的 hash 值</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED = -<span class="number">3</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一些特定的哈希值代表不同含义</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// hash for forwarding nodes</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// hash for roots of trees</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// CPU数</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors()</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 真正存储Node数据（桶首）节点的数组table</div><div class="line"> * 所有Node节点根据hash分桶存储</div><div class="line"> * table数组中存储的是所有桶（bin）的首节点</div><div class="line"> * hash值相同的节点以链表形式分装在桶中</div><div class="line"> * 当一个桶中节点数达到8个时，转换为红黑树，提高查询效率</div><div class="line"> * 装载Node的数组，作为ConcurrentHashMap的数据容器，采用懒加载的方式</div><div class="line"> * 直到第一次插入数据的时候才会进行初始化操作，数组的大小总是为2的幂次方。</div><div class="line"> */</div><div class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</div><div class="line"><span class="comment">// 扩容时候使用,平时为null，只有在扩容的时候才为非null</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</div><div class="line"><span class="comment">// 没有竞争条件时，使用</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</div><div class="line"></div><div class="line"><span class="comment">// 扩容时，将table中的元素迁移至nextTable . 扩容时非空</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  重要控制变量</div><div class="line"> *  根据变量的数值不同，类实例处于不同阶段</div><div class="line"> *  1. = -1 : 正在初始化</div><div class="line"> *  2. &lt; -1 : 正在扩容，数值为 -(1 + 参与扩容的线程数)</div><div class="line"> *  3. = 0  : 创建时初始为0</div><div class="line"> *  4. &gt; 0  : 下一次扩容的大小</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</div></pre></td></tr></table></figure>
<h2 id="ConcurrentHashMap-重要属性"><a href="#ConcurrentHashMap-重要属性" class="headerlink" title="ConcurrentHashMap 重要属性"></a>ConcurrentHashMap 重要属性</h2><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>Key-value entry, 继承自Map.Entry<k,v>对象。</k,v></p>
<p>Node<k,v>节点是ConcurrentHashMap存储数据的最<strong>基本结构</strong>。一个数据mapping节点中，存储4个变量：当前节点hash值、节点的key值、节点的value值、指向下一个节点的指针next。其中在子类中的hash可以为负数，具有特殊的并发处理意义，后文会解释。除了具有特殊意义的子类，Node中的key和val不允许为null。</k,v></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;  </div><div class="line">  		<span class="comment">// Node节点的hash值和key的hash值相同</span></div><div class="line">  		<span class="comment">// TreeNode节点的hash值</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;  </div><div class="line">        <span class="keyword">final</span> K key;  </div><div class="line">        <span class="keyword">volatile</span> V val; <span class="comment">//带有同步锁的value(保证可见性)  </span></div><div class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;<span class="comment">//带有同步锁的next指针</span></div><div class="line">   </div><div class="line">        Node(inthash, K key, V val, Node&lt;K,V&gt; next) &#123;  </div><div class="line">            <span class="keyword">this</span>.hash = hash;  </div><div class="line">            <span class="keyword">this</span>.key = key;  </div><div class="line">            <span class="keyword">this</span>.val = val;  </div><div class="line">            <span class="keyword">this</span>.next = next;  </div><div class="line">        &#125;  </div><div class="line">   </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>       </span>&#123; <span class="keyword">return</span> key; &#125;  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> val; &#125;  </div><div class="line">        <span class="comment">// HashMap调用Objects.hashCode()，最终也是调用Object.hashCode()；效果一样  </span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>   </span>&#123; returnkey.hashCode() ^ val.hashCode(); &#125;  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; returnkey + <span class="string">"="</span> + val; &#125;  </div><div class="line">  		<span class="comment">//不允许直接改变value的值</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123; <span class="comment">// 不允许修改value值，HashMap允许  </span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();  </div><div class="line">        &#125;  </div><div class="line">        <span class="comment">// HashMap使用if (o == this)，且嵌套if；concurrent使用&amp;&amp;  </span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;  </div><div class="line">            Object k, v, u; Map.Entry&lt;?,?&gt; e;  </div><div class="line">            <span class="keyword">return</span> ((oinstanceof Map.Entry) &amp;&amp;  </div><div class="line">                    (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != <span class="keyword">null</span> &amp;&amp;  </div><div class="line">                    (v = e.getValue()) != <span class="keyword">null</span> &amp;&amp;  </div><div class="line">                    (k == key || k.equals(key)) &amp;&amp;  </div><div class="line">                    (v == (u = val) || v.equals(u)));  </div><div class="line">        &#125;  </div><div class="line">   </div><div class="line">        <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(inth, Object k)</span> </span>&#123; <span class="comment">// 增加find方法辅助get方法  </span></div><div class="line">            Node&lt;K,V&gt; e = <span class="keyword">this</span>;  </div><div class="line">            <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;  </div><div class="line">                <span class="keyword">do</span> &#123;  </div><div class="line">                    K ek;  </div><div class="line">                    <span class="keyword">if</span> (e.hash == h &amp;&amp;  </div><div class="line">                        ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))  </div><div class="line">                        <span class="keyword">return</span> e;  </div><div class="line">                  <span class="comment">/**</span></div><div class="line">                  *  以链表形式查找桶中下一个Node信息</div><div class="line">                  *  当转换为subclass红黑树节点TreeNode</div><div class="line">                  *  则使用TreeNode中的find进行查询操作</div><div class="line">                  */</div><div class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);  </div><div class="line">            &#125;  </div><div class="line">            returnnull;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>另外可以看出很多属性都是用volatile进行修饰的，也就是为了保证内存可见性。</p>
<ol>
<li>这个Node内部类与HashMap中定义的Node类很相似，但是有一些差别  </li>
<li>它对value和next属性设置了volatile同步锁  </li>
<li>它不允许调用setValue方法直接改变Node的value域  </li>
<li>它增加了find方法辅助map.get()方法  </li>
</ol>
<h3 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode"></a>TreeNode</h3><p>Node的子类，红黑树节点，当Node链表过长时，会转换成红黑树。</p>
<p>位于 ConcurrentHashMap 类的 2653行 或 搜索 /<em> —————- TreeNodes ————– </em>/</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Nodes for use in TreeBins，链表&gt;8，才可能转为TreeNode.  </span></div><div class="line"><span class="comment">// HashMap的TreeNode继承至LinkedHashMap.Entry；而这里继承至自己实现的Node，将带有next指针，便于treebin访问。  </span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;   </div><div class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links  </span></div><div class="line">        TreeNode&lt;K,V&gt; left;  </div><div class="line">        TreeNode&lt;K,V&gt; right;  </div><div class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion  </span></div><div class="line">        <span class="keyword">boolean</span> red;  </div><div class="line">   </div><div class="line">        TreeNode(inthash, K key, V val, Node&lt;K,V&gt; next,  </div><div class="line">                 TreeNode&lt;K,V&gt; parent) &#123;  </div><div class="line">            <span class="keyword">super</span>(hash, key, val, next);  </div><div class="line">            <span class="keyword">this</span>.parent = parent;  </div><div class="line">        &#125;  </div><div class="line">   </div><div class="line">        <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(inth, Object k)</span> </span>&#123;  </div><div class="line">            <span class="keyword">return</span> findTreeNode(h, k, <span class="keyword">null</span>);  </div><div class="line">        &#125;  </div><div class="line">   </div><div class="line">        <span class="comment">/** </span></div><div class="line">         * Returns the TreeNode (or null if not found) for the given key </div><div class="line">         * starting at given root. </div><div class="line">         */ <span class="comment">// 查找hash为h，key为k的节点  </span></div><div class="line">        <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">findTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;  </div><div class="line">            <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123; <span class="comment">// 比HMap增加判空  </span></div><div class="line">                TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;  </div><div class="line">                <span class="keyword">do</span>  &#123;  </div><div class="line">                    intph, dir; K pk; TreeNode&lt;K,V&gt; q;  </div><div class="line">                    TreeNode&lt;K,V&gt; pl = p.left, pr = p.right;  </div><div class="line">                    <span class="keyword">if</span> ((ph = p.hash) &gt; h)  </div><div class="line">                        p = pl;  </div><div class="line">                    elseif (ph &lt; h)  </div><div class="line">                        p = pr;  </div><div class="line">                    elseif ((pk = p.key) == k || (pk != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))  </div><div class="line">                        returnp;  </div><div class="line">                    elseif (pl == <span class="keyword">null</span>)  </div><div class="line">                        p = pr;  </div><div class="line">                    elseif (pr == <span class="keyword">null</span>)  </div><div class="line">                        p = pl;  </div><div class="line">                    elseif ((kc != <span class="keyword">null</span> ||  </div><div class="line">                              (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;  </div><div class="line">                             (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)  </div><div class="line">                        p = (dir &lt; <span class="number">0</span>) ? pl : pr;  </div><div class="line">                    elseif ((q = pr.findTreeNode(h, k, kc)) != <span class="keyword">null</span>)  </div><div class="line">                        returnq;  </div><div class="line">                    <span class="keyword">else</span>  </div><div class="line">                        p = pl;  </div><div class="line">                &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);  </div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line"><span class="comment">// 和HashMap相比，这里的TreeNode相当简洁；ConcurrentHashMap链表转树时，并不会直接转，</span></div><div class="line"><span class="comment">// 正如注释（Nodes for use in TreeBins）所说，只是把这些节点包装成TreeNode放到TreeBin中，</span></div><div class="line"><span class="comment">// 再由TreeBin来转化红黑树。</span></div></pre></td></tr></table></figure>
<p>树节点，继承于承载数据的Node类。而红黑树的操作是针对TreeBin类的，从该类的注释也可以看出，也就是TreeBin会将TreeNode进行再一次封装</p>
<h3 id="TreeBin"><a href="#TreeBin" class="headerlink" title="TreeBin"></a>TreeBin</h3><p>位于 ConcurrentHashMap 类的 2709 行 或 搜索 /<em> —————- TreeBins ————– </em>/    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// TreeBin用于封装维护TreeNode，包含putTreeVal、lookRoot、UNlookRoot、remove、</span></div><div class="line"><span class="comment">// balanceInsetion、balanceDeletion等方法，这里只分析其构造函数。当链表转树时，</span></div><div class="line"><span class="comment">// 用于封装TreeNode，也就是说，ConcurrentHashMap的红黑树存放的是TreeBin，而不是treeNode。  </span></div><div class="line">TreeBin(TreeNode&lt;K,V&gt; b) &#123;  </div><div class="line">    <span class="keyword">super</span>(TREEBIN, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);<span class="comment">//hash值为常量TREEBIN=-2,表示roots of trees  </span></div><div class="line">    <span class="keyword">this</span>.first = b;  </div><div class="line">    TreeNode&lt;K,V&gt; r = <span class="keyword">null</span>;  </div><div class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = b, next; x != <span class="keyword">null</span>; x = next) &#123;  </div><div class="line">        next = (TreeNode&lt;K,V&gt;)x.next;  </div><div class="line">        x.left = x.right = <span class="keyword">null</span>;  </div><div class="line">        <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;  </div><div class="line">            x.parent = <span class="keyword">null</span>;  </div><div class="line">            x.red = <span class="keyword">false</span>;  </div><div class="line">            r = x;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">else</span> &#123;  </div><div class="line">            K k = x.key;  </div><div class="line">            inth = x.hash;  </div><div class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;  </div><div class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = r;;) &#123;  </div><div class="line">                intdir, ph;  </div><div class="line">                K pk = p.key;  </div><div class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)  </div><div class="line">                    dir = -<span class="number">1</span>;  </div><div class="line">                elseif (ph &lt; h)  </div><div class="line">                    dir = <span class="number">1</span>;  </div><div class="line">                elseif ((kc == <span class="keyword">null</span> &amp;&amp;  </div><div class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||  </div><div class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)  </div><div class="line">                    dir = tieBreakOrder(k, pk);  </div><div class="line">                    TreeNode&lt;K,V&gt; xp = p;  </div><div class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;  </div><div class="line">                    x.parent = xp;  </div><div class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)  </div><div class="line">                        xp.left = x;  </div><div class="line">                    <span class="keyword">else</span>  </div><div class="line">                        xp.right = x;  </div><div class="line">                    r = balanceInsertion(r, x);  </div><div class="line">                    <span class="keyword">break</span>;  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">this</span>.root = r;  </div><div class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个类并不负责包装用户的key、value信息，而是包装的很多TreeNode节点。实际的ConcurrentHashMap“数组”中，存放的是TreeBin对象，而不是TreeNode对象。</p>
<h3 id="threeifyBin"><a href="#threeifyBin" class="headerlink" title="threeifyBin"></a>threeifyBin</h3><p>位于 ConcurrentHashMap 类的 2611 行 或 搜索 “private final void treeifyBin”    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;  </div><div class="line">        Node&lt;K,V&gt; b; intn, sc;  </div><div class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123; </div><div class="line">      	<span class="comment">// 数组的大小还未超过64</span></div><div class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)  </div><div class="line">            tryPresize(n &lt;&lt; <span class="number">1</span>); <span class="comment">// 容量&lt;64，则table两倍扩容，不转树了  </span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;  </div><div class="line">            <span class="keyword">synchronized</span> (b) &#123; <span class="comment">// 读写锁  </span></div><div class="line">                <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;  </div><div class="line">                    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;  </div><div class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;  </div><div class="line">                        TreeNode&lt;K,V&gt; p =  </div><div class="line">                            <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,  </div><div class="line">                                              <span class="keyword">null</span>, <span class="keyword">null</span>);  </div><div class="line">                        <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)  </div><div class="line">                            hd = p;  </div><div class="line">                        <span class="keyword">else</span>  </div><div class="line">                            tl.next = p;  </div><div class="line">                        tl = p;  </div><div class="line">                    &#125;  </div><div class="line">                    setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ForwardingNode"><a href="#ForwardingNode" class="headerlink" title="ForwardingNode"></a>ForwardingNode</h3><p>位于 ConcurrentHashMap 类的 2163 行 或 搜索 “static final class ForwardingNode”    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// A node inserted at head of bins during transfer operations.连接两个table  </span></div><div class="line"><span class="comment">// 并不是我们传统的包含key-value的节点，只是一个标志节点，并且指向nextTable，提供find方法而已。</span></div><div class="line"><span class="comment">// 生命周期：仅存活于扩容操作且bin不为null时，一定会出现在每个bin的首位。  </span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;  </div><div class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;  </div><div class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;  </div><div class="line">        <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>); <span class="comment">// 此节点hash=-1，key、value、next均为null  </span></div><div class="line">        <span class="keyword">this</span>.nextTable = tab;  </div><div class="line">    &#125;  </div><div class="line">   </div><div class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;  </div><div class="line">        <span class="comment">// 查nextTable节点，outer避免深度递归  </span></div><div class="line">        outer: <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = nextTable;;) &#123;  </div><div class="line">            Node&lt;K,V&gt; e; intn;  </div><div class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span> || tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||  </div><div class="line">                (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) == <span class="keyword">null</span>)  </div><div class="line">                returnnull;  </div><div class="line">            <span class="keyword">for</span> (;;) &#123; <span class="comment">// CAS算法多和死循环搭配！直到查到或null  </span></div><div class="line">                <span class="keyword">int</span> eh; K ek;  </div><div class="line">                <span class="keyword">if</span> ((eh = e.hash) == h &amp;&amp;  </div><div class="line">                    ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))  </div><div class="line">                    returne;  </div><div class="line">                <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) &#123;  </div><div class="line">                    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ForwardingNode) &#123;  </div><div class="line">                        tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;  </div><div class="line">                        <span class="keyword">continue</span> outer;  </div><div class="line">                    &#125;  </div><div class="line">                    <span class="keyword">else</span>  </div><div class="line">                        <span class="keyword">return</span> e.find(h, k);  </div><div class="line">                &#125;  </div><div class="line">                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)  </div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在扩容时才会出现的特殊节点，其key,value,hash全部为null。并拥有nextTable指针引用新的table数组。</p>
<h3 id="Traverser"><a href="#Traverser" class="headerlink" title="Traverser"></a>Traverser</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Traverser</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; </div><div class="line">  	<span class="comment">//下一个要访问的entry</span></div><div class="line">    Node&lt;K,V&gt; next;</div><div class="line">  	<span class="comment">//发现forwardingNode时，保存当前tab相关信息</span></div><div class="line">    TableStack&lt;K,V&gt; stack, spare; </div><div class="line">    <span class="comment">//下一个要访问的hash桶索引</span></div><div class="line">    <span class="keyword">int</span> index;             </div><div class="line">  	<span class="comment">//当前正在访问的初始tab的hash桶索引</span></div><div class="line">    <span class="keyword">int</span> baseIndex;          </div><div class="line">    <span class="comment">//初始tab的hash桶索引边界</span></div><div class="line">    <span class="keyword">int</span> baseLimit; </div><div class="line">    <span class="comment">//初始tab的长度</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> baseSize; </div><div class="line"></div><div class="line">    Traverser(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> size, <span class="keyword">int</span> index, <span class="keyword">int</span> limit) &#123;</div><div class="line">        <span class="keyword">this</span>.tab = tab;</div><div class="line">        <span class="keyword">this</span>.baseSize = size;</div><div class="line">        <span class="keyword">this</span>.baseIndex = <span class="keyword">this</span>.index = index;</div><div class="line">        <span class="keyword">this</span>.baseLimit = limit;</div><div class="line">        <span class="keyword">this</span>.next = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 如果有可能，返回下一个有效节点，否则返回null。</span></div><div class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">advance</span><span class="params">()</span> </span>&#123;</div><div class="line">        Node&lt;K,V&gt; e;</div><div class="line">      	<span class="comment">//获取Node链表的下一个元素e</span></div><div class="line">        <span class="keyword">if</span> ((e = next) != <span class="keyword">null</span>)</div><div class="line">            e = e.next;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            Node&lt;K,V&gt;[] t; <span class="keyword">int</span> i, n;  </div><div class="line">          	<span class="comment">// e不为空，返回e</span></div><div class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> next = e;</div><div class="line">          	<span class="comment">//e为空，说明此链表已经遍历完成，准备遍历下一个hash桶</span></div><div class="line">            <span class="keyword">if</span> (baseIndex &gt;= baseLimit || (t = tab) == <span class="keyword">null</span> ||</div><div class="line">                (n = t.length) &lt;= (i = index) || i &lt; <span class="number">0</span>)</div><div class="line">              	<span class="comment">//到达边界，返回null</span></div><div class="line">                <span class="keyword">return</span> next = <span class="keyword">null</span>;</div><div class="line">          	<span class="comment">//获取下一个hash桶对应的node链表的头节点</span></div><div class="line">            <span class="keyword">if</span> ((e = tabAt(t, i)) != <span class="keyword">null</span> &amp;&amp; e.hash &lt; <span class="number">0</span>) &#123;</div><div class="line">              	<span class="comment">//转发节点,说明此hash桶中的节点已经迁移到了nextTable</span></div><div class="line">                <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ForwardingNode) &#123;</div><div class="line">                    tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;</div><div class="line">                    e = <span class="keyword">null</span>;</div><div class="line">                  	<span class="comment">//保存当前tab的遍历状态</span></div><div class="line">                    pushState(t, i, n);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//红黑树</span></div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeBin)</div><div class="line">                    e = ((TreeBin&lt;K,V&gt;)e).first;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    e = <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (stack != <span class="keyword">null</span>)</div><div class="line">              	<span class="comment">// 此时遍历的是迁移目标nextTable,尝试回退到源table，</span></div><div class="line">                <span class="comment">// 继续遍历源table中的节点</span></div><div class="line">                recoverState(n);</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((index = i + baseSize) &gt;= n)</div><div class="line">              	<span class="comment">//初始tab的hash桶索引+1 ，即遍历下一个hash桶</span></div><div class="line">                index = ++baseIndex; </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 在遇到转发节点时保存遍历状态。</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushState</span><span class="params">(Node&lt;K,V&gt;[] t, <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        TableStack&lt;K,V&gt; s = spare;  <span class="comment">// reuse if possible</span></div><div class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</div><div class="line">            spare = s.next;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            s = <span class="keyword">new</span> TableStack&lt;K,V&gt;();</div><div class="line">        s.tab = t;</div><div class="line">        s.length = n;</div><div class="line">        s.index = i;</div><div class="line">        s.next = stack;</div><div class="line">        stack = s;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">// 可能会弹出遍历状态</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recoverState</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        TableStack&lt;K,V&gt; s; <span class="keyword">int</span> len;</div><div class="line">      <span class="comment">// (s = stack) != null :stack不空，说明此时遍历的是nextTable</span></div><div class="line">      <span class="comment">//  (index += (len = s.length)) &gt;= n: 确保了按照index,</span></div><div class="line">      <span class="comment">//index+tab.length的顺序遍历nextTable,条件成立表示nextTable已经遍历完毕</span></div><div class="line">        </div><div class="line">        <span class="comment">//nextTable中的桶遍历完毕</span></div><div class="line">        <span class="keyword">while</span> ((s = stack) != <span class="keyword">null</span> &amp;&amp; (index += (len = s.length)) &gt;= n) &#123;</div><div class="line">          	<span class="comment">//弹出tab，获取tab的遍历状态，开始遍历tab中的桶</span></div><div class="line">            n = len;</div><div class="line">            index = s.index;</div><div class="line">            tab = s.tab;</div><div class="line">            s.tab = <span class="keyword">null</span>;</div><div class="line">            TableStack&lt;K,V&gt; next = s.next;</div><div class="line">            s.next = spare; <span class="comment">// save for reuse</span></div><div class="line">            stack = next;</div><div class="line">            spare = s;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> &amp;&amp; (index += baseSize) &gt;= n)</div><div class="line">            index = ++baseIndex;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="tryPresize-扩容"><a href="#tryPresize-扩容" class="headerlink" title="tryPresize(扩容)"></a>tryPresize(扩容)</h2><p>协调多个线程如何调用transfer方法进行hash桶的迁移（addCount，helpTransfer 方法中也有类似的逻辑）</p>
<p>tryPresize在putAll以及treeifyBin中调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryPresize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;  </div><div class="line">  	    <span class="comment">//计算扩容的目标size</span></div><div class="line">        <span class="comment">// 给定的容量若&gt;=MAXIMUM_CAPACITY的一半，直接扩容到允许的最大值，否则调用函数扩容  </span></div><div class="line">        <span class="keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY :  </div><div class="line">            tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);  </div><div class="line">        <span class="keyword">int</span> sc;  </div><div class="line">        <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123; <span class="comment">//没有正在初始化或扩容，或者说表还没有被初始化  </span></div><div class="line">            Node&lt;K,V&gt;[] tab = table; <span class="keyword">int</span> n;  </div><div class="line">           <span class="comment">//tab没有初始化	</span></div><div class="line">           <span class="keyword">if</span>(tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;  </div><div class="line">                n = (sc &gt; c) ? sc : c; <span class="comment">// 扩容阀值取较大者  </span></div><div class="line">         <span class="comment">// 期间没有其他线程对表操作，则CAS将SIZECTL状态置为-1，表示正在进行初始化  </span></div><div class="line">             	<span class="comment">//初始化之前，CAS设置sizeCtl=-1</span></div><div class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;  </div><div class="line">                    <span class="keyword">try</span> &#123;  </div><div class="line">                        <span class="keyword">if</span> (table == tab) &#123;  </div><div class="line">                            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)  </div><div class="line">                            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];  </div><div class="line">                            table = nt;  </div><div class="line">                          	<span class="comment">//sc=0.75n,相当于扩容阈值</span></div><div class="line">                            sc = n - (n &gt;&gt;&gt; <span class="number">2</span>); <span class="comment">//无符号右移2位，此即0.75*n  </span></div><div class="line">                        &#125;  </div><div class="line">                    &#125; <span class="keyword">finally</span> &#123;  </div><div class="line">                      	<span class="comment">// 此时并没有通过CAS赋值，因为其他想要执行初始化的线程，</span></div><div class="line">                        <span class="comment">// 发现sizeCtl=-1，就直接返回，从而确保任何情况，</span></div><div class="line">                        <span class="comment">// 只会有一个线程执行初始化操作。</span></div><div class="line">                        sizeCtl = sc;</div><div class="line">                    &#125;  </div><div class="line">                &#125;  </div><div class="line">            &#125;<span class="comment">// 若欲扩容值不大于原阀值，或现有容量&gt;=最值，什么都不用做了 </span></div><div class="line">          	<span class="comment">//目标扩容size小于扩容阈值，或者容量超过最大限制时，不需要扩容</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)  </div><div class="line">                <span class="keyword">break</span>;  </div><div class="line">          	<span class="comment">//扩容</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123; </div><div class="line">                <span class="keyword">int</span> rs = resizeStamp(n);  </div><div class="line">              	<span class="comment">// sc&lt;0表示，已经有其他线程正在扩容</span></div><div class="line">                <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;  </div><div class="line">                    Node&lt;K,V&gt;[] nt;<span class="comment">//RESIZE_STAMP_SHIFT=16,MAX_RESIZERS=2^15-1 </span></div><div class="line">               <span class="comment">// 1. (sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs ：扩容线程数 &gt; MAX_RESIZERS-1</span></div><div class="line">               <span class="comment">// 2. sc == rs + 1 和 sc == rs + MAX_RESIZERS ：表示什么？？？</span></div><div class="line">               <span class="comment">// 3. (nt = nextTable) == null ：表示nextTable正在初始化</span></div><div class="line">               <span class="comment">// transferIndex &lt;= 0 ：表示所有hash桶均分配出去</span></div><div class="line">                    <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||  </div><div class="line">                        sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||  </div><div class="line">                        transferIndex &lt;= <span class="number">0</span>)  </div><div class="line">                      	<span class="comment">//如果不需要帮其扩容，直接返回</span></div><div class="line">                        <span class="keyword">break</span>;  </div><div class="line">                  	<span class="comment">//CAS设置sizeCtl=sizeCtl+1</span></div><div class="line">                    <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) </div><div class="line">                      	<span class="comment">//帮其扩容</span></div><div class="line">                        transfer(tab, nt);  </div><div class="line">                &#125;  </div><div class="line">              	<span class="comment">// 第一个执行扩容操作的线程，将sizeCtl设置为：</span></div><div class="line">                <span class="comment">// (resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</span></div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,  </div><div class="line">                                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))  </div><div class="line">                    transfer(tab, <span class="keyword">null</span>);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;<span class="comment">//和HashMap一样,返回&gt;=n的最小2的自然数幂  </span></div><div class="line">  <span class="keyword">int</span> n = c - <span class="number">1</span>;  </div><div class="line">  n |= n &gt;&gt;&gt; <span class="number">1</span>;  </div><div class="line">  n |= n &gt;&gt;&gt; <span class="number">2</span>;  </div><div class="line">  n |= n &gt;&gt;&gt; <span class="number">4</span>;  </div><div class="line">  n |= n &gt;&gt;&gt; <span class="number">8</span>;  </div><div class="line">  n |= n &gt;&gt;&gt; <span class="number">16</span>;  </div><div class="line">  <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="spread-重新哈希"><a href="#spread-重新哈希" class="headerlink" title="spread 重新哈希"></a>spread 重新哈希</h2><p>spread()重哈希，以减小Hash冲突。我们知道对于一个hash表来说，hash值分散的不够均匀的话会大大增加哈希冲突的概率，从而影响到hash表的性能。因此通过spread方法进行了一次重hash从而大大减小哈希冲突的可能性。spread方法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">static final int spread(int h) &#123;</div><div class="line">  return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法主要是<strong>将key的hashCode的低16位于高16位进行异或运算</strong>，这样不仅能够使得hash值能够分散能够均匀减小hash冲突的概率，另外另外只用到了异或运算，在性能开销上也能兼顾，做到平衡的trade-off。</p>
<h2 id="get-查找"><a href="#get-查找" class="headerlink" title="get(查找)"></a>get(查找)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</div><div class="line">  		 <span class="comment">// 1. 重hash</span></div><div class="line">        <span class="keyword">int</span> h = spread(key.hashCode());</div><div class="line">  </div><div class="line">  		<span class="comment">// 2. table[i]桶节点的key与查找的key相同，则直接返回</span></div><div class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">            <span class="comment">// 唯一一处volatile读操作</span></div><div class="line">            (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;  </div><div class="line">            <span class="comment">// 注意：因为容器大小为2的次方，所以 h mod n = h &amp; (n -1)</span></div><div class="line">          </div><div class="line">            <span class="keyword">if</span> ((eh = e.hash) == h) &#123;<span class="comment">// 如果hash值相等</span></div><div class="line">              	<span class="comment">// 检查第一个Node</span></div><div class="line">                <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</div><div class="line">                    <span class="keyword">return</span> e.val;</div><div class="line">            &#125;</div><div class="line">          	<span class="comment">// hash为负表示是扩容中的ForwardingNode节点</span></div><div class="line">            <span class="comment">// 直接调用ForwardingNode的find方法(可以是代理到扩容中的nextTable)</span></div><div class="line">          	<span class="comment">// 3. 当前节点hash小于0说明为树节点，在红黑树中查找即可</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</div><div class="line">                <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</div><div class="line">            <span class="comment">// 遍历链表，对比key值</span></div><div class="line">          	<span class="comment">// 通过next指针，逐一查找</span></div><div class="line">            <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</div><div class="line">              	<span class="comment">//4. 从链表中查找，查找到则返回该节点的value，否则就返回null即可</span></div><div class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</div><div class="line">                    ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</div><div class="line">                    <span class="keyword">return</span> e.val;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>代码的逻辑请看注释，首先先看当前的hash桶数组节点即table[i]是否为查找的节点，若是则直接返回；若不是，则继续再看当前是不是树节点？通过看节点的hash值是否为小于0，如果小于0则为树节点。如果是树节点在红黑树中查找节点；如果不是树节点，那就只剩下为链表的形式的一种可能性了，就向后遍历查找节点，若查找到则返回节点的value即可，若没有找到就返回null。</p>
<p>这个 get 请求，我们需要 cas 来保证变量的原子性。如果 tab[i] 正被锁住，那么 CAS 就会失败，失败之后就会不断的重试。这也保证了在高并发情况下不会出错。</p>
<p>我们来分析一下哪些情况会导致 get 在并发的情况下可能取不到值。</p>
<ol>
<li>一个线程在 get 的时候，另一个线程在对同一个 key 的 node 进行 remove 操作</li>
<li>一个线程在 get 的时候，另一个线程正在重排 table 。可能导致旧 table 取不到值</li>
</ol>
<p>那么本质是，我在get的时候，有其他线程在对同一桶的链表或树进行修改。那么get是怎么保证同步性的呢？我们看到e = tabAt(tab, (n - 1) &amp; h)) != null，在看下tablAt到底是干嘛的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123;</div><div class="line">    return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它是对tab[i]进行原子性的读取，因为我们知道putVal等对table的桶操作是有加锁的，那么一般情况下我们对桶的读也是要加锁的，但是我们这边为什么不需要加锁呢？因为我们用了Unsafe的getObjectVolatile，因为table是volatile类型，所以对tab[i]的原子请求也是可见的。因为如果同步正确的情况下，根据happens-before原则，<strong>对volatile域的写入操作happens-before于每一个后续对同一域的读操作</strong>。所以不管其他线程对table链表或树的修改，都对get读取可见。用一张图说明，协调读-写线程可见示意图：</p>
<p>jdk7是没有用到CAS操作和Unsafe类的，下面是jdk7的get方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">V get(Object key, int hash) &#123; </div><div class="line">            if(count != 0) &#123;       // 首先读 count 变量</div><div class="line">                HashEntry&lt;K,V&gt; e = getFirst(hash); </div><div class="line">                while(e != null) &#123; </div><div class="line">                    if(e.hash == hash &amp;&amp; key.equals(e.key)) &#123; </div><div class="line">                        V v = e.value; </div><div class="line">                        if(v != null)            </div><div class="line">                            return v; </div><div class="line">                        // 如果读到 value 域为 null，说明发生了重排序，加锁后重新读取</div><div class="line">                        return readValueUnderLock(e); </div><div class="line">                    &#125; </div><div class="line">                    e = e.next; </div><div class="line">                &#125; </div><div class="line">            &#125; </div><div class="line">            return null; </div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>为什么我们在get的时候需要判断count不等于0呢？如果是在HashMap的源码中是没有这个判断的，不用判断不是也是可以的吗？这个就是用到线程安全发布情况下happens-before原则之volatile变量法则：<strong>对volatile域的写入操作happens-before于每一个后续对同一域的读操作</strong>，看下面的示意图：</p>
<h2 id="tabAt"><a href="#tabAt" class="headerlink" title="tabAt"></a>tabAt</h2><p>以 volatile 读的方式读取 table 数组中的元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这边为什么i要等于((long)i &lt;&lt; ASHIFT) + ABASE呢,计算偏移量</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">  <span class="comment">// Key对应的数组元素的可见性，由Unsafe的getObjectVolatile方法保证。</span></div><div class="line">  <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>tabAt 方法用来获取table数组中索引为i的Node元素。</p>
<h2 id="put-putVal"><a href="#put-putVal" class="headerlink" title="put/putVal"></a>put/putVal</h2><p>putVal是将一个新key-value mapping插入到当前ConcurrentHashMap的关键方法。</p>
<p>此方法的具体流程如下图：</p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171214/CEj7GLmk1G.png" alt="mark"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</div><div class="line">    <span class="comment">// 不允许 key 和 value 为空</span></div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">  	<span class="comment">// 1.计算 key 的 hash 值(计算新节点的hash值)</span></div><div class="line">    <span class="keyword">int</span> hash = spread(key.hashCode()); <span class="comment">// 返回 (h^(h&gt;&gt;&gt;16))&amp;HASH_BITS</span></div><div class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</div><div class="line">  	<span class="comment">// 获取当前table，进入死循环,直到插入成功！</span></div><div class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123; </div><div class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</div><div class="line">      	<span class="comment">// 2. 如果当前 table 还没初始化先调用 initTable 方法将 tab 进行初始化</span></div><div class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">            tab = initTable(); <span class="comment">// 如果table为空，执行初始化，也即是延迟初始化</span></div><div class="line">      	<span class="comment">// 3. tab中索引为i的位置的元素为null,则直接使用 CAS 将值插入即可</span></div><div class="line">      	<span class="comment">// 如果bin为空，则采用cas算法赋值，无需加锁</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,<span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</div><div class="line">              	<span class="comment">// 直接设置为桶首节点成功，退出死循环（出口之一）</span></div><div class="line">                <span class="keyword">break</span>;              </div><div class="line">        &#125;</div><div class="line">      	<span class="comment">// 4. 当前正在扩容</span></div><div class="line">      	<span class="comment">// 当前桶首节点正在特殊的扩容状态下，当前线程尝试参与扩容</span></div><div class="line">        <span class="comment">// 然后重新进入死循环</span></div><div class="line">        <span class="comment">//f.hash == MOVED 表示为：ForwardingNode，说明其他线程正在扩容</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) <span class="comment">// MOVED = -1 </span></div><div class="line">            tab = helpTransfer(tab, f); <span class="comment">// 当发现其他线程扩容时，帮其扩容</span></div><div class="line">       <span class="comment">// 通过桶首节点，将新节点加入table</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            V oldVal = <span class="keyword">null</span>;</div><div class="line">          	<span class="comment">// 获取桶首节点实例对象锁，进入临界区进行添加操作</span></div><div class="line">            <span class="keyword">synchronized</span> (f) &#123;</div><div class="line">              	<span class="comment">// 再判断以此f是否仍是第一个Node，如果不是，退出临界区，重复添加操作</span></div><div class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</div><div class="line">                    <span class="comment">//5. 当前为链表，在链表中插入新的键值对</span></div><div class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; <span class="comment">// 桶首节点hash值&gt;0，表示为链表</span></div><div class="line">                        binCount = <span class="number">1</span>;</div><div class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</div><div class="line">                            K ek;</div><div class="line">                          	<span class="comment">// 找到hash值相同的key,覆盖旧值即可</span></div><div class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                                ((ek = e.key) == key ||</div><div class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</div><div class="line">                                oldVal = e.val;</div><div class="line">                              	<span class="comment">// 仅 putIfAbsent() 方法中的 onlyIfAbsend 为 true;</span></div><div class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">                                  	<span class="comment">// putIfAbsend() 包含 key 则返回 get ,否则 put 并返回</span></div><div class="line">                                    e.val = value; </div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            &#125;</div><div class="line">                            Node&lt;K,V&gt; pred = e;</div><div class="line">                            <span class="comment">//如果到链表末尾仍未找到，则直接将新值插入到链表末尾即可</span></div><div class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</div><div class="line">                                                          value, <span class="keyword">null</span>);</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                  	<span class="comment">// 桶首节点为Node子类型TreeBin，表示为红黑树</span></div><div class="line">                    <span class="comment">// 6.当前为红黑树，将新的键值对插入到红黑树中</span></div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</div><div class="line">                        Node&lt;K,V&gt; p;</div><div class="line">                        binCount = <span class="number">2</span>;</div><div class="line">                      	<span class="comment">// 调用putTreeVal方法，插入新值</span></div><div class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</div><div class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</div><div class="line">                          	<span class="comment">// key已经存在，则替换</span></div><div class="line">                            oldVal = p.val;</div><div class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">                                p.val = value;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">             <span class="comment">// 7.插入完键值对后再根据实际大小看是否需要转换成红黑树</span></div><div class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</div><div class="line">                  	<span class="comment">// 插入新节点后，达到链表转换红黑树阈值，则执行转换操作</span></div><div class="line">                  	<span class="comment">// 此函数内部会判断是树化，还是扩容：tryPresize</span></div><div class="line">                    treeifyBin(tab, i);</div><div class="line">              	<span class="comment">// 退出死循环（出口之二）</span></div><div class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</div><div class="line">                    <span class="keyword">return</span> oldVal;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  	<span class="comment">// 更新计算count时的base和counterCells数组</span></div><div class="line">  	<span class="comment">//8.对当前容量大小进行检查，如果超过了临界值（实际大小*加载因子）就需要扩容 </span></div><div class="line">    addCount(<span class="number">1L</span>, binCount);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当table[i]为链表的头结点，在链表中插入新值在table[i]不为null并且不为forwardingNode时，并且当前Node f的hash值大于0（fh &gt;= 0）的话说明当前节点f为当前桶的所有的节点组成的链表的头结点。那么接下来，要想向ConcurrentHashMap插入新值的话就是向这个链表插入新值。通过synchronized (f)的方式进行加锁以实现线程安全性。往链表中插入节点的部分代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</div><div class="line">    binCount = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</div><div class="line">        K ek;</div><div class="line">        <span class="comment">// 找到hash值相同的key,覆盖旧值即可</span></div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">            ((ek = e.key) == key ||</div><div class="line">             (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</div><div class="line">            oldVal = e.val;</div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">                e.val = value;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        Node&lt;K,V&gt; pred = e;</div><div class="line">        <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//如果到链表末尾仍未找到，则直接将新值插入到链表末尾即可</span></div><div class="line">            pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</div><div class="line">                                      value, <span class="keyword">null</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这部分代码很好理解，就是两种情况：1. 在链表中如果找到了与待插入的键值对的key相同的节点，就直接覆盖即可；2. 如果直到找到了链表的末尾都没有找到的话，就直接将待插入的键值对追加到链表的末尾即可。</p>
<p>当table[i]为红黑树的根节点，在红黑树中插入新值按照之前的数组+链表的设计方案，这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，甚至在极端情况下，查找一个节点会出现时间复杂度为O(n)的情况，则会严重影响ConcurrentHashMap的性能，于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高ConcurrentHashMap的性能，其中会用到红黑树的插入、删除、查找等算法。当table[i]为红黑树的树节点时的操作为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</div><div class="line">    Node&lt;K,V&gt; p;</div><div class="line">    binCount = <span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</div><div class="line">                                   value)) != <span class="keyword">null</span>) &#123;</div><div class="line">        oldVal = p.val;</div><div class="line">        <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">            p.val = value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先在if中通过<code>f instanceof TreeBin</code>判断当前table[i]是否是树节点，这下也正好验证了我们在最上面介绍时说的TreeBin会对TreeNode做进一步封装，对红黑树进行操作的时候针对的是TreeBin而不是TreeNode。这段代码很简单，调用putTreeVal方法完成向红黑树插入新节点，同样的逻辑，<strong>如果在红黑树中存在于待插入键值对的Key相同（hash值相等并且equals方法判断为true）的节点的话，就覆盖旧值，否则就向红黑树追加新节点</strong>。</p>
<p>当table[i]为红黑树的根节点，在红黑树中插入新值。按照之前的数组+链表的设计方案，这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，甚至在极端情况下，查找一个节点会出现时间复杂度为O(n)的情况，则会严重影响ConcurrentHashMap的性能，于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高ConcurrentHashMap的性能，其中会用到红黑树的插入、删除、查找等算法。当table[i]为红黑树的树节点时的操作为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</div><div class="line"> Node&lt;K,V&gt; p;</div><div class="line"> binCount = <span class="number">2</span>;</div><div class="line"> <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,value)) != <span class="keyword">null</span>) &#123;</div><div class="line"> 			oldVal = p.val;</div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">            p.val = value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先在if中通过<code>f instanceof TreeBin</code>判断当前table[i]是否是树节点，这下也正好验证了我们在最上面介绍时说的TreeBin会对TreeNode做进一步封装，对红黑树进行操作的时候针对的是TreeBin而不是TreeNode。这段代码很简单，调用putTreeVal方法完成向红黑树插入新节点，同样的逻辑，<strong>如果在红黑树中存在于待插入键值对的Key相同（hash值相等并且equals方法判断为true）的节点的话，就覆盖旧值，否则就向红黑树追加新节点</strong>。</p>
<p>根据当前节点个数进行调整当完成数据新节点插入之后，会进一步对当前链表大小进行调整，这部分代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (binCount != 0) &#123;</div><div class="line">    if (binCount &gt;= TREEIFY_THRESHOLD)</div><div class="line">        treeifyBin(tab, i);</div><div class="line">    if (oldVal != null)</div><div class="line">        return oldVal;</div><div class="line">    break;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很容易理解，如果当前链表节点个数大于等于8（TREEIFY_THRESHOLD）的时候，就会调用treeifyBin方法将tabel[i]（第i个散列桶）拉链转换成红黑树。</p>
<p><strong>关于Put方法的逻辑就基本说的差不多了，现在来做一些总结：</strong></p>
<p><strong>整体流程：</strong></p>
<ol>
<li>首先对于每一个放入的值，首先利用spread方法对key的hashcode进行一次hash计算，由此来确定这个值在 table中的位置；</li>
<li>如果当前table数组还未初始化，先将table数组进行初始化操作；</li>
<li>如果这个位置是null的，那么使用CAS操作直接放入；</li>
<li>如果这个位置存在结点，说明发生了hash碰撞，首先判断这个节点的类型。如果该节点fh==MOVED(代表forwardingNode,数组正在进行扩容)的话，说明正在进行扩容；</li>
<li>如果是链表节点（fh&gt;0）,则得到的结点就是hash值相同的节点组成的链表的头节点。需要依次向后遍历确定这个新加入的值所在位置。如果遇到hash值与key值都与新加入节点是一致的情况，则只需要更新value值即可。否则依次向后遍历，直到链表尾插入这个结点；</li>
<li>如果这个节点的类型是TreeBin的话，直接调用红黑树的插入方法进行插入新的节点；</li>
<li>插入完节点之后再次检查链表长度，如果长度大于8，就把这个链表转换成红黑树；</li>
<li>对当前容量大小进行检查，如果超过了临界值（实际大小*加载因子）就需要扩容。</li>
</ol>
<p><strong>该流程中，可以细细品味的环节有： - 初始化方法 initTable - 扩容方法 transfer (在多线程扩容方法 helpTransfer 中被调用)</strong></p>
<h2 id="initTable"><a href="#initTable" class="headerlink" title="initTable"></a>initTable</h2><p>initTable方法允许多线程同时进入，但只有一个线程可以完成table的初始化，其他线程都会通过yield方法让出cpu。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</div><div class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</div><div class="line">      	<span class="comment">// 前文提及sizeCtl是重要的控制变量</span></div><div class="line">        <span class="comment">// sizeCtl = -1 表示正在初始化</span></div><div class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</div><div class="line">            <span class="comment">// 已经有其他线程在执行初始化，则主动让出cpu</span></div><div class="line">            <span class="comment">// 1. 保证只有一个线程正在进行初始化操作</span></div><div class="line">            Thread.yield();</div><div class="line">      </div><div class="line">      	<span class="comment">// 利用CAS操作设置sizeCtl为-1</span></div><div class="line">        <span class="comment">// 设置成功表示当前线程为执行初始化的唯一线程</span></div><div class="line">        <span class="comment">// 此处进入临界区</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">              	<span class="comment">// 由于让出cpu的线程也会后续进入该临界区</span></div><div class="line">                <span class="comment">// 需要进行再次确认table是否为null</span></div><div class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</div><div class="line">                    <span class="comment">// 2. 得出数组的大小</span></div><div class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</div><div class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">                    <span class="comment">// 3. 这里才真正的初始化数组，即分配Node数组</span></div><div class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</div><div class="line">                    table = tab = nt;</div><div class="line">                  	<span class="comment">// 默认负载为0.75</span></div><div class="line">                    <span class="comment">// 4. 计算数组中可用的大小：实际大小n*0.75（加载因子）</span></div><div class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                sizeCtl = sc;</div><div class="line">            &#125;</div><div class="line">          	<span class="comment">// 退出死循环的唯一出口</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> tab;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码的逻辑请见注释，有可能存在一个情况是多个线程同时走到这个方法中，为了保证能够正确初始化，在第1步中会先通过if进行判断，<strong>若当前已经有一个线程正在初始化即sizeCtl值变为-1</strong>，这个时候其他线程在If判断为true从而调用Thread.yield()让出CPU时间片。正在进行初始化的线程会调用U.compareAndSwapInt方法将sizeCtl改为-1即正在初始化的状态。另外还需要注意的事情是，在第四步中会进一步计算数组中可用的大小即为数组实际大小n乘以加载因子0.75.可以看看这里乘以0.75是怎么算的，0.75为四分之三，这里<code>n - (n &gt;&gt;&gt; 2)</code>是不是刚好是n-(1/4)n=(3/4)n，挺有意思的吧:)。如果选择是无参的构造器的话，这里在new Node数组的时候会使用默认大小为<code>DEFAULT_CAPACITY</code>（16），然后乘以加载因子0.75为12，也就是说数组的可用大小为12。</p>
<h2 id="casTabAt-原子操作方法"><a href="#casTabAt-原子操作方法" class="headerlink" title="casTabAt(原子操作方法)"></a>casTabAt(原子操作方法)</h2><p>以 CAS 的方式，将元素插入到 table 数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">  *这边为什么i要等于((long)i &lt;&lt; ASHIFT) + ABASE呢,计算偏移量</div><div class="line">  *ASHIFT是指tab[i]中第i个元素在相对于数组第一个元素的偏移量，而ABASE就算第一数组的内存素的偏移地址</div><div class="line">  *所以呢，((long)i &lt;&lt; ASHIFT) + ABASE就算i最后的地址</div><div class="line">  * 那么compareAndSwapObject的作用就算tab[i]和c比较，如果相等就tab[i]=v否则tab[i]=c;</div><div class="line">  */</div><div class="line">  <span class="comment">// 利用CAS算法设置i位置上的Node节点（将c和table[i]比较，相同则插入v）。  </span></div><div class="line">  <span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,  </span></span></div><div class="line">                                      Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123;  </div><div class="line">    	<span class="comment">//原子的执行如下逻辑：如果tab[i]==c,则设置tab[i]=v，并返回ture.否则返回false</span></div><div class="line">      <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);  </div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>利用CAS操作设置table数组中索引为i的元素</p>
<h2 id="setTabAt"><a href="#setTabAt" class="headerlink" title="setTabAt"></a>setTabAt</h2><p>以 valatile 写的方式，将元素插入 table 数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">static final &lt;K,V&gt; void setTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v) &#123;</div><div class="line">    U.putObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, v);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法用来设置table数组中索引为i的元素</p>
<h2 id="实例构造器方法"><a href="#实例构造器方法" class="headerlink" title="实例构造器方法"></a>实例构造器方法</h2><p>在使用ConcurrentHashMap第一件事自然而然就是new 出来一个ConcurrentHashMap对象，一共提供了如下几个构造器方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 构造一个空的map，即table数组还未初始化，初始化放在第一次插入数据时，默认大小为16</span></div><div class="line">ConcurrentHashMap()</div><div class="line"><span class="comment">// 2. 给定map的大小</span></div><div class="line">ConcurrentHashMap(<span class="keyword">int</span> initialCapacity) </div><div class="line"><span class="comment">// 3. 给定一个map</span></div><div class="line">ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)</div><div class="line"><span class="comment">// 4. 给定map的大小以及加载因子</span></div><div class="line">ConcurrentHashMap(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</div><div class="line"><span class="comment">// 5. 给定map大小，加载因子以及并发度（预计同时操作数据的线程）</span></div><div class="line">ConcurrentHashMap(<span class="keyword">int</span> initialCapacity,<span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</div></pre></td></tr></table></figure>
<p>ConcurrentHashMap一共给我们提供了5中构造器方法，具体使用请看注释，我们来看看第2种构造器，传入指定大小时的情况，该构造器源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">//1. 小于0直接抛异常</span></div><div class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">    <span class="comment">//2. 判断是否超过了允许的最大值，超过了话则取最大值，否则再对该值进一步处理</span></div><div class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</div><div class="line">               MAXIMUM_CAPACITY :</div><div class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</div><div class="line">    <span class="comment">//3. 赋值给sizeCtl</span></div><div class="line">    <span class="keyword">this</span>.sizeCtl = cap;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码的逻辑请看注释，很容易理解，如果小于0就直接抛出异常，如果指定值大于了所允许的最大值的话就取最大值，否则，在对指定值做进一步处理。最后将cap赋值给sizeCtl,关于sizeCtl的说明请看上面的说明，<strong>当调用构造器方法之后，sizeCtl的大小应该就代表了ConcurrentHashMap的大小，即table数组长度</strong>。tableSizeFor做了哪些事情了？源码为：</p>
<h2 id="tableSizeFor"><a href="#tableSizeFor" class="headerlink" title="tableSizeFor"></a>tableSizeFor</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private static final int tableSizeFor(int c) &#123;</div><div class="line">    int n = c - 1;</div><div class="line">    n |= n &gt;&gt;&gt; 1;</div><div class="line">    n |= n &gt;&gt;&gt; 2;</div><div class="line">    n |= n &gt;&gt;&gt; 4;</div><div class="line">    n |= n &gt;&gt;&gt; 8;</div><div class="line">    n |= n &gt;&gt;&gt; 16;</div><div class="line">    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过注释就很清楚了，该方法会将调用构造器方法时指定的大小转换成一个2的幂次方数，也就是说ConcurrentHashMap的大小一定是2的幂次方，比如，当指定大小为18时，为了满足2的幂次方特性，实际上concurrentHashMapd的大小为2的5次方（32）。另外，需要注意的是，<strong>调用构造器方法的时候并未构造出table数组（可以理解为ConcurrentHashMap的数据容器），只是算出table数组的长度，当第一次向ConcurrentHashMap插入数据的时候才真正的完成初始化创建table数组的工作</strong>。</p>
<h2 id="helpTransfer-协助扩容"><a href="#helpTransfer-协助扩容" class="headerlink" title="helpTransfer(协助扩容)"></a>helpTransfer(协助扩容)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 协助扩容方法。多线程下，当前线程检测到其他线程正进行扩容操作，则协助其一起扩容；（只有这种情况会被调用）从某种程度上说，其“优先级”很高，只要检测到扩容，就会放下其他工作，先扩容。  </span></div><div class="line"><span class="comment">// 调用之前，nextTable一定已存在。  </span></div><div class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;  </div><div class="line">    Node&lt;K,V&gt;[] nextTab; intsc;  </div><div class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (finstanceof ForwardingNode) &amp;&amp;  </div><div class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;  </div><div class="line">        intrs = resizeStamp(tab.length); <span class="comment">//标志位  </span></div><div class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;  </div><div class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;  </div><div class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||  </div><div class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)  </div><div class="line">                <span class="keyword">break</span>;  </div><div class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;  </div><div class="line">                transfer(tab, nextTab);<span class="comment">//调用扩容方法，直接进入复制阶段  </span></div><div class="line">                <span class="keyword">break</span>;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> nextTab;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> table;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="addCount"><a href="#addCount" class="headerlink" title="addCount"></a>addCount</h2><p>在put方法结尾处调用了addCount方法，把当前ConcurrentHashMap的元素个数+1这个方法一共做了两件事,更新baseCount的值，检测是否进行扩容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</div><div class="line">     CounterCell[] as; <span class="keyword">long</span> b, s;</div><div class="line">  </div><div class="line">  	<span class="comment">//利用CAS方法更新baseCount的值</span></div><div class="line">     <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</div><div class="line">         !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;<span class="comment">// 1</span></div><div class="line">         CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</div><div class="line">         <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</div><div class="line">         <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</div><div class="line">             (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</div><div class="line">             !(uncontended =</div><div class="line">               U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</div><div class="line">           	<span class="comment">// 多线程 CAS 发生失败的时候执行</span></div><div class="line">             fullAddCount(x, uncontended); <span class="comment">// 2</span></div><div class="line">             <span class="keyword">return</span>;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</div><div class="line">             <span class="keyword">return</span>;</div><div class="line">         s = sumCount();</div><div class="line">     &#125;</div><div class="line">  	<span class="comment">//如果check值大于等于0 则需要检验是否需要进行扩容操作</span></div><div class="line">     <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</div><div class="line">         Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</div><div class="line">       	<span class="comment">// 当条件满足的时候开始扩容</span></div><div class="line">         <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">                (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</div><div class="line">             <span class="keyword">int</span> rs = resizeStamp(n);</div><div class="line">           	<span class="comment">// 如果小于0 说明已经有线程在进行扩容了</span></div><div class="line">             <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</div><div class="line">     <span class="comment">// 一下的情况说明已经有在扩容或者多线程进行了扩容，其他线程直接 break 不要进入扩容</span></div><div class="line">                 <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</div><div class="line">                     sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</div><div class="line">                     transferIndex &lt;= <span class="number">0</span>)</div><div class="line">                     <span class="keyword">break</span>;</div><div class="line">               	<span class="comment">// 如果已经有其他线程在执行扩容操作</span></div><div class="line">               	<span class="comment">// 如果相等说明已经完成，可以继续扩容</span></div><div class="line">                 <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</div><div class="line">                     transfer(tab, nt);</div><div class="line">             &#125;</div><div class="line">           	<span class="comment">// 当前线程是唯一的或是第一个发起扩容的线程  此时nextTable=null</span></div><div class="line">    			<span class="comment">// 这个时候 sizeCtl 已经等于(rs&lt;&lt;RESIZE_STAMP_SHIFT)+2 等于一个大的负数，这边</span></div><div class="line">           	<span class="comment">// 加上2很巧，因为 transfer 后面对 sizeCtl-- 操作的时候，最多只能减两个就结束</span></div><div class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</div><div class="line">                                          (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</div><div class="line">                 transfer(tab, <span class="keyword">null</span>);</div><div class="line">             s = sumCount();</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>看上面的注释1,每次都会对 baseCount 加1,如果并发竞争太大，那么可能导致 U.compareAndSwapLong(this,BASECOUNT,b=baseCount,s = b + x) 失败,那么为了提高高并发的时候 baseCount 可见性的失败的问题,又避免一直重试，这样性能会有很大的影响,那么在 jdk 8的时候是有引入一个类 Striped64 ,其中 LongAdder 和 DoubleAdder 就是对这个类的实现。这两个方法都是为了解决高并发场景而生的，是 AtomicLong 的加强版,AtomicLong 在高并发场景性能会比 LongAdder 差。但是 LongAdder 的空间复杂度会高点。</p>
<h2 id="fullAddCount"><a href="#fullAddCount" class="headerlink" title="fullAddCount"></a>fullAddCount</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">fullAddCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</div><div class="line">     <span class="keyword">int</span> h;</div><div class="line">     <span class="comment">// 获取当前线程的 probe 值作为 hash 值,如果0则强制初始化当前线程的 Probe 值，</span></div><div class="line">  	<span class="comment">// 初始化 probe 值不为 0</span></div><div class="line">     <span class="keyword">if</span> ((h = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</div><div class="line">         ThreadLocalRandom.localInit();      <span class="comment">// force initialization</span></div><div class="line">         h = ThreadLocalRandom.getProbe();</div><div class="line">       	<span class="comment">// 设置未竞争标记为true</span></div><div class="line">         wasUncontended = <span class="keyword">true</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></div><div class="line">     <span class="keyword">for</span> (;;) &#123;</div><div class="line">         CounterCell[] as; CounterCell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</div><div class="line">         <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</div><div class="line">             <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</div><div class="line">               	<span class="comment">// Try to attach new Cell 如果当前没有 CounterCell 就创建一个</span></div><div class="line">                 <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;            </div><div class="line">                     CounterCell r = <span class="keyword">new</span> CounterCell(x); <span class="comment">// Optimistic create</span></div><div class="line">                     <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</div><div class="line">                         <span class="comment">// 这边加上 cellsBusy 锁  </span></div><div class="line">                         U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</div><div class="line">                         <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</div><div class="line">                         <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></div><div class="line">                             CounterCell[] rs; <span class="keyword">int</span> m, j;</div><div class="line">                             <span class="keyword">if</span> ((rs = counterCells) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">                                 (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">                                 rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;</div><div class="line">                                 rs[j] = r;</div><div class="line">                                 created = <span class="keyword">true</span>;</div><div class="line">                             &#125;</div><div class="line">                         &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                             <span class="comment">// 释放 cellsBusy 锁定，让其他线程可以进来</span></div><div class="line">                             cellsBusy = <span class="number">0</span>; </div><div class="line">                         &#125;</div><div class="line">                         <span class="keyword">if</span> (created)</div><div class="line">                             <span class="keyword">break</span>;</div><div class="line">                         <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></div><div class="line">                     &#125;</div><div class="line">                 &#125;</div><div class="line">                 collide = <span class="keyword">false</span>;</div><div class="line">             &#125;</div><div class="line">           	<span class="comment">// wasUncontended 为 false 说明已经发生了竞争，重置为true重新执行上面代码</span></div><div class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></div><div class="line">                 wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></div><div class="line">           	<span class="comment">// 对 cell 的值进行累计x(1)</span></div><div class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</div><div class="line">                 <span class="keyword">break</span>;</div><div class="line">           	<span class="comment">// 表明 as 已经过时，说明 cells 已经初始化完成，看下面，</span></div><div class="line">           	<span class="comment">// 重置 collide 为 false 表明已经存在竞争</span></div><div class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (counterCells != as || n &gt;= NCPU)</div><div class="line">                 collide = <span class="keyword">false</span>;            <span class="comment">// At max size or stale</span></div><div class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</div><div class="line">                 collide = <span class="keyword">true</span>;</div><div class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</div><div class="line">                      U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</div><div class="line">                 <span class="keyword">try</span> &#123;</div><div class="line">                   	<span class="comment">// 下面的方法主要是给 counterCells 扩容，尽可能避免冲突</span></div><div class="line">                     <span class="keyword">if</span> (counterCells == as) &#123;<span class="comment">// Expand table unless stale</span></div><div class="line">                         CounterCell[] rs = <span class="keyword">new</span> CounterCell[n &lt;&lt; <span class="number">1</span>];</div><div class="line">                         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">                             rs[i] = as[i];</div><div class="line">                         counterCells = rs;</div><div class="line">                     &#125;</div><div class="line">                 &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                     cellsBusy = <span class="number">0</span>;</div><div class="line">                 &#125;</div><div class="line">                 collide = <span class="keyword">false</span>;</div><div class="line">                 <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></div><div class="line">             &#125;</div><div class="line">             h = ThreadLocalRandom.advanceProbe(h);</div><div class="line">         &#125;</div><div class="line">       	<span class="comment">// 表明 counterCells 还没初始化，则初始化，这边用 cellsBusy 加锁</span></div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; counterCells == as &amp;&amp;</div><div class="line">                  U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</div><div class="line">             <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</div><div class="line">             <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></div><div class="line">                 <span class="keyword">if</span> (counterCells == as) &#123;</div><div class="line">                     CounterCell[] rs = <span class="keyword">new</span> CounterCell[<span class="number">2</span>];</div><div class="line">                     rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> CounterCell(x);</div><div class="line">                     counterCells = rs;</div><div class="line">                     init = <span class="keyword">true</span>;</div><div class="line">                 &#125;</div><div class="line">             &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                 cellsBusy = <span class="number">0</span>;</div><div class="line">             &#125;</div><div class="line">             <span class="keyword">if</span> (init)</div><div class="line">                 <span class="keyword">break</span>;</div><div class="line">         &#125;</div><div class="line">       	<span class="comment">// 最终如果上面的都失败就把 x 累计到 baseCount</span></div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, v = baseCount, v + x))</div><div class="line">             <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>回到 addCount 来,我们每次竞争都对 baseCount 进行加 1 当达到一定的容量时，就需要对 table 进行扩容。 使用 transfer 方法。</p>
<h2 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h2><p>负责迁移node节点</p>
<p>扩容transfer方法是一个设计极为精巧的方法。通过互斥读写ForwardingNode，多线程可以协同完成扩容任务。</p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171214/k7LKAjJm0m.png" alt="mark"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = tab.length, stride;</div><div class="line">  		<span class="comment">//计算每次迁移的node个数（MIN_TRANSFER_STRIDE该值作为下限，以避免扩容线程过多）</span></div><div class="line">        <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</div><div class="line">          	<span class="comment">// 确保每次迁移的node个数不少于16个</span></div><div class="line">            stride = MIN_TRANSFER_STRIDE; </div><div class="line">  		<span class="comment">// nextTab为扩容中的临时table</span></div><div class="line">        <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">              	<span class="comment">//扩容一倍	</span></div><div class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">              	<span class="comment">// 1. 新建一个 node 数组，容量为之前的两倍</span></div><div class="line">                Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</div><div class="line">                nextTab = nt;</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></div><div class="line">                sizeCtl = Integer.MAX_VALUE;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            nextTable = nextTab;</div><div class="line">          	<span class="comment">// transferIndex为扩容复制过程中的桶首节点遍历索引</span></div><div class="line">            <span class="comment">// 所以从n开始，表示从后向前遍历</span></div><div class="line">            transferIndex = n;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> nextn = nextTab.length;</div><div class="line">  		<span class="comment">// ForwardingNode是Node节点的直接子类，是扩容过程中的特殊桶首节点</span></div><div class="line">      	<span class="comment">// 该类中没有key,value,next</span></div><div class="line">      	<span class="comment">// hash值为特定的-1</span></div><div class="line">        <span class="comment">// 附加Node&lt;K,V&gt;[] nextTable变量指向扩容中的nextTab</span></div><div class="line">        <span class="comment">// 在find方法中，将扩容中的查询操作导入到nextTab上</span></div><div class="line">  		<span class="comment">//2. 新建forwardingNode引用，在之后会用到</span></div><div class="line">        ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</div><div class="line">        <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</div><div class="line">  		<span class="comment">// 循环的关键变量，判断是否已经扩容完成，完成就 return , 退出循环</span></div><div class="line">        <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; </div><div class="line">  		 <span class="comment">//【1】逆序迁移已经获取到的hash桶集合，如果迁移完毕，则更新transferIndex，</span></div><div class="line">         <span class="comment">// 获取下一批待迁移的hash桶</span></div><div class="line">         <span class="comment">//【2】如果transferIndex=0，表示所以hash桶均被分配，将i置为-1，</span></div><div class="line">  		<span class="comment">// 准备退出transfer方法</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</div><div class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</div><div class="line">          	<span class="comment">// 3. 确定遍历中的索引i（更新待迁移的hash桶索引）</span></div><div class="line">          	<span class="comment">// 循环的关键 i , i-- 操作保证了倒叙遍历数组</span></div><div class="line">            <span class="keyword">while</span> (advance) &#123;</div><div class="line">                <span class="keyword">int</span> nextIndex, nextBound;</div><div class="line">              	<span class="comment">// 更新迁移索引i</span></div><div class="line">                <span class="keyword">if</span> (--i &gt;= bound || finishing)</div><div class="line">                    advance = <span class="keyword">false</span>;</div><div class="line">              	<span class="comment">// transferIndex = 0表示table中所有数组元素都已经有其他线程负责扩容</span></div><div class="line">              	<span class="comment">// nextIndex=transferIndex=n=tab.length(默认16)</span></div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</div><div class="line">                  	<span class="comment">// transferIndex&lt;=0表示已经没有需要迁移的hash桶，</span></div><div class="line">                  	<span class="comment">// 将i置为-1，线程准备退出</span></div><div class="line">                    i = -<span class="number">1</span>;</div><div class="line">                    advance = <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">             <span class="comment">//cas无锁算法设置 transferIndex = transferIndex - stride		</span></div><div class="line">             <span class="comment">// 尝试更新transferIndex，获取当前线程执行扩容复制的索引区间</span></div><div class="line">             <span class="comment">// 更新成功，则当前线程负责完成索引为(nextBound，nextIndex)之间的桶首节点扩容</span></div><div class="line">             <span class="comment">//当迁移完bound这个桶后，尝试更新transferIndex，获取下一批待迁移的hash桶</span></div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</div><div class="line">                         (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</div><div class="line">                          nextBound = (nextIndex &gt; stride ?</div><div class="line">                                       nextIndex - stride : <span class="number">0</span>))) &#123;</div><div class="line">                    bound = nextBound;</div><div class="line">                    i = nextIndex - <span class="number">1</span>;</div><div class="line">                    advance = <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="comment">//退出transfer</span></div><div class="line">          	<span class="comment">//4.将原数组中的元素复制到新数组中去</span></div><div class="line">            <span class="comment">//4.5 for循环退出，扩容结束修改sizeCtl属性</span></div><div class="line"><span class="comment">// i&lt;0 说明已经遍历完旧的数组tab;i&gt;=n什么时候有可能呢？在下面看到i=n,所以目前i最大应该是n吧</span></div><div class="line"><span class="comment">// i+n&gt;=nextn,nextn=nextTab.length,所以如果满足i+n&gt;=nextn说明已经扩容完成</span></div><div class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</div><div class="line">                <span class="keyword">int</span> sc;</div><div class="line">                <span class="keyword">if</span> (finishing) &#123;   <span class="comment">// a</span></div><div class="line">                  	<span class="comment">//最后一个迁移的线程，recheck后，做收尾工作，然后退出</span></div><div class="line">                    nextTable = <span class="keyword">null</span>;</div><div class="line">                    table = nextTab;</div><div class="line">                  	<span class="comment">// 扩容成功，设置新sizeCtl，仍然为总大小的0.75</span></div><div class="line">                    sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">			</div><div class="line">                <span class="comment">// 第一个扩容的线程，执行transfer方法之前，会设置 sizeCtl = </span></div><div class="line">                <span class="comment">// (resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) + 2) 	</span></div><div class="line">                <span class="comment">// 后续帮其扩容的线程，执行transfer方法之前，会设置 sizeCtl = sizeCtl+1</span></div><div class="line">                <span class="comment">// 每一个退出transfer的方法的线程，退出之前，会设置 sizeCtl = sizeCtl-1</span></div><div class="line">                <span class="comment">// 那么最后一个线程退出时：</span></div><div class="line">                <span class="comment">// 必然有sc == (resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) + 2)，</span></div><div class="line">                <span class="comment">// 即 (sc - 2) == resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT</span></div><div class="line">              </div><div class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;                  </div><div class="line">                  	<span class="comment">// 如果有多个线程进行扩容，那么这个值在第二个线程以后就不会相等，因为 </span></div><div class="line">                  	<span class="comment">// sizeCtl 已经被减1了，所以后面的线程只能直接返回，</span></div><div class="line">                  	<span class="comment">// 始终保证只有一个线程执行了a(上面的注释a)</span></div><div class="line">                    <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                  	<span class="comment">// finishing 和 advance 保证线程已经扩容完成了可以退出循环</span></div><div class="line">                    finishing = advance = <span class="keyword">true</span>;</div><div class="line">                  	<span class="comment">//最后退出的线程要重新check下是否全部迁移完毕</span></div><div class="line">                    i = n;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">          	<span class="comment">// 当前table节点为空，不需要复制，直接放入ForwardingNode</span></div><div class="line">          	<span class="comment">//4.1 当前数组中第i个元素为null，用CAS设置成特殊节点forwardingNode(可以理解成占位符)</span></div><div class="line">          	<span class="comment">// 如果 tab[i] 为 null,那么就把 fwd 插入到 tab[i],表明这个节点已经处理过了</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</div><div class="line">                advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</div><div class="line">          	<span class="comment">// 当前table节点已经是ForwardingNode</span></div><div class="line">            <span class="comment">// 表示已经被其他线程处理了，则直接往前遍历</span></div><div class="line">            <span class="comment">// 通过CAS读写ForwardingNode节点状态，达到多线程互斥处理</span></div><div class="line">          	<span class="comment">// 4.2 如果遍历到ForwardingNode节点说明这个点已经被处理过了直接跳过</span></div><div class="line">            <span class="comment">// 这里是控制并发扩容的核心</span></div><div class="line">          	<span class="comment">// 如果 f.hash=-1 的话说明该节点为 ForwardingNode,说明该节点已经处理过了</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</div><div class="line">                advance = <span class="keyword">true</span>; </div><div class="line">          	<span class="comment">//迁移node节点</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">              	<span class="comment">// 锁住当前桶首节点</span></div><div class="line">                <span class="keyword">synchronized</span> (f) &#123;</div><div class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</div><div class="line">                        Node&lt;K,V&gt; ln, hn;</div><div class="line">                      	<span class="comment">// 链表节点复制(链表迁移)</span></div><div class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</div><div class="line">                        <span class="comment">// 4.3 处理当前节点为链表的头结点的情况，构造两个链表，一个是原链表  </span></div><div class="line">                        <span class="comment">// 另一个是原链表的反序排列</span></div><div class="line">                            <span class="keyword">int</span> runBit = fh &amp; n;</div><div class="line">                            Node&lt;K,V&gt; lastRun = f;</div><div class="line">                <span class="comment">//将node链表，分成2个新的node链表</span></div><div class="line">                <span class="comment">// 这边还对链表进行遍历，这边的算法和hashMap的算法又不一样了，对半拆分</span></div><div class="line">                <span class="comment">// 把链表拆分为，hash&amp;n 等于0和不等于0的，然后分别放在新表的i和i+n位置           	</span></div><div class="line">                <span class="comment">// 此方法同 HashMap 的 resize</span></div><div class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</div><div class="line">                                <span class="keyword">int</span> b = p.hash &amp; n;</div><div class="line">                                <span class="keyword">if</span> (b != runBit) &#123;</div><div class="line">                                    runBit = b;</div><div class="line">                                    lastRun = p;</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</div><div class="line">                                ln = lastRun;</div><div class="line">                                hn = <span class="keyword">null</span>;</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">else</span> &#123;</div><div class="line">                                hn = lastRun;</div><div class="line">                                ln = <span class="keyword">null</span>;</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</div><div class="line">                                <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</div><div class="line">                                <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</div><div class="line">                                    ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</div><div class="line">                                <span class="keyword">else</span></div><div class="line">                                    hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</div><div class="line">                            &#125;</div><div class="line">                          	<span class="comment">//将新node链表赋给nextTab</span></div><div class="line">                          	<span class="comment">//在nextTable的i位置上插入一个链表</span></div><div class="line">                            setTabAt(nextTab, i, ln);</div><div class="line">                            <span class="comment">//在nextTable的i+n的位置上插入另一个链表</span></div><div class="line">                            setTabAt(nextTab, i + n, hn);</div><div class="line">                          	<span class="comment">// 扩容成功后，设置ForwardingNode节点</span></div><div class="line">                          	<span class="comment">//在table的i位置上插入forwardNode节点表示已经处理过该节点</span></div><div class="line">                          	<span class="comment">// 把已经替换的节点的旧tab的i的位置用fwd替换，fwd包含nextTab</span></div><div class="line">                            setTabAt(tab, i, fwd);</div><div class="line">                            <span class="comment">//设置advance为true 返回到上面的while循环中 就可以执行i--操作</span></div><div class="line">                            advance = <span class="keyword">true</span>;</div><div class="line">                        &#125;</div><div class="line">                      	<span class="comment">// 红黑树节点复制(红黑树迁移)</span></div><div class="line">                      	<span class="comment">//4.4 处理当前节点是TreeBin时的情况，操作和上面的类似</span></div><div class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</div><div class="line">                            TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</div><div class="line">                            TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</div><div class="line">                            TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line">                            <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</div><div class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">                                <span class="keyword">int</span> h = e.hash;</div><div class="line">                                TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</div><div class="line">                                    (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">                                <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</div><div class="line">                                    <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</div><div class="line">                                        lo = p;</div><div class="line">                                    <span class="keyword">else</span></div><div class="line">                                        loTail.next = p;</div><div class="line">                                    loTail = p;</div><div class="line">                                    ++lc;</div><div class="line">                                &#125;</div><div class="line">                                <span class="keyword">else</span> &#123;</div><div class="line">                                    <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</div><div class="line">                                        hi = p;</div><div class="line">                                    <span class="keyword">else</span></div><div class="line">                                        hiTail.next = p;</div><div class="line">                                    hiTail = p;</div><div class="line">                                    ++hc;</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                          	<span class="comment">// 判断扩容后是否还需要红黑树</span></div><div class="line">                            ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</div><div class="line">                                (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</div><div class="line">                            hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</div><div class="line">                                (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</div><div class="line">                            setTabAt(nextTab, i, ln);</div><div class="line">                            setTabAt(nextTab, i + n, hn);</div><div class="line">                          	<span class="comment">// 扩容成功后，设置ForwardingNode节点</span></div><div class="line">                            setTabAt(tab, i, fwd);</div><div class="line">                            advance = <span class="keyword">true</span>;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>代码逻辑请看注释,整个扩容操作分为<strong>两个部分</strong>：</p>
<p><strong>第一部分</strong>是构建一个nextTable,它的容量是原来的两倍，这个操作是单线程完成的。新建table数组的代码为:<code>Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1]</code>,在原容量大小的基础上右移一位。</p>
<p><strong>第二个部分</strong>就是将原来table中的元素复制到nextTable中，主要是遍历复制的过程。<br>根据运算得到当前遍历的数组的位置i，然后利用tabAt方法获得i位置的元素再进行判断：</p>
<ol>
<li>如果这个位置为空，就在原table中的i位置放入forwardNode节点，这个也是触发并发扩容的关键点；</li>
<li>如果这个位置是Node节点（fh&gt;=0），如果它是一个链表的头节点，就构造一个反序链表，把他们分别放在nextTable的i和i+n的位置上</li>
<li>如果这个位置是TreeBin节点（fh&lt;0），也做一个反序处理，并且判断是否需要untreefi，把处理的结果分别放在nextTable的i和i+n的位置上</li>
<li>遍历过所有的节点以后就完成了复制工作，这时让nextTable作为新的table，并且更新sizeCtl为新容量的0.75倍 ，完成扩容。设置为新容量的0.75倍代码为 <code>sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1)</code>，仔细体会下是不是很巧妙，n&lt;<1相当于n右移一位表示n的两倍即2n,n>&gt;&gt;1左右一位相当于n除以2即0.5n,然后两者相减为2n-0.5n=1.5n,是不是刚好等于新容量的0.75倍即2n*0.75=1.5n。最后用一个示意图来进行总结（图片摘自网络）：</1相当于n右移一位表示n的两倍即2n,n></li>
</ol>
<h2 id="mappingCount-与-size"><a href="#mappingCount-与-size" class="headerlink" title="mappingCount 与 size"></a>mappingCount 与 size</h2><p><strong>mappingCount</strong>与<strong>size</strong>方法的类似 从给出的注释来看，应该使用mappingCount代替size方法 两个方法都没有直接返回basecount 而是统计一次这个值，而这个值其实也是一个大概的数值，因此可能在统计的时候有其他线程正在执行插入或删除操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> n = sumCount();</div><div class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</div><div class="line">            (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</div><div class="line">            (<span class="keyword">int</span>)n);</div><div class="line">&#125;</div><div class="line"> <span class="comment">/**</span></div><div class="line"> * Returns the number of mappings. This method should be used</div><div class="line"> * instead of &#123;<span class="doctag">@link</span> #size&#125; because a ConcurrentHashMap may</div><div class="line"> * contain more mappings than can be represented as an int. The</div><div class="line"> * value returned is an estimate; the actual count may differ if</div><div class="line"> * there are concurrent insertions or removals.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@return</span> the number of mappings</div><div class="line"> * <span class="doctag">@since</span> 1.8</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">mappingCount</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> n = sumCount();</div><div class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0L</span>) ? <span class="number">0L</span> : n; <span class="comment">// ignore transient negative values</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</div><div class="line">    CounterCell[] as = counterCells; CounterCell a;</div><div class="line">    <span class="keyword">long</span> sum = baseCount;</div><div class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</div><div class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</div><div class="line">                sum += a.value;<span class="comment">//所有counter的值求和</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><p><strong>和put方法一样，多个remove线程请求不同的hash桶时，可以并发执行</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/6283837-95df888f4f738601.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>如图所示：删除的node节点的next依然指着下一个元素。此时若有一个遍历线程正在遍历这个已经删除的节点，这个遍历线程依然可以通过next属性访问下一个元素。从遍历线程的角度看，他并没有感知到此节点已经删除了，这说明了ConcurrentHashMap提供了弱一致性的迭代器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> replaceNode(key, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">    <span class="comment">// 当参数 value == null 时，删除节点。否则更新节点的值为value</span></div><div class="line">    <span class="comment">// cv 是个期望值，当 map[key].value 等于期望值 cv 或 cv == null 时，</span></div><div class="line">    <span class="comment">// 删除节点，或者更新节点的值</span></div><div class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">replaceNode</span><span class="params">(Object key, V value, Object cv)</span> </span>&#123;</div><div class="line">      <span class="keyword">int</span> hash = spread(key.hashCode());</div><div class="line">      <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</div><div class="line">          Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</div><div class="line">        	<span class="comment">// table 还没初始化或key对应的 hash 桶为空</span></div><div class="line">          <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||</div><div class="line">              (f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>)</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">        	<span class="comment">// 正在扩容</span></div><div class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</div><div class="line">              tab = helpTransfer(tab, f);</div><div class="line">          <span class="keyword">else</span> &#123;</div><div class="line">              V oldVal = <span class="keyword">null</span>;</div><div class="line">              <span class="keyword">boolean</span> validated = <span class="keyword">false</span>;</div><div class="line">              <span class="keyword">synchronized</span> (f) &#123;</div><div class="line">                	<span class="comment">// CAS 获取 tab[i] ,如果此时 tab[i] != f,说明其他线程修改了 tab[i]</span></div><div class="line">                  <span class="comment">// 回到 for 循环开始处，重新执行</span></div><div class="line">                  <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</div><div class="line">                    	<span class="comment">// node 链表</span></div><div class="line">                      <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</div><div class="line">                          validated = <span class="keyword">true</span>;</div><div class="line">                          <span class="keyword">for</span> (Node&lt;K,V&gt; e = f, pred = <span class="keyword">null</span>;;) &#123;</div><div class="line">                              K ek;</div><div class="line">                              <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                                  ((ek = e.key) == key ||</div><div class="line">                                   (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</div><div class="line">                                  V ev = e.val;</div><div class="line">                                	<span class="comment">// ev 代表参数期望值</span></div><div class="line">                                	<span class="comment">// cv == null:直接更新value/删除节点</span></div><div class="line">                                	<span class="comment">// cv 不为空，则只有在 key 的 oldVal 等于</span></div><div class="line">                                	<span class="comment">// 期望值的时候，才更新 value/删除节点</span></div><div class="line">                                  <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == ev ||</div><div class="line">                                      (ev != <span class="keyword">null</span> &amp;&amp; cv.equals(ev))) &#123;</div><div class="line">                                      oldVal = ev;</div><div class="line">                                    	<span class="comment">//更新value</span></div><div class="line">                                      <span class="keyword">if</span> (value != <span class="keyword">null</span>)</div><div class="line">                                          e.val = value;</div><div class="line">                                    	<span class="comment">//删除非头节点</span></div><div class="line">                                      <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>)</div><div class="line">                                          pred.next = e.next;</div><div class="line">                                    	<span class="comment">//删除头节点</span></div><div class="line">                                      <span class="keyword">else</span></div><div class="line">                                        	<span class="comment">// 因为已经获取了头结点锁，所以此时</span></div><div class="line">                                        	<span class="comment">// 不需要使用casTabAt</span></div><div class="line">                                          setTabAt(tab, i, e.next);</div><div class="line">                                  &#125;</div><div class="line">                                  <span class="keyword">break</span>;</div><div class="line">                              &#125;</div><div class="line">                            	<span class="comment">//当前节点不是目标节点，继续遍历下一个节点</span></div><div class="line">                              pred = e;</div><div class="line">                              <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)</div><div class="line">                                	<span class="comment">//到达链表尾部，依旧没有找到，跳出循环</span></div><div class="line">                                  <span class="keyword">break</span>;</div><div class="line">                          &#125;</div><div class="line">                      &#125;</div><div class="line">                    	<span class="comment">//红黑树</span></div><div class="line">                      <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</div><div class="line">                          validated = <span class="keyword">true</span>;</div><div class="line">                          TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</div><div class="line">                          TreeNode&lt;K,V&gt; r, p;</div><div class="line">                          <span class="keyword">if</span> ((r = t.root) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">                              (p = r.findTreeNode(hash, key, <span class="keyword">null</span>)) != <span class="keyword">null</span>) &#123;</div><div class="line">                              V pv = p.val;</div><div class="line">                              <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == pv ||</div><div class="line">                                  (pv != <span class="keyword">null</span> &amp;&amp; cv.equals(pv))) &#123;</div><div class="line">                                  oldVal = pv;</div><div class="line">                                  <span class="keyword">if</span> (value != <span class="keyword">null</span>)</div><div class="line">                                      p.val = value;</div><div class="line">                                  <span class="keyword">else</span> <span class="keyword">if</span> (t.removeTreeNode(p))</div><div class="line">                                      setTabAt(tab, i, untreeify(t.first));</div><div class="line">                              &#125;</div><div class="line">                          &#125;</div><div class="line">                      &#125;</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">              <span class="keyword">if</span> (validated) &#123;</div><div class="line">                  <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>) &#123;</div><div class="line">                    	<span class="comment">//如果删除了节点，更新size</span></div><div class="line">                      <span class="keyword">if</span> (value == <span class="keyword">null</span>)</div><div class="line">                          addCount(-<span class="number">1L</span>, -<span class="number">1</span>);</div><div class="line">                      <span class="keyword">return</span> oldVal;</div><div class="line">                  &#125;</div><div class="line">                  <span class="keyword">break</span>;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h2 id="ForwardingNode-1"><a href="#ForwardingNode-1" class="headerlink" title="ForwardingNode"></a>ForwardingNode</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</div><div class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</div><div class="line">      	<span class="comment">//hash值为MOVED（-1）的节点就是ForwardingNode</span></div><div class="line">        <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">        <span class="keyword">this</span>.nextTable = tab;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  	<span class="comment">//通过此方法，访问被迁移到nextTable中的数据</span></div><div class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</div><div class="line">        <span class="comment">// loop to avoid arbitrarily deep recursion on forwarding nodes</span></div><div class="line">        outer: <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = nextTable;;) &#123;</div><div class="line">            Node&lt;K,V&gt; e; <span class="keyword">int</span> n;</div><div class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span> || tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||</div><div class="line">                (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) == <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">int</span> eh; K ek;</div><div class="line">                <span class="keyword">if</span> ((eh = e.hash) == h &amp;&amp;</div><div class="line">                    ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))</div><div class="line">                    <span class="keyword">return</span> e;</div><div class="line">                <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ForwardingNode) &#123;</div><div class="line">                        tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;</div><div class="line">                        <span class="keyword">continue</span> outer;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span></div><div class="line">                        <span class="keyword">return</span> e.find(h, k);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>JDK6,7中的ConcurrentHashmap主要使用Segment来实现减小锁粒度，分割成若干个Segment，在put的时候需要锁住Segment，get时候不加锁，使用volatile来保证可见性，当要统计全局时（比如size），首先会尝试多次计算modcount来确定，这几次尝试中，是否有其他线程进行了修改操作，如果没有，则直接返回size。如果有，则需要依次锁住所有的Segment来计算。</p>
<p>而在1.8的时候摒弃了segment臃肿的设计，这种设计在定位到具体的桶时，要先定位到具体的segment，然后再<br>在segment中定位到具体的桶。而到了1.8的时候是针对的是Node[] tale数组中的每一个桶，进一步减小了锁粒度。并且防止拉链过长导致性能下降，当链表长度大于8的时候采用红黑树的设计。</p>
<p>主要设计上的变化有以下几点:</p>
<ol>
<li>不采用segment而采用node，锁住node来实现减小锁粒度。</li>
<li>设计了MOVED状态 当resize的中过程中 线程2还在put数据，线程2会帮助resize。</li>
<li>使用3个CAS操作来确保node的一些操作的原子性，这种方式代替了锁。</li>
<li>sizeCtl的不同值来代表不同含义，起到了控制的作用。</li>
<li>采用synchronized而不是ReentrantLock</li>
<li>volatile语义提供更细颗粒度的轻量级锁，使得多线程可以(几乎)同时读写实例中的关键量，正确理解当前类所处的状态，进入对应if语句中执行相关逻辑。</li>
<li>采用更加细粒度的hash桶级别锁，扩容期间，依然可以保证写操作的并发度。</li>
<li>多线程无锁扩容的关键就是通过CAS设置sizeCtl与transferIndex变量，协调多个线程对table数组中的node进行迁移。</li>
</ol>
<p>参考文章：<a href="http://www.cnblogs.com/huaizuo/p/5413069.html" target="_blank" rel="external">http://www.cnblogs.com/huaizuo/p/5413069.html</a></p>
<p>参考文章：<a href="http://www.bijishequ.com/detail/560964?p=" target="_blank" rel="external">http://www.bijishequ.com/detail/560964?p=</a></p>
<p>参考文章：<a href="https://bentang.me/tech/2016/12/01/jdk8-concurrenthashmap-1/" target="_blank" rel="external">https://bentang.me/tech/2016/12/01/jdk8-concurrenthashmap-1/</a></p>
<p>参考文章:   <a href="http://www.jianshu.com/p/5bc70d9e5410" target="_blank" rel="external">http://www.jianshu.com/p/5bc70d9e5410</a></p>
<p>扩容原理:   <a href="http://www.jianshu.com/p/487d00afe6ca" target="_blank" rel="external">http://www.jianshu.com/p/487d00afe6ca</a></p>
<p>遍历操作：<a href="http://www.jianshu.com/p/3e85ac8f8662" target="_blank" rel="external">http://www.jianshu.com/p/3e85ac8f8662</a></p>
<p>改进说明带例子:<a href="http://www.voidcn.com/article/p-gdbewnlb-qh.html" target="_blank" rel="external">http://www.voidcn.com/article/p-gdbewnlb-qh.html</a></p>
<p><a href="http://nannan408.iteye.com/blog/2217042" target="_blank" rel="external">http://nannan408.iteye.com/blog/2217042</a></p>
]]></content>
      
        <categories>
            
            <category> ConcurrentHashMap </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础数据类型 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ConcurrentHashMap的使用]]></title>
      <url>/2017/12/26/ConcurrentHashMap%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="ConcurrentHashMap的使用"><a href="#ConcurrentHashMap的使用" class="headerlink" title="ConcurrentHashMap的使用"></a>ConcurrentHashMap的使用</h1><p>缓存的使用</p>
<ul>
<li>高性能本地缓存：对系统中常用到的业务数据放到缓存中以提高系统性能，限制是单服务器模式</li>
<li>分布式缓存：常用分布式缓存技术memcached、redis等</li>
</ul>
<p>ConcurrentHashMap就是常用的高并发下的缓存对象。<br><a id="more"></a><br>接下来直接上例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentMapTest</span> </span>&#123;</div><div class="line">  </div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> ConcurrentMap&lt;String, Future&lt;String&gt;&gt; cMap </div><div class="line">      = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line">  </div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, String&gt; cMap2 </div><div class="line">      = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line">  </div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">				<span class="meta">@Override</span></div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">					concurrentMap2(<span class="string">"3"</span>);</div><div class="line">					<span class="keyword">try</span> &#123;</div><div class="line">						concurrentMap(<span class="string">"123"</span>);</div><div class="line">					&#125; <span class="keyword">catch</span> (InterruptedException | </div><div class="line">                             ExecutionException | TimeoutException e) &#123;</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;).start();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 解决并发写的线程安全问题。但是高并发可读取会造成重复写的问题...</div><div class="line">	 * 如果put的业务计算复杂将耗费不必要的资源</div><div class="line">	 * 解决缓存读取问题，但可能会出现缓存重复写</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">concurrentMap2</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">" start ...."</span>);</div><div class="line">		String f = cMap2.get(key);</div><div class="line">		<span class="comment">// ConcurrentMap读不加锁，写加锁。</span></div><div class="line">        <span class="comment">// 当并发量高时会出现重复compute的操作，然后才put到map中</span></div><div class="line">		<span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				Thread.sleep(<span class="number">500</span>);</div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			cMap2.put(key, <span class="string">"dataTest"</span> + index);</div><div class="line">			System.out.println(Thread.currentThread().getName() </div><div class="line">                               + <span class="string">" compute , index================== "</span> + index++);</div><div class="line">		&#125;</div><div class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">" end .... "</span> </div><div class="line">                           + cMap2.get(key));</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 解决并发写问题，同时避免了重复put计算的问题 解决缓存读写的问题</div><div class="line">	 * </div><div class="line">	 * <span class="doctag">@param</span> key</div><div class="line">	 * <span class="doctag">@throws</span> InterruptedException</div><div class="line">	 * <span class="doctag">@throws</span> ExecutionException</div><div class="line">	 * <span class="doctag">@throws</span> TimeoutException</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">concurrentMap</span><span class="params">(String key)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</div><div class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">" start ...."</span>);</div><div class="line">		Future&lt;String&gt; f = <span class="keyword">null</span>;</div><div class="line">		f = cMap.get(key);</div><div class="line">		<span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				Thread.sleep(<span class="number">500</span>);</div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			FutureTask&lt;String&gt; fTask = <span class="keyword">new</span> FutureTask&lt;String&gt;</div><div class="line">              (<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</div><div class="line">				<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"></div><div class="line">					<span class="keyword">try</span> &#123;</div><div class="line">						Thread.sleep(<span class="number">2000</span>);</div><div class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">					System.out.println(Thread.currentThread().getName() </div><div class="line">                                       + <span class="string">" compute , index=============== "</span></div><div class="line">                                       + index++);</div><div class="line">					<span class="keyword">return</span> <span class="string">"456789123"</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;);</div><div class="line">			f = cMap.putIfAbsent(key, fTask); <span class="comment">// 相当于get-if-absent-compute，</span></div><div class="line">             <span class="comment">//而且是原子执行，解决了并发读的问题。（FutureTask解决compute步骤）		</span></div><div class="line">			<span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</div><div class="line">				f = fTask;</div><div class="line">				<span class="comment">// f的值是FutureTask对象引用，解决了call的重复调用问题,</span></div><div class="line">                 <span class="comment">// 只用一个线程会执行run()方法</span></div><div class="line">				fTask.run();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		System.out.println(<span class="string">"end ==========="</span>);</div><div class="line">		<span class="comment">// get会等待FutureTask的计算结果，可以设置等待超时事件,超时会抛出超时异常</span></div><div class="line">		System.out.println(Thread.currentThread().getName() </div><div class="line">                           + <span class="string">" end ....====== "</span> </div><div class="line">                           + f.get(<span class="number">3000</span>, TimeUnit.MILLISECONDS));</div><div class="line">		<span class="comment">// get会等待FutureTask的计算结果，永久等待</span></div><div class="line">		System.out.println(Thread.currentThread().getName() </div><div class="line">                           + <span class="string">" end .... "</span> + f.get());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>concurrentMap2的执行结果</p>
<p>Thread-0 start ….<br>Thread-2 start ….<br>Thread-4 start ….<br>Thread-1 start ….<br>Thread-3 start ….<br>Thread-4 compute , index================== 0<br>Thread-0 compute , index================== 2<br>Thread-0 end …. dataTest0<br>Thread-2 compute , index================== 1<br>Thread-2 end …. dataTest0<br>Thread-4 end …. dataTest0<br>Thread-3 compute , index================== 3<br>Thread-1 compute , index================== 4<br>Thread-1 end …. dataTest3<br>Thread-3 end …. dataTest3</p>
<p> 可以看到put方法被重复执行….</p>
<p>concurrentMap的执行结果</p>
<p>Thread-1 start ….<br>Thread-3 start ….<br>Thread-0 start ….<br>Thread-2 start ….<br>Thread-4 start ….<br>end ===========<br>end ===========<br>end ===========<br>end ===========<br>Thread-1 compute , index=============== 0<br>Thread-3 end ….====== 456789123<br>Thread-3 end …. 456789123<br>end ===========<br>Thread-1 end ….====== 456789123<br>Thread-1 end …. 456789123<br>Thread-0 end ….====== 456789123<br>Thread-0 end …. 456789123<br>Thread-2 end ….====== 456789123<br>Thread-2 end …. 456789123<br>Thread-4 end ….====== 456789123<br>Thread-4 end …. 456789123</p>
<p>可以看到put运算只执行一次….</p>
<p>总结：</p>
<ol>
<li>如果缓存对象可以在系统启动时进行初始化加载，可以不使用ConcurrentHashMap</li>
<li>如果缓存在put时计算比较复杂，那么推荐直接使用concurrentMap写法</li>
<li>ConcurrentHashMap缺陷就是缓存无法回收，导致内存溢出问题。此问题在google发布Guava的Cache很好的进行了处理，可查看另一篇文章<a href="http://itfish.net/article/64821.html#" target="_blank" rel="external">Guava Cache的使用</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> ConcurrentHashMap </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础数据类型 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[10 款最好的 Python IDE]]></title>
      <url>/2017/12/21/10%E6%AC%BE%E6%9C%80%E5%A5%BD%E7%9A%84Python%20IDE/</url>
      <content type="html"><![CDATA[<h1 id="10-款最好的-Python-IDE"><a href="#10-款最好的-Python-IDE" class="headerlink" title="10 款最好的 Python IDE"></a>10 款最好的 Python IDE</h1><p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171221/20G8aHLhha.png" alt="mark"></p>
<h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171221/09AB4IL3l8.png" alt="mark"></p>
<h2 id="Eclipse-PyDev"><a href="#Eclipse-PyDev" class="headerlink" title="Eclipse PyDev"></a>Eclipse PyDev</h2><p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171221/ijG2834aE6.png" alt="mark"></p>
<h2 id="Sublime-Text"><a href="#Sublime-Text" class="headerlink" title="Sublime Text"></a>Sublime Text</h2><p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171221/Dlj5E1HeDL.png" alt="mark"></p>
<h2 id="Emacs"><a href="#Emacs" class="headerlink" title="Emacs"></a>Emacs</h2><p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171221/5KL3IBgA86.png" alt="mark"></p>
<h2 id="Komodo"><a href="#Komodo" class="headerlink" title="Komodo"></a>Komodo</h2><p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171221/gFJi6mffGG.png" alt="mark"></p>
<p>PyCharm</p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171221/68B3ELEi09.png" alt="mark"></p>
<h2 id="Wing"><a href="#Wing" class="headerlink" title="Wing"></a>Wing</h2><p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171221/492EIljf6I.png" alt="mark"></p>
<h2 id="PyScripter"><a href="#PyScripter" class="headerlink" title="PyScripter"></a>PyScripter</h2><p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171221/BA3h86BbjF.png" alt="mark"></p>
<h2 id="The-Eric-Python-IDE"><a href="#The-Eric-Python-IDE" class="headerlink" title="The Eric Python IDE"></a>The Eric Python IDE</h2><p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171221/e0GC5C00DC.png" alt="mark"></p>
<h2 id="Interactive-Editor-for-Python"><a href="#Interactive-Editor-for-Python" class="headerlink" title="Interactive Editor for Python"></a>Interactive Editor for Python</h2><p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171221/iG8BGKk6h7.png" alt="mark"></p>
]]></content>
      
        <categories>
            
            <category> Python IDE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Sublime Text 3 搭建Python开发环境]]></title>
      <url>/2017/12/21/Sublime%20Text%203%20%E6%90%AD%E5%BB%BAPython%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      <content type="html"><![CDATA[<h1 id="Sublime-Text-3-搭建Python开发环境"><a href="#Sublime-Text-3-搭建Python开发环境" class="headerlink" title="Sublime Text 3 搭建Python开发环境"></a>Sublime Text 3 搭建Python开发环境</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  Sublime Text：一款具有代码高亮、语法提示、自动完成且反应快速的编辑器软件，不仅具有华丽的界面，还支持插件扩展机制，用她来写代码，绝对是一种享受。相比于难于上手的 Vim ，浮肿沉重的 Eclipse ， VS ，即便体积轻巧迅速启动的 Editplus 、 Notepad++ ，在 Sublime Text 面前也略显失色，无疑这款性感无比的编辑器是 Coding 和 Writing 最佳的选择，没有之一。</p>
<a id="more"></a>
<p>  Sublime Text 3 的功能实在是太强大了，搭配各种 package ，码代码、美如画。对于 Sublime Text 3 的介绍网上一大堆，博主就不再这里赘述了。本篇博文主要是记录一下博主如何在 Sublime Text 3 下优雅的编写、编译、运行 python 代码。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>  我使用的版本是 Sublime Text Build 3143 ，大家自行下载后直接安装即可，安装完之后需要 License 来激活我们的软件。</p>
<p>​    <strong>Sublime Text Build 3143的下载路径：</strong></p>
<p>​    <a href="https://code.aliyun.com/shenwenfang106/SublimeTextBuild3143.git" target="_blank" rel="external">https://code.aliyun.com/shenwenfang106/SublimeTextBuild3143.git</a></p>
<p>  直接将下面的 License 复制过去就好，亲测可用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">—– BEGIN LICENSE —– </div><div class="line">TwitterInc </div><div class="line">200 User License </div><div class="line">EA7E-890007 </div><div class="line">1D77F72E 390CDD93 4DCBA022 FAF60790 </div><div class="line">61AA12C0 A37081C5 D0316412 4584D136 </div><div class="line">94D7F7D4 95BC8C1C 527DA828 560BB037 </div><div class="line">D1EDDD8C AE7B379F 50C9D69D B35179EF </div><div class="line">2FE898C4 8E4277A8 555CE714 E1FB0E43 </div><div class="line">D5D52613 C3D12E98 BC49967F 7652EED2 </div><div class="line">9D2D2E61 67610860 6D338B72 5CF95C69 </div><div class="line">E36B85CC 84991F19 7575D828 470A92AB </div><div class="line">—— END LICENSE ——12345678910111213</div></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="Package-Control"><a href="#Package-Control" class="headerlink" title="Package Control"></a>Package Control</h3><p>  按 Ctrl+` 调出 console ，粘贴以下代码到底部命令行并回车：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib.request,os,hashlib; h = <span class="string">'6f4c264a24d933ce70df5dedcf1dcaee'</span> + <span class="string">'ebe013ee18cced0ef93d5f746d80ef60'</span>; pf = <span class="string">'Package Control.sublime-package'</span>; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( <span class="string">'http://packagecontrol.io/'</span> + pf.replace(<span class="string">' '</span>, <span class="string">'%20'</span>)).read(); dh = hashlib.sha256(by).hexdigest(); print(<span class="string">'Error validating download (got %s instead of %s), please try manual install'</span> % (dh, h)) <span class="keyword">if</span> dh != h <span class="keyword">else</span> open(os.path.join( ipp, pf), <span class="string">'wb'</span> ).write(by)<span class="number">1</span></div></pre></td></tr></table></figure>
<p>  重启 Sublime Text 3。如果在 Perferences-&gt;package settings 中看到 package control 这一项，则安装成功。按下 Ctrl+Shift+P 调出命令面板输入 install 调出 Install Package 选项并回车，然后在列表中选中要安装的插件。</p>
<p>  下面介绍几个比较实用的 package 。</p>
<h3 id="SideBarEnhancements"><a href="#SideBarEnhancements" class="headerlink" title="SideBarEnhancements"></a>SideBarEnhancements</h3><p>  SideBarEnhancements 扩展了侧边栏中菜单选项的数量，从而提升你的工作效率。诸如 “New file” 和 “Duplicate” 这样的选项对于 ST3 来说实在是太重要了，而且仅凭 “Delete” 这一个功能就让这个插件值得下载。这个功能将你会在你删除文件的时候把它放入回收站。虽然这个功能乍一看没什么用，但是当你没有使用这样的功能而彻底删除了一个文件的时候，除非你用了版本管理软件，否则你将很难恢复这个文件。</p>
<h3 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h3><p>  Anaconda 是一个终极 Python 插件。它为 ST3 增添了多项 IDE 类似的功能，例如：</p>
<ul>
<li>Autocompletion 自动完成，该选项默认开启，同时提供多种配置选项。</li>
<li>Code linting 使用支持 pep8 标准的 PyLint 或者 PyFlakes。</li>
<li>McCabe code complexity checker 让你可以在特定的文件中使用 McCabe complexity checker.</li>
<li>Goto Definitions 能够在你的整个工程中查找并且显示任意一个变量，函数，或者类的定义。</li>
<li>Find Usage 能够快速的查找某个变量，函数或者类在某个特定文件中的什么地方被使用了。</li>
<li>Show Documentation： 能够显示一个函数或者类的说明性字符串(当然，是在定义了字符串的情况下)</li>
</ul>
<p>  但是，刚安装完之后，打开一个 python 文档，所有代码都会被白色细线框中，如图所示；</p>
<p>​    <img src="http://orbs83j4x.bkt.clouddn.com/blog/171221/8FeHd6GlLB.png" alt="mark"></p>
<p>  强迫症的我看着好难受，决心要搞一搞这东西。后来发现在 Sublime &gt; Preferences &gt; Package Settings &gt; Anaconda &gt; Settings – Default 下修改 linting behaviour 选项即可，我这里改成了只有在保存的时候linting工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">    Sets the linting behaviour for anaconda:</div><div class="line"></div><div class="line">    "always" - Linting works always even while you are writing (in the background)</div><div class="line">    "load-save" - Linting works in file load and save only</div><div class="line">    "save-only" - Linting works in file save only</div><div class="line">*/</div><div class="line"><span class="string">"anaconda_linting_behaviour"</span>: <span class="string">"save-only"</span>,</div></pre></td></tr></table></figure>
<h3 id="SublimeREPL"><a href="#SublimeREPL" class="headerlink" title="SublimeREPL"></a>SublimeREPL</h3><p>  这可能是对程序员来说最有用的插件。SublimeREPL 允许你在 Sublime Text 中运行各种语言（NodeJS ，Python，Ruby， Scala 和 Haskell 等等）。</p>
<p>  在 Sublime &gt; Tools &gt; SublimeREPL 下我们可以看到 SublimeREPL 支持运行的所有语言。</p>
<p>  下面的代码是在 AppData\Roaming\Sublime Text 3\Packages\SublimeREPL\config\Python 下的 Default.sublime-commands 文件，从中我们可以看到 SublimeREPL 所支持的 python 的各种运行方式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">    &#123;</div><div class="line">        <span class="string">"caption"</span>: <span class="string">"SublimeREPL: Python"</span>,</div><div class="line">        <span class="string">"command"</span>: <span class="string">"run_existing_window_command"</span>, <span class="string">"args"</span>:</div><div class="line">        &#123;</div><div class="line">            <span class="string">"id"</span>: <span class="string">"repl_python"</span>,</div><div class="line">            <span class="string">"file"</span>: <span class="string">"config/Python/Main.sublime-menu"</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        <span class="string">"caption"</span>: <span class="string">"SublimeREPL: Python - PDB current file"</span>,</div><div class="line">        <span class="string">"command"</span>: <span class="string">"run_existing_window_command"</span>, <span class="string">"args"</span>:</div><div class="line">        &#123;</div><div class="line">            <span class="string">"id"</span>: <span class="string">"repl_python_pdb"</span>,</div><div class="line">            <span class="string">"file"</span>: <span class="string">"config/Python/Main.sublime-menu"</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        <span class="string">"caption"</span>: <span class="string">"SublimeREPL: Python - RUN current file"</span>,</div><div class="line">        <span class="string">"command"</span>: <span class="string">"run_existing_window_command"</span>, <span class="string">"args"</span>:</div><div class="line">        &#123;</div><div class="line">            <span class="string">"id"</span>: <span class="string">"repl_python_run"</span>,</div><div class="line">            <span class="string">"file"</span>: <span class="string">"config/Python/Main.sublime-menu"</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        <span class="string">"command"</span>: <span class="string">"python_virtualenv_repl"</span>,</div><div class="line">        <span class="string">"caption"</span>: <span class="string">"SublimeREPL: Python - virtualenv"</span></div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        <span class="string">"caption"</span>: <span class="string">"SublimeREPL: Python - IPython"</span>,</div><div class="line">        <span class="string">"command"</span>: <span class="string">"run_existing_window_command"</span>, <span class="string">"args"</span>:</div><div class="line">        &#123;</div><div class="line">            <span class="string">"id"</span>: <span class="string">"repl_python_ipython"</span>,</div><div class="line">            <span class="string">"file"</span>: <span class="string">"config/Python/Main.sublime-menu"</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">]</div></pre></td></tr></table></figure>
<p>  接下来配置快捷键，打开 Sublime &gt; Preferences &gt; Key Building ，在右侧栏（ User 部分）添加下面的代码。<strong>下面的代码用 F5 来执行当前 Python 脚本，用 F4 来实现切换至 Python 命令行窗口</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">    &#123;<span class="string">"keys"</span>:[<span class="string">"f5"</span>],</div><div class="line">    <span class="string">"caption"</span>: <span class="string">"SublimeREPL: Python - RUN current file"</span>,</div><div class="line">    <span class="string">"command"</span>: <span class="string">"run_existing_window_command"</span>, <span class="string">"args"</span>:</div><div class="line">    &#123;<span class="string">"id"</span>: <span class="string">"repl_python_run"</span>,</div><div class="line">    <span class="string">"file"</span>: <span class="string">"config/Python/Main.sublime-menu"</span>&#125;&#125;</div><div class="line">    ,</div><div class="line">    &#123;<span class="string">"keys"</span>:[<span class="string">"f4"</span>],</div><div class="line">    <span class="string">"caption"</span>: <span class="string">"SublimeREPL: Python"</span>,</div><div class="line">    <span class="string">"command"</span>: <span class="string">"run_existing_window_command"</span>, <span class="string">"args"</span>:</div><div class="line">    &#123;<span class="string">"id"</span>: <span class="string">"repl_python"</span>,</div><div class="line">    <span class="string">"file"</span>: <span class="string">"config/Python/Main.sublime-menu"</span>&#125;&#125;</div><div class="line">]</div></pre></td></tr></table></figure>
<p>【1】Shift+Ctrl+Alt+p 创建 python 文件</p>
<p> <img src="http://orbs83j4x.bkt.clouddn.com/blog/171221/GdKBia0ead.png" alt="mark"></p>
<p>先保存再执行。</p>
<p>【2】F5 执行代码 （如果你没有设置快捷键就 win+b）</p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171221/ELAf82G4Aa.png" alt="mark"></p>
<p>【3】 看 Python 命令行窗口</p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171221/fFkk8dBJ6B.png" alt="mark"></p>
<p>​    </p>
<p>  当然，如果你电脑里面安装了两个版本的 Python ，而你想指定使用某个版本，则需要修改下面的代码。下面的代码是在 AppData\Roaming\Sublime Text 3\Packages\SublimeREPL\config\Python 下的 Main.sublime-menu 文件，主要修改 “cmd” 后面跟着的 python 命令。比如我电脑里 python2.7 的执行程序命名是 python.exe ，而 python3.6 的执行程序命名为 python3.exe ，我想要使用 python3 ，所以把所有 “cmd” 后面跟着的命令都改为 “python3” 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">     &#123;</div><div class="line">        <span class="string">"id"</span>: <span class="string">"tools"</span>,</div><div class="line">        <span class="string">"children"</span>:</div><div class="line">        [&#123;</div><div class="line">            <span class="string">"caption"</span>: <span class="string">"SublimeREPL"</span>,</div><div class="line">            <span class="string">"mnemonic"</span>: <span class="string">"R"</span>,</div><div class="line">            <span class="string">"id"</span>: <span class="string">"SublimeREPL"</span>,</div><div class="line">            <span class="string">"children"</span>:</div><div class="line">            [</div><div class="line">                &#123;<span class="string">"caption"</span>: <span class="string">"Python"</span>,</div><div class="line">                <span class="string">"id"</span>: <span class="string">"Python"</span>,</div><div class="line"></div><div class="line">                 <span class="string">"children"</span>:[</div><div class="line">                    &#123;<span class="string">"command"</span>: <span class="string">"repl_open"</span>,</div><div class="line">                     <span class="string">"caption"</span>: <span class="string">"Python"</span>,</div><div class="line">                     <span class="string">"id"</span>: <span class="string">"repl_python"</span>,</div><div class="line">                     <span class="string">"mnemonic"</span>: <span class="string">"P"</span>,</div><div class="line">                     <span class="string">"args"</span>: &#123;</div><div class="line">                        <span class="string">"type"</span>: <span class="string">"subprocess"</span>,</div><div class="line">                        <span class="string">"encoding"</span>: <span class="string">"utf8"</span>,</div><div class="line">                        <span class="string">"cmd"</span>: [<span class="string">"python3"</span>, <span class="string">"-i"</span>, <span class="string">"-u"</span>],</div><div class="line">                        <span class="string">"cwd"</span>: <span class="string">"$file_path"</span>,</div><div class="line">                        <span class="string">"syntax"</span>: <span class="string">"Packages/Python/Python.tmLanguage"</span>,</div><div class="line">                        <span class="string">"external_id"</span>: <span class="string">"python"</span>,</div><div class="line">                        <span class="string">"extend_env"</span>: &#123;<span class="string">"PYTHONIOENCODING"</span>: <span class="string">"utf-8"</span>&#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;,</div><div class="line">                    &#123;<span class="string">"command"</span>: <span class="string">"python_virtualenv_repl"</span>,</div><div class="line">                     <span class="string">"id"</span>: <span class="string">"python_virtualenv_repl"</span>,</div><div class="line">                     <span class="string">"caption"</span>: <span class="string">"Python - virtualenv"</span>&#125;,</div><div class="line">                    &#123;<span class="string">"command"</span>: <span class="string">"repl_open"</span>,</div><div class="line">                     <span class="string">"caption"</span>: <span class="string">"Python - PDB current file"</span>,</div><div class="line">                     <span class="string">"id"</span>: <span class="string">"repl_python_pdb"</span>,</div><div class="line">                     <span class="string">"mnemonic"</span>: <span class="string">"D"</span>,</div><div class="line">                     <span class="string">"args"</span>: &#123;</div><div class="line">                        <span class="string">"type"</span>: <span class="string">"subprocess"</span>,</div><div class="line">                        <span class="string">"encoding"</span>: <span class="string">"utf8"</span>,</div><div class="line">                        <span class="string">"cmd"</span>: [<span class="string">"python3"</span>, <span class="string">"-i"</span>, <span class="string">"-u"</span>, <span class="string">"-m"</span>, <span class="string">"pdb"</span>, <span class="string">"$file_basename"</span>],</div><div class="line">                        <span class="string">"cwd"</span>: <span class="string">"$file_path"</span>,</div><div class="line">                        <span class="string">"syntax"</span>: <span class="string">"Packages/Python/Python.tmLanguage"</span>,</div><div class="line">                        <span class="string">"external_id"</span>: <span class="string">"python"</span>,</div><div class="line">                        <span class="string">"extend_env"</span>: &#123;<span class="string">"PYTHONIOENCODING"</span>: <span class="string">"utf-8"</span>&#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;,</div><div class="line">                    &#123;<span class="string">"command"</span>: <span class="string">"repl_open"</span>,</div><div class="line">                     <span class="string">"caption"</span>: <span class="string">"Python - RUN current file"</span>,</div><div class="line">                     <span class="string">"id"</span>: <span class="string">"repl_python_run"</span>,</div><div class="line">                     <span class="string">"mnemonic"</span>: <span class="string">"R"</span>,</div><div class="line">                     <span class="string">"args"</span>: &#123;</div><div class="line">                        <span class="string">"type"</span>: <span class="string">"subprocess"</span>,</div><div class="line">                        <span class="string">"encoding"</span>: <span class="string">"utf8"</span>,</div><div class="line">                        <span class="string">"cmd"</span>: [<span class="string">"python3"</span>, <span class="string">"-u"</span>, <span class="string">"$file_basename"</span>],</div><div class="line">                        <span class="string">"cwd"</span>: <span class="string">"$file_path"</span>,</div><div class="line">                        <span class="string">"syntax"</span>: <span class="string">"Packages/Python/Python.tmLanguage"</span>,</div><div class="line">                        <span class="string">"external_id"</span>: <span class="string">"python"</span>,</div><div class="line">                        <span class="string">"extend_env"</span>: &#123;<span class="string">"PYTHONIOENCODING"</span>: <span class="string">"utf-8"</span>&#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;,</div><div class="line">                    &#123;<span class="string">"command"</span>: <span class="string">"repl_open"</span>,</div><div class="line">                     <span class="string">"caption"</span>: <span class="string">"Python - IPython"</span>,</div><div class="line">                     <span class="string">"id"</span>: <span class="string">"repl_python_ipython"</span>,</div><div class="line">                     <span class="string">"mnemonic"</span>: <span class="string">"I"</span>,</div><div class="line">                     <span class="string">"args"</span>: &#123;</div><div class="line">                        <span class="string">"type"</span>: <span class="string">"subprocess"</span>,</div><div class="line">                        <span class="string">"encoding"</span>: <span class="string">"utf8"</span>,</div><div class="line">                        <span class="string">"autocomplete_server"</span>: true,</div><div class="line">                        <span class="string">"cmd"</span>: &#123;</div><div class="line">                            <span class="string">"osx"</span>: [<span class="string">"python3"</span>, <span class="string">"-u"</span>, <span class="string">"$&#123;packages&#125;/SublimeREPL/config/Python/ipy_repl.py"</span>],</div><div class="line">                            <span class="string">"linux"</span>: [<span class="string">"python3"</span>, <span class="string">"-u"</span>, <span class="string">"$&#123;packages&#125;/SublimeREPL/config/Python/ipy_repl.py"</span>],</div><div class="line">                            <span class="string">"windows"</span>: [<span class="string">"python3"</span>, <span class="string">"-u"</span>, <span class="string">"$&#123;packages&#125;/SublimeREPL/config/Python/ipy_repl.py"</span>]</div><div class="line">                        &#125;,</div><div class="line">                        <span class="string">"cwd"</span>: <span class="string">"$file_path"</span>,</div><div class="line">                        <span class="string">"syntax"</span>: <span class="string">"Packages/Python/Python.tmLanguage"</span>,</div><div class="line">                        <span class="string">"external_id"</span>: <span class="string">"python"</span>,</div><div class="line">                        <span class="string">"extend_env"</span>: &#123;</div><div class="line">                            <span class="string">"PYTHONIOENCODING"</span>: <span class="string">"utf-8"</span>,</div><div class="line">                            <span class="string">"SUBLIMEREPL_EDITOR"</span>: <span class="string">"$editor"</span></div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    &#125;</div><div class="line">                ]&#125;</div><div class="line">            ]</div><div class="line">        &#125;]</div><div class="line">    &#125;</div><div class="line">]</div></pre></td></tr></table></figure>
<p>  别忘了， Sublime Text 3 也有自己的 build 功能，即也支持 python 等语言的代码构建（ ctrl + b ）。同样的，我们如何添加不同的 python 版本到我们的构建系统呢？很简单，Sublime &gt; Tools &gt; Build System &gt; New Build System，分别添加如下代码之后，再分别保存为 python2.sublime-build 和 python3.sublime-build ，这样，当我们再次打开 Sublime &gt; Tools &gt; Build System 之后，就会发现我们新添加的 python2 和 python3 构建系统了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"cmd"</span>: [<span class="string">"D:/Program Files/Python/Python27/python.exe"</span>, <span class="string">"-u"</span>, <span class="string">"$file"</span>],</div><div class="line">    <span class="string">"file_regex"</span>: <span class="string">"^[ ]*File \"(...*?)\", line([0-9]*)"</span>,</div><div class="line">    <span class="string">"selector"</span>: <span class="string">"source.python"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"cmd"</span>: [<span class="string">"D:/Program Files/Python/Python36/python3.exe"</span>, <span class="string">"-u"</span>, <span class="string">"$file"</span>],</div><div class="line">    <span class="string">"file_regex"</span>: <span class="string">"^[ ]*File \"(...*?)\", line([0-9]*)"</span>,</div><div class="line">    <span class="string">"selector"</span>: <span class="string">"source.python"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="SublimeTmpl"><a href="#SublimeTmpl" class="headerlink" title="SublimeTmpl"></a>SublimeTmpl</h3><p>  快速生成文件模板</p>
<p>  ，SublimeTmpl能新建html、css、javascript、php、python、ruby六种类型的文件模板，所有的文件模板都在插件目录的templates文件夹里，可以自定义编辑文件模板。</p>
<p>  SublimeTmpl默认的快捷键:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ctrl+alt+h html</div><div class="line">ctrl+alt+j javascript</div><div class="line">ctrl+alt+c css</div><div class="line">ctrl+alt+p php</div><div class="line">ctrl+alt+r ruby</div><div class="line">ctrl+alt+shift+p python</div></pre></td></tr></table></figure>
<p>  这里我想修改一下python模板，所以就需要进行如下操作：Sublime &gt; Preferences &gt; Package Settings &gt; SublimeTmpl &gt; Settings – User 添加如下代码。然后 ctrl+alt+shift+p 来新建一个模板试试看。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;  </div><div class="line">    <span class="string">"disable_keymap_actions"</span>: false, // <span class="string">"all"</span>; <span class="string">"html,css"</span>  </div><div class="line">    <span class="string">"date_format"</span> : <span class="string">"%Y-%m-%d %H:%M:%S"</span>,  </div><div class="line">    <span class="string">"attr"</span>: &#123;  </div><div class="line">        <span class="string">"author"</span>: <span class="string">"WordZzzz"</span>,  </div><div class="line">        <span class="string">"email"</span>: <span class="string">"wordzzzz@foxmail.com"</span>,  </div><div class="line">        <span class="string">"link"</span>: <span class="string">"http://blog.csdn.net/u011475210"</span>  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  快捷键也是可以更改的，全部在 Sublime &gt; Preferences &gt; Package Settings &gt; SublimeTmpl 的设置中。</p>
<p>  如果想要新建其他类型的文件模板的话，先自定义文件模板方在templates文件夹里，再分别打开Default (Windows).sublime-keymap、Default.sublime-commands、Main.sublime-menu、SublimeTmpl.sublime-settings这四个文件照着里面的格式自定义想要新建的类型，这里就不详细介绍了，请各位自己折腾哈~</p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul>
<li>跳转到任意内容 (“cmd+p”) 用来快速查找和打开文件。你仅仅只需要工程中文件的一部分路径或者文件名你就可以很容易的打开这个文件。这在一个大型的 Django 工程中显得非常方便。</li>
<li>跳转到指定行 (“ctrl+g”) 让你在当前文件中跳转到指定行数。</li>
<li>跳转到标志 (“cmd+r”) 可以列出当前文件中所有的函数或者类，让你更方便查找。你可以通过输入关键字来查找你所需要的函数或者类。</li>
<li>跳转到行首 (cmd+left-arrow-key) 与 跳转到行尾 (cmd+right-arrow-key)</li>
<li>删除当前行(ctrl+shift+k)</li>
<li>多重编辑 是我迄今为止最喜欢的快捷键<br>选定一个单词，点击 “cmd+d”来选择同样的单词，再次点击 “cmd+d”*继续选择下一个单词…<br>或者 “cmd+单击”来指定多个你想要同时修改的地方。</li>
<li>块编辑 (option+left-mouse-click) 用于选择一整块的内容。通常在整理 CSV 文件的时候用于删除空白内容。</li>
</ul>
<h2 id="自定义命令"><a href="#自定义命令" class="headerlink" title="自定义命令"></a>自定义命令</h2><p>  你可以很容易地使用 Python 来编辑你自己的自定义命令和快捷键组合。例如：</p>
<ul>
<li>拷贝当前文件路径到剪贴板 – 链接</li>
<li>关闭除当前活动标签页以外的所有其他标签页 – 链接</li>
</ul>
<p>  通过文件选项打开你的 Package 文件夹(Sublime &gt; Preferences &gt; Browse Packages)，然后打开 User 文件夹，接下来将上述的 Python 文件添加到 “/Sublime Text 3/Packages/User” 文件夹中。</p>
<p>  最后请在 Key Bindings – User file (Sublime Text &gt; Preferences &gt; Package Settings &gt; AdvancedNewFile &gt; Key Bindings – User) 文件中完成快捷键绑定。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  // Copy file name</div><div class="line">  &#123;</div><div class="line">    <span class="string">"keys"</span>: [<span class="string">"cmd+shift+c"</span>],</div><div class="line">     <span class="string">"command"</span>: <span class="string">"copy_path_to_clipboard"</span></div><div class="line">  &#125;,</div><div class="line">  // Close all other tabs</div><div class="line">  &#123;  </div><div class="line">    <span class="string">"keys"</span>: [<span class="string">"cmd+alt+w"</span>],</div><div class="line">    <span class="string">"command"</span>: <span class="string">"close_tabs"</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>参看文章：<a href="http://blog.csdn.net/u011475210/article/details/78168341" target="_blank" rel="external">http://blog.csdn.net/u011475210/article/details/78168341</a></p>
]]></content>
      
        <categories>
            
            <category> 搭建Python开发环境 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据迭代的基本用法]]></title>
      <url>/2017/12/20/python%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3/</url>
      <content type="html"><![CDATA[<h1 id="数据迭代的基本用法："><a href="#数据迭代的基本用法：" class="headerlink" title="数据迭代的基本用法："></a>数据迭代的基本用法：</h1><h2 id="for-循环的使用"><a href="#for-循环的使用" class="headerlink" title="for 循环的使用"></a>for 循环的使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;fav_movies = [<span class="string">"The Holy Crail"</span>,<span class="string">"The Life of Brian"</span>]</div><div class="line">&gt;&gt;&gt;<span class="keyword">for</span> each_flick <span class="keyword">in</span> fav_movies:print(each_flick)</div><div class="line"></div><div class="line">The Holy Crail</div><div class="line">The Life of Brian</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="while-循环的使用"><a href="#while-循环的使用" class="headerlink" title="while 循环的使用"></a>while 循环的使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;count=<span class="number">2</span></div><div class="line">&gt;&gt;&gt;<span class="keyword">while</span> count&gt;<span class="number">0</span>: 【注意加冒号了再回车】</div><div class="line">		print(<span class="string">"aaaa"</span>) 【如果正确会自动缩进】</div><div class="line">		count = count<span class="number">-1</span></div><div class="line">		</div><div class="line">aaaa 【输出结果】</div><div class="line">aaaa</div></pre></td></tr></table></figure>
<h2 id="enumerate，dict，zip-使用"><a href="#enumerate，dict，zip-使用" class="headerlink" title="enumerate，dict，zip  使用"></a>enumerate，dict，zip  使用</h2><p>通过一个练习，看看这三个函数怎么用的哈。小丽，你也跟着敲一下代码，看看运行效果</p>
<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>现有:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">list1=[&apos;neil&apos;,&apos;mike&apos;,&apos;lucy&apos;]</div><div class="line">list2=[&apos;123456&apos;,&apos;xuiasj==&apos;,&apos;passWD123&apos;]</div><div class="line">list3=[&apos;www.abc.com&apos;,&apos;www.mike.org&apos;,&apos;www.lucy.gov&apos;]</div></pre></td></tr></table></figure>
<p>需要形成列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fin_list = [&#123;&apos;name&apos;:&apos;neil&apos;,&apos;passwd&apos;:&apos;123456&apos;,&apos;url&apos;:&apos;www.abc.com&apos;&#125;,&#123;&apos;name&apos;:&apos;mike&apos;,&apos;passwd&apos;:&apos;xuiasj==&apos;,&apos;url&apos;:&apos;www.mike.org&apos;&#125;,&#123;&apos;name&apos;:&apos;lucy&apos;,&apos;passwd&apos;:&apos;passWD123&apos;,&apos;url&apos;:&apos;www.lucy.gov&apos;&#125;]</div></pre></td></tr></table></figure>
<p>python新手的小丽啊，这要如何实现呢？你先自己好好想想怎么实现，动手敲敲代码哈。</p>
<p>在这里我提供两种方法：</p>
<p><strong>方法1: 使用 enumerate 函数来实现</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">【按题目定义<span class="number">3</span>个列表】</div><div class="line">&gt;&gt;&gt;list1 = [<span class="string">'neil'</span>,<span class="string">'mike'</span>,<span class="string">'lucy'</span>]</div><div class="line">&gt;&gt;&gt;list2 = [<span class="string">'123456'</span>,<span class="string">'xuiasj=='</span>,<span class="string">'passWD123'</span>]</div><div class="line">&gt;&gt;&gt;list3 = [<span class="string">'www.abc.com'</span>,<span class="string">'www.mike.org'</span>,<span class="string">'www.lucy.gov'</span>]</div><div class="line">&gt;&gt;&gt;fin_list = []</div><div class="line">&gt;&gt;&gt;<span class="keyword">for</span> i , name <span class="keyword">in</span> enumerate(list1):</div><div class="line">  		d = &#123;&#125;</div><div class="line">    	d[<span class="string">'name'</span>] = name</div><div class="line">        d[<span class="string">'password'</span>] = list2[i]</div><div class="line">        d[<span class="string">'url'</span>] = list3[i]</div><div class="line">        fin_list.append(d)</div><div class="line">        							【小丽你回车,会空格一行】</div><div class="line">&gt;&gt;&gt;fin_list 【再输入要输出的这个列表名】</div><div class="line">【这是输出的结果】</div><div class="line">[&#123;<span class="string">'name'</span>: <span class="string">'neil'</span>, <span class="string">'password'</span>: <span class="string">'123456'</span>, <span class="string">'url'</span>: <span class="string">'www.abc.com'</span>&#125;, &#123;<span class="string">'name'</span>: <span class="string">'mike'</span>, <span class="string">'password'</span>: <span class="string">'xuiasj=='</span>, <span class="string">'url'</span>: <span class="string">'www.mike.org'</span>&#125;, &#123;<span class="string">'name'</span>: <span class="string">'lucy'</span>, <span class="string">'password'</span>: <span class="string">'passWD123'</span>, <span class="string">'url'</span>: <span class="string">'www.lucy.gov'</span>&#125;]</div></pre></td></tr></table></figure>
<p>之前你问我:python 中 in 的使用 和 enumerate 函数，在这里我来回答你，你要认真看哈！</p>
<h3 id="enumerate-函数"><a href="#enumerate-函数" class="headerlink" title="enumerate 函数"></a>enumerate 函数</h3><p>一般情况下我们对一个列表或数组既要遍历索引又要遍历元素时，会这样写： </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;<span class="keyword">for</span> i <span class="keyword">in</span> range (<span class="number">0</span>,len(list)):  【其实，在 ypthon 中 <span class="keyword">for</span>... <span class="keyword">in</span> .. 它就是一个语法】</div><div class="line">&gt;&gt;&gt;<span class="keyword">print</span> i ,list[i]				  【range 是取一个范围的值】</div></pre></td></tr></table></figure>
<p>但是这种方法有些累赘，使用内置enumerrate函数会有更加直接，优美的做法，先看看enumerate的定义：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;def enumerate(collection):    【def 函数我在下面会跟你讲】</div><div class="line">&gt;&gt;&gt;  'Generates an indexed series:  (0,coll[0]), (1,coll[1])'</div><div class="line">&gt;&gt;&gt;  i = 0 </div><div class="line">&gt;&gt;&gt;  it = iter(collection) </div><div class="line">&gt;&gt;&gt;  while 1: </div><div class="line">&gt;&gt;&gt;  yield (i, it.next()) </div><div class="line">&gt;&gt;&gt;  i += 1</div></pre></td></tr></table></figure>
<p> <strong>enumerate会将数组或列表组成一个索引序列</strong>。使我们再获取索引和索引内容的时候更加方便如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;<span class="keyword">for</span> index，text <span class="keyword">in</span> enumerate(list)):</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>  <span class="keyword">print</span> index ,text</div></pre></td></tr></table></figure>
<p>如果你要计算文件的行数，可以这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;count = len(open(thefilepath,‘rU’).readlines())</div></pre></td></tr></table></figure>
<p>前面这种方法简单，但是可能比较慢，当文件比较大时甚至不能工作，下面这种循环读取的方法更合适些。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;Count = <span class="number">-1</span> </div><div class="line">&gt;&gt;&gt;For count,line <span class="keyword">in</span> enumerate(open(thefilepath,‘rU’))：</div><div class="line"><span class="meta">&gt;&gt;&gt; </span> Pass</div><div class="line">&gt;&gt;&gt;Count += <span class="number">1</span></div></pre></td></tr></table></figure>
<p>小丽，计算文件的行数的这两种方法，看不懂没关系，你只要知道就可以了。</p>
<p>看到这里你必须掌握的是：for 的迭代 和 enumerate 行数的使用</p>
<p><strong>在来看看 def 函数</strong></p>
<h3 id="def-函数"><a href="#def-函数" class="headerlink" title="def 函数"></a>def 函数</h3><p>对于某些需要重复调用的程序，可以使用函数进行定义，基本形式为：</p>
<p>def 函数名(参数1, 参数2, ……, 参数N):</p>
<p>执行语句函数名为调用的表示名，参数则是传入的参数。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 例1：简单的函数使用</span></div><div class="line"><span class="comment"># coding=gb2312</span></div><div class="line"> </div><div class="line"><span class="comment"># 定义函数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line">  <span class="keyword">print</span> <span class="string">'hello python!'</span></div><div class="line">   </div><div class="line"><span class="comment"># 调用函数    </span></div><div class="line">hello()</div><div class="line">   </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hello python!</div></pre></td></tr></table></figure>
<p>函数可以带参数和返回值，参数将按从左到右的匹配，参数可设置默认值，当使用函数时没给相应的参数时，会按照默认值进行赋值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 例2：累加计算值</span></div><div class="line"><span class="comment"># coding=gb2312</span></div><div class="line"> </div><div class="line"><span class="comment"># 定义函数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">myadd</span><span class="params">(a=<span class="number">1</span>,b=<span class="number">100</span>)</span>:</span></div><div class="line">  result = <span class="number">0</span></div><div class="line">  i = a</div><div class="line">  <span class="keyword">while</span> i &lt;= b:  <span class="comment"># 默认值为1+2+3+……+100</span></div><div class="line">    result += i  </div><div class="line">    i += <span class="number">1</span></div><div class="line">  <span class="keyword">return</span> result</div><div class="line"> </div><div class="line"><span class="comment"># 打印1+2+……+10    </span></div><div class="line"><span class="keyword">print</span> myadd(<span class="number">1</span>,<span class="number">10</span>)</div><div class="line"><span class="keyword">print</span> myadd()    <span class="comment"># 使用默认参数1，100</span></div><div class="line"><span class="keyword">print</span> myadd(<span class="number">50</span>)   <span class="comment"># a赋值50，b使用默认值</span></div><div class="line">   </div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">55</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5050</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3825</span></div></pre></td></tr></table></figure>
<p>Python 函数的参数传递时，值得注意的是参数传入时若为变量会被当作临时赋值给参数变量，如果是对象则会被引用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 例3：</span></div><div class="line"><span class="comment"># coding=gb2312</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">testpara</span><span class="params">(p1,p2)</span>:</span></div><div class="line">  p1 = <span class="number">10</span></div><div class="line">  p2.append(<span class="string">'hello'</span>)</div><div class="line"> </div><div class="line">l = []   <span class="comment"># 定义一数组对像</span></div><div class="line">a = <span class="number">20</span>   <span class="comment"># 给变量a赋值</span></div><div class="line">testpara(a,l) <span class="comment"># 变量a与对象数组l作为参数传入</span></div><div class="line"><span class="keyword">print</span> a   <span class="comment"># 打印运行参数后的值</span></div><div class="line"><span class="keyword">for</span> v <span class="keyword">in</span> l: <span class="comment"># 打印数组对象的成员</span></div><div class="line">  <span class="keyword">print</span> v</div><div class="line">     </div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">20</span>    <span class="comment"># 调用函数后a变量并未被复值</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hello  <span class="comment"># 而对象l数组则增加成员hello</span></div></pre></td></tr></table></figure>
<p>方法2: 使用 dict 和 zip  函数来实现**</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">【按题目定义<span class="number">3</span>个列表】</div><div class="line">&gt;&gt;&gt;list1 = [<span class="string">'neil'</span>,<span class="string">'mike'</span>,<span class="string">'lucy'</span>]</div><div class="line">&gt;&gt;&gt;list2 = [<span class="string">'123456'</span>,<span class="string">'xuiasj=='</span>,<span class="string">'passWD123'</span>]</div><div class="line">&gt;&gt;&gt;list3 = [<span class="string">'www.abc.com'</span>,<span class="string">'www.mike.org'</span>,<span class="string">'www.lucy.gov'</span>]</div><div class="line">&gt;&gt;&gt;fin_list = []</div><div class="line">&gt;&gt;&gt;style = [<span class="string">'name'</span>,<span class="string">'passwd'</span>,<span class="string">'url'</span>]</div><div class="line">&gt;&gt;&gt;fin_list.append(dict(zip(style,list1)))</div><div class="line">&gt;&gt;&gt;fin_list.append(dict(zip(style,list2)))</div><div class="line">&gt;&gt;&gt;fin_list.append(dict(zip(style,list3)))</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt;print(fin_list)</div><div class="line">【这是输出的结果】</div><div class="line">[&#123;<span class="string">'name'</span>: <span class="string">'neil'</span>, <span class="string">'password'</span>: <span class="string">'123456'</span>, <span class="string">'url'</span>: <span class="string">'www.abc.com'</span>&#125;, &#123;<span class="string">'name'</span>: <span class="string">'mike'</span>, <span class="string">'password'</span>: <span class="string">'xuiasj=='</span>, <span class="string">'url'</span>: <span class="string">'www.mike.org'</span>&#125;, &#123;<span class="string">'name'</span>: <span class="string">'lucy'</span>, <span class="string">'password'</span>: <span class="string">'passWD123'</span>, <span class="string">'url'</span>: <span class="string">'www.lucy.gov'</span>&#125;]</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 数据迭代 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python3 安装]]></title>
      <url>/2017/12/20/Python3%20%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<h1 id="Python3-安装"><a href="#Python3-安装" class="headerlink" title="Python3 安装"></a>Python3 安装</h1><p>Linux下默认安装的是Python2.7，要使用Python3，需要自行安装。Python3最新的版本是Python3.6。</p>
<p>在这里介绍在CentOS，Debian和Windows上安装Python3.6。</p>
<p>小丽，你跳过前面的，只看Windows上安装Python3.6哈。</p>
<a id="more"></a>
<h2 id="CentOS安装Python3-6"><a href="#CentOS安装Python3-6" class="headerlink" title="CentOS安装Python3.6"></a>CentOS安装Python3.6</h2><p>更详细的安装过程查看：<a href="https://www.yuzhi100.com/tutorial/centos/centos-anzhuang-python36" target="_blank" rel="external">CentOS7安装Python3.6</a></p>
<p>IUS软件源中包含了Python3.6，可以使用IUS软件源安装Python3.6，查看<a href="https://www.yuzhi100.com/article/centos7-ruhe-shiyong-ius-xinban-ruanjian" target="_blank" rel="external">如何安装使用IUS软件源</a></p>
<p>1）安装IUS软件源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">复制#安装EPEL依赖</div><div class="line">sudo yum install epel-release</div><div class="line"></div><div class="line">#安装IUS软件源</div><div class="line">sudo yum install https://centos7.iuscommunity.org/ius-release.rpm</div></pre></td></tr></table></figure>
<p>2）安装Python3.6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">复制sudo yum install python36u</div></pre></td></tr></table></figure>
<p>安装Python3完成后的shell命令为python3.6，为了使用方便，创建一个到python3的符号链接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">复制sudo ln -s /bin/python3.6 /bin/python3</div></pre></td></tr></table></figure>
<p>3）安装pip3</p>
<p>安装完成python36u并没有安装pip，安装pip</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">复制sudo yum install python36u-pip</div></pre></td></tr></table></figure>
<p>安装pip完成后的shell命令为pip3.6，为了使用方便，创建一个到pip3的符号链接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">复制sudo ln -s /bin/pip3.6 /bin/pip3</div></pre></td></tr></table></figure>
<h2 id="Debian安装Python3-6"><a href="#Debian安装Python3-6" class="headerlink" title="Debian安装Python3.6"></a>Debian安装Python3.6</h2><p>Debian8的软件源中包含了Python3.4，要安装Python3.6，需要下载源文件安装：</p>
<p>1）安装编译，安装Python源文件的依赖包，GCC编译器，Make编译程序，Zlib压缩库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">复制sudo aptitude -y install gcc make zlib1g-dev</div></pre></td></tr></table></figure>
<p>2）运行如下命令安装Python3.6，以下命令依次为获取Python3.6源文件，解压，配置环境，编译，安装Python3.6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">复制wget https://www.python.org/ftp/python/3.6.0/Python-3.6.0.tar.xz</div><div class="line">tar xJf Python-3.6.0.tar.xz</div><div class="line">cd Python-3.6.0</div><div class="line">sudo ./configure</div><div class="line">sudo make</div><div class="line">sudo make install</div></pre></td></tr></table></figure>
<p>安装完成后，Python安装在了/usr/local文件夹中，可运行文件/usr/local/bin，库文件/usr/local/lib，可以使用如下命令查看安装位置和版本</p>
<p>3）查看安装位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">复制anxin@bogon:~$ which python3</div><div class="line"></div><div class="line">/usr/local/bin/python3</div></pre></td></tr></table></figure>
<p>4）验证Python3.6版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">复制anxin@bogon:~$ python3 -V</div><div class="line"></div><div class="line">Python 3.6.0</div></pre></td></tr></table></figure>
<h2 id="Windows安装Python3-6"><a href="#Windows安装Python3-6" class="headerlink" title="Windows安装Python3.6"></a>Windows安装Python3.6</h2><p>1）进入<a href="https://www.python.org/downloads/" target="_blank" rel="external">Python下载页面</a>下载对应版本的Python安装包，本例下载Python3.6 64位Windows安装包 python-3.6.2-amd64.exe</p>
<p><strong>如果你的电脑系统是32 位的,你就直接点击箭头的按钮下载就好了!</strong> </p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171220/em47IffHIC.png" alt="mark"></p>
<p><strong>如果你的电脑系统是64 位的,就按下面流程下载哈</strong></p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171220/Hhj4AC819m.png" alt="mark"></p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171220/lj0mE2G40B.png" alt="mark"></p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171220/LkaDhF964L.png" alt="mark"></p>
<p>下载下来：</p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171220/5CIc1GB4ii.png" alt="mark"></p>
<p>2）双击Python3.6安装包，开始安装Python3.6。</p>
<p><strong>1. 选择 Install Now 安装方式方式</strong></p>
<p><strong>其实你也可以一步就完成 Python3.6 的安装，如果选择 Install Now 安装方式</strong>，以后下的步骤你可以全部不用做。</p>
<p>查看安装是否成功，打开cmd 输入 python 即可</p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171220/lGDD9DK26a.png" alt="mark"></p>
<p><strong>2. 选择选择自定义安装（Customize installation）方式</strong>，可以选择安装的内容和目录：</p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171220/7AkhCB08fC.png" alt="mark"></p>
<p>注：安装Python3.6时，可以选中 Add Python 3.6 to PATH ，这样Python会自动把Python3.6的路径加入当前用户的PATH路径下，而不是系统的PATH路径下。</p>
<p>3）选择要安装的内容（如果你清除它们是什么），一般可以选择默认，即：所有内容，点击Next</p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171220/4g2BHFGJAC.png" alt="mark"></p>
<p>4）选择一些安装选择，一般选择默认，在这一步可以选择安装目录，<strong>也可以直接输入目录地址</strong>，点击“浏览（Browse）”按钮：</p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171220/IllKcK3K4k.png" alt="mark"></p>
<p>5）选择安装的目录，最好先创建好目录如 python36 ，点击“确定”按钮：</p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171220/K99deLGafF.png" alt="mark"></p>
<p>6）如图所示选择好Python3.6的安装目录，点击“Install”按钮，开始安装Python3.6</p>
<p>7）如不出什么以外，会提示你安装完成</p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171220/2h4lLL7Aah.png" alt="mark"></p>
<p>恭喜你，成功的在Windows安装了Python 3.6！</p>
<h2 id="配置Python3-6环境变量"><a href="#配置Python3-6环境变量" class="headerlink" title="配置Python3.6环境变量"></a>配置Python3.6环境变量</h2><p>你也可以在安装完成Python3.6后，自己手动配置Python3.6的环境变量。</p>
<p>Win7进入控制面板–&gt;系统和安全–&gt;系统–&gt;高级系统设置–&gt;环境变量–&gt;系统变量，选中Path，双击编辑Path环境变量，添加路径<python-home>\和<python-home>\Scripts\：</python-home></python-home></p>
<p><img src="https://www.yuzhi100.com/sites/default/files/inline-images/win7-install-python-362-7.jpg" alt="配置Python3.6环境变量"></p>
<p>在本例中我们添加的Python3.6环境变量的路径为：;C:\python36\Scripts\;C:\python36\，注意：Windows的环境变量已 ; 分隔。</p>
<h3 id="我们敲代码的地方"><a href="#我们敲代码的地方" class="headerlink" title="我们敲代码的地方"></a>我们敲代码的地方</h3><p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171220/Dh8J6JH3hB.png" alt="mark"></p>
<p>打开箭头指向的 IDLE ，就是我们的编辑器。 </p>
]]></content>
      
        <categories>
            
            <category> Python3 安装 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2017/12/14/ConcurrentHashMap%E6%89%A9%E5%AE%B9%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h1 id="ConcurrentHashMap扩容实现机制"><a href="#ConcurrentHashMap扩容实现机制" class="headerlink" title="ConcurrentHashMap扩容实现机制"></a>ConcurrentHashMap扩容实现机制</h1><p>jdk8中，采用多线程扩容。整个扩容过程，通过CAS设置sizeCtl，transferIndex等变量协调多个线程进行<strong>并发扩容</strong>。</p>
<h1 id="扩容相关的属性"><a href="#扩容相关的属性" class="headerlink" title="扩容相关的属性"></a>扩容相关的属性</h1><h2 id="nextTable"><a href="#nextTable" class="headerlink" title="nextTable"></a>nextTable</h2><p>扩容期间，将table数组中的元素 迁移到 nextTable。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * The next table to use; non-null only while resizing.</div><div class="line">   扩容时，将table中的元素迁移至nextTable . 扩容时非空</div><div class="line"> */</div><div class="line">private transient volatile Node&lt;K,V&gt;[] nextTable;</div></pre></td></tr></table></figure>
<h2 id="sizeCtl属性"><a href="#sizeCtl属性" class="headerlink" title="sizeCtl属性"></a>sizeCtl属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private transient volatile int sizeCtl;</div></pre></td></tr></table></figure>
<p><strong>多线程之间，以volatile的方式读取sizeCtl属性，来判断ConcurrentHashMap当前所处的状态。通过cas设置sizeCtl属性，告知其他线程ConcurrentHashMap的状态变更</strong>。</p>
<p>不同状态，sizeCtl所代表的含义也有所不同。</p>
<ul>
<li>未初始化：<ul>
<li>sizeCtl=0：表示没有指定初始容量。</li>
<li>sizeCtl&gt;0：表示初始容量。</li>
</ul>
</li>
</ul>
<ul>
<li>初始化中：<ul>
<li>sizeCtl=-1,标记作用，告知其他线程，正在初始化</li>
</ul>
</li>
<li>正常状态：<ul>
<li>sizeCtl=0.75n ,扩容阈值</li>
</ul>
</li>
<li>扩容中:<ul>
<li>sizeCtl &lt; 0 : 表示有其他线程正在执行扩容</li>
<li>sizeCtl = (resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) + 2 :表示此时只有一个线程在执行扩容</li>
</ul>
</li>
</ul>
<p>ConcurrentHashMap的状态图如下：</p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171214/2ifidi9IcG.png" alt="mark"></p>
<h2 id="transferIndex属性"><a href="#transferIndex属性" class="headerlink" title="transferIndex属性"></a>transferIndex属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private transient volatile int transferIndex;</div><div class="line"></div><div class="line"></div><div class="line"> /**</div><div class="line">  扩容线程每次最少要迁移16个hash桶</div><div class="line"> */</div><div class="line">private static final int MIN_TRANSFER_STRIDE = 16;</div></pre></td></tr></table></figure>
<p><strong>扩容索引，表示已经分配给扩容线程的table数组索引位置。主要用来协调多个线程，并发安全地获取迁移任务（hash桶）。</strong></p>
<p>1 在扩容之前，transferIndex 在数组的最右边 。此时有一个线程发现已经到达扩容阈值，准备开始扩容。</p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171214/8bdb3048Bk.png" alt="mark"></p>
<p>2 扩容线程，在迁移数据之前，首先要将transferIndex右移（以cas的方式修改 <strong>transferIndex=transferIndex-stride(要迁移hash桶的个数)</strong>），获取迁移任务。每个扩容线程都会通过for循环+CAS的方式设置transferIndex，因此可以确保多线程扩容的并发安全。</p>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171214/kjgeEBH1Cj.png" alt="mark"></p>
<p>换个角度，我们可以将待迁移的table数组，看成一个任务队列，transferIndex看成任务队列的头指针。而扩容线程，就是这个队列的消费者。扩容线程通过CAS设置transferIndex索引的过程，就是消费者从任务队列中获取任务的过程。为了性能考虑，我们当然不会每次只获取一个任务（hash桶），因此ConcurrentHashMap规定，每次至少要获取16个迁移任务（迁移16个hash桶，MIN_TRANSFER_STRIDE = 16）</p>
<p>cas设置transferIndex的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;</div><div class="line">      //计算每次迁移的node个数</div><div class="line">      if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</div><div class="line">          stride = MIN_TRANSFER_STRIDE; // 确保每次迁移的node个数不少于16个</div><div class="line">      ...</div><div class="line">      for (int i = 0, bound = 0;;) &#123;</div><div class="line">          ...</div><div class="line">          //cas无锁算法设置 transferIndex = transferIndex - stride</div><div class="line">          if (U.compareAndSwapInt</div><div class="line">                       (this, TRANSFERINDEX, nextIndex,</div><div class="line">                        nextBound = (nextIndex &gt; stride ?</div><div class="line">                                     nextIndex - stride : 0))) &#123;</div><div class="line">                ...</div><div class="line">                ...</div><div class="line">          &#125;</div><div class="line">          ...//省略迁移逻辑</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h2 id="ForwardingNode节点"><a href="#ForwardingNode节点" class="headerlink" title="ForwardingNode节点"></a>ForwardingNode节点</h2><ol>
<li>标记作用，表示其他线程正在扩容，并且此节点已经扩容完毕</li>
<li>关联了nextTable,扩容期间可以通过find方法，访问已经迁移到了nextTable中的数据</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> static final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;</div><div class="line">    final Node&lt;K,V&gt;[] nextTable;</div><div class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</div><div class="line">        //hash值为MOVED（-1）的节点就是ForwardingNode</div><div class="line">        super(MOVED, null, null, null);</div><div class="line">        this.nextTable = tab;</div><div class="line">    &#125;</div><div class="line">    //通过此方法，访问被迁移到nextTable中的数据</div><div class="line">    Node&lt;K,V&gt; find(int h, Object k) &#123;</div><div class="line">       ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="何时扩容"><a href="#何时扩容" class="headerlink" title="何时扩容"></a>何时扩容</h1><h2 id="1-当前容量超过阈值"><a href="#1-当前容量超过阈值" class="headerlink" title="1 当前容量超过阈值"></a>1 当前容量超过阈值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</div><div class="line">      ...</div><div class="line">      addCount(1L, binCount);</div><div class="line">      ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">private final void addCount(long x, int check) &#123;</div><div class="line">      ...</div><div class="line">      if (check &gt;= 0) &#123;</div><div class="line">          Node&lt;K,V&gt;[] tab, nt; int n, sc;</div><div class="line">          //s&gt;=sizeCtl 即容量达到扩容阈值，需要扩容</div><div class="line">          while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;</div><div class="line">                 (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</div><div class="line">             //调用transfer()扩容</div><div class="line">             ...</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h2 id="2-当链表中元素个数超过默认设定（8个），当数组的大小还未超过64的时候，此时进行数组的扩容，如果超过则将链表转化成红黑树"><a href="#2-当链表中元素个数超过默认设定（8个），当数组的大小还未超过64的时候，此时进行数组的扩容，如果超过则将链表转化成红黑树" class="headerlink" title="2 当链表中元素个数超过默认设定（8个），当数组的大小还未超过64的时候，此时进行数组的扩容，如果超过则将链表转化成红黑树"></a>2 当链表中元素个数超过默认设定（8个），当数组的大小还未超过64的时候，此时进行数组的扩容，如果超过则将链表转化成红黑树</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</div><div class="line">       ...</div><div class="line">       if (binCount != 0) &#123;</div><div class="line">                   //链表中元素个数超过默认设定（8个）</div><div class="line">                   if (binCount &gt;= TREEIFY_THRESHOLD)</div><div class="line">                       treeifyBin(tab, i);</div><div class="line">                   if (oldVal != null)</div><div class="line">                       return oldVal;</div><div class="line">                   break;</div><div class="line">       &#125;</div><div class="line">       ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) &#123;</div><div class="line">    Node&lt;K,V&gt; b; int n, sc;</div><div class="line">    if (tab != null) &#123;</div><div class="line">        //数组的大小还未超过64</div><div class="line">        if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</div><div class="line">            //扩容</div><div class="line">            tryPresize(n &lt;&lt; 1);</div><div class="line">        else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) &#123;</div><div class="line">            //转换成红黑树</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-当发现其他线程扩容时，帮其扩容"><a href="#3-当发现其他线程扩容时，帮其扩容" class="headerlink" title="3 当发现其他线程扩容时，帮其扩容"></a>3 当发现其他线程扩容时，帮其扩容</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</div><div class="line">   ...</div><div class="line">    //f.hash == MOVED 表示为：ForwardingNode，说明其他线程正在扩容</div><div class="line">    else if ((fh = f.hash) == MOVED)</div><div class="line">        tab = helpTransfer(tab, f);</div><div class="line">   ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="扩容过程分析"><a href="#扩容过程分析" class="headerlink" title="扩容过程分析"></a>扩容过程分析</h1><ol>
<li>线程执行put操作，发现容量已经达到扩容阈值，需要进行扩容操作，此时transferindex=tab.length=32</li>
</ol>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171214/1j5jEjjfGC.png" alt="mark"></p>
<ol>
<li>扩容线程A 以cas的方式修改transferindex=32-16=16 ,然后按照降序迁移table[32]–table[16]这个区间的hash桶</li>
</ol>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171214/bECFGcgkKg.png" alt="mark"></p>
<ol>
<li>迁移hash桶时，会将桶内的链表或者红黑树，按照一定算法，拆分成2份，将其插入nextTable[i]和nextTable[i+n]（n是table数组的长度）。 迁移完毕的hash桶,会被设置成ForwardingNode节点，以此告知访问此桶的其他线程，此节点已经迁移完毕。</li>
</ol>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171214/8I0gCE52kl.png" alt="mark"></p>
<p>相关代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;</div><div class="line">            ...//省略无关代码</div><div class="line">            synchronized (f) &#123;</div><div class="line">                    //将node链表，分成2个新的node链表</div><div class="line">                    for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</div><div class="line">                        int ph = p.hash; K pk = p.key; V pv = p.val;</div><div class="line">                        if ((ph &amp; n) == 0)</div><div class="line">                            ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);</div><div class="line">                        else</div><div class="line">                            hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);</div><div class="line">                    &#125;</div><div class="line">                    //将新node链表赋给nextTab</div><div class="line">                    setTabAt(nextTab, i, ln);</div><div class="line">                    setTabAt(nextTab, i + n, hn);</div><div class="line">                    setTabAt(tab, i, fwd);</div><div class="line">            &#125;</div><div class="line">            ...//省略无关代码</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>此时线程2访问到了ForwardingNode节点，如果线程2执行的put或remove等写操作，那么就会先帮其扩容。如果线程2执行的是get等读方法，则会调用ForwardingNode的find方法，去nextTable里面查找相关元素。</li>
</ol>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171214/k7aDHb1JCc.png" alt="mark"></p>
<ol>
<li>线程2加入扩容操作</li>
</ol>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171214/29j61FCbIA.png" alt="mark"></p>
<ol>
<li>如果准备加入扩容的线程，发现以下情况，放弃扩容，直接返回。</li>
</ol>
<ul>
<li>发现transferIndex=0,即<strong>所有node均已分配</strong></li>
<li>发现扩容线程已经达到<strong>最大扩容线程数</strong></li>
</ul>
<p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171214/B6ch1929bL.png" alt="mark"></p>
<h1 id="部分源码分析"><a href="#部分源码分析" class="headerlink" title="部分源码分析"></a>部分源码分析</h1><h2 id="tryPresize方法"><a href="#tryPresize方法" class="headerlink" title="tryPresize方法"></a>tryPresize方法</h2><p>协调多个线程如何调用transfer方法进行hash桶的迁移（addCount，helpTransfer 方法中也有类似的逻辑）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryPresize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">    <span class="comment">//计算扩容的目标size</span></div><div class="line">    <span class="keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY :</div><div class="line">        tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</div><div class="line">    <span class="keyword">int</span> sc;</div><div class="line">    <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</div><div class="line">        Node&lt;K,V&gt;[] tab = table; <span class="keyword">int</span> n;</div><div class="line">        <span class="comment">//tab没有初始化</span></div><div class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</div><div class="line">            n = (sc &gt; c) ? sc : c;</div><div class="line">            <span class="comment">//初始化之前，CAS设置sizeCtl=-1 </span></div><div class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (table == tab) &#123;</div><div class="line">                        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</div><div class="line">                        table = nt;</div><div class="line">                        <span class="comment">//sc=0.75n,相当于扩容阈值</span></div><div class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    <span class="comment">// 此时并没有通过CAS赋值，因为其他想要执行初始化的线程，</span></div><div class="line">                    <span class="comment">// 发现sizeCtl=-1，就直接返回，从而确保任何情况，</span></div><div class="line">                    <span class="comment">// 只会有一个线程执行初始化操作。</span></div><div class="line">                    sizeCtl = sc;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//目标扩容size小于扩容阈值，或者容量超过最大限制时，不需要扩容</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="comment">//扩容</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</div><div class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</div><div class="line">            <span class="comment">//sc&lt;0表示，已经有其他线程正在扩容</span></div><div class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</div><div class="line">                Node&lt;K,V&gt;[] nt;</div><div class="line">            <span class="comment">//1 (sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs ：扩容线程数 &gt; MAX_RESIZERS-1</span></div><div class="line">            <span class="comment">//2 sc == rs + 1 和 sc == rs + MAX_RESIZERS ：表示什么？？？       </span></div><div class="line">            <span class="comment">//3 (nt = nextTable) == null ：表示nextTable正在初始化</span></div><div class="line">            <span class="comment">//4 transferIndex &lt;= 0 ：表示所有hash桶均分配出去</span></div><div class="line">                 </div><div class="line">                <span class="comment">//如果不需要帮其扩容，直接返回</span></div><div class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</div><div class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</div><div class="line">                    transferIndex &lt;= <span class="number">0</span>)</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="comment">//CAS设置sizeCtl=sizeCtl+1</span></div><div class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</div><div class="line">                    <span class="comment">//帮其扩容</span></div><div class="line">                    transfer(tab, nt);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 第一个执行扩容操作的线程，将sizeCtl设置为：</span></div><div class="line">            <span class="comment">// (resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</div><div class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</div><div class="line">                transfer(tab, <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="transfer方法"><a href="#transfer方法" class="headerlink" title="transfer方法"></a>transfer方法</h2><p>负责迁移node节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n = tab.length, stride;</div><div class="line">    <span class="comment">//计算需要迁移多少个hash桶（MIN_TRANSFER_STRIDE该值作为下限，以避免扩容线程过多）</span></div><div class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</div><div class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></div><div class="line">   </div><div class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//扩容一倍</span></div><div class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</div><div class="line">            nextTab = nt;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></div><div class="line">            sizeCtl = Integer.MAX_VALUE;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        nextTable = nextTab;</div><div class="line">        transferIndex = n;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> nextn = nextTab.length;</div><div class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</div><div class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; </div><div class="line">  </div><div class="line">    <span class="comment">// 1.逆序迁移已经获取到的hash桶集合，如果迁移完毕，</span></div><div class="line">    <span class="comment">// 则更新transferIndex，获取下一批待迁移的hash桶</span></div><div class="line">    <span class="comment">// 2.如果transferIndex=0，表示所以hash桶均被分配，</span></div><div class="line">  	<span class="comment">// 将i置为-1，准备退出transfer方法</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</div><div class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</div><div class="line">        </div><div class="line">        <span class="comment">//更新待迁移的hash桶索引</span></div><div class="line">        <span class="keyword">while</span> (advance) &#123;</div><div class="line">            <span class="keyword">int</span> nextIndex, nextBound;</div><div class="line">            <span class="comment">//更新迁移索引i。</span></div><div class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</div><div class="line">                advance = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// transferIndex&lt;=0表示已经没有需要迁移的hash桶，</span></div><div class="line">              	<span class="comment">// 将i置为-1，线程准备退出</span></div><div class="line">                i = -<span class="number">1</span>;</div><div class="line">                advance = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 当迁移完bound这个桶后，尝试更新transferIndex，</span></div><div class="line">            <span class="comment">// 获取下一批待迁移的hash桶</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</div><div class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</div><div class="line">                      nextBound = (nextIndex &gt; stride ?</div><div class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</div><div class="line">                bound = nextBound;</div><div class="line">                i = nextIndex - <span class="number">1</span>;</div><div class="line">                advance = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//退出transfer</span></div><div class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</div><div class="line">            <span class="keyword">int</span> sc;</div><div class="line">            <span class="keyword">if</span> (finishing) &#123;</div><div class="line">                <span class="comment">//最后一个迁移的线程，recheck后，做收尾工作，然后退出</span></div><div class="line">                nextTable = <span class="keyword">null</span>;</div><div class="line">                table = nextTab;</div><div class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</div><div class="line">  <span class="comment">// 第一个扩容的线程，执行transfer方法之前，会设置 sizeCtl = </span></div><div class="line">            <span class="comment">// (resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) + 2) 	</span></div><div class="line">            <span class="comment">// 后续帮其扩容的线程，执行transfer方法之前，会设置 sizeCtl = sizeCtl+1</span></div><div class="line">            <span class="comment">// 每一个退出transfer的方法的线程，退出之前，会设置 sizeCtl = sizeCtl-1</span></div><div class="line">            <span class="comment">// 那么最后一个线程退出时：</span></div><div class="line">            <span class="comment">// 必然有sc == (resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) + 2)，</span></div><div class="line">            <span class="comment">// 即 (sc - 2) == resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT</span></div><div class="line">                </div><div class="line">                <span class="comment">//不相等，说明不到最后一个线程，直接退出transfer方法</span></div><div class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                finishing = advance = <span class="keyword">true</span>;</div><div class="line">                <span class="comment">//最后退出的线程要重新check下是否全部迁移完毕</span></div><div class="line">                i = n; <span class="comment">// recheck before commit</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</div><div class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</div><div class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></div><div class="line">        <span class="comment">//迁移node节点</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">synchronized</span> (f) &#123;</div><div class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</div><div class="line">                    Node&lt;K,V&gt; ln, hn;</div><div class="line">                    <span class="comment">//链表迁移</span></div><div class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</div><div class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</div><div class="line">                        Node&lt;K,V&gt; lastRun = f;</div><div class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</div><div class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</div><div class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</div><div class="line">                                runBit = b;</div><div class="line">                                lastRun = p;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</div><div class="line">                            ln = lastRun;</div><div class="line">                            hn = <span class="keyword">null</span>;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">else</span> &#123;</div><div class="line">                            hn = lastRun;</div><div class="line">                            ln = <span class="keyword">null</span>;</div><div class="line">                        &#125;</div><div class="line">                        <span class="comment">//将node链表，分成2个新的node链表</span></div><div class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</div><div class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</div><div class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</div><div class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</div><div class="line">                        &#125;</div><div class="line">                        <span class="comment">//将新node链表赋给nextTab</span></div><div class="line">                        setTabAt(nextTab, i, ln);</div><div class="line">                        setTabAt(nextTab, i + n, hn);</div><div class="line">                        setTabAt(tab, i, fwd);</div><div class="line">                        advance = <span class="keyword">true</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//红黑树迁移</span></div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</div><div class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</div><div class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</div><div class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</div><div class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">                            <span class="keyword">int</span> h = e.hash;</div><div class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</div><div class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</div><div class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</div><div class="line">                                    lo = p;</div><div class="line">                                <span class="keyword">else</span></div><div class="line">                                    loTail.next = p;</div><div class="line">                                loTail = p;</div><div class="line">                                ++lc;</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">else</span> &#123;</div><div class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</div><div class="line">                                    hi = p;</div><div class="line">                                <span class="keyword">else</span></div><div class="line">                                    hiTail.next = p;</div><div class="line">                                hiTail = p;</div><div class="line">                                ++hc;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</div><div class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</div><div class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</div><div class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</div><div class="line">                        setTabAt(nextTab, i, ln);</div><div class="line">                        setTabAt(nextTab, i + n, hn);</div><div class="line">                        setTabAt(tab, i, fwd);</div><div class="line">                        advance = <span class="keyword">true</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>多线程无锁扩容的关键就是通过CAS设置sizeCtl与transferIndex变量，协调多个线程对table数组中的node进行迁移。</p>
<p><strong>勘误：tab.length为32，扩容阈值是32*0.75=24</strong></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[IntelliJ IDEA  版本控制的使用]]></title>
      <url>/2017/12/13/IDEA%20%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</url>
      <content type="html"><![CDATA[<h1 id="版本控制的使用"><a href="#版本控制的使用" class="headerlink" title="版本控制的使用"></a>版本控制的使用</h1><h2 id="IntelliJ-IDEA-下的版本控制介绍"><a href="#IntelliJ-IDEA-下的版本控制介绍" class="headerlink" title="IntelliJ IDEA 下的版本控制介绍"></a>IntelliJ IDEA 下的版本控制介绍</h2><p>这一章节放在这么靠前位置来讲是因为版本控制在我心目中的地位比后面的实战知识点都来得重要。不管是个人开发或是团队开发，版本控制都是可以很好地被使用的，目前我找不到任何开发者不使用版本控制的理由。而且对于 IDE 来讲，集成版本控制的本身就是它最大的亮点之一，很多开发者也是为此而使用它。</p>
<p>在本章节中也会对 IntelliJ IDEA 的相关版本控制进行了介绍，会开始涉及到一些 IntelliJ IDEA 人性化设置，也希望你能从这一讲开始认识到 IntelliJ IDEA 的优雅。</p>
<p><img src="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/images/xvi-a-version-control-system-introduce-1.jpg" alt="IntelliJ IDEA 下的版本控制介绍"></p>
<blockquote>
<ul>
<li>很多人认为 IntelliJ IDEA 自带了 SVN 或是 Git 等版本控制工具，认为只要安装了 IntelliJ IDEA 就可以完全使用版本控制应有的功能。这完全是一种错误的解读，IntelliJ IDEA 是自带对这些版本控制工具的支持插件，但是该装什么版本控制客户端还是要照样装的。</li>
<li>如上图标注 1 所示，IntelliJ IDEA 对版本控制的支持是以插件化的方式来实现的。旗舰版默认支持目前主流的版本控制软件：CVS、Subversion（SVN）、Git、ClearCase、Mercurial、Perforce、TFS。又因为目前太多人使用 Github 进行协同或是项目版本管理，所以 IntelliJ IDEA 同时自带了 Github 插件，方便 Checkout 和管理你的 Github 项目。</li>
</ul>
</blockquote>
<h2 id="SVN-的配置"><a href="#SVN-的配置" class="headerlink" title="SVN 的配置"></a>SVN 的配置</h2><p>要在 IntelliJ IDEA 中使用 SVN，需要先安装 SVN 客户端或是 TortoiseSVN 这类图形化工具，Windows 系统这里推荐安装 TortoiseSVN，即使在不使用 IntelliJ IDEA 也可以方便管理我们的项目。</p>
<p>SVN 主要使用的版本有 1.6、1.7、1.8，最新的是 1.9。推荐大家使用 1.8 的。如果你的项目使用的是 1.6 的版本，在安装 1.8 之后是可以直接对项目文件进行升级的，所以无需担心，也因此更加推荐大家使用 1.8。</p>
<blockquote>
<ul>
<li>Subversion 官网下载：<a href="https://subversion.apache.org/download/#recommended-release" target="_blank" rel="external">https://subversion.apache.org/download/#recommended-release</a></li>
<li>TortoiseSVN 官网下载：<a href="http://tortoisesvn.net/downloads.zh.html" target="_blank" rel="external">http://tortoisesvn.net/downloads.zh.html</a></li>
</ul>
</blockquote>
<p><img src="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/images/xvi-b-version-control-system-svn-introduce-1.jpg" alt="SVN 的使用"></p>
<blockquote>
<ul>
<li>如上图箭头所示，在安装 TortoiseSVN 的时候，默认 <code>command line client tools</code>，是不安装的，这里建议勾选上。</li>
</ul>
</blockquote>
<p><img src="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/images/xvi-b-version-control-system-svn-introduce-2.jpg" alt="SVN 的使用"></p>
<blockquote>
<ul>
<li>如上图标注 1 所示，勾选 <code>Use command line client</code></li>
<li>如上图标注 2 所示，建议 svn 的路径自己根据安装后的路径进行选择，不然有时候 IntelliJ IDEA 无法识别到会报：<code>Cannot run program &quot;svn&quot;</code> 这类错误。</li>
<li>如上图标注 3 所示，当使用一段时间 SVN 以后，发现各种 SVN 相关问题无法解决，可以考虑点击此按钮进行清除一下缓存。</li>
</ul>
</blockquote>
<p>根据目前的使用经验来看，IntelliJ IDEA 下 SVN 的使用经历并不算愉快，至少比 Git 不好用很多，经常遇到很多问题，所以这里也算是先给大家提个醒。如果紧急情况下 IntelliJ IDEA 无法更新、提交的时候，要记得使用 TortoiseSVN 来操作。</p>
<h2 id="Git-的配置"><a href="#Git-的配置" class="headerlink" title="Git 的配置"></a>Git 的配置</h2><p>要在 IntelliJ IDEA 中使用 Git，需要先安装 Git 客户端，这里推荐安装官网版本。</p>
<p>Git 主要的版本有 1.X、2.X，最新的是 2.X，使用版本随意，但是不要太新了，不然可能 IntelliJ IDEA 小旧版本会无法支持可能。</p>
<blockquote>
<ul>
<li>Git 官网下载：<a href="http://git-scm.com/" target="_blank" rel="external">http://git-scm.com/</a></li>
<li>TortoiseGit 官网下载：<a href="http://download.tortoisegit.org/tgit/" target="_blank" rel="external">http://download.tortoisegit.org/tgit/</a></li>
</ul>
</blockquote>
<p><img src="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/images/xvi-c-version-control-system-git-introduce-1.jpg" alt="Git 的使用"></p>
<p>如上图标注 1 所示，确定好该路径下是否有对应的可执行文件。</p>
<h2 id="Github-的配置和使用"><a href="#Github-的配置和使用" class="headerlink" title="Github 的配置和使用"></a>Github 的配置和使用</h2><p><img src="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/images/xvi-d-version-control-system-github-introduce-1.jpg" alt="Github 的使用"></p>
<blockquote>
<ul>
<li>如上图标注 1 所示，填写你的 Github 登录账号和密码，点击 <code>Test</code> 可以进行测试是否可以正确连上。</li>
</ul>
</blockquote>
<p><img src="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/images/xvi-d-version-control-system-github-introduce-2.jpg" alt="Github 的使用"></p>
<blockquote>
<ul>
<li>如上图标注 1 所示，支持直接从你当前登录的 Github 账号上 Checkout 项目。</li>
</ul>
</blockquote>
<p><img src="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/images/xvi-d-version-control-system-github-introduce-3.jpg" alt="Github 的使用"></p>
<blockquote>
<ul>
<li>如上图标注 1 所示，支持把当前本地项目分享到你的 Github 账号上。</li>
</ul>
</blockquote>
<p><img src="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/images/xvi-d-version-control-system-github-introduce-4.jpg" alt="Github 的使用"></p>
<blockquote>
<ul>
<li>如上图标注 1 所示，支持创建 <code>Gist</code>。Github 的 Gist 官网地址：<a href="https://gist.github.com/" target="_blank" rel="external">https://gist.github.com/</a></li>
</ul>
</blockquote>
<h2 id="版本控制主要操作按钮"><a href="#版本控制主要操作按钮" class="headerlink" title="版本控制主要操作按钮"></a>版本控制主要操作按钮</h2><p><img src="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/images/xvi-e-version-control-system-operation-introduce-1.jpg" alt="版本控制主要操作按钮"></p>
<blockquote>
<ul>
<li>如上图标注 1 所示，对目录进行右键弹出的菜单选项。</li>
</ul>
</blockquote>
<p><img src="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/images/xvi-e-version-control-system-operation-introduce-2.jpg" alt="版本控制主要操作按钮"></p>
<blockquote>
<ul>
<li>如上图标注 1 所示，对文件进行右键弹出的菜单选项。</li>
</ul>
</blockquote>
<p><img src="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/images/xvi-e-version-control-system-operation-introduce-3.jpg" alt="版本控制主要操作按钮"></p>
<blockquote>
<ul>
<li>如上图标注红圈所示，为工具栏上版本控制操作按钮，基本上大家也都是使用这里进行操作。</li>
</ul>
<blockquote>
<ul>
<li>第一个按钮：<code>Update Project</code> 更新项目。</li>
<li>第二个按钮：<code>Commit changes</code> 提交项目上所有变化文件。点击这个按钮不会立马提交所有文件，而是先弹出一个被修改文件的一个汇总框，具体操作下面会有图片进行专门介绍。</li>
<li>第三个按钮：<code>Compare with the Same Repository Version</code> 当前文件与服务器上该文件通版本的内容进行比较。如果当前编辑的文件没有修改，则是灰色不可点击。</li>
<li>第四个按钮：<code>Show history</code> 显示当前文件的历史记录。</li>
<li>第五个按钮：<code>Revert</code> 还原当前被修改的文件到未被修改的版本状态下。如果当前编辑的文件没有修改，则是灰色不可点击。</li>
</ul>
</blockquote>
</blockquote>
<p><img src="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/images/xvi-e-version-control-system-operation-introduce-4.jpg" alt="版本控制主要操作按钮"></p>
<blockquote>
<ul>
<li>如上图标注 1 所示，菜单栏上的版本控制操作区。</li>
</ul>
</blockquote>
<h2 id="版本控制相关的常用设置说明"><a href="#版本控制相关的常用设置说明" class="headerlink" title="版本控制相关的常用设置说明"></a>版本控制相关的常用设置说明</h2><p><img src="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/images/xvi-f-version-control-system-settings-introduce-1.jpg" alt="版本控制相关的常用设置说明"></p>
<blockquote>
<ul>
<li>如上图标注 1 所示，当前项目使用的版本控制是 <code>Git</code>。如果你不愿意这个项目继续使用版本控制可以点击旁边的减号按钮，如果你要切换版本控制，可以点击 <code>Git</code>，会出现 IntelliJ IDEA 支持的各种版本控制选择列表，但是我们一般情况下一个项目不会有多个版本控制的。</li>
<li>如上图标注 2 所示，<code>Show directories with changed descendants</code> 表示子目录有文件被修改了，则该文件的所有上层目录都显示版本控制被概念的颜色。默认是不勾选的，我一般建议勾选此功能。</li>
</ul>
</blockquote>
<p><img src="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/images/xvi-f-version-control-system-settings-introduce-2.jpg" alt="版本控制相关的常用设置说明"></p>
<blockquote>
<ul>
<li>如上图标注 1 所示，<code>When files are created</code> 表示当有新文件放进项目中的时候 IntelliJ IDEA 做如何处理，默认是 <code>Show options before adding to version control</code> 表示弹出提示选项，让开发者决定这些新文件是加入到版本控制中还是不加入。如果不想弹出提示，则选择下面两个选项进行默认操作。</li>
<li>如上图标注 2 所示，<code>When files are deleted</code> 表示当有新文件在项目中被删除的时候 IntelliJ IDEA 做如何处理，默认是 <code>Show options before removing from version control</code> 表示弹出提示选项，让开发者决定这些被删除的是否从版本控制中删除。如果不想弹出提示，则选择下面两个选项进行默认操作。</li>
</ul>
</blockquote>
<p><img src="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/images/xvi-f-version-control-system-settings-introduce-3.jpg" alt="版本控制相关的常用设置说明"></p>
<blockquote>
<ul>
<li>如上图标注 1 所示，对于不想加入到版本控制的文件，可以添加要此忽略的列表中。但是如果已经加入到版本控制的文件使用此功能，则表示该文件 或 目录无法再使用版本控制相关的操作，比如提交、更新等。我个人使用过程中发现在 SVN 上此功能不太好用，Git 上是可以用的。</li>
</ul>
</blockquote>
<p><img src="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/images/xvi-f-version-control-system-settings-introduce-4.jpg" alt="版本控制相关的常用设置说明"></p>
<blockquote>
<ul>
<li>上图所示的弹出层就是本文上面说的 <code>Commit Changes</code> 点击后弹出的变动文件汇总弹出层。</li>
<li>如上图标注 1 所示，可以在文件上右键进行操作。</li>
</ul>
<blockquote>
<ul>
<li><code>Show Diff</code> 当前文件与服务器上该文件通版本的内容进行比较。</li>
<li><code>Move to Another Changelist</code> 将选中的文件转移到其他的 <code>Change list</code> 中。<code>Change list</code> 是一个重要的概念，这里需要进行重点说明。很多时候，我们开发一个项目同时并发的任务可能有很多，每个任务涉及到的文件可能都是基于业务来讲的。所以就会存在一个这样的情况：我改了 30 个文件，其中 15 个文件是属于订单问题，剩下 15 个是会员问题，那我希望提交代码的时候是根据业务区分这些文件的，这样我填写 <code>Commit Message</code> 是好描述的，同时在文件多的情况下，我也好区分这些要提交的文件业务模块。所以我一般会把属于订单的 15 个文件转移到其他的 <code>Change list</code>中，先把专注点集中在 15 个会员问题的文件，先提交会员问题的 <code>Change list</code>，然后在提交订单会员的 <code>Change list</code>。我个人还有一种用法是把一些文件暂时不提交的文件转移到一个我指定的 <code>Change list</code>，等后面我觉得有必要提交了，再做提交操作，这样这些文件就不会干扰我当前修改的文件提交。总结下 <code>Change list</code> 的功能就是为了让你更好地管理你的版本控制文件，让你的专注点得到更好的集中，从而提供效率。</li>
<li><code>Jump to Source</code> 打开并跳转到被选中。</li>
<li>如上图标注 2 所示，可以根据工具栏按钮进行操作，操作的对象会鼠标选中的文件，多选可以按 <code>Ctrl</code>后不放，需要注意的是这个更前面的复选框是没有多大关系的。</li>
<li>如上图标注 3 所示，可以在提交前自动对被提交的文件进行一些操作事件（该项目使用的 Git，使用其他版本控制可能有些按钮有差异。）：</li>
<li><code>Reformat code</code> 格式化代码，如果是 Web 开发建议不要勾选，因为格式化 JSP 类文件，格式化效果不好。如果都是 Java 类则可以安心格式化。</li>
<li><code>Rearrange code</code> 重新编排代码，IntelliJ IDEA 支持各种复杂的编排设置选项，这个会在后面说。设置好了编码功能之后，这里就可以尝试勾选这个进行自动编排。</li>
<li><code>Optimize imports</code> 优化导入包，会在自动去掉没有使用的包。这个建议都勾选，这个只对 Java 类有作用，所以不用担心有副作用。</li>
<li><code>Perform code analysis</code> 进行代码分析，这个建议不用在提交的时候处理，而是在开发完之后，要专门养成对代码进行分析的习惯。IntelliJ IDEA 集成了代码分析功能。</li>
<li><code>Check TODO</code> 检查代码中的 <code>TODO</code>。<code>TODO</code> 功能后面也会有章节进行讲解，这里简单介绍：这是一个记录待办事项的功能。</li>
<li><code>Cleanup</code> 清除下版本控制系统，去掉一些版本控制系统的错误信息，建议勾选（主要针对 SVN，Git 不适用）。</li>
<li>如上图标注 4 所示，填写提交的信息。</li>
<li>如上图标注 5 所示，<code>Change list</code> 改变列表，这是一个下拉选项，说明我们可以切换不同的 <code>Change list</code>，提交不同的 <code>Change list</code> 文件。</li>
<li>如上图标注箭头所示，我们可以查看我们提交历史中使用的 <code>Commit Message</code>，有些时候，我们做得是同一个任务，但是需要提交多次，为了更好管理项目，建议是提交的 <code>Message</code> 是保持一致的。</li>
</ul>
</blockquote>
</blockquote>
<p><img src="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/images/xvi-f-version-control-system-settings-introduce-5.jpg" alt="版本控制相关的常用设置说明"></p>
<blockquote>
<ul>
<li>如上图标注箭头所示，如果你使用的 Git，点击此位置可以切换分支和创建分支，以及合并、删除分支等操作。</li>
</ul>
</blockquote>
<h2 id="SVN-的使用"><a href="#SVN-的使用" class="headerlink" title="SVN 的使用"></a>SVN 的使用</h2><p>SVN 的这个窗口有的 IntelliJ IDEA 上叫 <code>Changes</code>，有的叫 <code>Version Control</code>，具体是什么原因引起这样的差异，我暂时还不清楚。但是不管叫法如何里面的结构是一样的，所以对使用者来讲没多大影响，但是你需要知道他们其实是一样的功能即可。</p>
<p><img src="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/images/xvi-g-svn-feature-1.jpg" alt="SVN 的使用"></p>
<p>上图 <code>Local Changes</code> 这个 Tab 表示当前项目的 SVN 中各个文件的总的情况预览。这里的 <code>Default</code> 是 IntelliJ IDEA 的默认 change list 名称，<code>no commit</code> 是我自己创建的一个change list，我个人有一个习惯是把一些暂时不需要提交的先放这个 list 里面。change list 很常用而且重要，本文前面也有强调过了，所以一定好认真对待。<code>unversioned Files</code>表示项目中未加到版本控制系统中的文件，你可以点击 <code>Click to browse</code>，会弹出一个弹出框列表显示这些未被加入的文件。</p>
<p><img src="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/images/xvi-g-svn-feature-2.jpg" alt="SVN 的使用"></p>
<p>上图 <code>Repository</code> 这个 Tab 表示项目的 SVN 信息汇总，内容非常的详细，也是我平时用最多的地方。如果你点击这个 Tab 没看到数据，是因为你需要点击上图红圈这个刷新按钮。初次使用下默认的过滤条件不是我上图这样的，我习惯根据 User 进行过滤筛选，所以上图箭头中的 Filter 我是选择 User。选择之后，如上图标注 1 所示，显示了这个项目中参与提交的各个用户名，选择一个用户之后，上图标注 2 所以会显示出该用户提交了哪些记录。选择标注 2 区域中的某个提交记录后，标注 3 显示对应的具体提交细节，我们可以对这些文件进行右键操作，具体操作内容跟本文上面提到的那些提交时的操作按钮差不多，这里不多讲。</p>
<p>总的来说，SVN 这个功能用来管理和审查开发团队中人员的代码是非常好用的，所以非常非常建议你一定要学会该功能。</p>
<h2 id="Git-常见问题"><a href="#Git-常见问题" class="headerlink" title="Git 常见问题"></a>Git 常见问题</h2><ul>
<li><p>更新的时候报：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Can&apos;t update: no tracked branch</div></pre></td></tr></table></figure>
<ul>
<li>解决办法：打开 git-bash（路径：C:\Program Files\Git\git-bash.exe），切换到这个更新不下来的项目的根目录，然后输入：<code>git branch --set-upstream-to origin/master master</code>，回车之后重新回到 IntelliJ IDEA 进行更新，正常就可以了。</li>
</ul>
</li>
<li><p>输错密码后，弹出验证的登录框没有再出现：</p>
<ul>
<li>解决办法如下图：选择 <code>Do not save, forget passwords after restart</code> 等你确定你的密码没错后再选择保存密码方案。</li>
</ul>
</li>
</ul>
<p><img src="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/images/xvi-g-git-problem-1.jpg" alt="Git 常见问题"></p>
<h2 id="Git-Flow-的介绍"><a href="#Git-Flow-的介绍" class="headerlink" title="Git Flow 的介绍"></a>Git Flow 的介绍</h2><h3 id="Git-Flow-概念"><a href="#Git-Flow-概念" class="headerlink" title="Git Flow 概念"></a>Git Flow 概念</h3><ul>
<li>Git Flow 是一个 git 扩展集，按 Vincent Driessen 的分支模型提供高层次的库操作。这里的重点是 Vincent Driessen 的分支模型思想，下面讲解的内容也是基于 Vincent Driessen 思想。<ul>
<li>Vincent Driessen 的观点：<a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="external">http://nvie.com/posts/a-successful-git-branching-model/</a></li>
<li><code>Git Flow 是一个 git 扩展集</code> 你可以理解 Git Flow 是一个基于 Git 的插件，这个插件简化了 Git 一些复杂的命令，比如 Git Flow 用一条命令，就可以代替 Git 原生 10 条命令。</li>
<li>Git Flow 对原生的 Git 不会有任何影响，你可以照旧用 Git 原生命令，也可以使用 Git Flow 命令。</li>
</ul>
</li>
<li>还有其他的一些分支管理模型思想，具体可以看：<a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2015/12/git-workflow.html</a></li>
</ul>
<h3 id="Git-Flow-核心概念"><a href="#Git-Flow-核心概念" class="headerlink" title="Git Flow 核心概念"></a>Git Flow 核心概念</h3><ul>
<li>必须有的两个核心分支（长期分支）：<ul>
<li>master，Git 代码仓库中默认的一条主分支。这条分支上的代码一般都建议为是正式版本的代码，并且这条分支不能进行代码修改，只能用来合并其他分支。</li>
<li>develop，一般用于存储开发过程的代码分支，并且这条分支也不能进行代码修改，只能用来合并其他辅助分支。</li>
</ul>
</li>
<li>根据情况创建的辅助分支（临时分支）<ul>
<li>feature branches（功能分支）<ul>
<li><strong>基于 develop 分支上创建</strong></li>
<li><strong>开发完成后合并到 develop 分支上</strong></li>
<li>当要开始一个新功能的开发时，我门可以创建一个 Feature branches 。等待这个新功能开发完成并确定应用到新版本中就合并回 develop</li>
<li>对于单人开发的 feature branches，start 之后，开发完成后可以直接 finish。</li>
<li>对于多人开发的 feature branches，start 之后，开发完成后先 publish 给其他开发人员进行合并，最后大家都开发完成后再 finish。这个思路也同样适用下面几个辅助分支场景。</li>
<li>feature branches 开发过程有 bug，直接在 feature branches 上修改、提交。</li>
</ul>
</li>
<li>release branches（预发布分支）<ul>
<li><strong>基于 develop 分支上创建</strong></li>
<li><strong>测试确定新功能没有问题，合并到 develop 分支和 master 分支上</strong></li>
<li>用来做新版本发布前的准备工作，在上面可以做一些小的 bug 修复、准备发布版本号等等和发布有关的小改动，其实已经是一个比较成熟的版本了。另外这样我们既可以在预发布分支上做一些发布前准备，也不会影响 “develop” 分支上下一版本的新功能开发。</li>
</ul>
</li>
<li>hotfix branches（基于 master 基础上的生产环境 bug 的修复分支）<ul>
<li><strong>基于 master 分支上创建</strong></li>
<li><strong>修复测试无误后合并到 master 分支和 develop 分支上</strong></li>
<li>主要用于处理线上版本出现的一些需要立刻修复的 bug 情况</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Git-Flow-安装"><a href="#Git-Flow-安装" class="headerlink" title="Git Flow 安装"></a>Git Flow 安装</h3><ul>
<li>Windows：如果你安装 Git 用的是 <a href="https://git-for-windows.github.io/" target="_blank" rel="external">Git for Windows</a>，那它已经内置了。</li>
<li>Mac：<code>brew install git-flow-avh</code></li>
<li>Linux：<code>wget --no-check-certificate -q https://raw.githubusercontent.com/petervanderdoes/gitflow-avh/develop/contrib/gitflow-installer.sh &amp;&amp; sudo bash gitflow-installer.sh install stable; rm gitflow-installer.sh</code></li>
<li>更多版本：<a href="https://github.com/petervanderdoes/gitflow-avh/wiki/Installation" target="_blank" rel="external">https://github.com/petervanderdoes/gitflow-avh/wiki/Installation</a></li>
<li>在系统环境上支持之后，再安装 IntelliJ IDEA 对 Git Flow 支持的插件：<a href="https://plugins.jetbrains.com/plugin/7315-git-flow-integration" target="_blank" rel="external">https://plugins.jetbrains.com/plugin/7315-git-flow-integration</a></li>
</ul>
<h3 id="Git-Flow-基础命令资料"><a href="#Git-Flow-基础命令资料" class="headerlink" title="Git Flow 基础命令资料"></a>Git Flow 基础命令资料</h3><ul>
<li><a href="https://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html" target="_blank" rel="external">https://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html</a></li>
<li><a href="http://www.jianshu.com/p/9e4291078853" target="_blank" rel="external">http://www.jianshu.com/p/9e4291078853</a></li>
<li><a href="http://stormzhang.com/git/2014/01/29/git-flow/" target="_blank" rel="external">http://stormzhang.com/git/2014/01/29/git-flow/</a></li>
</ul>
<p>Hotfix/Release/Develop/Feature/</p>
<h3 id="Git-Flow-Integration-插件的使用·"><a href="#Git-Flow-Integration-插件的使用·" class="headerlink" title="Git Flow Integration 插件的使用·"></a>Git Flow Integration 插件的使用·</h3><ul>
<li>如果你已经理解了上面的理论，再看下面这些截图你能理解对应的是什么意思。</li>
</ul>
<p><img src="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/images/xvi-h-git-flow-feature-1.png" alt="Git Flow Integration 插件的使用"></p>
]]></content>
      
        <categories>
            
            <category> IntelliJ IDEA </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 开发工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IntelliJ IDEA  调试教程]]></title>
      <url>/2017/12/12/IntelliJ%20IDEA%20%20%E8%B0%83%E8%AF%95%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="IntelliJ-IDEA-调试教程"><a href="#IntelliJ-IDEA-调试教程" class="headerlink" title="IntelliJ IDEA  调试教程"></a>IntelliJ IDEA  调试教程</h2><p>在调试代码的时候，你的项目得debug模式启动，也就是点那个绿色的甲虫启动服务器，然后，就可以在代码里面断点调试啦。<br>下面不要在意，这个快捷键具体是啥，因为，这个keymap是可以自己配置的，有的人keymap是mac版的，有的是Windows版的。<br>我的就是Windows，而且修改keymap为eclipse的keymap，因为我算是eclipse转过来的吧。</p>
<h2 id="看图，每一个按钮（按钮对应图中的数字）都是什么功能"><a href="#看图，每一个按钮（按钮对应图中的数字）都是什么功能" class="headerlink" title="看图，每一个按钮（按钮对应图中的数字）都是什么功能"></a>看图，每一个按钮（按钮对应图中的数字）都是什么功能</h2><p><img src="http://img.blog.csdn.net/20170320131146112" alt="img"></p>
<ol>
<li><img src="http://orbs83j4x.bkt.clouddn.com/blog/171212/cjGl0fd8lf.png" alt="mark">rerun XXX，这个就是直接重新跑某个程序。</li>
<li><img src="http://orbs83j4x.bkt.clouddn.com/blog/171212/h2c1BBH1Ih.png" alt="mark">这个相当于eclipse里面的f8，直接跑完，到下一个断点停下，没有就直接跑完程序。</li>
<li><img src="http://orbs83j4x.bkt.clouddn.com/blog/171212/Kj8F9A7JGD.png" alt="mark">停止项目或者程序。要是自己的main呢，点一下就停下了，要是Java web项目，则点2下，就把服务器给停了。</li>
<li><img src="http://orbs83j4x.bkt.clouddn.com/blog/171212/LjEK3ak1Je.png" alt="mark">查看所有的断点设置情况。具体详情，下面有示意图，再细细解释。</li>
<li><img src="http://orbs83j4x.bkt.clouddn.com/blog/171212/c8G34gE85F.png" alt="mark">直接取消所有断点，让所有断点无效。</li>
<li><img src="http://orbs83j4x.bkt.clouddn.com/blog/171212/AlDIlcf1BI.png" alt="mark">要是你一不小心把这个下面的布局给弄乱了，你点这个，就把下面的布局给还原咯。</li>
<li><img src="http://orbs83j4x.bkt.clouddn.com/blog/171212/AFC366akbD.png" alt="mark">跳转到当前代码所执行的地方，也就是说你在看代码的时候，点到其他地方，一点这个按钮，就到了程序执行到当前哪行的代码的地方。</li>
<li><img src="http://orbs83j4x.bkt.clouddn.com/blog/171212/b3Id5Ee3BD.png" alt="mark">下一步，如果是方法，他是不会跳进去的。就是一行行的往下走。（eclipse里面的快捷键就是f6）</li>
<li><img src="http://orbs83j4x.bkt.clouddn.com/blog/171212/clm4ILmmLH.png" alt="mark"><strong>跳转到详情，如果下一行调试代码是可执行方法，就可以f7进去，查看这个方法的运行详细情况。重点就是点进去执行</strong></li>
<li><img src="http://orbs83j4x.bkt.clouddn.com/blog/171212/1k6D64ICmd.png" alt="mark"><strong>从详情跳出去，和上面的9相反。</strong></li>
<li><img src="http://orbs83j4x.bkt.clouddn.com/blog/171212/A5l67jKdJ8.png" alt="mark">看字面意思就是跳转到下一个断点</li>
<li><img src="http://orbs83j4x.bkt.clouddn.com/blog/171212/BI0Jkh044K.png" alt="mark">这个点开之后，可以计算你想要看的代码段的值，后面详细上图。</li>
<li><img src="http://orbs83j4x.bkt.clouddn.com/blog/171212/ckELijK98K.png" alt="mark">看意思，同eclipse里面的watch，查看某个对象的值，自定义的对象。</li>
<li><img src="http://orbs83j4x.bkt.clouddn.com/blog/171212/Dhc387i7hD.png" alt="mark"><strong>把自定义的查看对象的值，分开到另一个tab页</strong>。</li>
<li><img src="http://orbs83j4x.bkt.clouddn.com/blog/171212/d1f2L4FmK1.png" alt="mark">有时候当我们步入方法体之后，还想回退到方法体外，点这个按钮后，断点重新回到方法体之外。在继续还是可以再次进到方法内</li>
</ol>
<h2 id="查看断点处的某个对象的值，可以-如下几个方法："><a href="#查看断点处的某个对象的值，可以-如下几个方法：" class="headerlink" title="查看断点处的某个对象的值，可以 如下几个方法："></a>查看断点处的某个对象的值，可以 如下几个方法：</h2><p>1，选中对象后，鼠标悬停在对象上 2 秒左右<br>2，在watch里面添加这个对象，<br>3，下面也许会自动列出来你代码里面有的<br>4，使用上面图上标注的12的那个按钮</p>
<p>下面就再详细说下 4，12，13，14<br>4，查看所有的断点的详情，点开如下所示。<br>在图中condition中可以设置断点的条件，当i==4的时候，才停下。查看具体断点内容。</p>
<p><img src="http://img.blog.csdn.net/20170320131232675" alt="img"></p>
<p>关于设置断点条件，还可以，直接在代码断点处，右键设置，完啦之后，done，设置完成。</p>
<p><img src="http://img.blog.csdn.net/20170320131255269" alt="img"><br>12，这个用的也比较多，这个就比较随意。可以根据你的输入，计算你要的结果，不局限代码里面的变量啥的。<br>这个在debug的时候，使用起来是很方便的。</p>
<p><img src="http://img.blog.csdn.net/20170320131343972" alt="img"></p>
<p><img src="http://img.blog.csdn.net/20170320131405019" alt="img"><br>13，14，这2个点完之后，效果如下图，只是把自定义的变量和代码里面自带的变量分在两个tab页面展示。<br>你可以点13号按钮，自行添加，你想查看的变量的值。</p>
<p><img src="http://img.blog.csdn.net/20170320131416144" alt="img"></p>
<p>还有个需求，就是<strong>在调试代码的时候，实时的修改，运行状态的代码变量的值。</strong></p>
<p><img src="http://img.blog.csdn.net/20170929165528587" alt="img"></p>
<p>仔细看下图，就知道，怎么在实时调试代码的时候，怎么设置某些变量的值，可以看到，我上面在输入a之后，下面就有类似你写代码时候的提示，你就可以在这地方修改变量的值啦</p>
<p>关于调试的时候，<strong>设置运行时的参数</strong>，如下：</p>
<p><img src="http://img.blog.csdn.net/20170331150125192" alt="img"></p>
<p><img src="http://img.blog.csdn.net/20170331145517965" alt="img"><img src="http://img.blog.csdn.net/20170331145536084" alt="img"></p>
<p>入口如下，2个地方都可以。</p>
<p><img src="http://img.blog.csdn.net/20170331145906070" alt="img"></p>
<p>一般都是跑简单的main方法，跑main方法的时候，还带参数文件的，还是第一次，顺带做个记录吧。</p>
<hr>
<hr>
<p><strong>更新：</strong>这个编辑器为了方便从eclipse编辑器转过来的同学们，他可以设置keymap的。具体看图。</p>
<p><img src="http://img.blog.csdn.net/20170605154813115" alt="img"></p>
<p>因为我就是刚刚开始的时候，使用的就是eclipse，后来转过来的，所以，在使用的时候，就先设置了一下，这个键盘映射。使用的还是以前在eclipse上使用的快捷键。不需要再次去记一遍新的快捷键映射。这个也是极其方便的。</p>
<p>所以，在这个debug的快捷键上和使用eclipse时候，是一样的f5进去，f6是下一步。</p>
]]></content>
      
        <categories>
            
            <category> IntelliJ IDEA </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 开发工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java线程面试题]]></title>
      <url>/2017/12/10/Java%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%20Top%2050/</url>
      <content type="html"><![CDATA[<h1 id="Java线程面试题"><a href="#Java线程面试题" class="headerlink" title="Java线程面试题"></a>Java线程面试题</h1><p><em>摘要：</em> 不管你是新程序员还是老手，你一定在面试中遇到过有关线程的问题。Java语言一个重要的特点就是内置了对并发的支持，让Java大受企业和程序员的欢迎。大多数待遇丰厚的Java开发职位都要求开发者精通多线程技术并且有丰富的Java程序开发、调试、优化经验，所以线程相关的问题在面试中经常会被提到。</p>
<p>不管你是新程序员还是老手，你一定在面试中遇到过有关线程的问题。Java语言一个重要的特点就是内置了对并发的支持，让Java大受企业和程序员的欢迎。大多数待遇丰厚的Java开发职位都要求开发者精通多线程技术并且有丰富的Java程序开发、调试、优化经验，所以线程相关的问题在面试中经常会被提到。</p>
<p>　　在典型的Java面试中， 面试官会从线程的基本概念问起, 如：为什么你需要使用线程， 如何创建线程，用什么方式创建线程比较好（比如：继承thread类还是调用Runnable接口），然后逐渐问到并发问题像在Java并发编程的过程中遇到了什么挑战，Java内存模型，JDK1.5引入了哪些更高阶的并发工具，并发编程常用的设计模式，经典多线程问题如生产者消费者，哲学家就餐，读写器或者简单的有界缓冲区问题。仅仅知道线程的基本概念是远远不够的， 你必须知道如何处理死锁，竞态条件，内存冲突和线程安全等并发问题。掌握了这些技巧，你就可以轻松应对多线程和并发面试了。</p>
<p>　　许多Java程序员在面试前才会去看面试题，这很正常。因为收集面试题和练习很花时间，所以我从许多面试者那里收集了Java多线程和并发相关的50个热门问题。我只收集了比较新的面试题且没有提供全部答案。想必聪明的你对这些问题早就心中有数了， 如果遇到不懂的问题，你可以用Google找到答案。若你实在找不到答案，可以在文章的评论中向我求助。你也可以在这找到一些答案Java线程问答Top 12。</p>
<h2 id="50道Java线程面试题"><a href="#50道Java线程面试题" class="headerlink" title="50道Java线程面试题"></a>50道Java线程面试题</h2><p>　　下面是Java线程相关的热门面试题，你可以用它来好好准备面试。</p>
<h3 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h3><p>　　线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。Java在语言层面对多线程提供了卓越的支持，它也是一个很好的卖点。欲了解更多详细信息请点击这里。</p>
<h3 id="线程和进程有什么区别？"><a href="#线程和进程有什么区别？" class="headerlink" title="线程和进程有什么区别？"></a>线程和进程有什么区别？</h3><p>　　线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。更多详细信息请点击这里。</p>
<h3 id="如何在Java中实现线程？"><a href="#如何在Java中实现线程？" class="headerlink" title="如何在Java中实现线程？"></a>如何在Java中实现线程？</h3><p>　　在语言层面有两种方式。java.lang.Thread 类的实例就是一个线程但是它需要调用java.lang.Runnable接口来执行，由于线程类本身就是调用的Runnable接口所以你可以继承java.lang.Thread 类或者直接调用Runnable接口来重写run()方法实现线程。更多详细信息请点击这里.</p>
<h3 id="用Runnable还是Thread？"><a href="#用Runnable还是Thread？" class="headerlink" title="用Runnable还是Thread？"></a>用Runnable还是Thread？</h3><p>　　这个问题是上题的后续，大家都知道我们可以通过继承Thread类或者调用Runnable接口来实现线程，问题是，那个方法更好呢？什么情况下使用它？这个问题很容易回答，如果你知道Java不支持类的多重继承，但允许你调用多个接口。所以如果你要继承其他类，当然是调用Runnable接口好了。更多详细信息请点击这里。</p>
<h3 id="Thread-类中的start-和-run-方法有什么区别？"><a href="#Thread-类中的start-和-run-方法有什么区别？" class="headerlink" title="Thread 类中的start() 和 run() 方法有什么区别？"></a>Thread 类中的start() 和 run() 方法有什么区别？</h3><p>　　这个问题经常被问到，但还是能从此区分出面试者对Java线程模型的理解程度。start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。更多讨论请点击这里</p>
<h3 id="Java中Runnable和Callable有什么不同？"><a href="#Java中Runnable和Callable有什么不同？" class="headerlink" title="Java中Runnable和Callable有什么不同？"></a>Java中Runnable和Callable有什么不同？</h3><p>　　Runnable和Callable都代表那些要在不同的线程中执行的任务。Runnable从JDK1.0开始就有了，Callable是在JDK1.5增加的。它们的主要区别是Callable的 call() 方法可以返回值和抛出异常，而Runnable的run()方法没有这些功能。Callable可以返回装载有计算结果的Future对象。我的博客有更详细的说明。</p>
<h3 id="Java中CyclicBarrier-和-CountDownLatch有什么不同？"><a href="#Java中CyclicBarrier-和-CountDownLatch有什么不同？" class="headerlink" title="Java中CyclicBarrier 和 CountDownLatch有什么不同？"></a>Java中CyclicBarrier 和 CountDownLatch有什么不同？</h3><p>　　CyclicBarrier 和 CountDownLatch 都可以用来让一组线程等待其它线程。与 CyclicBarrier 不同的是，CountdownLatch 不能重新使用。点此查看更多信息和示例代码。</p>
<h3 id="Java内存模型是什么？"><a href="#Java内存模型是什么？" class="headerlink" title="Java内存模型是什么？"></a>Java内存模型是什么？</h3><p>　　Java内存模型规定和指引Java程序在不同的内存架构、CPU和操作系统间有确定性地行为。它在多线程的情况下尤其重要。Java内存模型对一个线程所做的变动能被其它线程可见提供了保证，它们之间是先行发生关系。这个关系定义了一些规则让程序员在并发编程时思路更清晰。比如，先行发生关系确保了：</p>
<p>线程内的代码能够按先后顺序执行，这被称为程序次序规则。<br>对于同一个锁，一个解锁操作一定要发生在时间上后发生的另一个锁定操作之前，也叫做管程锁定规则。<br>前一个对volatile的写操作在后一个volatile的读操作之前，也叫volatile变量规则。<br>一个线程内的任何操作必需在这个线程的start()调用之后，也叫作线程启动规则。<br>一个线程的所有操作都会在线程终止之前，线程终止规则。<br>一个对象的终结操作必需在这个对象构造完成之后，也叫对象终结规则。<br>可传递性<br>　　我强烈建议大家阅读《Java并发编程实践》第十六章来加深对Java内存模型的理解。</p>
<h3 id="Java中的volatile-变量是什么？"><a href="#Java中的volatile-变量是什么？" class="headerlink" title="Java中的volatile 变量是什么？"></a>Java中的volatile 变量是什么？</h3><p>　　volatile是一个特殊的修饰符，只有成员变量才能使用它。在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。volatile变量可以保证下一个读取操作会在前一个写操作之后发生，就是上一题的volatile变量规则。点击这里查看更多volatile的相关内容。</p>
<h3 id="什么是线程安全？Vector是一个线程安全类吗？-（详见这里"><a href="#什么是线程安全？Vector是一个线程安全类吗？-（详见这里" class="headerlink" title="什么是线程安全？Vector是一个线程安全类吗？ （详见这里)"></a>什么是线程安全？Vector是一个线程安全类吗？ （详见这里)</h3><p>　　如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。</p>
<h3 id="Java中什么是竞态条件？-举个例子说明。"><a href="#Java中什么是竞态条件？-举个例子说明。" class="headerlink" title="Java中什么是竞态条件？ 举个例子说明。"></a>Java中什么是竞态条件？ 举个例子说明。</h3><p>　　竞态条件会导致程序在并发情况下出现一些bugs。多线程对一些资源的竞争的时候就会产生竞态条件，如果首先要执行的程序竞争失败排到后面执行了，那么整个程序就会出现一些不确定的bugs。这种bugs很难发现而且会重复出现，因为线程间的随机竞争。一个例子就是无序处理，详见答案。</p>
<h3 id="Java中如何停止一个线程？"><a href="#Java中如何停止一个线程？" class="headerlink" title="Java中如何停止一个线程？"></a>Java中如何停止一个线程？</h3><p>　　Java提供了很丰富的API但没有为停止线程提供API。JDK 1.0本来有一些像stop(), suspend() 和 resume()的控制方法但是由于潜在的死锁威胁因此在后续的JDK版本中他们被弃用了，之后Java API的设计者就没有提供一个兼容且线程安全的方法来停止一个线程。当run() 或者 call() 方法执行完的时候线程会自动结束,如果要手动结束一个线程，你可以用volatile 布尔变量来退出run()方法的循环或者是取消任务来中断线程。点击这里查看示例代码。</p>
<h3 id="一个线程运行时发生异常会怎样？"><a href="#一个线程运行时发生异常会怎样？" class="headerlink" title="一个线程运行时发生异常会怎样？"></a>一个线程运行时发生异常会怎样？</h3><p>　　这是我在一次面试中遇到的一个很刁钻的Java面试题, 简单的说，如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理。</p>
<h3 id="如何在两个线程间共享数据？"><a href="#如何在两个线程间共享数据？" class="headerlink" title="如何在两个线程间共享数据？"></a>如何在两个线程间共享数据？</h3><p>　　你可以通过共享对象来实现这个目的，或者是使用像阻塞队列这样并发的数据结构。这篇教程《Java线程间通信》(涉及到在两个线程间共享对象)用wait和notify方法实现了生产者消费者模型。</p>
<h3 id="Java中notify-和-notifyAll有什么区别？"><a href="#Java中notify-和-notifyAll有什么区别？" class="headerlink" title="Java中notify 和 notifyAll有什么区别？"></a>Java中notify 和 notifyAll有什么区别？</h3><p>　　这又是一个刁钻的问题，因为多线程可以等待单监控锁，Java API 的设计人员提供了一些方法当等待条件改变的时候通知它们，但是这些方法没有完全实现。notify()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。我的博客有更详细的资料和示例代码。</p>
<h3 id="为什么wait-notify-和-notifyAll这些方法不在thread类里面？"><a href="#为什么wait-notify-和-notifyAll这些方法不在thread类里面？" class="headerlink" title="为什么wait, notify 和 notifyAll这些方法不在thread类里面？"></a>为什么wait, notify 和 notifyAll这些方法不在thread类里面？</h3><p>　　这是个设计相关的问题，它考察的是面试者对现有系统和一些普遍存在但看起来不合理的事物的看法。回答这些问题的时候，你要说明为什么把这些方法放在Object类里是有意义的，还有不把它放在Thread类里的原因。一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。你也可以查看这篇文章了解更多。</p>
<h3 id="什么是ThreadLocal变量？"><a href="#什么是ThreadLocal变量？" class="headerlink" title="什么是ThreadLocal变量？"></a>什么是ThreadLocal变量？</h3><p>　　ThreadLocal是Java里一种特殊的变量。每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用ThreadLocal让SimpleDateFormat变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。线程局部变量的另一个不错的例子是ThreadLocalRandom类，它在多线程环境中减少了创建代价高昂的Random对象的个数。查看答案了解更多。</p>
<h3 id="什么是FutureTask？"><a href="#什么是FutureTask？" class="headerlink" title="什么是FutureTask？"></a>什么是FutureTask？</h3><p>　　在Java并发程序中FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对调用了Callable和Runnable的对象进行包装，由于FutureTask也是调用了Runnable接口所以它可以提交给Executor来执行。</p>
<h3 id="Java中interrupted-和-isInterruptedd方法的区别？"><a href="#Java中interrupted-和-isInterruptedd方法的区别？" class="headerlink" title="Java中interrupted 和 isInterruptedd方法的区别？"></a>Java中interrupted 和 isInterruptedd方法的区别？</h3><p>　　interrupted() 和 isInterrupted()的主要区别是前者会将中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能被其它线程调用中断来改变。</p>
<h3 id="为什么wait和notify方法要在同步块中调用？"><a href="#为什么wait和notify方法要在同步块中调用？" class="headerlink" title="为什么wait和notify方法要在同步块中调用？"></a>为什么wait和notify方法要在同步块中调用？</h3><p>　　主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。还有一个原因是为了避免wait和notify之间产生竞态条件。</p>
<h3 id="为什么你应该在循环中检查等待条件"><a href="#为什么你应该在循环中检查等待条件" class="headerlink" title="为什么你应该在循环中检查等待条件?"></a>为什么你应该在循环中检查等待条件?</h3><p>　　处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait()方法效果更好的原因，你可以在Eclipse中创建模板调用wait和notify试一试。如果你想了解更多关于这个问题的内容，我推荐你阅读《Effective Java》这本书中的线程和同步章节。</p>
<h3 id="Java中的同步集合与并发集合有什么区别？"><a href="#Java中的同步集合与并发集合有什么区别？" class="headerlink" title="Java中的同步集合与并发集合有什么区别？"></a>Java中的同步集合与并发集合有什么区别？</h3><p>　　同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在Java1.5之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。更多内容详见答案。</p>
<h3 id="Java中堆和栈有什么不同？"><a href="#Java中堆和栈有什么不同？" class="headerlink" title="Java中堆和栈有什么不同？"></a>Java中堆和栈有什么不同？</h3><p>　　为什么把这个问题归类在多线程和并发面试题里？因为栈是一块和线程紧密相关的内存区域。每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的。而堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时volatile 变量就可以发挥作用了，它要求线程从主存中读取变量的值。 更多内容详见答案。</p>
<h3 id="什么是线程池？-为什么要使用它？"><a href="#什么是线程池？-为什么要使用它？" class="headerlink" title="什么是线程池？ 为什么要使用它？"></a>什么是线程池？ 为什么要使用它？</h3><p>　　创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）。更多内容详见这篇文章。</p>
<h3 id="如何写代码来解决生产者消费者问题？"><a href="#如何写代码来解决生产者消费者问题？" class="headerlink" title="如何写代码来解决生产者消费者问题？"></a>如何写代码来解决生产者消费者问题？</h3><p>　　在现实中你解决的许多线程问题都属于生产者消费者模型，就是一个线程生产任务供其它线程进行消费，你必须知道怎么进行线程间通信来解决这个问题。比较低级的办法是用wait和notify来解决这个问题，比较赞的办法是用Semaphore 或者 BlockingQueue来实现生产者消费者模型，这篇教程有实现它。</p>
<h3 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h3><p><a href="http://www.cnblogs.com&amp;iframeId=iframe_0.21145907562000632" target="_blank" rel="external">http://www.cnblogs.com&amp;iframeId=iframe_0.21145907562000632</a>“ frameborder=”0” scrolling=”no” height=”20”&gt;<br>　　Java多线程中的死锁 死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件：</p>
<p>互斥条件：一个资源每次只能被一个进程使用。<br>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。<br>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。<br>避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。这篇教程有代码示例和避免死锁的讨论细节。</p>
<h3 id="Java中活锁和死锁有什么区别？"><a href="#Java中活锁和死锁有什么区别？" class="headerlink" title="Java中活锁和死锁有什么区别？"></a>Java中活锁和死锁有什么区别？</h3><p>　　这是上题的扩展，活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者进程的状态可以改变但是却不能继续执行。</p>
<h3 id="怎么检测一个线程是否拥有锁？"><a href="#怎么检测一个线程是否拥有锁？" class="headerlink" title="怎么检测一个线程是否拥有锁？"></a>怎么检测一个线程是否拥有锁？</h3><p>　　我一直不知道我们竟然可以检测一个线程是否拥有锁，直到我参加了一次电话面试。在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。你可以查看这篇文章了解更多。</p>
<h3 id="你如何在Java中获取线程堆栈？"><a href="#你如何在Java中获取线程堆栈？" class="headerlink" title="你如何在Java中获取线程堆栈？"></a>你如何在Java中获取线程堆栈？</h3><p>　　对于不同的操作系统，有多种方法来获得Java进程的线程堆栈。当你获取线程堆栈时，JVM会把所有线程的状态存到日志文件或者输出到控制台。在Windows你可以使用Ctrl + Break组合键来获取线程堆栈，Linux下用kill -3命令。你也可以用jstack这个工具来获取，它对线程id进行操作，你可以用jps这个工具找到id。</p>
<h3 id="JVM中哪个参数是用来控制线程的栈堆栈小的"><a href="#JVM中哪个参数是用来控制线程的栈堆栈小的" class="headerlink" title="JVM中哪个参数是用来控制线程的栈堆栈小的"></a>JVM中哪个参数是用来控制线程的栈堆栈小的</h3><p>　　这个问题很简单， -Xss参数用来控制线程的堆栈大小。你可以查看JVM配置列表来了解这个参数的更多信息。</p>
<h3 id="Java中synchronized-和-ReentrantLock-有什么不同？"><a href="#Java中synchronized-和-ReentrantLock-有什么不同？" class="headerlink" title="Java中synchronized 和 ReentrantLock 有什么不同？"></a>Java中synchronized 和 ReentrantLock 有什么不同？</h3><p>　　Java在过去很长一段时间只能通过synchronized关键字来实现互斥，它有一些缺点。比如你不能扩展锁之外的方法或者块边界，尝试获取锁时不能中途取消等。Java 5 通过Lock接口提供了更复杂的控制来解决这些问题。 ReentrantLock 类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义且它还具有可扩展性。你可以查看这篇文章了解更多</p>
<h3 id="有三个线程T1，T2，T3，怎么确保它们按顺序执行？"><a href="#有三个线程T1，T2，T3，怎么确保它们按顺序执行？" class="headerlink" title="有三个线程T1，T2，T3，怎么确保它们按顺序执行？"></a>有三个线程T1，T2，T3，怎么确保它们按顺序执行？</h3><p>　　在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成。你可以查看这篇文章了解更多。</p>
<h3 id="Thread类中的yield方法有什么作用？"><a href="#Thread类中的yield方法有什么作用？" class="headerlink" title="Thread类中的yield方法有什么作用？"></a>Thread类中的yield方法有什么作用？</h3><p>　　Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。点击这里查看更多yield方法的相关内容。</p>
<h3 id="Java中ConcurrentHashMap的并发度是什么？"><a href="#Java中ConcurrentHashMap的并发度是什么？" class="headerlink" title="Java中ConcurrentHashMap的并发度是什么？"></a>Java中ConcurrentHashMap的并发度是什么？</h3><p>　　ConcurrentHashMap把实际map划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是ConcurrentHashMap类构造函数的一个可选参数，默认值为16，这样在多线程情况下就能避免争用。欲了解更多并发度和内部大小调整请阅读我的文章How ConcurrentHashMap works in Java。</p>
<h3 id="Java中Semaphore是什么？"><a href="#Java中Semaphore是什么？" class="headerlink" title="Java中Semaphore是什么？"></a>Java中Semaphore是什么？</h3><p>　　Java中的Semaphore是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore只对可用许可的号码进行计数，并采取相应的行动。信号量常常用于多线程的代码中，比如数据库连接池。更多详细信息请点击这里。</p>
<h3 id="如果你提交任务时，线程池队列已满。会时发会生什么？"><a href="#如果你提交任务时，线程池队列已满。会时发会生什么？" class="headerlink" title="如果你提交任务时，线程池队列已满。会时发会生什么？"></a>如果你提交任务时，线程池队列已满。会时发会生什么？</h3><p>　　这个问题问得很狡猾，许多程序员会认为该任务会阻塞直到线程池队列有空位。事实上如果一个任务不能被调度执行那么ThreadPoolExecutor’s submit()方法将会抛出一个RejectedExecutionException异常。</p>
<h3 id="Java线程池中submit-和-execute-方法有什么区别？"><a href="#Java线程池中submit-和-execute-方法有什么区别？" class="headerlink" title="Java线程池中submit() 和 execute()方法有什么区别？"></a>Java线程池中submit() 和 execute()方法有什么区别？</h3><p>　　两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中, 而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。更多详细信息请点击这里。</p>
<h3 id="什么是阻塞式方法？"><a href="#什么是阻塞式方法？" class="headerlink" title="什么是阻塞式方法？"></a>什么是阻塞式方法？</h3><p>　　阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。更多详细信息请点击这里。</p>
<h3 id="Swing是线程安全的吗？-为什么？"><a href="#Swing是线程安全的吗？-为什么？" class="headerlink" title="Swing是线程安全的吗？ 为什么？"></a>Swing是线程安全的吗？ 为什么？</h3><p>　　你可以很肯定的给出回答，Swing不是线程安全的，但是你应该解释这么回答的原因即便面试官没有问你为什么。当我们说swing不是线程安全的常常提到它的组件，这些组件不能在多线程中进行修改，所有对GUI组件的更新都要在AWT线程中完成，而Swing提供了同步和异步两种回调方法来进行更新。点击这里查看更多swing和线程安全的相关内容。</p>
<h3 id="Java中invokeAndWait-和-invokeLater有什么区别？"><a href="#Java中invokeAndWait-和-invokeLater有什么区别？" class="headerlink" title="Java中invokeAndWait 和 invokeLater有什么区别？"></a>Java中invokeAndWait 和 invokeLater有什么区别？</h3><p>　　这两个方法是Swing API 提供给Java开发者用来从当前线程而不是事件派发线程更新GUI组件用的。InvokeAndWait()同步更新GUI组件，比如一个进度条，一旦进度更新了，进度条也要做出相应改变。如果进度被多个线程跟踪，那么就调用invokeAndWait()方法请求事件派发线程对组件进行相应更新。而invokeLater()方法是异步调用更新组件的。更多详细信息请点击这里。</p>
<h3 id="Swing-API中那些方法是线程安全的？"><a href="#Swing-API中那些方法是线程安全的？" class="headerlink" title="Swing API中那些方法是线程安全的？"></a>Swing API中那些方法是线程安全的？</h3><p>　　这个问题又提到了swing和线程安全，虽然组件不是线程安全的但是有一些方法是可以被多线程安全调用的，比如repaint(), revalidate()。 JTextComponent的setText()方法和JTextArea的insert() 和 append() 方法也是线程安全的。</p>
<h3 id="如何在Java中创建Immutable对象？"><a href="#如何在Java中创建Immutable对象？" class="headerlink" title="如何在Java中创建Immutable对象？"></a>如何在Java中创建Immutable对象？</h3><p>　　这个问题看起来和多线程没什么关系， 但不变性有助于简化已经很复杂的并发程序。Immutable对象可以在没有同步的情况下共享，降低了对该对象进行并发访问时的同步化开销。可是Java没有@Immutable这个注解符，要创建不可变类，要实现下面几个步骤：通过构造方法初始化所有成员、对变量不要提供setter方法、将所有的成员声明为私有的，这样就不允许直接访问这些成员、在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝。我的文章how to make an object Immutable in Java有详细的教程，看完你可以充满自信。</p>
<h3 id="Java中的ReadWriteLock是什么？"><a href="#Java中的ReadWriteLock是什么？" class="headerlink" title="Java中的ReadWriteLock是什么？"></a>Java中的ReadWriteLock是什么？</h3><p>　　一般而言，读写锁是用来提升并发程序性能的锁分离技术的成果。Java中的ReadWriteLock是Java 5 中新增的一个接口，一个ReadWriteLock维护一对关联的锁，一个用于只读操作一个用于写。在没有写线程的情况下一个读锁可能会同时被多个读线程持有。写锁是独占的，你可以使用JDK中的ReentrantReadWriteLock来实现这个规则，它最多支持65535个写锁和65535个读锁。</p>
<h3 id="多线程中的忙循环是什么"><a href="#多线程中的忙循环是什么" class="headerlink" title="多线程中的忙循环是什么?"></a>多线程中的忙循环是什么?</h3><p>　　忙循环就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。你可以查看这篇文章获得更多信息。</p>
<h3 id="volatile-变量和-atomic-变量有什么不同？"><a href="#volatile-变量和-atomic-变量有什么不同？" class="headerlink" title="volatile 变量和 atomic 变量有什么不同？"></a>volatile 变量和 atomic 变量有什么不同？</h3><p>　　这是个有趣的问题。首先，volatile 变量和 atomic 变量看起来很像，但功能却不一样。Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么 count++ 操作就不是原子性的。而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</p>
<h3 id="如果同步块内的线程抛出异常会发生什么？"><a href="#如果同步块内的线程抛出异常会发生什么？" class="headerlink" title="如果同步块内的线程抛出异常会发生什么？"></a>如果同步块内的线程抛出异常会发生什么？</h3><p>　　这个问题坑了很多Java程序员，若你能想到锁是否释放这条线索来回答还有点希望答对。无论你的同步块是正常还是异常退出的，里面的线程都会释放锁，所以对比锁接口我更喜欢同步块，因为它不用我花费精力去释放锁，该功能可以在finally block里释放锁实现。</p>
<h3 id="单例模式的双检锁是什么？"><a href="#单例模式的双检锁是什么？" class="headerlink" title="单例模式的双检锁是什么？"></a>单例模式的双检锁是什么？</h3><p>　　这个问题在Java面试中经常被问到，但是面试官对回答此问题的满意度仅为50%。一半的人写不出双检锁还有一半的人说不出它的隐患和Java1.5是如何对它修正的。它其实是一个用来创建线程安全的单例的老方法，当单例实例第一次被创建时它试图用单个锁进行性能优化，但是由于太过于复杂在JDK1.4中它是失败的，我个人也不喜欢它。无论如何，即便你也不喜欢它但是还是要了解一下，因为它经常被问到。你可以查看how double checked locking on Singleton works这篇文章获得更多信息。</p>
<h3 id="如何在Java中创建线程安全的Singleton？"><a href="#如何在Java中创建线程安全的Singleton？" class="headerlink" title="如何在Java中创建线程安全的Singleton？"></a>如何在Java中创建线程安全的Singleton？</h3><p>　　这是上面那个问题的后续，如果你不喜欢双检锁而面试官问了创建Singleton类的替代方法，你可以利用JVM的类加载和静态变量初始化特征来创建Singleton实例，或者是利用枚举类型来创建Singleton，我很喜欢用这种方法。你可以查看这篇文章获得更多信息。</p>
<h3 id="写出3条你遵循的多线程最佳实践"><a href="#写出3条你遵循的多线程最佳实践" class="headerlink" title="写出3条你遵循的多线程最佳实践"></a>写出3条你遵循的多线程最佳实践</h3><p>　　这种问题我最喜欢了，我相信你在写并发代码来提升性能的时候也会遵循某些最佳实践。以下三条最佳实践我觉得大多数Java程序员都应该遵循：</p>
<p>给你的线程起个有意义的名字。 这样可以方便找bug或追踪。OrderProcessor, QuoteProcessor or TradeProcessor 这种名字比 Thread-1. Thread-2 and Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。<br>避免锁定和缩小同步的范围 锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。<br>多用同步类少用wait 和 notify 首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的JDK中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。<br>多用并发集合少用同步集合 这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到map，你应该首先想到用ConcurrentHashMap。我的文章Java并发集合有更详细的说明。</p>
<h3 id="如何强制启动一个线程？"><a href="#如何强制启动一个线程？" class="headerlink" title="如何强制启动一个线程？"></a>如何强制启动一个线程？</h3><p>　　这个问题就像是如何强制进行Java垃圾回收，目前还没有觉得方法，虽然你可以使用System.gc()来进行垃圾回收，但是不保证能成功。在Java里面没有办法强制启动一个线程，它是被线程调度器控制着且Java没有公布相关的API。</p>
<h3 id="Java中的fork-join框架是什么？"><a href="#Java中的fork-join框架是什么？" class="headerlink" title="Java中的fork join框架是什么？"></a>Java中的fork join框架是什么？</h3><p>　　fork join框架是JDK7中出现的一款高效的工具，Java开发人员可以通过它充分利用现代服务器上的多处理器。它是专门为了那些可以递归划分成许多子模块设计的，目的是将所有可用的处理能力用来提升程序的性能。fork join框架一个巨大的优势是它使用了工作窃取算法，可以完成更多任务的工作线程可以从其它线程中窃取任务来执行。你可以查看这篇文章获得更多信息。</p>
<h3 id="Java多线程中调用wait-和-sleep-方法有什么不同？"><a href="#Java多线程中调用wait-和-sleep-方法有什么不同？" class="headerlink" title="Java多线程中调用wait() 和 sleep()方法有什么不同？"></a>Java多线程中调用wait() 和 sleep()方法有什么不同？</h3><p>　　Java程序中wait 和 sleep都会造成某种形式的暂停，它们可以满足不同的需要。wait()方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁，而sleep()方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁。你可以查看这篇文章获得更多信息。</p>
<p>以上就是50道热门Java多线程和并发面试题啦。我没有分享所有题的答案但给未来的阅读者提供了足够的提示和线索来寻找答案。如果你真的找不到某题的答案，联系我吧，我会加上去的。这篇文章不仅可以用来准备面试，还能检查你对多线程、并发、设计模式和竞态条件、死锁和线程安全等线程问题的理解。我打算把这篇文章的问题弄成所有Java多线程问题的大合集，但是没有你的帮助恐怖是不能完成的，你也可以跟我分享其它任何问题，包括那些你被问到却还没有找到答案的问题。这篇文章对初学者或者是经验丰富的Java开发人员都很有用，过两三年甚至五六年你再读它也会受益匪浅。它可以扩展初学者尤其有用因为这个可以扩展他们的知识面，我会不断更新这些题，大家可以在文章后面的评论中提问，分享和回答问题一起把这篇面试题完善。</p>
]]></content>
      
        <categories>
            
            <category> Java线程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试精髓 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[(两到三年)Java 面试精髓]]></title>
      <url>/2017/12/10/(%E4%B8%A4%E5%88%B0%E4%B8%89%E5%B9%B4)Java%20%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%AB%93/</url>
      <content type="html"><![CDATA[<h1 id="两到三年-Java-面试精髓"><a href="#两到三年-Java-面试精髓" class="headerlink" title="(两到三年)Java 面试精髓"></a>(两到三年)Java 面试精髓</h1><h2 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h2><p>工作两到三年。在面试的时候，其实会对我们平时所有用框架的源码和一些功能底层代码实现给出提问。<br><a id="more"></a></p>
<h2 id="Struts2框架的执行流程"><a href="#Struts2框架的执行流程" class="headerlink" title="Struts2框架的执行流程 ?"></a>Struts2框架的执行流程 ?</h2><p>从客户端发送请求过来,先经过前端控制器（核心过滤器）过滤器中,执行一组拦截器（一组拦截器 就会完成部分功能代码）执行目标Action,</p>
<p>在Action中返回一个结果视图,根据Result的配置进行页面的跳转.</p>
<p>Struts2和Struts1没有任何联系.Struts2内核是webwork的内核.</p>
<h2 id="hibernate框架的理解"><a href="#hibernate框架的理解" class="headerlink" title="hibernate框架的理解?"></a>hibernate框架的理解?</h2><p>定义:</p>
<p>Hibernate是一个开放源代码的对象关系映射（ORM）框架，它对JDBC进行了非常轻量级的对象封装，</p>
<p>使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库.可以通过对象保存到关系型数据库中,仅提供sava/get方法即可</p>
<p>Hibernate是一个持久层的ORM框架.</p>
<h2 id="Spring框架的理解"><a href="#Spring框架的理解" class="headerlink" title="Spring框架的理解?"></a>Spring框架的理解?</h2><p>Spring是一个开源框架,核心是控制反转（IOC编程思想）和面向切面（AOP）。简单来说，Spring是一个分层的JavaSE/EEfull-stack(一站式) 轻量级开源框架</p>
<p>Spring的AOP的理解:通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术,利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率.可以在不修改源代码的前提下，对程序进行增强.</p>
<p>例如:在以前配置事务的时候,进行事务的回滚,提交等操作,配置AOP 以后可以将事务的权限交给Spring框架去管理,自动管理</p>
<h2 id="SpringMVC的理解"><a href="#SpringMVC的理解" class="headerlink" title="SpringMVC的理解?"></a>SpringMVC的理解?</h2><p>springMvc:是一个表现层框架,就是从请求中接收传入的参数,</p>
<p>将处理后的结果数据返回给页面展示</p>
<p>基本类型:string,double,float,integer,long.boolean</p>
<h2 id="Mybatis的理解"><a href="#Mybatis的理解" class="headerlink" title="Mybatis的理解?"></a>Mybatis的理解?</h2><p>MyBatis是一个优秀的持久层框架，它对jdbc的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。</p>
<p>Mybatis通过xml或注解的方式将要执行的各种statement（statement、preparedStatement、CallableStatement）配置起来，并通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象并返回。</p>
<p>#{}可以有效防止sql注入</p>
<h2 id="Servlet的理解"><a href="#Servlet的理解" class="headerlink" title="Servlet的理解?"></a>Servlet的理解?</h2><p>* GET和POST区别?</p>
<p>* GET：请求参数会显示到地址栏.GET方式有大小的限制.GET方式没有请求体</p>
<p>* POST：请求参数不会显示到地址栏.在请求体中.POST没有大小限制.POST方式有请求体.</p>
<p>* 只有表单设置为method=”post”才是post请求.其他的都是get请求</p>
<p>生命周期:客户端第一次访问该Servlet的时候才会创建一个Servlet的对象,那么Servlet中的init方法就会执行.任何一次从客户端发送的请求,那么服务器创建一个新的线程执行Servlet中service方法为这次请求服务.</p>
<p>service方法的内部根据请求的方式的不同调用不同doXXX的方法.当Servlet从服务器中移除或者关闭服务器的时候Servlet对象就会被销毁.destroy的方法就会执行.</p>
<h2 id="Struts2与SpringMVC的区别"><a href="#Struts2与SpringMVC的区别" class="headerlink" title="Struts2与SpringMVC的区别?"></a>Struts2与SpringMVC的区别?</h2><p>1)springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过虑器。</p>
<p>2)springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。</p>
<p>3)Struts采用值栈存储请求和响应的数据，通过OGNL存取数据， springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。</p>
<h2 id="Jsp的核心及核心标签"><a href="#Jsp的核心及核心标签" class="headerlink" title="Jsp的核心及核心标签?"></a>Jsp的核心及核心标签?</h2><p>a) Servlet</p>
<p>b) Core XML Database Funcations</p>
<h2 id="Redis什么情况下使用，redis持久化方案"><a href="#Redis什么情况下使用，redis持久化方案" class="headerlink" title="Redis什么情况下使用，redis持久化方案?"></a>Redis什么情况下使用，redis持久化方案?</h2><p>a) 处理大数据量的时候</p>
<p>b) Redis的所有数据都是保存在内存中，</p>
<p>Rdb：快照形式，定期把内存中当前时刻的数据保存到磁盘，redis默认支持的持久化方案</p>
<p>aof形式：append only file。把所有对redis数据库操作的命令，增删改操作命令，保存到文件中，数据库恢复是把所有命令执行一遍即可。</p>
<h2 id="Hibernate和Mybatis的区别和优劣"><a href="#Hibernate和Mybatis的区别和优劣" class="headerlink" title="Hibernate和Mybatis的区别和优劣?"></a>Hibernate和Mybatis的区别和优劣?</h2><p>a) Sql优化方面：hibernate的查询会将表中所有的字段查询出来，这一点会有性能的消耗</p>
<p>Mybatis的sql是手动编写的，所以可以按需求指定查询的字段，sql会更灵活，可控性更好</p>
<p>b) Hibernate是在JDBC上进行了一次封装</p>
<p>Mybatis是基于原生的JDBC，运行速度有优势</p>
<p>c) Mybatis mapper xml支持动态sql；Hibernate不支持</p>
<p>d) Hibernate与具体数据库的关联只需在xml文件中配置即可，所有hql语句与具体的数据库无关，移植性好</p>
<p>Mybatis项目所有的sql语句都是依赖所用的数据库的，所以不同数据库类型的支持不好</p>
<h2 id="StringBuffer、StringBuilder的区别"><a href="#StringBuffer、StringBuilder的区别" class="headerlink" title="StringBuffer、StringBuilder的区别?"></a>StringBuffer、StringBuilder的区别?</h2><p>StringBuffer、StringBuilder是容器，是可变的字符串序列，存放于堆内存。</p>
<p>StringBuffer是JDK1.0版本的，线程是安全的，效率比较低。StringBuilder是JDK1.5出现的，线程不安全，效率高。</p>
<h2 id="说一下SOLR"><a href="#说一下SOLR" class="headerlink" title="说一下SOLR?"></a>说一下SOLR?</h2><p>solr就是一个中文搜索引擎,做完分词之后会做热度排名,核心是中文分词器,全文搜索支持,索引值指向对应的文档,相当于是一个字典,默认为collection的一个域对象,查询快,效率高.</p>
<p>可以在Redis里做分词之后的缓存,每次搜索一次就次数加一,里面还有一个投票容错机制,主机挂掉还有备份机,一般配置都为奇数态配置.</p>
<h2 id="Solr与Lucene的区别"><a href="#Solr与Lucene的区别" class="headerlink" title="Solr与Lucene的区别?"></a>Solr与Lucene的区别?</h2><p>Lucene是一个开放源代码的全文检索引擎工具包，它不是一个完整的全文检索引擎，Lucene提供了完整的查询引擎和索引引擎，目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者以Lucene为基础构建全文检索引擎。</p>
<p>Solr的目标是打造一款企业级的搜索引擎系统，它是一个搜索引擎服务，可以独立运行，通过Solr可以非常快速的构建企业的搜索引擎，通过Solr也可以高效的完成站内搜索功能。</p>
<h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis?"></a>什么是Redis?</h2><p>1) Redis的高性能是由于其将所有数据都存储在了内存中，为了使Redis在重启之后仍能保证数据不丢失，需要将数据从内存中同步到硬盘中，这一过程就是持久化。</p>
<p>Redis支持两种方式的持久化，一种是RDB方式，一种是AOF方式。可以单独使用其中一种或将二者结合使用。</p>
<p>1.1RDB持久化</p>
<p>RDB方式的持久化是通过快照（snapshotting）完成的，当符合一定条件时Redis会自动将内存中的数据进行快照并持久化到硬盘。</p>
<p>每次进行访问进行存储,如果服务器一旦崩溃,会导致数据丢失</p>
<p>RDB是Redis默认采用的持久化方式，在redis.conf配置文件中默认有此下配置：</p>
<p>save 900 1 , save 300 10, save 60 10000</p>
<p>save 开头的一行就是持久化配置，可以配置多个条件（每行配置一个条件），每个条件之间是“或”的关系，“save 900 1”表示15分钟（900秒钟）内</p>
<p>至少</p>
<p>1个键被更改则进行快照，“save 300 10”表示5分钟（300秒）内至少10个键被更改则进行快照。</p>
<p>在redis.conf中：</p>
<p>配置dir指定</p>
<p>rdb快照文件的位置;配置dbfilenam指定rdb快照文件的名称</p>
<p>Redis启动后会读取RDB快照文件，将数据从硬盘载入到内存。根据数据量大小与结构和服务器性能不同，这个时间也不同。</p>
<p>通常将记录一千万个字符串类型键、大小为1GB的快照文件载入到内存中需要花费20～30秒钟。</p>
<p>问题总结：</p>
<p>通过RDB方式实现持久化，一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据。这就需要开发者根据具体的应用场合，通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能够接受的范围。如果数据很重要以至于无法承受任何损失，则可以考虑使用AOF方式进行持久化。</p>
<p>1.2AOF持久化</p>
<p>默认情况下Redis没有开启AOF（append only file）方式的持久化，访问一段存储一段,效率高.</p>
<p>可以通过appendonly参数开启：appendonly yes开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件</p>
<p>AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof，可以通过appendfilename参数修改：appendfilename appendonly.aof</p>
<p>2)主从复制（了解）</p>
<p>2.1什么是主从复制</p>
<p>持久化保证了即使redis服务重启也会丢失数据，因为redis服务重启后会将硬盘上持久化的数据恢复到内存中，但是当redis服务器的硬盘损坏了可能会导致数据丢失，如果通过redis的主从复制机制就可以避免这种单点故障，如下图：</p>
<p>说明：</p>
<p>n主redis中的数据有两个副本（replication）即从redis1和从redis2，即使一台redis服务器宕机其它两台redis服务也可以继续提供服务。</p>
<p>n主redis中的数据和从redis上的数据保持实时同步，当主redis写入数据时通过主从复制机制会复制到两个从redis服务上。</p>
<p>n只有一个主redis，可以有多个从redis。</p>
<p>n主从复制不会阻塞master，在同步数据时，master 可以继续处理client 请求</p>
<p>n一个redis可以即是主又是从，如下图：</p>
<p>2.2主从配置</p>
<p>2.2.1主redis配置</p>
<p>无需特殊配置。</p>
<p>2.2.2从redis配置</p>
<p>修改从redis服务器上的redis.conf文件，添加slaveof主redisip主redis端口</p>
<p>上边的配置说明当前该从redis服务器所对应的主redis是192.168.101.3，端口是6379</p>
<p>2.3主从复制过程</p>
<p>2.3.1完整复制</p>
<p>在redis2.8版本之前主从复制过程如下图：</p>
<p>复制过程说明：</p>
<p>1、slave 服务启动，slave 会建立和master 的连接，发送sync 命令。</p>
<p>2、master启动一个后台进程将数据库快照保存到RDB文件中</p>
<p>注意：此时如果生成RDB文件过程中存在写数据操作会导致RDB文件和当前主redis数据不一致，所以此时master 主进程会开始收集写命令并缓存起来。</p>
<p>3、master 就发送RDB文件给slave</p>
<p>4、slave 将文件保存到磁盘上，然后加载到内存恢复</p>
<p>5、master把缓存的命令转发给slave</p>
<p>注意：后续master 收到的写命令都会通过开始建立的连接发送给slave。</p>
<p>当master 和slave 的连接断开时slave 可以自动重新建立连接。如果master 同时收到多个slave 发来的同步连接命令，只会启动一个进程来写数据库镜像，然后发送给所有slave。</p>
<p>完整复制的问题：</p>
<p>在redis2.8之前从redis每次同步都会从主redis中复制全部的数据，如果从redis是新创建的从主redis中复制全部的数据这是没有问题的，但是，如果当从redis停止运行，再启动时可能只有少部分数据和主redis不同步，此时启动redis仍然会从主redis复制全部数据，这样的性能肯定没有只复制那一小部分不同步的数据高。</p>
<p>2.3.2部分复制</p>
<p>部分复制说明：</p>
<p>从机连接主机后，会主动发起 PSYNC 命令，从机会提供 master的runid(机器标识，随机生成的一个串) 和 offset（数据偏移量，如果offset主从不一致则说明数据不同步），主机验证 runid 和 offset 是否有效， runid 相当于主机身份验证码，用来验证从机上一次连接的主机，如果runid验证未通过则，则进行全同步，如果验证通过则说明曾经同步过，根据offset同步部分数据。</p>
<p>2)redis是一个nosql(not only sql不仅仅只有sql)数据库.翻译成中文叫做非关系型型数据库.</p>
<p>关系型数据库:以二维表形式存储数据</p>
<p>非关系型数据库: 以键值对形式存储数据(key, value形式)</p>
<p>Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库。它通过提供多种键值数据类型来适应不同场景下的存储需求，</p>
<p>目前为止Redis支持的键值数据类型如下：</p>
<p>字符串类型</p>
<p>散列类型</p>
<p>列表类型</p>
<p>集合类型</p>
<p>有序集合类型。</p>
<p>3)redis的应用场景</p>
<p>缓存（数据查询、短连接、新闻内容、商品内容等等）。（最多使用）</p>
<p>分布式集群架构中的session分离。</p>
<p>聊天室的在线好友列表。</p>
<p>任务队列。（秒杀、抢购、12306等等）</p>
<p>应用排行榜。</p>
<p>网站访问统计。</p>
<p>数据过期处理（可以精确到毫秒）</p>
<p>redis是将数据存放到内存中,由于内容存取速度快所以redis被广泛应用在互联网项目中,</p>
<p>redis有点:存取速度快,官方称读取速度会达到30万次每秒,写速度在10万次每秒最有,具体限制于硬件.</p>
<p>缺点:对持久化支持不够良好,</p>
<p>所以redis一般不作为数据的主数据库存储,一般配合传统的关系型数据库使用.</p>
<p>4) redis应用领域</p>
<p>分布式缓存</p>
<p>分布式session</p>
<p>保存博客或者论坛的留言回复等.</p>
<p>总之是用在数据量大,并发量高的情况下</p>
<h2 id="谈下DUBBO"><a href="#谈下DUBBO" class="headerlink" title="谈下DUBBO?"></a>谈下DUBBO?</h2><p>Dubbo就是资源调度和治理中心的管理工具。</p>
<p>调用关系说明：</p>
<p>\0. 服务容器负责启动，加载，运行服务提供者。</p>
<p>\1. 服务提供者在启动时，向注册中心注册自己提供的服务。</p>
<p>\2. 服务消费者在启动时，向注册中心订阅自己所需的服务。</p>
<p>\3. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</p>
<p>\4. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>
<p>\5. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p>
<h2 id="解决跨域问题"><a href="#解决跨域问题" class="headerlink" title="解决跨域问题?"></a>解决跨域问题?</h2><p>JSONP–&gt;Script Tags</p>
<h2 id="秒杀方案："><a href="#秒杀方案：" class="headerlink" title="秒杀方案："></a>秒杀方案：</h2><p>1、把商品的数量放到redis中。</p>
<p>2、秒杀时使用decr命令对商品数量减一。如果不是负数说明抢到。</p>
<p>3、一旦返回数值变为0说明商品已售完。</p>
<h2 id="ZOOKeeper"><a href="#ZOOKeeper" class="headerlink" title="ZOOKeeper?"></a>ZOOKeeper?</h2><p>Zookeeper 作为一个分布式的服务框架，主要用来解决分布式集群中应用系统的一致性问题，它能提供基于类似于文件系统的目录节点树方式的数据存储，但是 Zookeeper 并不是用来专门存储数据的，它的作用主要是用来维护和监控你存储的数据的状态变化。</p>
<p>通过监控这些数据状态的变化，从而可以达到基于数据的集群管理</p>
<p>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力小。使用dubbo-2.3.3以上版本，建议使用zookeeper注册中心。</p>
<p>Zookeeper是Apacahe Hadoop的子项目，是一个树型的目录服务，支持变更推送，适合作为Dubbo服务的注册中心，工业强度较高，可用于生产环境，并推荐使用</p>
<h2 id="ActiveMQ的消息形式"><a href="#ActiveMQ的消息形式" class="headerlink" title="ActiveMQ的消息形式"></a>ActiveMQ的消息形式</h2><p>一种是点对点的，即一个生产者和一个消费者一一对应；可进行缓存,只允许单人登录查看</p>
<p>另一种是发布/订阅模式，即一个生产者产生消息并进行发送后，可以由多个消费者进行接收。无法进行缓存,支持多人访问.</p>
<p>JMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。</p>
<p>StreamMessage – Java原始值的数据流</p>
<p>MapMessage–一套名称-值对</p>
<p>TextMessage–一个字符串对象</p>
<p>ObjectMessage–一个序列化的 Java对象</p>
<p>BytesMessage–一个字节的数据流</p>
<p>1.订单系统</p>
<p>1.1.功能分析</p>
<p>1、在购物车页面点击“去结算”按钮跳转到订单确认页面。</p>
<p>a)展示商品列表</p>
<p>b)配送地址列表</p>
<p>c)选择支付方式</p>
<p>2、展示订单确认页面之前，应该确认用户身份。</p>
<p>a)使用拦截器实现。</p>
<p>b)Cookie中取token</p>
<p>c)取不到token跳转到登录页面</p>
<p>d)取到token，根据token查询用户信息。</p>
<p>e)如果没有用户信息，登录过期跳转到登录页面</p>
<p>f)取到用户信息，放行。</p>
<p>3、提交订单</p>
<p>a)生成订单</p>
<p>b)展示订单提交成功页面。</p>
<p>订单系统系统：订单确认页面、订单提交成功页面。</p>
<p>订单服务系统</p>
<p>1.1.展示订单确认页面</p>
<p>1.1.1.功能分析</p>
<p>1、在购物车页面点击“去结算”按钮跳转到订单确认页面。</p>
<p>2、请求的url：</p>
<p>/order/order-cart</p>
<p>3、参数：没有参数。</p>
<p>4、购物车商品数据从cookie中取出来的。可以在订单系统中取到cookie中的购物车数据。</p>
<p>5、配送地址列表，需要用户登录。需要根据用户id查询收货地址列表。静态数据。</p>
<p>6、支付方式。静态数据。</p>
<p>7、返回值：逻辑视图String，展示订单确认页面。</p>
<p>1.1.2.Dao层、Service层（没有）</p>
<p>需要根据用户id查询收货地址列表。没有此功能。</p>
<p>1.1.3.表现层</p>
<p>请求的url：/order/order-cart</p>
<p>参数：无</p>
<p>业务逻辑：</p>
<p>从cookie中取商品列表展示到页面。</p>
<p>返回值：逻辑视图。</p>
<p>1.1.用户身份认证</p>
<p>在展示订单确认页面之前，需要对用户身份进行认证，要求用户必须登录。</p>
<p>1.1.1.功能分析</p>
<p>1、使用springmvc的拦截器实现。需要实现一个接口HandlerInterceptor接口。</p>
<p>2、业务逻辑</p>
<p>a)从cookie中取token。</p>
<p>b)没有token，需要跳转到登录页面。</p>
<p>c)有token。调用sso系统的服务，根据token查询用户信息。</p>
<p>d)如果查不到用户信息。用户登录已经过期。需要跳转到登录页面。</p>
<p>e)查询到用户信息。放行。</p>
<p>3、在springmvc.xml中配置拦截器。</p>
<p>1.1.2.拦截器实现</p>
<p>1.1.1.功能分析</p>
<p>1、在订单确认页面点击“提交订单”按钮生成订单。</p>
<p>2、请求的url：/order/create</p>
<p>3、参数：提交的是表单的数据。保存的数据：订单、订单明细、配送地址。</p>
<p>a)向tb_order中插入记录。</p>
<p>i.订单号需要手动生成。</p>
<p>要求订单号不能重复。</p>
<p>订单号可读性号。</p>
<p>可以使用redis的incr命令生成订单号。订单号需要一个初始值。</p>
<p>ii.Payment：表单数据</p>
<p>iii.payment_type：表单数据</p>
<p>iv.user_id：用户信息</p>
<p>v.buyer_nick：用户名</p>
<p>vi.其他字段null</p>
<p>b)向tb_order_item订单明细表插入数据。</p>
<p>i.Id：使用incr生成</p>
<p>ii.order_id：生成的订单号</p>
<p>iii.其他的都是表单中的数据。</p>
<p>c)tb_order_shipping，订单配送信息</p>
<p>i.order_id：生成的订单号</p>
<p>ii.其他字段都是表单中的数据。</p>
<p>d)使用pojo接收表单的数据。</p>
<p>可以扩展TbOrder，在子类中添加两个属性一个是商品明细列表，一个是配送信息。</p>
<p>把pojo放到taotao-order-interface工程中。</p>
<p>业务逻辑：</p>
<p>1、接收表单的数据</p>
<p>2、生成订单id</p>
<p>3、向订单表插入数据。</p>
<p>4、向订单明细表插入数据</p>
<p>5、向订单物流表插入数据。</p>
<p>6、返回TaotaoResult。</p>
<p>返回值：TaotaoResult</p>
<p>1.1.1.Dao层</p>
<p>可以使用逆向工程。</p>
<p>1.1.2.Service层</p>
<p>参数：OrderInfo</p>
<h2 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h2><p>单点登录就是我们是做了分布式，tomcat集群之后会有session复制的问题，影响利群数量。所以把注册登录拿出来单独做了一个单点登录系统。做的时候是用的redis，key是用uuid生成的一个token,类似于session id,是用户的唯一标识，value是用户的信息。设置了有效期是7天。然后把redis放到了cookie中，实现了cookie的二级跨域。当我们进行操作时，首先要从cookie里面取出token如果取不到，就跳到单点登录系统进行登录操作如果取到了，再看看token有没有过期，如果过期了，也是跳到单点登录系统登录一下，没过期就继续用户的操作。密码进行了加密，用Md5</p>
<h2 id="HashMap-和-HashTable-的区别"><a href="#HashMap-和-HashTable-的区别" class="headerlink" title="HashMap 和 HashTable 的区别"></a>HashMap 和 HashTable 的区别</h2><p>1）容器整体结构：</p>
<ul>
<li><code>HashMap</code>的<code>key</code>和<code>value</code>都允许为<code>null</code>，<code>HashMap</code>遇到<code>key</code>为<code>null</code>的时候，调用<code>putForNullKey</code>方法进行处理，而对<code>value</code>没有处理。</li>
<li><code>Hashtable</code>的<code>key</code>和<code>value</code>都不允许为<code>null</code>。<code>Hashtable</code>遇到<code>null</code>，直接返回<code>NullPointerException</code>。</li>
</ul>
<p>2） 容量设定与扩容机制：</p>
<ul>
<li><code>HashMap</code>默认初始化容量为 16，并且容器容量一定是2的n次方，扩容时，是以原容量 2倍 的方式 进行扩容。</li>
<li><code>Hashtable</code>默认初始化容量为 11，扩容时，是以原容量 2倍 再加 1的方式进行扩容。即<code>int newCapacity = (oldCapacity &lt;&lt; 1) + 1;</code>。</li>
</ul>
<p>3） 散列分布方式（计算存储位置）：</p>
<ul>
<li><code>HashMap</code>是先将<code>key</code>键的<code>hashCode</code>经过扰动函数扰动后得到<code>hash</code>值，然后再利用 <code>hash &amp; (length - 1)</code>的方式代替取模，得到元素的存储位置。</li>
<li><code>Hashtable</code>则是除留余数法进行计算存储位置的（因为其默认容量也不是2的n次方。所以也无法用位运算替代模运算），<code>int index = (hash &amp; 0x7FFFFFFF) % tab.length;</code>。</li>
<li>由于<code>HashMap</code>的容器容量一定是2的n次方，所以能使用<code>hash &amp; (length - 1)</code>的方式代替取模的方式计算元素的位置提高运算效率，但<code>Hashtable</code>的容器容量不一定是2的n次方，所以不能使用此运算方式代替。</li>
</ul>
<p>4）线程安全（最重要）：</p>
<ul>
<li><code>HashMap</code> 不是线程安全，如果想线程安全，可以通过调用<code>synchronizedMap(Map&lt;K,V&gt; m)</code>使其线程安全。但是使用时的运行效率会下降，所以建议使用<code>ConcurrentHashMap</code>容器以此达到线程安全。</li>
<li><code>Hashtable</code>则是线程安全的，每个操作方法前都有<code>synchronized</code>修饰使其同步，但运行效率也不高，所以还是建议使用<code>ConcurrentHashMap</code>容器以此达到线程安全。</li>
</ul>
<p>因此，<code>Hashtable</code>是一个遗留容器，如果我们不需要线程同步，则建议使用<code>HashMap</code>，如果需要线程同步，则建议使用<code>ConcurrentHashMap</code>。</p>
<h2 id="ArrayList和LinkedList-的区别"><a href="#ArrayList和LinkedList-的区别" class="headerlink" title="ArrayList和LinkedList 的区别"></a>ArrayList和LinkedList 的区别</h2><ol>
<li>LinkedList内部存储的是<code>Node&lt;E&gt;</code>，不仅要维护数据域，还要维护<code>prev</code>和<code>next</code>，如果LinkedList中的结点特别多，则LinkedList比ArrayList更占内存。</li>
<li>插入删除操作效率：<br>LinkedList在做插入和删除操作时，插入或删除头部或尾部时是高效的，操作越靠近中间位置的元素时，需要遍历查找，速度相对慢一些，如果在数据量较大时，每次插入或删除时遍历查找比较费时。所以LinkedList插入与删除，慢在遍历查找，快在只需要更改相关结点的引用地址。<br>ArrayList在做插入和删除操作时，插入或删除尾部时也一样是高效的，操作其他位置，则需要批量移动元素，所以ArrayList插入与删除，快在遍历查找，慢在需要批量移动元素。</li>
<li>循环遍历效率：</li>
</ol>
<ul>
<li>由于ArrayList实现了<code>RandomAccess</code>随机访问接口，所以使用for(int i = 0; i &lt; size; i++)遍历会比使用Iterator迭代器来遍历快</li>
</ul>
<ul>
<li>而由于LinkedList未实现<code>RandomAccess</code>接口，所以推荐使用Iterator迭代器来遍历数据。</li>
<li>因此，如果我们需要频繁在列表的中部改变插入或删除元素时，建议使用LinkedList，否则，建议使用ArrayList，因为ArrayList遍历查找元素较快，并且只需存储元素的数据域，不需要额外记录其他数据的位置信息，可以节省内存空间。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java 面试精髓 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础面试题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面试感悟：工作经验java程序员应有的技能]]></title>
      <url>/2017/12/10/%E9%9D%A2%E8%AF%95%E6%84%9F%E6%82%9F%EF%BC%9A%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8Cjava%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E6%9C%89%E7%9A%84%E6%8A%80%E8%83%BD/</url>
      <content type="html"><![CDATA[<h1 id="面试感悟：工作经验java程序员应有的技能"><a href="#面试感悟：工作经验java程序员应有的技能" class="headerlink" title="面试感悟：工作经验java程序员应有的技能"></a>面试感悟：工作经验java程序员应有的技能</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为和同事有约定再加上LZ自己也喜欢做完一件事之后进行总结，因此有了这篇文章。这篇文章大部分内容都是面向整个<a href="http://www.codeceo.com/" target="_blank" rel="external">程序员</a>群体的，当然因为LZ本身是做Java开发的，因此有一部分内容也是专门面向咱们Java程序员的。</p>
<p>简单先说一下，LZ坐标杭州，13届本科毕业，算上年前在阿里巴巴B2B事业部的面试，一共有面试了有6家公司（因为LZ不想请假，因此只是每个晚上去其他公司面试，所以面试的公司比较少），其中成功的有4家，另外两家失败的原因在于：</p>
<p>1、阿里巴巴B2B事业部的面试，两轮技术面试都过了，最后一轮面试是对方的主管，由于听说技术面试过了基本上90%都面试成功了，所以LZ在和主管的交谈中也是毫无顾忌，说得天花乱坠，很多自己介于知道和不知道的东西都直接脱口而出了，结果多次被对方一反问就问得哑口无言。事后想来，模棱两可的答案是面试中最忌讳的，这次的失败也让LZ认真地对待后面的每一次面试</p>
<p>2、另外一家失败的是一家小公司，也就20来个人吧，整个团队是支付宝出来创业的，非常厉害。面试完LZ多方了解了一下，对方认为我基本功什么的都不错，但是实际项目经验还是欠缺一些，因为对方是创业型公司，需要人上手就能干活，因此我在这个时候还不是特别适合他们团队</p>
<p>至于其他成功的四家公司，给LZ的面试评价都挺高的貌似，但LZ也不想记流水账，因此就不一一列举每家公司的面试过程了，下面LZ主要谈谈作为一名工作三年左右的Java程序员应该具备的一些技能以及个人的一些其他感悟。</p>
<h2 id="关于程序员的几个阶段"><a href="#关于程序员的几个阶段" class="headerlink" title="关于程序员的几个阶段"></a>关于程序员的几个阶段</h2><p>每个程序员、或者说每个工作者都应该有自己的职业规划，如果看到这里的朋友没有自己的职业规划，希望你可以思考一下自己的将来。</p>
<p>LZ常常思考自己的未来，也从自己的思考中总结出了一些东西，作为第一部分来谈谈。LZ认为一名程序员应该有几个阶段（以下时间都算上实习期）：</p>
<p>第一阶段：三年</p>
<p>我认为三年对于程序员来说是第一个门槛，这个阶段将会淘汰掉一批不适合写代码的人。这一阶段，我们走出校园，迈入社会，成为一名程序员，正式从书本上的内容迈向真正的企业级开发。我们知道如何团队协作、如何使用项目管理工具、项目版本如何控制、我们写的代码如何测试如何在线上运行等等，积累了一定的开发经验，也对代码有了一定深入的认识，是一个比较纯粹的Coder的阶段</p>
<p>第二阶段：五年</p>
<p>五年又是区分程序员的第二个门槛。有些人在三年里，除了完成工作，在空余时间基本不会研究别的东西，这些人永远就是个Coder，年纪大一些势必被更年轻的人给顶替；有些人在三年里，除了写代码之外，还热衷于研究各种技术实现细节、看了N多好书、写一些博客、在Github上分享技术，这些人在五年后必然具备在技术上独当一面的能力并且清楚自己未来的发展方向，从一个Coder逐步走向系统分析师或是架构师，成为项目组中不可或缺的人物</p>
<p>第三阶段：十年</p>
<p>十年又是另一个门槛了，转行或是继续做一名程序员就在这个节点上。如果在前几年就抱定不转行的思路并且为之努力的话，那么在十年的这个节点上，有些人必然成长为一名对行业有着深入认识、对技术有着深入认识、能从零开始对一个产品进行分析的程序员，这样的人在公司基本担任的都是CTO、技术专家、首席架构师等最关键的职位，这对于自己绝对是一件荣耀的事，当然老板在经济上也绝不会亏待你</p>
<p>第一部分总结一下，我认为，随着你工作年限的增长、对生活对生命认识的深入，应当不断思考三个问题：</p>
<p>1、我到底适不适合当一名程序员？</p>
<p>2、我到底应不应该一辈子以程序员为职业？</p>
<p>3、我对编程到底持有的是一种什么样的态度，是够用就好呢还是不断研究？</p>
<p>最终，明确自己的职业规划，对自己的规划负责并为之努力。</p>
<h2 id="关于项目经验"><a href="#关于项目经验" class="headerlink" title="关于项目经验"></a>关于项目经验</h2><p>LZ在网上经常看到一些别的朋友有提出项目经验的问题，依照LZ面试的感觉来说，面试主要看几点：项目经验+基本技术+个人潜力（也就是值不值得培养）。</p>
<p>关于项目经验，我认为并发编程网的创始人方腾飞老师讲的一段话非常好：</p>
<blockquote>
<p>介绍产品时面试官会考察应聘者的沟通能力和思考能力，我们大部分情况都是做产品的一个功能或一个模块，但是即使是这样，自己有没有把整个系统架构或产品搞清楚，并能介绍清楚，为什么做这个系统？这个系统的价值是什么？这个系统有哪些功能？优缺点有哪些？如果让你重新设计这个系统你会如何设计？</p>
</blockquote>
<p>我觉得这就已经足以概括了。也许你仅仅工作一年，也许你做的是项目中微不足道的模块，当然这些一定是你的劣势且无法改变，但是如何弥补这个劣势，从方老师的话中我总结几点：</p>
<p>1、明确你的项目到底是做什么的，有哪些功能</p>
<p>2、明确你的项目的整体架构，在面试的时候能够清楚地画给面试官看并且清楚地指出从哪里调用到哪里、使用什么方式调用</p>
<p>3、明确你的模块在整个项目中所处的位置及作用</p>
<p>4、明确你的模块用到了哪些技术，更好一些的可以再了解一下整个项目用到了哪些技术</p>
<p>在你无法改变自己的工作年限、自己的不那么有说服力的项目经验的情况下（这一定是扣分项），可以通过这种方式来一定程度上地弥补并且增进面试官对你的好感度。</p>
<h2 id="关于专业技能"><a href="#关于专业技能" class="headerlink" title="关于专业技能"></a>关于专业技能</h2><p>写完项目接着写写一名3年工作经验的Java程序员应该具备的技能，这可能是Java程序员们比较关心的内容。我这里要说明一下，以下列举的内容不是都要会的东西—-但是如果你掌握得越多，最终能得到的评价、拿到的薪水势必也越高。</p>
<p>1、基本语法</p>
<p>这包括static、final、transient等关键字的作用，foreach循环的原理等等。今天面试我问你static关键字有哪些作用，如果你答出static修饰变量、修饰方法我会认为你合格，答出静态块，我会认为你不错，答出静态内部类我会认为你很好，答出静态导包我会对你很满意，因为能看出你非常热衷研究技术。</p>
<p>最深入的一次，LZ记得面试官直接问到了我<a href="http://www.codeceo.com/article/java-volatile-var.html" target="_blank" rel="external">Volatile</a>关键字的底层实现原理（顺便插一句，面试和被面试本身就是相对的，面试官能问这个问题同时也让面试者感觉到面试官也是一个喜爱研究技术的人，增加了面试者对公司的好感，LZ最终选择的就是问了这个问题的公司），不要觉得这太吹毛求疵了—-越简单的问题越能看出一个人的水平，别人对你技术的考量绝大多数都是以深度优先、广度次之为标准的，切记。</p>
<p>2、集合</p>
<p>非常重要，也是必问的内容。基本上就是List、Map、Set，问的是各种实现类的底层实现原理，实现类的优缺点。</p>
<p>集合要掌握的是ArrayList、LinkedList、Hashtable、HashMap、ConcurrentHashMap、HashSet的实现原理，能流利作答，当然能掌握CopyOnWrite容器和Queue是再好不过的了。另外多说一句，ConcurrentHashMap的问题在面试中问得特别多，大概是因为这个类可以衍生出非常多的问题，关于ConcurrentHashMap，我给网友朋友们提供三点回答或者是研究方向：</p>
<p>（1）ConcurrentHashMap的锁分段技术</p>
<p>（2）ConcurrentHashMap的读是否要加锁，为什么</p>
<p>（3）ConcurrentHashMap的迭代器是强一致性的迭代器还是弱一致性的迭代器</p>
<p>3、<a href="http://www.codeceo.com/article/category/develop/design-patterns" target="_blank" rel="external">设计模式</a></p>
<p>本来以为蛮重要的一块内容，结果只在阿里巴巴B2B事业部面试的时候被问了一次，当时问的是装饰器模式。</p>
<p>当然咱们不能这么功利，为了面试而学习，设计模式在工作中还是非常重要、非常有用的，23种设计模式中重点研究常用的十来种就可以了，面试中关于设计模式的问答主要是三个方向：</p>
<p>（1）你的项目中用到了哪些设计模式，如何使用</p>
<p>（2）知道常用设计模式的优缺点</p>
<p>（3）能画出常用设计模式的UML图</p>
<p>4、多线程</p>
<p>这也是必问的一块了。因为三年工作经验，所以基本上不会再问你怎么实现多线程了，会问得深入一些比如说Thread和Runnable的区别和联系、多次start一个线程会怎么样、线程有哪些状态。当然这只是最基本的，出乎意料地，几次面试几乎都被同时问到了一个问题，问法不尽相同，总结起来是这么一个意思：</p>
<blockquote>
<p>假如有Thread1、Thread2、Threa<a href="http://www.codeceo.com/article/javascript-d3-js.html" target="_blank" rel="external">D3</a>、Thread4四条线程分别统计C、D、E、F四个盘的大小，所有线程都统计完毕交给Thread5线程去做汇总，应当如何实现？</p>
</blockquote>
<p>聪明的网友们对这个问题是否有答案呢？不难，java.util.concurrent下就有现成的类可以使用。</p>
<p>另外，线程池也是比较常问的一块，常用的线程池有几种？这几种线程池之间有什么区别和联系？线程池的实现原理是怎么样的？实际一些的，会给你一些具体的场景，让你回答这种场景该使用什么样的线程池比较合适。</p>
<p>最后，虽然这次面试问得不多，但是多线程同步、锁这块也是重点。synchronized和ReentrantLock的区别、synchronized锁普通方法和锁静态方法、死锁的原理及排查方法等等，关于多线程，我在之前有些过文章总结过多线程的40个问题，可以参看<a href="http://www.codeceo.com/article/40-java-thread-problems.html" target="_blank" rel="external">40个Java多线程问题总结</a>。</p>
<p>5、JDK源码</p>
<p>要想拿高工资，JDK源码不可不读。上面的内容可能还和具体场景联系起来，JDK源码就是实打实地看你平时是不是爱钻研了。LZ面试过程中被问了不少JDK源码的问题，其中最刁钻的一个问了LZ，String的hashCode()方法是怎么实现的，幸好LZ平时String源代码看得多，答了个大概。JDK源码其实没什么好总结的，纯粹看个人，总结一下比较重要的源码：</p>
<p>（1）List、Map、Set实现类的源代码</p>
<p>（2）ReentrantLock、AQS的源代码</p>
<p>（3）AtomicInteger的实现原理，主要能说清楚CAS机制并且AtomicInteger是如何利用CAS机制实现的</p>
<p>（4）线程池的实现原理</p>
<p>（5）Object类中的方法以及每个方法的作用</p>
<p>这些其实要求蛮高的，LZ去年一整年基本把JDK中重要类的源代码研究了个遍，真的花费时间、花费精力，当然回头看，是值得的—-不仅仅是为了应付面试。</p>
<p>6、框架</p>
<p>老生常谈，面试必问的东西。一般来说会问你一下你们项目中使用的框架，然后给你一些场景问你用框架怎么做，比如我想要在Spring初始化bean的时候做一些事情该怎么做、想要在bean销毁的时候做一些事情该怎么做、MyBatis中$和#的区别等等，这些都比较实际了，平时积累得好、有多学习框架的使用细节自然都不成问题。</p>
<p>如果上面你的问题答得好，面试官往往会深入地问一些框架的实现原理。问得最多的就是Spring AOP的实现原理，当然这个很简单啦，两句话就搞定的的事儿，即使你不会准备一下就好了。LZ遇到的最变态的是让LZ画一下Spring的Bean工厂实现的UML图，当然面对这样一个有深度的问题，LZ是绝对答不出来的/(ㄒoㄒ)/~~</p>
<p>7、数据库</p>
<p>数据库十有八九也都会问到。一些基本的像union和union all的区别、left join、几种索引及其区别就不谈了，比较重要的就是数据库性能的优化，如果对于数据库的性能优化一窍不通，那么有时间，还是建议你在面试前花一两天专门把SQL基础和SQL优化的内容准备一下。</p>
<p>不过数据库倒是不用担心，一家公司往往有很多部门，如果你对数据库不熟悉而基本技术又非常好，九成都是会要你的，估计会先把你放到对数据库使用不是要求非常高的部门锻炼一下。</p>
<p>8、数据结构和算法分析</p>
<p>数据结构和算法分析，对于一名程序员来说，会比不会好而且在工作中绝对能派上用场。数组、链表是基础，栈和队列深入一些但也不难，树挺重要的，比较重要的树AVL树、红黑树，可以不了解它们的具体实现，但是要知道什么是二叉查找树、什么是平衡树，AVL树和红黑树的区别。记得某次面试，某个面试官和我聊到了数据库的索引，他问我：</p>
<blockquote>
<p>你知道索引使用的是哪种数据结构实现吗？</p>
</blockquote>
<p>LZ答到用的Hash表吧，答错。他又问，你知道为什么要使用树吗？LZ答到因为Hash表可能会出现比较多的冲突，在千万甚至是上亿级别的数据面前，会大大增加查找的时间复杂度。而树比较稳定，基本保证最多二三十次就能找到想要的数据，对方说不完全对，最后我们还是交流了一下这个问题，我也明白了为什么要使用树，这里不说，网友朋友们觉得索引为什么要使用树来实现呢？</p>
<p>至于算法分析，不会、不想研究就算了，记得某次面试对方问我，Collections.sort方法使用的是哪种排序方法，额，吐血三升。当然为了显示LZ的博学，对算法分析也有一定的研究(⊙﹏⊙)b，LZ还是硬着头皮说了一句可能是冒泡排序吧。当然答案肯定不是，有兴趣的网友朋友们可以去看一下Collections.sort方法的源代码，用的是一种叫做TimSort的排序法，也就是增强型的归并排序法。</p>
<p>9、Java虚拟机</p>
<p>出乎LZ的意料，Java虚拟机应该是很重要的一块内容，结果在这几家公司中被问到的概率几乎为0。要知道，LZ去年可是花了大量的时间去研究Java虚拟机的，光周志明老师的《深入理解Java虚拟机：JVM高级特性与最佳实践》，LZ就读了不下五遍。</p>
<p>言归正传，虽然Java虚拟机没问到，但我觉得还是有必要研究的，LZ就简单地列一个提纲吧，谈谈Java虚拟机中比较重要的内容：</p>
<p>（1）Java虚拟机的内存布局</p>
<p>（2）GC算法及几种垃圾收集器</p>
<p>（3）类加载机制，也就是双亲委派模型</p>
<p>（4）Java内存模型</p>
<p>（5）happens-before规则</p>
<p>（6）volatile关键字使用规则</p>
<p>也许面试无用，但在走向大牛的路上，不可不会。</p>
<p>10、Web方面的一些问题</p>
<p>Java主要面向Web端，因此Web的一些问题也是必问的。LZ碰到过问得最多的两个问题是：</p>
<blockquote>
<p>谈谈分布式Session的几种实现方式</p>
</blockquote>
<p>常用的四种能答出来自然是让面试官非常满意的，另外一个常问的问题是：</p>
<blockquote>
<p>讲一下Session和Cookie的区别和联系以及Session的实现原理</p>
</blockquote>
<p>这两个问题之外，web.xml里面的内容是重点，Filter、Servlet、Listener，不说对它们的实现原理一清二楚吧，至少能对它们的使用知根知底。另外，一些细节的方面比如get/post的区别、forward/重定向的区别、HTTPS的实现原理也都可能会被考察到。</p>
<p>噢，想起来了，一致性Hash算法貌似也被问到了几次，这个LZ以前专门深入研究过并且写了两篇博文，因此问到这个问题LZ自然是答得毫不费力。文章是<a href="http://www.codeceo.com/article/memcache-usage-learn.html" target="_blank" rel="external">MemCache超详细解读</a>和对<a href="http://www.cnblogs.com/xrq730/p/5186728.html" target="_blank" rel="external">一致性Hash算法，Java代码实现的深入研究</a>，特别说明，LZ真的不是在为自已以前写的文章打广告啊啊啊啊啊啊。</p>
<p>最后，如果有兴趣有时间，建议学习、研究一下SOA和RPC，面向服务体系，大型分布式架构必备，救命良方、包治百病、屡试不爽。</p>
<h2 id="关于HR面试"><a href="#关于HR面试" class="headerlink" title="关于HR面试"></a>关于HR面试</h2><p>如果你过五关斩六将，成功地通过了所有的技术面，那么恭喜你，你离升职加薪、出任CEO、迎娶白富美、走向人生巅峰又进了一步。但是还没有到谈薪资待遇的时候，最后还有一个考验：HR面试。基本所有的大公司都有这一轮的面试，不要小看HR面试，很多公司的HR对于面试者都有一票否决权的—-即使前面的面试对你的评价再高。</p>
<p>所以，这轮的面试也必须重视起来，HR面试主要问的是几点：</p>
<p>1、简历中写的过去工作经历的离职原因</p>
<p>2、当前公司薪资待遇</p>
<p>3、期望能到怎样的一家公司</p>
<p>4、个人未来的发展方向</p>
<p>我专门提一下第2点。可能有人比较排斥也不想说这个，我个人倒是持开放状态，问了就说了，当然一些的夸大还是必要的，当前公司薪资待遇多报个一千块钱完全没问题（毕竟是一家互联网公司总多多少少有些补贴啊什么的嘛）。因为这和你在新公司能拿到的薪水关系不大，新公司能拿到的薪水的决定因素是整个公司的薪资情况以及根据你的面试情况在公司的定位，都是有固定的薪资范围的。HR问这个主要也就是心里有个数并且看你是否诚信—-有些公司入职时会要求你提供最近一家单位的银行流水号。</p>
<p>HR面试就说到这里了，总结起来其实就是四个字：滴水不漏。整个面试过程态度积极向上，不要有任何悲观消极的态度（尤其在谈到以前公司情况的时候，即使有再多的不满），就不会有问题。</p>
<h2 id="关于面试心态"><a href="#关于面试心态" class="headerlink" title="关于面试心态"></a>关于面试心态</h2><p>这个嘛，LZ其实在公司也面试过几个人，一半以上的面试者回答问题的时候都属于那种双腿发抖、声音颤抖的类型。在LZ看来这大可不必并且这还是扣分项，回答问题的时候最最基本的两个要求：</p>
<p>1、不紧不慢，平心静气</p>
<p>2、条理清晰</p>
<p>表达能力绝对是面试的时候重要的考察项目。咱们做的是程序员这一行，讲究的是团队协作，不是写作、画画，一支笔、一个人就行了，一个表达能力不行的程序员，要来又有什么用呢？</p>
<p>除此之外，就是保持良好的心态。古语说得好，只要功夫深，铁杵磨成针，面试的成功与否，在于平时的积累，临时抱抱佛脚，看两道面试题是没有用的，只要平时足够努力，成功是水到渠成的事情，平时不怎么研究技术的，那也就是个听天由命的事情，只要充分地展示平时自己的所学就可以了。</p>
<p>因此在我看来，不要把面试当作面试，当做一次技术交流，把面试的心态从我要找到一份工作转变为我要通过面试去发现不足、提升自己，这样就会平和多了，即使失败也不会有太多失望的感觉。</p>
<p>另外，如果平时自己热衷于研究技术的朋友，真的要有自信，不要觉得别人面试你别人就比你厉害。面试官未必比你优秀，他问的问题往往都是他平时研究得比较多的问题，你一样有很多自己的研究面试官未必知道。</p>
<h2 id="关于Java"><a href="#关于Java" class="headerlink" title="关于Java"></a>关于Java</h2><p>网上常看到一种说法：Java比较简单。某种程度上这会打击Java程序员的信心—-原来咱们平时用的是这种小儿科的玩意儿啊，在我看来这种想法大可不必，这一部分我来讲讲对于这个话题的看法。</p>
<p>这种说法有些片面，得分开两部分来看，我用四个自总结一下就是：易学难精。</p>
<p>1、易学部分</p>
<p>Java易学我认为有两部分的原因：</p>
<p>（1）很多培训公司包括大四的学生找工作都会学习Java，绝大多数是因为易学。Java从C/C++发展而来，感谢前人的智慧，它消除了C/C++中最复杂和让人困惑的语法、它消除了平台的差异性、它不需要用户手动释放内存空间、它避免了Java程序员和本地语言的交互，让程序员只需要专注于语法层面和应用层面。</p>
<p>（2）Java作为一门面向对象的语言，在企业级开发中体现出了它无与伦比的特性，整个开发流程比较固定化、模块化，需求分析起来也相对容易。我举个自己以前的例子吧，我在大一学习C语言的时候，用C语言写了一个图书管理系统写了2000+的代码，大四学了C++之后，用面向对象的语言C++取代面向过程的语言C语言重新写了一个功能相似的图书管理系统，只写了1100行的样子，这就是面向对象的优势。</p>
<p>2、难精部分</p>
<p>接着咱们聊聊难精的部分。</p>
<p>Java语言的设计者帮助Java程序员做了这么多事情，这有利也有弊。有利的部分前面已经说过了，让Java易学，不过有弊的部分同样明显。假如在应用运行过程中遇到了语法层面和应用层面之外的错误，应当如何处理？比如线上环境出现内存溢出怎么办？GC时间过长怎么办？IO长时间没反应怎么办？方法抛出莫名其妙的异常怎么办？</p>
<p>凡此种种，绝不是一名只会写几个if…else…的Java程序员就可以解决的，这需要大量的经历、大量的实践、大量对Java底层实现细节的研究，而这往往是最难、最考验Java程序员的部分，一些人根本就不想往深去研究，另外一些人研究了一点点就研究不下去了。</p>
<p>Java为什么难精？就是这个原因。除非你水平特别高，否则五年工作经验以下的Java程序员在简历上写”精通Java”绝对是一件非常愚蠢的事情。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>文章写到这里，感觉有点像鸡汤文了，那就以最后的鸡汤作为结尾吧。</p>
<p>在以前博客园的一篇文章中，讲到了奔三程序员的困惑，大致说的是三十岁之后程序员要转行之类的云云，LZ在博文中留下了如下的评论：</p>
<p><img src="http://static.codeceo.com/images/2016/03/0eada6b2dcac3a6a274b0196c277cea5.png" alt="img"></p>
<p>就以这段话自勉、共勉吧。越努力、越幸运，如果你不是官二代、富二代、红二代，那么请记住：勤奋才是改变你命运的唯一捷径。</p>
]]></content>
      
        <categories>
            
            <category> 工作经验java程序员应有的技能 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试精髓 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LinkedList 源码分析]]></title>
      <url>/2017/12/09/LinkedList%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="LinkedList-源码分析"><a href="#LinkedList-源码分析" class="headerlink" title="LinkedList 源码分析"></a>LinkedList 源码分析</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有了ArrayList，自然少不了LinkedList了。</p>
<p>下面我就以面试问答的形式学习我们的常用的装载容器——<code>LinkedList</code>（源码分析基于JDK8）</p>
<h1 id="问答内容"><a href="#问答内容" class="headerlink" title="问答内容"></a>问答内容</h1><h2 id="LinkedList-用来做什么，怎么使用？"><a href="#LinkedList-用来做什么，怎么使用？" class="headerlink" title="LinkedList 用来做什么，怎么使用？"></a>LinkedList 用来做什么，怎么使用？</h2><p>问：请简单介绍一下您所了解的LinkedList，它可以用来做什么，怎么使用？</p>
<p>答：</p>
<ul>
<li>LinkedList底层是双向链表，同时实现了List接口和Deque接口，所以它既可以看作是一个<strong>顺序容器</strong>，也可以看作是一个<strong>队列(Queue)</strong>，同时也可以看作是一个<strong>栈</strong>(Stack)，但如果想使用栈或队列等数据结构的话，推荐使用ArrayDeque，它作为栈或队列会比LinkedList有更好的使用性能。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个LinkedList，链表的每个节点的内存空间都是实时分配的，所以无须事先指定容器大小</span></div><div class="line">LinkedList&lt;String&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;String&gt;();</div><div class="line"><span class="comment">// 往容器里面添加元素</span></div><div class="line">linkedList.add(<span class="string">"张三"</span>);</div><div class="line">linkedList.add(<span class="string">"李四"</span>);</div><div class="line"><span class="comment">// 在张三与李四之间插入一个王五</span></div><div class="line">linkedList.add(<span class="number">1</span>, <span class="string">"王五"</span>);</div><div class="line"><span class="comment">// 在头部插入一个小三</span></div><div class="line">linkedList.addFirst(<span class="string">"小三"</span>);</div><div class="line"><span class="comment">// 获取index下标为2的元素 王五</span></div><div class="line">String element = linkedList.get(<span class="number">2</span>);</div><div class="line"><span class="comment">// 修改index下标为2的元素 王五 为小四</span></div><div class="line">linkedList.set(<span class="number">2</span>, <span class="string">"小四"</span>);</div><div class="line"><span class="comment">// 删除index下标为1的元素 张三</span></div><div class="line">String removeElement = linkedList.remove(<span class="number">1</span>);</div><div class="line"><span class="comment">// 删除第一个元素</span></div><div class="line">String removeFirstElement = linkedList.removeFirst();</div><div class="line"><span class="comment">// 删除最后一个元素</span></div><div class="line">String removeLastElement = linkedList.removeLast();</div></pre></td></tr></table></figure>
<ul>
<li>LinkedList底层实现是双向链表，核心组成元素有：<code>int size = 0</code>用于记录链表长度；<code>Node&lt;E&gt; first;</code>用于记录头（第一个）结点（储存的是头结点的引用）；<code>Node&lt;E&gt; last;</code>用于记录尾（最后一个）结点（储存的是尾结点的引用）。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</div><div class="line">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// 记录链表长度</span></div><div class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Pointer to first node. 指向第一个结点</div><div class="line">     * Invariant: (first == null &amp;&amp; last == null) ||</div><div class="line">     *            (first.prev == null &amp;&amp; first.item != null)</div><div class="line">     */</div><div class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Pointer to last node. 指向最后一个结点</div><div class="line">     * Invariant: (first == null &amp;&amp; last == null) ||</div><div class="line">     *            (last.next == null &amp;&amp; last.item != null)</div><div class="line">     */</div><div class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>双向链表的核心组成元素还有一个最重要的<code>Node&lt;E&gt;</code>，<code>Node&lt;E&gt;</code>包含：<code>E item;</code> 用于存储元素数据，<code>Node&lt;E&gt; next;</code> 指向当前元素的后继结点，<code>Node&lt;E&gt; prev;</code> 指向当前元素的前驱结点。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 定义LinkedList底层的结点实现</div><div class="line"> */</div><div class="line">private static class Node&lt;E&gt; &#123;</div><div class="line">    E item; // 存储元素数据</div><div class="line">    Node&lt;E&gt; next;// 指向当前元素的后继结点</div><div class="line">    Node&lt;E&gt; prev;// 指向当前元素的前驱结点</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Node结点构造方法</div><div class="line">     */</div><div class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</div><div class="line">        this.item = element;// 存储的元素</div><div class="line">        this.next = next;// 后继结点</div><div class="line">        this.prev = prev;// 前驱结点</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://user-gold-cdn.xitu.io/2017/8/28/8cfa61381cb1e233627e865c8cd33955?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="双向链表底层实现，图片来自网络">双向链表底层实现，图片来自网络</p>
<p>上图中的head即Node first; tail即Node last;</p>
<h2 id="LinkedList-的操作和对应的时间复杂度。"><a href="#LinkedList-的操作和对应的时间复杂度。" class="headerlink" title="LinkedList 的操作和对应的时间复杂度。"></a>LinkedList 的操作和对应的时间复杂度。</h2><p>问：请分别分析一下它是如何获取元素，修改元素，新增元素与删除元素，并分析这些操作对应的时间复杂度。</p>
<p>答：</p>
<ul>
<li>获取元素：LinkedList提供了三种获取元素的方法，分别是：</li>
</ul>
<ol>
<li>获取第一个元素<code>getFirst()</code>，获取第一个元素，直接返回<code>Node&lt;E&gt; first</code>指向的结点即可，所以时间复杂度为O(1)。</li>
<li>获取最后一个元素<code>getLast()</code>，获取最后一个元素，直接返回<code>Node&lt;E&gt; last</code>指向的结点即可，所以时间复杂度也为O(1)。</li>
<li>获取指定索引index位置的元素<code>get(int index)</code>，由于<code>Node&lt;E&gt;</code>结点在内存中存储的空间不是连续存储的，所以查找某一位置的结点，只能通过遍历链表的方式查找结点，因此LinkedList会先通过判断<code>index &lt; (size &gt;&gt; 1)</code>，<code>size&gt;&gt;1</code>即为<code>size/2</code>当前链表长度的一半，判断index的位置是在链表的前半部分还是后半部分。决定是从头部遍历查找数据还是从尾部遍历查找数据。最坏情况下，获取中间元素，则需要遍历n/2次才能获取到对应元素，所以此方法的时间复杂度为O(n)。</li>
</ol>
<ul>
<li>综上所述，LinkedList获取元素的时间复杂度为O(n)。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 返回列表中指定位置的元素</div><div class="line"> *</div><div class="line"> * @param index 指定index位置</div><div class="line"> * @return 返回指定位置的元素</div><div class="line"> * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</div><div class="line"> */</div><div class="line">public E get(int index) &#123;</div><div class="line">    // 检查index下标是否合法[0,size)</div><div class="line">    checkElementIndex(index);</div><div class="line">    // 遍历列表获取对应index位置的元素</div><div class="line">    return node(index).item;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 检查下标是否合法</div><div class="line"> */</div><div class="line">private void checkElementIndex(int index) &#123;</div><div class="line">    if (!isElementIndex(index))</div><div class="line">        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">&#125;</div><div class="line"></div><div class="line">private boolean isElementIndex(int index) &#123;</div><div class="line">    return index &gt;= 0 &amp;&amp; index &lt; size;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 返回指定位置的结点元素（重点）</div><div class="line"> */</div><div class="line">Node&lt;E&gt; node(int index) &#123;</div><div class="line">    // assert isElementIndex(index);</div><div class="line">    // 判断index位置是在链表的前半部分还是后半部分</div><div class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</div><div class="line">        // 从头结点开始，从前往后遍历找到对应位置的结点元素</div><div class="line">        Node&lt;E&gt; x = first;</div><div class="line">        for (int i = 0; i &lt; index; i++)</div><div class="line">            x = x.next;</div><div class="line">        return x;</div><div class="line">    &#125; else &#123;</div><div class="line">        // 从尾结点开始，从后往前遍历找到对应位置的结点元素</div><div class="line">        Node&lt;E&gt; x = last;</div><div class="line">        for (int i = size - 1; i &gt; index; i--)</div><div class="line">            x = x.prev;</div><div class="line">        return x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>修改元素：LinkedList提供了一种修改元素数据的方法<code>set(int index, E element)</code>，修改元素数据的步骤是：1.检查index索引是否合法[0,size)。2.折半查询获取对应索引元素。3.将新元素赋值，返回旧元素。由获取元素的分析可知，折半查询的时间复杂度为O(n)，故修改元素数据的时间复杂度为O(n)。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 修改指定位置结点的存储数据</div><div class="line"> *</div><div class="line"> * @param index 指定位置</div><div class="line"> * @param element 修改的存储数据</div><div class="line"> * @return 返回未修改前的存储数据</div><div class="line"> * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</div><div class="line"> */</div><div class="line">public E set(int index, E element) &#123;</div><div class="line">    // 检查index下标是否合法[0,size)</div><div class="line">    checkElementIndex(index);</div><div class="line">    // 折半查询获取对应索引元素</div><div class="line">    Node&lt;E&gt; x = node(index);</div><div class="line">    // 将新元素赋值，返回旧元素</div><div class="line">    E oldVal = x.item;</div><div class="line">    x.item = element;</div><div class="line">    return oldVal;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>新增元素：LinkedList提供了四种新增元素的方法，分别是：</li>
</ul>
<ol>
<li>将指定元素插入到链表的第一个位置中<code>addFirst(E e)</code>，只需将头结点<code>first</code>指向新元素结点，将原第一结点的前驱指针指向新元素结点即可。不需要移动原数据存储位置，只需交换一下相关结点的指针域信息即可。所以时间复杂度为O(1)。</li>
<li>将指定元素插入到链表的最后一个位置中<code>addLast(E e)</code>，只需将尾结点<code>last</code>指向新元素结点，将原最后一个结点的后继指针指向新元素结点即可。不需要移动原数据存储位置，只需交换一下相关结点的指针域信息即可。所以时间复杂度也为O(1)。</li>
<li>添加元素方法<code>add(E e)</code> 等价于<code>addLast(E e)</code>。</li>
<li>将指定元素插入到链表的指定位置index中<code>add(int index, E element)</code>，需要先根据位置index调用<code>node(index)</code>遍历链表获取该位置的原结点，然后将新结点插入至原该位置结点的前面，不需要移动原数据存储位置，只需交换一下相关结点的指针域信息即可。所以时间复杂度也为O(1)。</li>
</ol>
<ul>
<li>综上所述，LinkedList新增元素的时间复杂度为O(1)，单纯论插入新元素，操作是非常高效的，特别是插入至头部或插入到尾部。但如果是通过索引index的方式插入，插入的位置越靠近链表中间所费时间越长，因为需要对链表进行遍历查找。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2017/8/28/373537715b40c9830bbc6f5de35dc6d3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="添加元素结点示意图，图片来自《大话数据结构》">添加元素结点示意图，图片来自《大话数据结构》</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 将指定元素插入到链表的第一个位置中</div><div class="line"> *</div><div class="line"> * @param e 要插入的元素</div><div class="line"> */</div><div class="line">public void addFirst(E e) &#123;</div><div class="line">    linkFirst(e);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 将元素e作为第一个元素</div><div class="line"> */</div><div class="line">private void linkFirst(E e) &#123;</div><div class="line">    // 获取原头结点</div><div class="line">    final Node&lt;E&gt; f = first;</div><div class="line">    // 初始化新元素结点</div><div class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);</div><div class="line">    // 头指针指向新元素结点</div><div class="line">    first = newNode;</div><div class="line">    // 如果是第一个元素（链表为空）</div><div class="line">    if (f == null)</div><div class="line">        // 将尾指针也指向新元素结点</div><div class="line">        last = newNode;</div><div class="line">    else // 链表不会空</div><div class="line">        // 原头结点的前驱指针指向新结点</div><div class="line">        f.prev = newNode;</div><div class="line">    // 记录链表长度的size + 1</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 将指定元素插入到链表的最后一个位置中</div><div class="line"> *</div><div class="line"> * &lt;p&gt;此方法等同与add(E e)方法 &#123;@link #add&#125;.</div><div class="line"> *</div><div class="line"> * @param e 要插入的元素</div><div class="line"> */</div><div class="line">public void addLast(E e) &#123;</div><div class="line">    linkLast(e);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 将指定元素插入到链表的最后一个位置中</div><div class="line"> *</div><div class="line"> * &lt;p&gt;此方法等同与addLast(E e)方法  &#123;@link #addLast&#125;.</div><div class="line"> *</div><div class="line"> * @param e 要插入的元素</div><div class="line"> * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;)</div><div class="line"> */</div><div class="line">public boolean add(E e) &#123;</div><div class="line">    linkLast(e);</div><div class="line">    return true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 将元素e作为最后一个元素</div><div class="line"> */</div><div class="line">void linkLast(E e) &#123;</div><div class="line">    // 获取原尾结点</div><div class="line">    final Node&lt;E&gt; l = last;</div><div class="line">    // 初始化新元素结点</div><div class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</div><div class="line">    // 位指针指向新元素结点</div><div class="line">    last = newNode;</div><div class="line">    // 如果是第一个元素（链表为空）</div><div class="line">    if (l == null)</div><div class="line">        // 将头指针也指向新元素结点</div><div class="line">        first = newNode;</div><div class="line">    else // 链表不会空</div><div class="line">        // 原尾结点的后继指针指向新结点</div><div class="line">        l.next = newNode;</div><div class="line">    // 记录链表长度的size + 1</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 将指定元素插入到链表的指定位置index中</div><div class="line"> *</div><div class="line"> * @param index 元素要插入的位置index</div><div class="line"> * @param element 要插入的元素</div><div class="line"> * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</div><div class="line"> */</div><div class="line">public void add(int index, E element) &#123;</div><div class="line">    // 检查插入位置是否合法[0,size]</div><div class="line">    checkPositionIndex(index);</div><div class="line">    // 如果插入的位置和当前链表长度相等，则直接将元素插入至链表的尾部</div><div class="line">    if (index == size)</div><div class="line">        // 将元素插入至链表的尾部</div><div class="line">        linkLast(element);</div><div class="line">    else</div><div class="line">        //将元素插入至指定位置,node(index)先获取占有该index位置的原结点</div><div class="line">        linkBefore(element, node(index));</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 检查位置是否合法</div><div class="line"> */</div><div class="line">private void checkPositionIndex(int index) &#123;</div><div class="line">    if (!isPositionIndex(index))</div><div class="line">        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 检查位置是否合法</div><div class="line"> */</div><div class="line">private boolean isPositionIndex(int index) &#123;</div><div class="line">    //合法位置为[0,size]</div><div class="line">    return index &gt;= 0 &amp;&amp; index &lt;= size;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 将新元素e插入至旧元素succ前面</div><div class="line"> */</div><div class="line">void linkBefore(E e, Node&lt;E&gt; succ) &#123;</div><div class="line">    // assert succ != null;</div><div class="line">    // 记录旧元素结点succ的前驱指针</div><div class="line">    final Node&lt;E&gt; pred = succ.prev;</div><div class="line">    // 初始化新元素结点</div><div class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);</div><div class="line">    // 旧元素结点的前驱指针指向新元素结点(即新元素结点放至在旧元素结点的前面，取代了原本旧元素的位置)</div><div class="line">    succ.prev = newNode;</div><div class="line">    // 如果旧元素结点的前驱指针为空，则证明旧元素结点是头结点，</div><div class="line">    // 将新元素结点插入至旧元素结点前面，所以现时新的头结点是新元素结点</div><div class="line">    if (pred == null)</div><div class="line">        first = newNode;</div><div class="line">    else //不是插入至头部</div><div class="line">        // 旧元素的前驱结点的后继指针指向新元素结点</div><div class="line">        pred.next = newNode;</div><div class="line">    // 记录链表长度的size + 1</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>删除元素：LinkedList提供了四种删除元素的方法，分别是：</li>
</ul>
<ol>
<li>删除链表中的第一个元素<code>removeFirst()</code>，只需将头结点<code>first</code>指向删除元素结点的后继结点并将其前驱结点指针信息<code>prev</code>清空即可。不需要移动原数据存储位置，只需操作相关结点的指针域信息即可。所以时间复杂度为O(1)。</li>
<li>删除链表中的最后一个元素<code>removeLast()</code>，只需将尾结点<code>last</code>指向删除元素结点的前驱结点并将其后继结点指针信息<code>next</code>清空即可。不需要移动原数据存储位置，只需操作相关结点的指针域信息即可，所以时间复杂度也为O(1)。</li>
<li>将指定位置index的元素删除<code>remove(int index)</code>，需要先根据位置index调用<code>node(index)</code>遍历链表获取该位置的原结点，然后将删除元素结点的前驱结点的<code>next</code>后继结点指针域指向删除元素结点的后继结点<code>node.prev.next = node.next</code>，删除元素结点的后继结点的<code>prev</code>前驱结点指针域指向删除元素结点的前驱结点即可<code>node.next.prev = node.prev</code>（此处可能有些绕，不太理解的同学自行学习一下双向链表的数据结构吧），不需要移动原数据存储位置，只需交换一下相关结点的指针域信息即可。所以时间复杂度也为O(1)。</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2017/8/28/f85573ac41422b664bdd69d0b9e25a66?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="删除元素结点示意图，图片来自《大话数据结构》">删除元素结点示意图，图片来自《大话数据结构》</p>
<ol>
<li>删除传入的Object o指定对象，比较对象是否一致通过o.equals方法比较<code>remove(Object o)</code>，和3.的思路基本差不多，关键是比较对象是通过o.equals方法，记住这点即可。</li>
</ol>
<ul>
<li>综上所述，LinkedList删除元素的时间复杂度为O(1)，单纯论删除元素，操作是非常高效的，特别是删除第一个结点或删除最后一个结点。但如果是通过索引index的方式或者object对象的方式删除，则需要对链表进行遍历查找对应index索引的对象或者利用equals方法判断对象。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 删除链表中的第一个元素并返回</div><div class="line"> *</div><div class="line"> * @return 链表中的第一个元素</div><div class="line"> * @throws NoSuchElementException if this list is empty</div><div class="line"> */</div><div class="line">public E removeFirst() &#123;</div><div class="line">    //根据头结点获取第一个元素结点</div><div class="line">    final Node&lt;E&gt; f = first;</div><div class="line">    if (f == null) // 没有元素结点则抛出异常</div><div class="line">        throw new NoSuchElementException();</div><div class="line">    return unlinkFirst(f);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 移除第一个元素</div><div class="line"> */</div><div class="line">private E unlinkFirst(Node&lt;E&gt; f) &#123;</div><div class="line">    // assert f == first &amp;&amp; f != null;</div><div class="line">    // 记录要移除元素结点的数据域</div><div class="line">    final E element = f.item;</div><div class="line">    // 记录要移除元素结点的后继结点指针</div><div class="line">    final Node&lt;E&gt; next = f.next;</div><div class="line">    // 清空要删除结点的数据域和next指针域信息，以帮助垃圾回收</div><div class="line">    f.item = null;</div><div class="line">    f.next = null; // help GC</div><div class="line">    // 头结点指向要移除元素结点的后继结点</div><div class="line">    first = next;</div><div class="line">    // 如果要移除元素结点的后继结点为空，则证明链表只有一个元素</div><div class="line">    // 所以需要将尾结点的指针信息也要清空</div><div class="line">    if (next == null)</div><div class="line">        last = null;</div><div class="line">    else</div><div class="line">        // 将新的第一个结点的前驱结点指针信息清空</div><div class="line">        next.prev = null;</div><div class="line">    // 记录链表长度的size - 1</div><div class="line">    size--;</div><div class="line">    modCount++;</div><div class="line">    // 返回移除元素结点的数据域</div><div class="line">    return element;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 删除链表中的最后一个元素并返回</div><div class="line"> *</div><div class="line"> * @return 链表中的最后一个元素</div><div class="line"> * @throws NoSuchElementException if this list is empty</div><div class="line"> */</div><div class="line">public E removeLast() &#123;</div><div class="line">    // 根据尾结点获取最后一个元素结点</div><div class="line">    final Node&lt;E&gt; l = last;</div><div class="line">    if (l == null)// 没有元素结点则抛出异常</div><div class="line">        throw new NoSuchElementException();</div><div class="line">    return unlinkLast(l);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> * 移除最后一个元素</div><div class="line"> */</div><div class="line">private E unlinkLast(Node&lt;E&gt; l) &#123;</div><div class="line">    // assert l == last &amp;&amp; l != null;</div><div class="line">    // 记录要移除元素结点的数据域</div><div class="line">    final E element = l.item;</div><div class="line">    // 记录要移除元素结点的前驱结点指针</div><div class="line">    final Node&lt;E&gt; prev = l.prev;</div><div class="line">    // 清空要删除结点的数据域和prev指针域信息，以帮助垃圾回收</div><div class="line">    l.item = null;</div><div class="line">    l.prev = null; // help GC</div><div class="line">    // 头结点指向要移除元素结点的前驱结点</div><div class="line">    last = prev;</div><div class="line">    // 如果要移除元素结点的前驱结点为空，则证明链表只有一个元素</div><div class="line">    // 所以需要将头结点的指针信息也要清空</div><div class="line">    if (prev == null)</div><div class="line">        first = null;</div><div class="line">    else</div><div class="line">        // 将新的最后一个结点的后继结点指针信息清空</div><div class="line">        prev.next = null;</div><div class="line">    // 记录链表长度的size - 1</div><div class="line">    size--;</div><div class="line">    modCount++;</div><div class="line">    // 返回移除元素结点的数据域</div><div class="line">    return element;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 将指定位置index的元素删除</div><div class="line"> *</div><div class="line"> * @param index 要删除的位置index</div><div class="line"> * @return 要删除位置的原元素</div><div class="line"> * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</div><div class="line"> */</div><div class="line">public E remove(int index) &#123;</div><div class="line">    // 检查index下标是否合法[0,size)</div><div class="line">    checkElementIndex(index);</div><div class="line">    // 根据index进行遍历链表获取要删除的结点，再调用unlink方法进行删除</div><div class="line">    return unlink(node(index));</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 删除传入的Object o指定对象，比较对象是否一致通过o.equals方法比较</div><div class="line"> * @param o 要删除的Object o指定对象</div><div class="line"> * @return &#123;@code true&#125; 是否存在要删除对象o</div><div class="line"> */</div><div class="line">public boolean remove(Object o) &#123;</div><div class="line">    // 如果删除对象为null，则遍历链表查找node.item数据域为null的结点并移除</div><div class="line">    if (o == null) &#123;</div><div class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</div><div class="line">            if (x.item == null) &#123;</div><div class="line">                unlink(x);</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        // 从头开始遍历链表，并通过equals方法逐一比较node.item是否相等 </div><div class="line">        // 相等则对象一致，删除此对象。</div><div class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</div><div class="line">            if (o.equals(x.item)) &#123;</div><div class="line">                unlink(x);</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> * 移除指定结点x</div><div class="line"> */</div><div class="line">E unlink(Node&lt;E&gt; x) &#123;</div><div class="line">    // assert x != null;</div><div class="line">    // 记录要移除元素结点的数据域</div><div class="line">    final E element = x.item;</div><div class="line">    // 记录要移除元素结点的后继结点指针</div><div class="line">    final Node&lt;E&gt; next = x.next;</div><div class="line">    // 记录要移除元素结点的前驱结点指针</div><div class="line">    final Node&lt;E&gt; prev = x.prev;</div><div class="line"></div><div class="line">    // 如果要移除元素结点的前驱结点为空，则证明要删除结点为第一个结点</div><div class="line">    if (prev == null) &#123;</div><div class="line">        // 头结点指向要删除元素结点的后继结点</div><div class="line">        first = next;</div><div class="line">    &#125; else &#123;</div><div class="line">        // 要删除元素结点的前驱结点的后继指针指向要删除元素结点的后继结点</div><div class="line">        prev.next = next;</div><div class="line">        // 清空要删除结点的前驱结点指针信息，以帮助GC</div><div class="line">        x.prev = null;</div><div class="line">    &#125;</div><div class="line">    // 如果要移除元素结点的后继结点为空，则证明要删除结点为最后一个结点</div><div class="line">    if (next == null) &#123;</div><div class="line">        // 尾结点指向要删除元素结点的前驱结点</div><div class="line">        last = prev;</div><div class="line">    &#125; else &#123;</div><div class="line">        // 要删除元素结点的后继结点的前驱指针指向要删除元素结点的前驱结点</div><div class="line">        next.prev = prev;</div><div class="line">        // 清空要删除结点的后继结点指针信息，以帮助GC</div><div class="line">        x.next = null;</div><div class="line">    &#125;</div><div class="line">    // 清空要删除元素的数据域，以帮助GC</div><div class="line">    x.item = null;</div><div class="line">    // 记录链表长度的size - 1</div><div class="line">    size--;</div><div class="line">    modCount++;</div><div class="line">    // 返回移除元素结点的数据域</div><div class="line">    return element;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ArrayList和LinkedList-的区别"><a href="#ArrayList和LinkedList-的区别" class="headerlink" title="ArrayList和LinkedList 的区别"></a>ArrayList和LinkedList 的区别</h2><p>问：那您可以比较一下ArrayList和LinkedList吗?</p>
<p>答：</p>
<ol>
<li>LinkedList内部存储的是<code>Node&lt;E&gt;</code>，不仅要维护数据域，还要维护<code>prev</code>和<code>next</code>，如果LinkedList中的结点特别多，则LinkedList比ArrayList更占内存。</li>
<li>插入删除操作效率：<br>LinkedList在做插入和删除操作时，插入或删除头部或尾部时是高效的，操作越靠近中间位置的元素时，需要遍历查找，速度相对慢一些，如果在数据量较大时，每次插入或删除时遍历查找比较费时。所以LinkedList插入与删除，慢在遍历查找，快在只需要更改相关结点的引用地址。<br>ArrayList在做插入和删除操作时，插入或删除尾部时也一样是高效的，操作其他位置，则需要批量移动元素，所以ArrayList插入与删除，快在遍历查找，慢在需要批量移动元素。</li>
<li>循环遍历效率：</li>
</ol>
<ul>
<li>由于ArrayList实现了<code>RandomAccess</code>随机访问接口，所以使用for(int i = 0; i &lt; size; i++)遍历会比使用Iterator迭代器来遍历快：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">for (int i=0, n=list.size(); i &lt; n; i++) &#123;     </div><div class="line">    list.get(i);</div><div class="line">&#125;</div><div class="line"></div><div class="line">runs faster than this loop:</div><div class="line">for (Iterator i=list.iterator(); i.hasNext(); ) &#123; </div><div class="line">   i.next();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>而由于LinkedList未实现<code>RandomAccess</code>接口，所以推荐使用Iterator迭代器来遍历数据。</li>
<li>因此，如果我们需要频繁在列表的中部改变插入或删除元素时，建议使用LinkedList，否则，建议使用ArrayList，因为ArrayList遍历查找元素较快，并且只需存储元素的数据域，不需要额外记录其他数据的位置信息，可以节省内存空间。</li>
</ul>
<h2 id="LinkedList是线程安全的吗？"><a href="#LinkedList是线程安全的吗？" class="headerlink" title="LinkedList是线程安全的吗？"></a>LinkedList是线程安全的吗？</h2><p>问：LinkedList是线程安全的吗？</p>
<p>答：LinkedList不是线程安全的，如果多个线程同时对同一个LinkedList更改数据的话，会导致数据不一致或者数据污染。如果出现线程不安全的操作时，LinkedList会尽可能的抛出<code>ConcurrentModificationException</code>防止数据异常，当我们在对一个LinkedList进行遍历时，在遍历期间，我们是不能对LinkedList进行添加，删除等更改数据结构的操作的，否则也会抛出<code>ConcurrentModificationException</code>异常，此为fail-fast（快速失败）机制。从源码上分析，我们在<code>add,remove</code>等更改LinkedList数据时，都会导致modCount的改变，当<code>expectedModCount != modCount</code>时，则抛出<code>ConcurrentModificationException</code>。如果想要线程安全，可以考虑调用<code>Collections.synchronizedCollection(Collection&lt;T&gt; c)</code>方法。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line">private class ListItr implements ListIterator&lt;E&gt; &#123;</div><div class="line">    private Node&lt;E&gt; lastReturned;</div><div class="line">    private Node&lt;E&gt; next;</div><div class="line">    private int nextIndex;</div><div class="line">    private int expectedModCount = modCount;</div><div class="line"></div><div class="line">    ListItr(int index) &#123;</div><div class="line">        // assert isPositionIndex(index);</div><div class="line">        next = (index == size) ? null : node(index);</div><div class="line">        nextIndex = index;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public boolean hasNext() &#123;</div><div class="line">        return nextIndex &lt; size;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public E next() &#123;</div><div class="line">        checkForComodification();</div><div class="line">        if (!hasNext())</div><div class="line">            throw new NoSuchElementException();</div><div class="line"></div><div class="line">        lastReturned = next;</div><div class="line">        next = next.next;</div><div class="line">        nextIndex++;</div><div class="line">        return lastReturned.item;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public boolean hasPrevious() &#123;</div><div class="line">        return nextIndex &gt; 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public E previous() &#123;</div><div class="line">        checkForComodification();</div><div class="line">        if (!hasPrevious())</div><div class="line">            throw new NoSuchElementException();</div><div class="line"></div><div class="line">        lastReturned = next = (next == null) ? last : next.prev;</div><div class="line">        nextIndex--;</div><div class="line">        return lastReturned.item;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int nextIndex() &#123;</div><div class="line">        return nextIndex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int previousIndex() &#123;</div><div class="line">        return nextIndex - 1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void remove() &#123;</div><div class="line">        checkForComodification();</div><div class="line">        if (lastReturned == null)</div><div class="line">            throw new IllegalStateException();</div><div class="line"></div><div class="line">        Node&lt;E&gt; lastNext = lastReturned.next;</div><div class="line">        unlink(lastReturned);</div><div class="line">        if (next == lastReturned)</div><div class="line">            next = lastNext;</div><div class="line">        else</div><div class="line">            nextIndex--;</div><div class="line">        lastReturned = null;</div><div class="line">        expectedModCount++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void set(E e) &#123;</div><div class="line">        if (lastReturned == null)</div><div class="line">            throw new IllegalStateException();</div><div class="line">        checkForComodification();</div><div class="line">        lastReturned.item = e;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void add(E e) &#123;</div><div class="line">        checkForComodification();</div><div class="line">        lastReturned = null;</div><div class="line">        if (next == null)</div><div class="line">            linkLast(e);</div><div class="line">        else</div><div class="line">            linkBefore(e, next);</div><div class="line">        nextIndex++;</div><div class="line">        expectedModCount++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;</div><div class="line">        Objects.requireNonNull(action);</div><div class="line">        while (modCount == expectedModCount &amp;&amp; nextIndex &lt; size) &#123;</div><div class="line">            action.accept(next.item);</div><div class="line">            lastReturned = next;</div><div class="line">            next = next.next;</div><div class="line">            nextIndex++;</div><div class="line">        &#125;</div><div class="line">        checkForComodification();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    final void checkForComodification() &#123;</div><div class="line">        if (modCount != expectedModCount)</div><div class="line">            throw new ConcurrentModificationException();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>LinkedList的结论已在第三个问题中展现了一部分了，所以不再重复说明了，我以面试问答的形式和大家一同学习了LinkedList，由于没有时间画图，可能此次没有ArrayList说的那么清楚，如果大家有看不懂的地方，请自行看一下关于链表的数据结构吧。如果此文对你有帮助，麻烦点个喜欢，谢谢各位。</p>
]]></content>
      
        <categories>
            
            <category> LinkedList </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础数据类型 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HashMap 的详细分析]]></title>
      <url>/2017/12/09/HashMap%20%E7%9A%84%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="HashMap-的详细分析"><a href="#HashMap-的详细分析" class="headerlink" title="HashMap 的详细分析"></a>HashMap 的详细分析</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这次我和大家一起学习<code>HashMap</code>，<code>HashMap</code>我们在工作中经常会使用，而且面试中也很频繁会问到，因为它里面蕴含着很多知识点，可以很好的考察个人基础。但一个这么重要的东西，我为什么没有在一开始就去学习它呢，因为它是由多种基础的数据结构和一些代码设计思想组成的。我们要学习了这些基础，再学习<code>HashMap</code>，这样我们才能更好的去理解它。古人云：无欲速，无见小利。欲速则不达，见小利则大事不成。</p>
<a id="more"></a>
<p><code>HashMap</code>其实就是<code>ArrayList</code>和<code>LinkedList</code>的数据结构加上<code>hashCode</code>和<code>equals</code>方法的思想设计出来的。没有理解上述说的知识点的同学可以翻开我过往的文章记录。</p>
<p>下面我就以面试问答的形式学习我们的——<code>HashMap</code>（源码分析基于JDK8，辅以JDK7），问答内容只是对<code>HashMap</code>的一个总结归纳，因为现时已经有大牛把<code>HashMap</code>通俗易懂的剖析了一遍，我学习<code>HashMap</code>也是主要通过这篇文章学习的，强烈推荐：美团点评技术团队的<a href="https://link.juejin.im/?target=https%3A%2F%2Ftech.meituan.com%2Fjava-hashmap.html" target="_blank" rel="external">Java 8系列之重新认识HashMap</a></p>
<h1 id="问答内容"><a href="#问答内容" class="headerlink" title="问答内容"></a>问答内容</h1><h2 id="HashMap-的主要用途"><a href="#HashMap-的主要用途" class="headerlink" title="HashMap 的主要用途"></a>HashMap 的主要用途</h2><p>问：<code>HashMap</code>有用过吗？您能给我说说他的主要用途吗？</p>
<p>答：</p>
<ul>
<li>有用过，我在平常工作中经常会用到<code>HashMap</code>这种数据结构，<code>HashMap</code>是基于<code>Map</code>接口实现的一种键-值对<code>&lt;key,value&gt;</code>的存储结构，允许<code>null</code>值，同时非有序，非同步(即线程不安全)。<code>HashMap</code>的底层实现是数组 + 链表 + 红黑树（JDK1.8增加了红黑树部分）。它存储和查找数据时，是根据键<code>key</code>的<code>hashCode</code>的值计算出具体的存储位置。<code>HashMap</code>最多只允许一条记录的键<code>key</code>为<code>null</code>，<code>HashMap</code>增删改查等常规操作都有不错的执行效率，是<code>ArrayList</code>和<code>LinkedList</code>等数据结构的一种折中实现。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个HashMap，如果没有指定初始大小，默认底层hash表数组的大小为16</span></div><div class="line">HashMap&lt;String, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</div><div class="line"><span class="comment">// 往容器里面添加元素</span></div><div class="line">hashMap.put(<span class="string">"小明"</span>, <span class="string">"好帅"</span>);</div><div class="line">hashMap.put(<span class="string">"老王"</span>, <span class="string">"坑爹货"</span>);</div><div class="line">hashMap.put(<span class="string">"老铁"</span>, <span class="string">"没毛病"</span>);</div><div class="line">hashMap.put(<span class="string">"掘金"</span>, <span class="string">"好地方"</span>);</div><div class="line">hashMap.put(<span class="string">"王五"</span>, <span class="string">"别搞事"</span>);</div><div class="line"><span class="comment">// 获取key为小明的元素 好帅</span></div><div class="line">String element = hashMap.get(<span class="string">"小明"</span>);</div><div class="line"><span class="comment">// value : 好帅</span></div><div class="line">System.out.println(element);</div><div class="line"><span class="comment">// 移除key为王五的元素</span></div><div class="line">String removeElement = hashMap.remove(<span class="string">"王五"</span>);</div><div class="line"><span class="comment">// value : 别搞事</span></div><div class="line">System.out.println(removeElement);</div><div class="line"><span class="comment">// 修改key为小明的元素的值value 为 其实有点丑</span></div><div class="line">hashMap.replace(<span class="string">"小明"</span>, <span class="string">"其实有点丑"</span>);</div><div class="line"><span class="comment">// &#123;老铁=没毛病, 小明=其实有点丑, 老王=坑爹货, 掘金=好地方&#125;</span></div><div class="line">System.out.println(hashMap);</div><div class="line"><span class="comment">// 通过put方法也可以达到修改对应元素的值的效果</span></div><div class="line">hashMap.put(<span class="string">"小明"</span>, <span class="string">"其实还可以啦,开玩笑的"</span>);</div><div class="line"><span class="comment">// &#123;老铁=没毛病, 小明=其实还可以啦,开玩笑的, 老王=坑爹货, 掘金=好地方&#125;</span></div><div class="line">System.out.println(hashMap);</div><div class="line"><span class="comment">// 判断key为老王的元素是否存在(捉奸老王)</span></div><div class="line"><span class="keyword">boolean</span> isExist = hashMap.containsKey(<span class="string">"老王"</span>);</div><div class="line"><span class="comment">// true , 老王竟然来搞事</span></div><div class="line">System.out.println(isExist);</div><div class="line"><span class="comment">// 判断是否有 value = "坑爹货" 的人</span></div><div class="line"><span class="keyword">boolean</span> isHasSomeOne = hashMap.containsValue(<span class="string">"坑爹货"</span>);</div><div class="line"><span class="comment">// true 老王是坑爹货</span></div><div class="line">System.out.println(isHasSomeOne);</div><div class="line"><span class="comment">// 查看这个容器里面还有几个家伙 value : 4</span></div><div class="line">System.out.println(hashMap.size());</div></pre></td></tr></table></figure>
<ul>
<li><code>HashMap</code>的底层实现是数组 + 链表 + 红黑树（JDK1.8增加了红黑树部分），核心组成元素有：</li>
</ul>
<ol>
<li><code>int size;</code>用于记录<code>HashMap</code>实际存储元素的个数；</li>
<li><code>float loadFactor;</code>负载因子（默认是0.75，此属性后面详细解释）。</li>
<li><code>int threshold;</code>下一次扩容时的阈值，达到阈值便会触发扩容机制<code>resize</code>（阈值 threshold = 容器容量 capacity * 负载因子 load factor）。也就是说，在容器定义好容量之后，负载因子越大，所能容纳的键值对元素个数就越多。</li>
<li><code>Node&lt;K,V&gt;[] table;</code> 底层数组，充当哈希表的作用，用于存储对应hash位置的元素<code>Node&lt;K,V&gt;</code>，此数组长度总是2的N次幂。（具体原因后面详细解释）</li>
</ol>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></div><div class="line">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> &#123;</div><div class="line">·····</div><div class="line"></div><div class="line">    <span class="comment">/* ---------------- Fields -------------- */</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 哈希表，在第一次使用到时进行初始化，重置大小是必要的操作，</div><div class="line">     * 当分配容量时，长度总是2的N次幂。</div><div class="line">     */</div><div class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 实际存储的key - value 键值对 个数</div><div class="line">     */</div><div class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 下一次扩容时的阈值 </div><div class="line">     * (阈值 threshold = 容器容量 capacity * 负载因子 load factor).</div><div class="line">     * <span class="doctag">@serial</span></div><div class="line">     */</div><div class="line">    <span class="keyword">int</span> threshold;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 哈希表的负载因子</div><div class="line">     *</div><div class="line">     * <span class="doctag">@serial</span></div><div class="line">     */</div><div class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</div><div class="line"></div><div class="line">·····</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>其中<code>Node&lt;K,V&gt;[] table;</code>哈希表存储的核心元素是<code>Node&lt;K,V&gt;</code>,<code>Node&lt;K,V&gt;</code>包含：</li>
</ul>
<ol>
<li><code>final int hash;</code>元素的哈希值，决定元素存储在<code>Node&lt;K,V&gt;[] table;</code>哈希表中的位置。由<code>final</code>修饰可知，当<code>hash</code>的值确定后，就不能再修改。</li>
<li><code>final K key;</code> 键，由<code>final</code>修饰可知，当<code>key</code>的值确定后，就不能再修改。</li>
<li><code>V value;</code> 值</li>
<li><code>Node&lt;K,V&gt; next;</code> 记录下一个元素结点(单链表结构，用于解决hash冲突)</li>
</ol>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 定义HashMap存储元素结点的底层实现</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;<span class="comment">//元素的哈希值 由final修饰可知，当hash的值确定后，就不能再修改</span></div><div class="line">    <span class="keyword">final</span> K key;<span class="comment">// 键，由final修饰可知，当key的值确定后，就不能再修改</span></div><div class="line">    V value; <span class="comment">// 值</span></div><div class="line">    Node&lt;K,V&gt; next; <span class="comment">// 记录下一个元素结点(单链表结构，用于解决hash冲突)</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Node结点构造方法</div><div class="line">     */</div><div class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</div><div class="line">        <span class="keyword">this</span>.hash = hash;<span class="comment">//元素的哈希值</span></div><div class="line">        <span class="keyword">this</span>.key = key;<span class="comment">// 键</span></div><div class="line">        <span class="keyword">this</span>.value = value; <span class="comment">// 值</span></div><div class="line">        <span class="keyword">this</span>.next = next;<span class="comment">// 记录下一个元素结点</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 为Node重写hashCode方法，值为：key的hashCode 异或 value的hashCode </div><div class="line">     * 运算作用就是将2个hashCode的二进制中，同一位置相同的值为0，不同的为1。</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 修改某一元素的值</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</div><div class="line">        V oldValue = value;</div><div class="line">        value = newValue;</div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 为Node重写equals方法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</div><div class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</div><div class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</div><div class="line">                Objects.equals(value, e.getValue()))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://user-gold-cdn.xitu.io/2017/10/19/db63a0bc793f06e3d80ba8885e91c798?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="hashMap内存结构图 - 图片来自于《美团点评技术团队文章》">hashMap内存结构图 - 图片来自于《美团点评技术团队文章》</p>
<h2 id="HashMap-常用操作的底层实现原理"><a href="#HashMap-常用操作的底层实现原理" class="headerlink" title="HashMap 常用操作的底层实现原理"></a>HashMap 常用操作的底层实现原理</h2><p>问：您能说说<code>HashMap</code>常用操作的底层实现原理吗？如存储<code>put(K key, V value)</code>，查找<code>get(Object key)</code>，删除<code>remove(Object key)</code>，修改<code>replace(K key, V value)</code>等操作。</p>
<p>答：</p>
<ul>
<li>调用<code>put(K key, V value)</code>操作添加<code>key-value</code>键值对时，进行了如下操作：</li>
</ul>
<ol>
<li>判断哈希表<code>Node&lt;K,V&gt;[] table</code>是否为空或者<code>null</code>，是则执行<code>resize()</code>方法进行扩容。</li>
<li>根据插入的键值<code>key</code>的<code>hash</code>值，通过<code>(n - 1) &amp; hash</code>当前元素的<code>hash</code>值 &amp; <code>hash</code>表长度 - 1（实际就是 <code>hash</code>值 % <code>hash</code>表长度） 计算出存储位置<code>table[i]</code>。如果存储位置没有元素存放，则将新增结点存储在此位置<code>table[i]</code>。</li>
<li>如果存储位置已经有键值对元素存在，则判断该位置元素的<code>hash</code>值和<code>key</code>值是否和当前操作元素一致，一致则证明是修改<code>value</code>操作，覆盖<code>value</code>即可。</li>
<li>当前存储位置即有元素，又不和当前操作元素一致，则证明此位置<code>table[i]</code>已经发生了hash冲突，则通过判断头结点是否是<code>treeNode</code>，如果是<code>treeNode</code>则证明此位置的结构是红黑树，已红黑树的方式新增结点。</li>
<li>如果不是红黑树，则证明是单链表，将新增结点插入至链表的最后位置，随后判断当前链表长度是否 大于等于 8，是则将当前存储位置的链表转化为红黑树。遍历过程中如果发现<code>key</code>已经存在，则直接覆盖<code>value</code>。</li>
<li>插入成功后，判断当前存储键值对的数量 大于 阈值<code>threshold</code> 是则扩容。</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2017/10/19/eb270f06461f7a70314b33b7a9cfe6ba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="hashMap put方法执行流程图- 图片来自于《美团点评技术团队文章》">hashMap put方法执行流程图- 图片来自于《美团点评技术团队文章》</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 添加key-value键值对</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> key 键</div><div class="line"> * <span class="doctag">@param</span> value 值</div><div class="line"> * <span class="doctag">@return</span> 如果原本存在此key，则返回旧的value值，如果是新增的key-     </div><div class="line"> *         value，则返回nulll</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="comment">//实际调用putVal方法进行添加 key-value 键值对操作</span></div><div class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 根据key 键 的 hashCode 通过 “扰动函数” 生成对应的 hash值</div><div class="line"> * 经过此操作后，使每一个key对应的hash值生成的更均匀，</div><div class="line"> * 减少元素之间的碰撞几率（后面详细说明）</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h;</div><div class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 添加key-value键值对的实际调用方法（重点）</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> hash key 键的hash值</div><div class="line"> * <span class="doctag">@param</span> key 键</div><div class="line"> * <span class="doctag">@param</span> value 值</div><div class="line"> * <span class="doctag">@param</span> onlyIfAbsent 此值如果是true, 则如果此key已存在value，则不执</div><div class="line"> * 行修改操作 </div><div class="line"> * <span class="doctag">@param</span> evict 此值如果是false，哈希表是在初始化模式</div><div class="line"> * <span class="doctag">@return</span> 返回原本的旧值, 如果是新增，则返回null</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line">               <span class="keyword">boolean</span> evict) &#123;</div><div class="line">    <span class="comment">// 用于记录当前的hash表</span></div><div class="line">    Node&lt;K,V&gt;[] tab; </div><div class="line">    <span class="comment">// 用于记录当前的链表结点</span></div><div class="line">    Node&lt;K,V&gt; p; </div><div class="line">    <span class="comment">// n用于记录hash表的长度，i用于记录当前操作索引index</span></div><div class="line">    <span class="keyword">int</span> n, i;</div><div class="line">    <span class="comment">// 当前hash表为空</span></div><div class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">        <span class="comment">// 初始化hash表，并把初始化后的hash表长度值赋值给n</span></div><div class="line">        n = (tab = resize()).length;</div><div class="line">    <span class="comment">// 1）通过 (n - 1) &amp; hash 当前元素的hash值 &amp; hash表长度 - 1</span></div><div class="line">    <span class="comment">// 2）确定当前元素的存储位置，此运算等价于 当前元素的hash值 % hash表的长度</span></div><div class="line">    <span class="comment">// 3）计算出的存储位置没有元素存在</span></div><div class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</div><div class="line">        <span class="comment">// 4) 则新建一个Node结点，在该位置存储此元素</span></div><div class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 当前存储位置已经有元素存在了(不考虑是修改的情况的话，就代表发生hash冲突了)</span></div><div class="line">        <span class="comment">// 用于存放新增结点</span></div><div class="line">        Node&lt;K,V&gt; e; </div><div class="line">        <span class="comment">// 用于临时存在某个key值</span></div><div class="line">        K k;</div><div class="line">        <span class="comment">// 1)如果当前位置已存在元素的hash值和新增元素的hash值相等</span></div><div class="line">        <span class="comment">// 2)并且key也相等，则证明是同一个key元素，想执行修改value操作</span></div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            e = p;<span class="comment">// 将当前结点引用赋值给e</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 如果当前结点是树结点</span></div><div class="line">            <span class="comment">// 则证明当前位置的链表已变成红黑树结构，则已红黑树结点结构新增元素</span></div><div class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line">        <span class="keyword">else</span> &#123;<span class="comment">// 排除上述情况，则证明已发生hash冲突，并hash冲突位置现时的结构是单链表结构</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">                <span class="comment">//遍历单链表，将新元素结点放置此链表的最后一位</span></div><div class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">// 将新元素结点放在此链表的最后一位</span></div><div class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                    <span class="comment">// 新增结点后，当前结点数量是否大于等于 阈值 8 </span></div><div class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                        <span class="comment">// 大于等于8则将链表转换成红黑树</span></div><div class="line">                        treeifyBin(tab, hash);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 如果链表中已经存在对应的key，则覆盖value</span></div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// 已存在对应key</span></div><div class="line">            V oldValue = e.value;</div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>) <span class="comment">//如果允许修改，则修改value为新值</span></div><div class="line">                e.value = value;</div><div class="line">            afterNodeAccess(e);</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ++modCount;</div><div class="line">    <span class="comment">// 当前存储键值对的数量 大于 阈值 是则扩容</span></div><div class="line">    <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line">       <span class="comment">// 重置hash大小，将旧hash表的数据逐一复制到新的hash表中（后面详细讲解）</span></div><div class="line">        resize();</div><div class="line">    afterNodeInsertion(evict);</div><div class="line">    <span class="comment">// 返回null，则证明是新增操作，而不是修改操作</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用<code>get(Object key)</code>操作根据键<code>key</code>查找对应的<code>key-value</code>键值对时，进行了如下操作：</li>
</ul>
<p>1.先调用 <code>hash(key)</code>方法计算出 <code>key</code> 的 <code>hash</code>值</p>
<p>2.根据查找的键值<code>key</code>的<code>hash</code>值，通过<code>(n - 1) &amp; hash</code>当前元素的<code>hash</code>值 &amp; <code>hash</code>表长度 - 1（实际就是 <code>hash</code>值 % <code>hash</code>表长度） 计算出存储位置<code>table[i]</code>，判断存储位置是否有元素存在 。</p>
<ul>
<li>如果存储位置有元素存放，则首先比较头结点元素，如果头结点的<code>key</code>的<code>hash</code>值 和 要获取的<code>key</code>的<code>hash</code>值相等，并且 头结点的<code>key</code>本身 和要获取的 <code>key</code> 相等，则返回该位置的头结点。</li>
<li>如果存储位置没有元素存放，则返回<code>null</code>。</li>
</ul>
<p>3.如果存储位置有元素存放，但是头结点元素不是要查找的元素，则需要遍历该位置进行查找。</p>
<p>4.先判断头结点是否是<code>treeNode</code>，如果是<code>treeNode</code>则证明此位置的结构是红黑树，以红色树的方式遍历查找该结点，没有则返回<code>null</code>。</p>
<p>5.如果不是红黑树，则证明是单链表。遍历单链表，逐一比较链表结点，链表结点的<code>key</code>的<code>hash</code>值 和 要获取的<code>key</code>的<code>hash</code>值相等，并且 链表结点的<code>key</code>本身 和要获取的 <code>key</code> 相等，则返回该结点，遍历结束仍未找到对应<code>key</code>的结点，则返回<code>null</code>。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 返回指定 key 所映射的 value 值</div><div class="line"> * 或者 返回 null 如果容器里不存在对应的key</div><div class="line"> *</div><div class="line"> * 更确切地讲，如果此映射包含一个满足 (key==null ? k==null :key.equals(k))</div><div class="line"> * 的从 k 键到 v 值的映射关系，</div><div class="line"> * 则此方法返回 v；否则返回 null。（最多只能有一个这样的映射关系。）</div><div class="line"> *</div><div class="line"> * 返回 null 值并不一定 表明该映射不包含该键的映射关系；</div><div class="line"> * 也可能该映射将该键显示地映射为 null。可使用containsKey操作来区分这两种情况。 </div><div class="line"> *</div><div class="line"> * <span class="doctag">@see</span> #put(Object, Object)</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    <span class="comment">// 1.先调用 hash(key)方法计算出 key 的 hash值</span></div><div class="line">    <span class="comment">// 2.随后调用getNode方法获取对应key所映射的value值</span></div><div class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 获取哈希表结点的方法实现</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> hash key 键的hash值</div><div class="line"> * <span class="doctag">@param</span> key 键</div><div class="line"> * <span class="doctag">@return</span> 返回对应的结点，如果结点不存在，则返回null</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</div><div class="line">    <span class="comment">// 用于记录当前的hash表 </span></div><div class="line">    Node&lt;K,V&gt;[] tab; </div><div class="line">    <span class="comment">// first用于记录对应hash位置的第一个结点，e充当工作结点的作用</span></div><div class="line">    Node&lt;K,V&gt; first, e; </div><div class="line">    <span class="comment">// n用于记录hash表的长度</span></div><div class="line">    <span class="keyword">int</span> n; </div><div class="line">    <span class="comment">// 用于临时存放Key</span></div><div class="line">    K k;</div><div class="line">    <span class="comment">// 通过 (n - 1) &amp; hash 当前元素的hash值 &amp; hash表长度 - 1</span></div><div class="line">    <span class="comment">// 判断当前元素的存储位置是否有元素存在 </span></div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;<span class="comment">//元素存在的情况</span></div><div class="line">       <span class="comment">// 如果头结点的key的hash值 和 要获取的key的hash值相等</span></div><div class="line">       <span class="comment">// 并且 头结点的key本身 和要获取的 key 相等</span></div><div class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node 总是检查头结点</span></div><div class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            <span class="comment">// 返回该位置的头结点</span></div><div class="line">            <span class="keyword">return</span> first;</div><div class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;<span class="comment">// 头结点不相等</span></div><div class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 如果当前结点是树结点</span></div><div class="line">                <span class="comment">// 则证明当前位置的链表已变成红黑树结构</span></div><div class="line">                <span class="comment">// 通过红黑树结点的方式获取对应key结点</span></div><div class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class="line">            <span class="keyword">do</span> &#123;<span class="comment">// 当前位置不是红黑树，则证明是单链表</span></div><div class="line">                <span class="comment">// 遍历单链表，逐一比较链表结点</span></div><div class="line">                <span class="comment">// 链表结点的key的hash值 和 要获取的key的hash值相等</span></div><div class="line">                <span class="comment">// 并且 链表结点的key本身 和要获取的 key 相等</span></div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="comment">// 找到对应的结点则返回</span></div><div class="line">                    <span class="keyword">return</span> e;</div><div class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 通过上述查找均无找到，则返回null</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用<code>remove(Object key)</code>操作根据键<code>key</code>删除对应的<code>key-value</code>键值对时，进行了如下操作：</li>
</ul>
<p>1.先调用 <code>hash(key)</code>方法计算出 <code>key</code> 的 <code>hash</code>值</p>
<p>2.根据查找的键值<code>key</code>的<code>hash</code>值，通过<code>(n - 1) &amp; hash</code>当前元素的<code>hash</code>值 &amp; <code>hash</code>表长度 - 1（实际就是 <code>hash</code>值 % <code>hash</code>表长度） 计算出存储位置<code>table[i]</code>，判断存储位置是否有元素存在 。</p>
<ul>
<li>如果存储位置有元素存放，则首先比较头结点元素，如果头结点的<code>key</code>的<code>hash</code>值 和 要获取的<code>key</code>的<code>hash</code>值相等，并且 头结点的<code>key</code>本身 和要获取的 <code>key</code> 相等，则该位置的头结点即为要删除的结点，记录此结点至变量<code>node</code>中。</li>
<li>如果存储位置没有元素存放，则没有找到对应要删除的结点，则返回<code>null</code>。</li>
</ul>
<p>3.如果存储位置有元素存放，但是头结点元素不是要删除的元素，则需要遍历该位置进行查找。</p>
<p>4.先判断头结点是否是<code>treeNode</code>，如果是<code>treeNode</code>则证明此位置的结构是红黑树，以红色树的方式遍历查找并删除该结点，没有则返回<code>null</code>。</p>
<p>5.如果不是红黑树，则证明是单链表。遍历单链表，逐一比较链表结点，链表结点的<code>key</code>的<code>hash</code>值 和 要获取的<code>key</code>的<code>hash</code>值相等，并且 链表结点的<code>key</code>本身 和要获取的 <code>key</code> 相等，则此为要删除的结点，记录此结点至变量<code>node</code>中，遍历结束仍未找到对应<code>key</code>的结点，则返回<code>null</code>。</p>
<p>6.如果找到要删除的结点<code>node</code>，则判断是否需要比较<code>value</code>也是否一致，如果<code>value</code>值一致或者不需要比较<code>value</code>值，则执行删除结点操作，删除操作根据不同的情况与结构进行不同的处理。</p>
<ul>
<li>如果当前结点是树结点，则证明当前位置的链表已变成红黑树结构，通过红黑树结点的方式删除对应结点。</li>
<li>如果不是红黑树，则证明是单链表。如果要删除的是头结点，则当前存储位置<code>table[i]</code>的头结点指向删除结点的下一个结点。</li>
<li>如果要删除的结点不是头结点，则将要删除的结点的后继结点<code>node.next</code>赋值给要删除结点的前驱结点的<code>next</code>域，即<code>p.next = node.next;</code>。</li>
</ul>
<p>7.<code>HashMap</code>当前存储键值对的数量 - 1，并返回删除结点。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 从此映射中移除指定键的映射关系（如果存在）。</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span>  key 其映射关系要从映射中移除的键</div><div class="line"> * <span class="doctag">@return</span> 与 key 关联的旧值；如果 key 没有任何映射关系，则返回 null。</div><div class="line"> *        （返回 null 还可能表示该映射之前将 null 与 key 关联。）</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    <span class="comment">// 1.先调用 hash(key)方法计算出 key 的 hash值</span></div><div class="line">    <span class="comment">// 2.随后调用removeNode方法删除对应key所映射的结点</span></div><div class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</div><div class="line">        <span class="keyword">null</span> : e.value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 删除哈希表结点的方法实现</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> hash 键的hash值</div><div class="line"> * <span class="doctag">@param</span> key 键</div><div class="line"> * <span class="doctag">@param</span> value 用于比较的value值，当matchValue 是 true时才有效, 否则忽略</div><div class="line"> * <span class="doctag">@param</span> matchValue 如果是 true 只有当value相等时才会移除</div><div class="line"> * <span class="doctag">@param</span> movable 如果是 false当执行移除操作时，不删除其他结点</div><div class="line"> * <span class="doctag">@return</span> 返回删除结点node，不存在则返回null</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></div><div class="line">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable) &#123;</div><div class="line">    <span class="comment">// 用于记录当前的hash表</span></div><div class="line">    Node&lt;K,V&gt;[] tab; </div><div class="line">    <span class="comment">// 用于记录当前的链表结点</span></div><div class="line">    Node&lt;K,V&gt; p; </div><div class="line">    <span class="comment">// n用于记录hash表的长度，index用于记录当前操作索引index</span></div><div class="line">    <span class="keyword">int</span> n, index;</div><div class="line">    <span class="comment">// 通过 (n - 1) &amp; hash 当前元素的hash值 &amp; hash表长度 - 1</span></div><div class="line">    <span class="comment">// 判断当前元素的存储位置是否有元素存在 </span></div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;<span class="comment">// 元素存在的情况</span></div><div class="line">        <span class="comment">// node 用于记录找到的结点，e为工作结点</span></div><div class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; </div><div class="line">        K k; V v;</div><div class="line">       <span class="comment">// 如果头结点的key的hash值 和 要获取的key的hash值相等</span></div><div class="line">       <span class="comment">// 并且 头结点的key本身 和要获取的 key 相等</span></div><div class="line">       <span class="comment">// 则证明此头结点就是要删除的结点</span></div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            <span class="comment">// 记录要删除的结点的引用地址至node中</span></div><div class="line">            node = p;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;<span class="comment">// 头结点不相等</span></div><div class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)<span class="comment">// 如果当前结点是树结点</span></div><div class="line">                <span class="comment">// 则证明当前位置的链表已变成红黑树结构</span></div><div class="line">                <span class="comment">// 通过红黑树结点的方式获取对应key结点</span></div><div class="line">                <span class="comment">// 记录要删除的结点的引用地址至node中</span></div><div class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</div><div class="line">            <span class="keyword">else</span> &#123;<span class="comment">// 当前位置不是红黑树，则证明是单链表</span></div><div class="line">                <span class="keyword">do</span> &#123;</div><div class="line">                    <span class="comment">// 遍历单链表，逐一比较链表结点</span></div><div class="line">                    <span class="comment">// 链表结点的key的hash值 和 要获取的key的hash值相等</span></div><div class="line">                    <span class="comment">// 并且 链表结点的key本身 和要获取的 key 相等</span></div><div class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.key) == key ||</div><div class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</div><div class="line">                        <span class="comment">// 找到则记录要删除的结点的引用地址至node中，中断遍历</span></div><div class="line">                        node = e;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                    p = e;</div><div class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 如果找到要删除的结点，则判断是否需要比较value也是否一致</span></div><div class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</div><div class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</div><div class="line">            <span class="comment">// value值一致或者不需要比较value值，则执行删除结点操作</span></div><div class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 如果当前结点是树结点</span></div><div class="line">                <span class="comment">// 则证明当前位置的链表已变成红黑树结构</span></div><div class="line">                <span class="comment">// 通过红黑树结点的方式删除对应结点</span></div><div class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p) <span class="comment">// node 和 p相等，则证明删除的是头结点</span></div><div class="line">                <span class="comment">// 当前存储位置的头结点指向删除结点的下一个结点</span></div><div class="line">                tab[index] = node.next;</div><div class="line">            <span class="keyword">else</span> <span class="comment">// 删除的不是头结点</span></div><div class="line">                <span class="comment">// p是删除结点node的前驱结点，p的next改为记录要删除结点node的后继结点</span></div><div class="line">                p.next = node.next;</div><div class="line">            ++modCount;</div><div class="line">           <span class="comment">// 当前存储键值对的数量 - 1</span></div><div class="line">            --size;</div><div class="line">            afterNodeRemoval(node);</div><div class="line">            <span class="comment">// 返回删除结点</span></div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 不存在要删除的结点，则返回null</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用<code>replace(K key, V value)</code>操作根据键<code>key</code>查找对应的<code>key-value</code>键值对，随后替换对应的值<code>value</code>，进行了如下操作：</li>
</ul>
<ol>
<li>先调用 <code>hash(key)</code>方法计算出 <code>key</code> 的 <code>hash</code>值</li>
<li>随后调用<code>getNode</code>方法获取对应<code>key</code>所映射的<code>value</code>值 。</li>
<li>记录元素旧值，将新值赋值给元素，返回元素旧值，如果没有找到元素，则返回<code>null</code>。</li>
</ol>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 替换指定 key 所映射的 value 值</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> key 对应要替换value值元素的key键</div><div class="line"> * <span class="doctag">@param</span> value 要替换对应元素的新value值</div><div class="line"> * <span class="doctag">@return</span> 返回原本的旧值，如果没有找到key对应的元素，则返回null</div><div class="line"> * <span class="doctag">@since</span> 1.8 JDK1.8新增方法</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    <span class="comment">// 1.先调用 hash(key)方法计算出 key 的 hash值</span></div><div class="line">    <span class="comment">// 2.随后调用getNode方法获取对应key所映射的value值</span></div><div class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span>) &#123;<span class="comment">// 如果找到对应的元素</span></div><div class="line">        <span class="comment">// 元素旧值</span></div><div class="line">        V oldValue = e.value;</div><div class="line">        <span class="comment">// 将新值赋值给元素</span></div><div class="line">        e.value = value;</div><div class="line">        afterNodeAccess(e);</div><div class="line">        <span class="comment">// 返回元素旧值</span></div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 没有找到元素，则返回null</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="HashMap-若要新增的这个元素存在了或hash冲突了怎么办"><a href="#HashMap-若要新增的这个元素存在了或hash冲突了怎么办" class="headerlink" title="HashMap 若要新增的这个元素存在了或hash冲突了怎么办"></a>HashMap 若要新增的这个元素存在了或hash冲突了怎么办</h2><p>问 1：您上面说，存放一个元素时，先计算它的hash值确定它的存储位置，然后再把这个元素放到对应的位置上，那万一这个位置上面已经有元素存在呢，新增的这个元素怎么办？</p>
<p>问 2：<code>hash</code>冲突（或者叫<code>hash</code>碰撞）是什么？为什么会出现这种现象，如何解决<code>hash</code>冲突？</p>
<p>答：</p>
<ul>
<li><code>hash</code>冲突： 当我们调用<code>put(K key, V value)</code>操作添加<code>key-value</code>键值对，这个<code>key-value</code>键值对存放在的位置是通过扰动函数<code>(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>计算键<code>key</code>的<code>hash</code>值。随后将 这个<code>hash</code>值 % 模上 哈希表<code>Node&lt;K,V&gt;[] table</code>的长度 得到具体的存放位置。所以<code>put(K key, V value)</code>多个元素，是有可能计算出相同的存放位置。此现象就是<code>hash</code>冲突或者叫<code>hash</code>碰撞。</li>
<li>例子如下：<br>元素 A 的<code>hash</code>值 为 9，元素 B 的<code>hash</code>值 为 17。哈希表<code>Node&lt;K,V&gt;[] table</code>的长度为8。则元素 A 的存放位置为<code>9 % 8 = 1</code>，元素 B 的存放位置为<code>17 % 8 = 1</code>。两个元素的存放位置均为<code>table[1]</code>，发生了<code>hash</code>冲突。</li>
<li><code>hash</code>冲突的避免：既然会发生<code>hash</code>冲突，我们就应该想办法避免此现象的发生，解决这个问题最关键就是如果生成元素的<code>hash</code>值。Java是使用“扰动函数”生成元素的<code>hash</code>值。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * JDK 7 的 hash方法</div><div class="line"> */</div><div class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</div><div class="line"></div><div class="line">     h ^= k.hashCode();</div><div class="line"></div><div class="line">     h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</div><div class="line">     <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * JDK 8 的 hash方法</div><div class="line"> */</div><div class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">     <span class="keyword">int</span> h;</div><div class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>Java7做了4次16位右位移异或混合，Java 8中这步已经简化了，只做一次16位右位移异或混合，而不是四次，但原理是不变的。例子如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/10/19/acf1abecfd91bdd0d465c6707dc57bfc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="扰动函数执行例子 - 图片来自于《知乎》">扰动函数执行例子 - 图片来自于《知乎》</p>
<p>右位移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。</p>
<p>上述扰动函数的解释参考自：<a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F20733617" target="_blank" rel="external">JDK 源码中 HashMap 的 hash 方法原理是什么？</a></p>
<ul>
<li><code>hash</code>冲突解决：解决<code>hash</code>冲突的方法有很多，常见的有：开发定址法，<br>再散列法，链地址法，公共溢出区法（详细说明请查看我的文章<a href="https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F59b25f825188257e7e11500c" target="_blank" rel="external">JAVA基础-自问自答学hashCode和equals</a>）。<code>HashMap</code>是使用链地址法解决<code>hash</code>冲突的，当有冲突元素放进来时，会将此元素插入至此位置链表的最后一位，形成单链表。但是由于是单链表的缘故，每当通过<code>hash % length</code>找到该位置的元素时，均需要从头遍历链表，通过逐一比较<code>hash</code>值，找到对应元素。如果此位置元素过多，造成链表过长，遍历时间会大大增加，最坏情况下的时间复杂度为<code>O(N)</code>，造成查找效率过低。所以当存在位置的链表长度 大于等于 8 时，<code>HashMap</code>会将链表 转变为 红黑树，红黑树最坏情况下的时间复杂度为<code>O(logn)</code>。以此提高查找效率。</li>
</ul>
<h2 id="HashMap-的容量为什么一定要是2的n次方"><a href="#HashMap-的容量为什么一定要是2的n次方" class="headerlink" title="HashMap 的容量为什么一定要是2的n次方"></a>HashMap 的容量为什么一定要是2的n次方</h2><p>问：<code>HashMap</code>的容量为什么一定要是2的n次方？</p>
<p>答：</p>
<ul>
<li>因为调用<code>put(K key, V value)</code>操作添加<code>key-value</code>键值对时，具体确定此元素的位置是通过 <code>hash</code>值 % 模上 哈希表<code>Node&lt;K,V&gt;[] table</code>的长度 <code>hash % length</code> 计算的。但是”模”运算的消耗相对较大，通过位运算<code>h &amp; (length-1)</code>也可以得到取模后的存放位置，而位运算的运行效率高，但只有<code>length</code>的长度是2的n次方时，<code>h &amp; (length-1)</code> 才等价于 <code>h % length</code>。</li>
<li>而且当数组长度为2的n次幂的时候，不同的key算出的index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。</li>
</ul>
<p>例子：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/10/19/c61e51c7084d9506e8a3fd4d402022d8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="hash &amp;  (length-1)运算过程.jpg">hash &amp; (length-1)运算过程.jpg</p>
<ul>
<li>上图中，左边两组的数组长度是16（2的4次方），右边两组的数组长度是15。两组的<code>hash</code>值均为8和9。</li>
<li>当数组长度是15时，当它们和<code>1110</code>进行<code>&amp;</code>与运算（相同为1，不同为0）时，计算的结果都是<code>1000</code>，所以他们都会存放在相同的位置<code>table[8]</code>中，这样就发生了<code>hash</code>冲突，那么查询时就要遍历链表，逐一比较<code>hash</code>值，降低了查询的效率。</li>
<li>同时，我们可以发现，当数组长度为15的时候，<code>hash</code>值均会与<code>14（1110）</code>进行<code>&amp;</code>与运算，那么最后一位永远是0，而<code>0001</code>，<code>0011</code>，<code>0101</code>，<code>1001</code>，<code>1011</code>，<code>0111</code>，<code>1101</code>这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率。</li>
</ul>
<ul>
<li>所以，<code>HashMap</code>的容量是2的n次方，有利于提高计算元素存放位置时的效率，也降低了<code>hash</code>冲突的几率。因此，我们使用<code>HashMap</code>存储大量数据的时候，最好先预先指定容器的大小为2的n次方，即使我们不指定为2的n次方，<code>HashMap</code>也会把容器的大小设置成最接近设置数的2的n次方，如，设置<code>HashMap</code>的大小为 7 ，则<code>HashMap</code>会将容器大小设置成最接近7的一个2的n次方数，此值为 8 。</li>
</ul>
<p>上述回答参考自：<a href="https://link.juejin.im/?target=http%3A%2F%2Fannegu.iteye.com%2Fblog%2F539465" target="_blank" rel="external">深入理解HashMap</a></p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 返回一个比指定数cap大的，并且大小是2的n次方的数</div><div class="line"> * Returns a power of two size for the given target capacity.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</div><div class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="HashMap-的负载因子是什么，有什么作用"><a href="#HashMap-的负载因子是什么，有什么作用" class="headerlink" title="HashMap 的负载因子是什么，有什么作用"></a>HashMap 的负载因子是什么，有什么作用</h2><p>问：<code>HashMap</code>的负载因子是什么，有什么作用？</p>
<p>答：负载因子表示哈希表空间的使用程度（或者说是哈希表空间的利用率）。</p>
<ul>
<li>例子如下：<br>底层哈希表<code>Node&lt;K,V&gt;[] table</code>的容量大小<code>capacity</code>为 16，负载因子<code>load factor</code>为 0.75，则当存储的元素个数<code>size = capacity 16 * load factor 0.75</code>等于 12 时，则会触发<code>HashMap</code>的扩容机制，调用<code>resize()</code>方法进行扩容。</li>
<li>当负载因子越大，则<code>HashMap</code>的装载程度就越高。也就是能容纳更多的元素，元素多了，发生<code>hash</code>碰撞的几率就会加大，从而链表就会拉长，此时的查询效率就会降低。</li>
<li>当负载因子越小，则链表中的数据量就越稀疏，此时会对空间造成浪费，但是此时查询效率高。</li>
<li>我们可以在创建<code>HashMap</code> 时根据实际需要适当地调整<code>load factor</code> 的值；如果程序比较关心空间开销、内存比较紧张，可以适当地增加负载因子；如果程序比较关心时间开销，内存比较宽裕则可以适当的减少负载因子。通常情况下，默认负载因子 (0.75) 在时间和空间成本上寻求一种折衷，程序员无需改变负载因子的值。</li>
<li>因此，如果我们在初始化<code>HashMap</code>时，就预估知道需要装载<code>key-value</code>键值对的容量<code>size</code>，我们可以通过<code>size / load factor</code> 计算出我们需要初始化的容量大小<code>initialCapacity</code>，这样就可以避免<code>HashMap</code>因为存放的元素达到阈值<code>threshold</code>而频繁调用<code>resize()</code>方法进行扩容。从而保证了较好的性能。</li>
</ul>
<h2 id="HashMap-和-HashTable-的区别"><a href="#HashMap-和-HashTable-的区别" class="headerlink" title="HashMap 和 HashTable 的区别"></a>HashMap 和 HashTable 的区别</h2><p>问：您能说说<code>HashMap</code>和<code>HashTable</code>的区别吗？</p>
<p>答：<code>HashMap</code>和<code>HashTable</code>有如下区别：</p>
<p>1）容器整体结构：</p>
<ul>
<li><code>HashMap</code>的<code>key</code>和<code>value</code>都允许为<code>null</code>，<code>HashMap</code>遇到<code>key</code>为<code>null</code>的时候，调用<code>putForNullKey</code>方法进行处理，而对<code>value</code>没有处理。</li>
<li><code>Hashtable</code>的<code>key</code>和<code>value</code>都不允许为<code>null</code>。<code>Hashtable</code>遇到<code>null</code>，直接返回<code>NullPointerException</code>。</li>
</ul>
<p>2） 容量设定与扩容机制：</p>
<ul>
<li><code>HashMap</code>默认初始化容量为 16，并且容器容量一定是2的n次方，扩容时，是以原容量 2倍 的方式 进行扩容。</li>
<li><code>Hashtable</code>默认初始化容量为 11，扩容时，是以原容量 2倍 再加 1的方式进行扩容。即<code>int newCapacity = (oldCapacity &lt;&lt; 1) + 1;</code>。</li>
</ul>
<p>3） 散列分布方式（计算存储位置）：</p>
<ul>
<li><code>HashMap</code>是先将<code>key</code>键的<code>hashCode</code>经过扰动函数扰动后得到<code>hash</code>值，然后再利用 <code>hash &amp; (length - 1)</code>的方式代替取模，得到元素的存储位置。</li>
<li><code>Hashtable</code>则是除留余数法进行计算存储位置的（因为其默认容量也不是2的n次方。所以也无法用位运算替代模运算），<code>int index = (hash &amp; 0x7FFFFFFF) % tab.length;</code>。</li>
<li>由于<code>HashMap</code>的容器容量一定是2的n次方，所以能使用<code>hash &amp; (length - 1)</code>的方式代替取模的方式计算元素的位置提高运算效率，但<code>Hashtable</code>的容器容量不一定是2的n次方，所以不能使用此运算方式代替。</li>
</ul>
<p>4）线程安全（最重要）：</p>
<ul>
<li><code>HashMap</code> 不是线程安全，如果想线程安全，可以通过调用<code>synchronizedMap(Map&lt;K,V&gt; m)</code>使其线程安全。但是使用时的运行效率会下降，所以建议使用<code>ConcurrentHashMap</code>容器以此达到线程安全。</li>
<li><code>Hashtable</code>则是线程安全的，每个操作方法前都有<code>synchronized</code>修饰使其同步，但运行效率也不高，所以还是建议使用<code>ConcurrentHashMap</code>容器以此达到线程安全。</li>
</ul>
<p>因此，<code>Hashtable</code>是一个遗留容器，如果我们不需要线程同步，则建议使用<code>HashMap</code>，如果需要线程同步，则建议使用<code>ConcurrentHashMap</code>。</p>
<p>此处不再对Hashtable的源码进行逐一分析了，如果想深入了解的同学，可以参考此文章<br><a href="https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Fchdjj%2Farticle%2Fdetails%2F38581035" target="_blank" rel="external">Hashtable源码剖析</a></p>
<h2 id="HashMap-在多线程下如何处理，啥时会发生线程不安全"><a href="#HashMap-在多线程下如何处理，啥时会发生线程不安全" class="headerlink" title="HashMap 在多线程下如何处理，啥时会发生线程不安全"></a>HashMap 在多线程下如何处理，啥时会发生线程不安全</h2><p>问：您说<code>HashMap</code>不是线程安全的，那如果多线程下，它是如何处理的？并且什么情况下会发生线程不安全的情况？</p>
<p>答：</p>
<ul>
<li><code>HashMap</code>不是线程安全的，如果多个线程同时对同一个<code>HashMap</code>更改数据的话，会导致数据不一致或者数据污染。如果出现线程不安全的操作时，<code>HashMap</code>会尽可能的抛出<code>ConcurrentModificationException</code>防止数据异常，当我们在对一个<code>HashMap</code>进行遍历时，在遍历期间，我们是不能对<code>HashMap</code>进行添加，删除等更改数据的操作的，否则也会抛出<code>ConcurrentModificationException</code>异常，此为fail-fast（快速失败）机制。从源码上分析，我们在<code>put,remove</code>等更改<code>HashMap</code>数据时，都会导致modCount的改变，当<code>expectedModCount != modCount</code>时，则抛出<code>ConcurrentModificationException</code>。如果想要线程安全，可以考虑使用<code>ConcurrentHashMap</code>。</li>
<li>而且，在多线程下操作<code>HashMap</code>，由于存在扩容机制，当<code>HashMap</code>调用<code>resize()</code>进行自动扩容时，可能会导致死循环的发生。</li>
</ul>
<p>由于时间关系，我暂不带着大家一起去分析<code>resize()</code>方法导致死循环发生的现象造成原因了，迟点有空我会再补充上去，请见谅，大家可以参考如下文章：</p>
<p><a href="https://link.juejin.im/?target=https%3A%2F%2Ftech.meituan.com%2Fjava-hashmap.html" target="_blank" rel="external">Java 8系列之重新认识HashMap</a></p>
<p><a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.importnew.com%2F22011.html" target="_blank" rel="external">谈谈HashMap线程不安全的体现</a></p>
<h2 id="使用-HashMap-，选取什么对象作为-key-键比较好"><a href="#使用-HashMap-，选取什么对象作为-key-键比较好" class="headerlink" title="使用 HashMap ，选取什么对象作为 key 键比较好"></a>使用 HashMap ，选取什么对象作为 key 键比较好</h2><p>问：我们在使用<code>HashMap</code>时，选取什么对象作为<code>key</code>键比较好，为什么？</p>
<p>答：</p>
<ul>
<li>可变对象：指创建后自身状态能改变的对象。换句话说，可变对象是该对象在创建后它的哈希值可能被改变。</li>
<li>我们在使用<code>HashMap</code>时，最好选择不可变对象作为<code>key</code>。例如<code>String</code>，<code>Integer</code>等不可变类型作为<code>key</code>是非常明智的。</li>
<li>如果<code>key</code>对象是可变的，那么<code>key</code>的哈希值就可能改变。在<code>HashMap</code>中可变对象作为Key会造成数据丢失。因为我们再进行<code>hash &amp; (length - 1)</code>取模运算计算位置查找对应元素时，位置可能已经发生改变，导致数据丢失。</li>
</ul>
<p>详细例子说明请参考：<a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.importnew.com%2F13384.html" target="_blank" rel="external">危险！在HashMap中将可变对象用作Key</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><code>HashMap</code>是基于<code>Map</code>接口实现的一种键-值对<code>&lt;key,value&gt;</code>的存储结构，允许<code>null</code>值，同时非有序，非同步(即线程不安全)。<code>HashMap</code>的底层实现是数组 + 链表 + 红黑树（JDK1.8增加了红黑树部分）。</li>
<li><code>HashMap</code>定位元素位置是通过键<code>key</code>经过扰动函数扰动后得到<code>hash</code>值，然后再通过<code>hash &amp; (length - 1)</code>代替取模的方式进行元素定位的。</li>
<li><code>HashMap</code>是使用链地址法解决<code>hash</code>冲突的，当有冲突元素放进来时，会将此元素插入至此位置链表的最后一位，形成单链表。当存在位置的链表长度 大于等于 8 时，<code>HashMap</code>会将链表 转变为 红黑树，以此提高查找效率。</li>
<li><code>HashMap</code>的容量是2的n次方，有利于提高计算元素存放位置时的效率，也降低了<code>hash</code>冲突的几率。因此，我们使用<code>HashMap</code>存储大量数据的时候，最好先预先指定容器的大小为2的n次方，即使我们不指定为2的n次方，<code>HashMap</code>也会把容器的大小设置成最接近设置数的2的n次方，如，设置<code>HashMap</code>的大小为 7 ，则<code>HashMap</code>会将容器大小设置成最接近7的一个2的n次方数，此值为 8 。</li>
<li><code>HashMap</code>的负载因子表示哈希表空间的使用程度（或者说是哈希表空间的利用率）。当负载因子越大，则<code>HashMap</code>的装载程度就越高。也就是能容纳更多的元素，元素多了，发生<code>hash</code>碰撞的几率就会加大，从而链表就会拉长，此时的查询效率就会降低。当负载因子越小，则链表中的数据量就越稀疏，此时会对空间造成浪费，但是此时查询效率高。</li>
<li><code>HashMap</code>不是线程安全的，<code>Hashtable</code>则是线程安全的。但<code>Hashtable</code>是一个遗留容器，如果我们不需要线程同步，则建议使用<code>HashMap</code>，如果需要线程同步，则建议使用<code>ConcurrentHashMap</code>。</li>
<li>在多线程下操作<code>HashMap</code>，由于存在扩容机制，当<code>HashMap</code>调用<code>resize()</code>进行自动扩容时，可能会导致死循环的发生。</li>
<li>我们在使用<code>HashMap</code>时，最好选择不可变对象作为<code>key</code>。例如<code>String</code>，<code>Integer</code>等不可变类型作为<code>key</code>是非常明智的。</li>
</ol>
<ul>
<li>由于最近工作较忙，也有拖延症发作的问题，所以文章迟迟未能完成发布，现时完成的文章其实对我而言，也不算太好，但还是打算先发出来让大家看看，一起学习学习，看有什么不好的地方，我再慢慢改进，如果此文对你有帮助，请给个赞，谢谢大家。</li>
</ul>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://link.juejin.im/?target=https%3A%2F%2Ftech.meituan.com%2Fjava-hashmap.html" target="_blank" rel="external">Java 8系列之重新认识HashMap</a><br><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F20733617" target="_blank" rel="external">JDK 源码中 HashMap 的 hash 方法原理是什么？</a><br><a href="https://link.juejin.im/?target=http%3A%2F%2Fannegu.iteye.com%2Fblog%2F539465" target="_blank" rel="external">深入理解HashMap</a><br><a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.cnblogs.com%2Fyesiamhere%2Fp%2F6653135.html" target="_blank" rel="external">HashMap负载因子</a><br><a href="https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Fchdjj%2Farticle%2Fdetails%2F38581035" target="_blank" rel="external">Hashtable源码剖析</a><br><a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.importnew.com%2F13384.html" target="_blank" rel="external">危险！在HashMap中将可变对象用作Key</a><br><a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.importnew.com%2F22011.html" target="_blank" rel="external">谈谈HashMap线程不安全的体现</a></p>
]]></content>
      
        <categories>
            
            <category> HashMap </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础数据类型 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ArrayList 源码分析]]></title>
      <url>/2017/12/09/ArrayList%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="ArrayList-源码分析"><a href="#ArrayList-源码分析" class="headerlink" title="ArrayList 源码分析"></a>ArrayList 源码分析</h1><p><img src="http://orbs83j4x.bkt.clouddn.com/blog/171208/C88BKj3C76.png" alt="mark"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>以面试问答的形式学习我们的最常用的装载容器——<code>ArrayList</code>（源码分析基于JDK8）</p>
<a id="more"></a>
<h1 id="问答内容"><a href="#问答内容" class="headerlink" title="问答内容"></a>问答内容</h1><h2 id="ArrayList是什么，可以用来干嘛？"><a href="#ArrayList是什么，可以用来干嘛？" class="headerlink" title="ArrayList是什么，可以用来干嘛？"></a>ArrayList是什么，可以用来干嘛？</h2><p>问：ArrayList有用过吗？它是一个什么东西？可以用来干嘛？</p>
<p>答：有用过，ArrayList就是数组列表，主要用来装载数据，当我们装载的是基本类型的数据<code>int,long,boolean,short,byte...</code>的时候我们只能存储他们对应的包装类，它的主要底层实现是数组<code>Object[] elementData</code>。与它类似的是LinkedList，和LinkedList相比，它的查找和访问元素的速度较快，但新增，删除的速度较慢。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个ArrayList，如果没有指定初始大小，默认容器大小为10</span></div><div class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line"><span class="comment">// 往容器里面添加元素</span></div><div class="line">arrayList.add(<span class="string">"张三"</span>);</div><div class="line">arrayList.add(<span class="string">"李四"</span>);</div><div class="line">arrayList.add(<span class="string">"王五"</span>);</div><div class="line"><span class="comment">// 获取index下标为0的元素      张三</span></div><div class="line">String element = arrayList.get(<span class="number">0</span>);</div><div class="line"><span class="comment">// 删除index下标为1的元素      李四</span></div><div class="line">String removeElement = arrayList.remove(<span class="number">1</span>);</div></pre></td></tr></table></figure>
<p>ArrayList底层实现示意图</p>
<h2 id="ArrayList中不断添加数据会有什么问题吗？"><a href="#ArrayList中不断添加数据会有什么问题吗？" class="headerlink" title="ArrayList中不断添加数据会有什么问题吗？"></a>ArrayList中不断添加数据会有什么问题吗？</h2><p>问：您说它的底层实现是数组，但是数组的大小是定长的，如果我们不断的往里面添加数据的话，不会有问题吗？</p>
<p>答：ArrayList可以通过构造方法在初始化的时候指定底层数组的大小。</p>
<ul>
<li>通过无参构造方法的方式<code>ArrayList()</code>初始化，则赋值底层数组<code>Object[] elementData</code>为一个默认空数组<code>Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}</code>所以数组容量为0，只有真正对数据进行添加<code>add</code>时，才分配默认<code>DEFAULT_CAPACITY = 10</code>的初始容量。<br>示例代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义ArrayList默认容量为10</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="comment">// 空数组，当调用无参构造方法时默认复制这个空数组</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 真正保存数据的底层数组</span></div><div class="line"><span class="keyword">transient</span> Object[] elementData; </div><div class="line"></div><div class="line"><span class="comment">// ArrayList的实际元素数量</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 无参构造方法默认为空数组</span></div><div class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>通过指定容量初始大小的构造方法方式<code>ArrayList(int initialCapacity)</code>初始化，则赋值底层数组<code>Object[] elementData</code>为指定大小的数组<code>this.elementData = new Object[initialCapacity];</code><br>示例代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 通过构造方法出入指定的容量来设置默认底层数组大小 </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</div><div class="line">                                           initialCapacity);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>当我们添加的元素数量已经达到底层数组<code>Object[] elementData</code>的上限时，我们再往ArrayList元素，则会触发ArrayList的自动扩容机制，ArrayList会通过位运算<code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code>以1.5倍的方式初始化一个新的数组（如初始化数组大小为10，则扩容后的数组大小为15），然后使用<code>Arrays.copyOf(elementData, newCapacity);</code>方法将原数据的数据逐一复制到新数组上面去，以此达到ArrayList扩容的效果。虽然，<code>Arrays.copyOf(elementData, newCapacity);</code>方法最终调用的是<code>native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>是一个底层方法，效率还算可以，但如果我们在知道ArrayList想装多少个元素的情况下，却没有指定容器大小，则就会导致ArrayList频繁触发扩容机制，频繁进行底层数组之间的数据复制，大大降低使用效率。<br>示例代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="comment">//确保底层数组容量，如果容量不足，则扩容</span></div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>); </div><div class="line">    elementData[size++] = e;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line"></div><div class="line">    <span class="comment">// 容量不足，则调用grow方法进行扩容</span></div><div class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">        grow(minCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 扩容方法(重点)</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// 获得原容量大小</span></div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">    <span class="comment">// 新容量为原容量的1.5倍</span></div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</div><div class="line">    <span class="comment">// 再判断新容量是否已足够，如果扩容后仍然不足够，则复制为最小容量长度</span></div><div class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">        newCapacity = minCapacity;</div><div class="line">    <span class="comment">// 判断是否超过最大长度限制</span></div><div class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">        newCapacity = hugeCapacity(minCapacity);</div><div class="line">    <span class="comment">// 将原数组的数据复制至新数组， ArrayList的底层数组引用指向新数组</span></div><div class="line">    <span class="comment">// 如果数据量很大，重复扩容，则会影响效率</span></div><div class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>因此，在我们使用ArrayList的时候，如果知道最终的存储容量capacity，则应该在初始化的时候就指定ArrayList的容量<code>ArrayList(int initialCapacity)</code>，如果初始化时无法预知装载容量，但在使用过程中，得知最终容量，我们可以通过调用<code>ensureCapacity(int minCapacity)</code>方法来指定ArrayList的容量，并且，如果我们在使用途中，如果确定容量大小，但是由于之前每次扩容都扩充50%，所以会造成一定的存储空间浪费，我们可以调用<code>trimToSize()</code>方法将容器最小化到存储元素容量，进而消除这些存储空间浪费。例如：我们当前存储了11个元素，我们不会再添加但是当前的ArrayList的大小为15，有4个存储空间没有被使用，则调用<code>trimToSize()</code>方法后，则会重新创建一个容量为11的数组<code>Object[] elementData</code>，将原有的11个元素复制至新数组，达到节省内存空间的效果。<br>示例代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 将底层数组一次性指定到指定容量的大小</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</div><div class="line">        <span class="comment">// any size if not default element table </span></div><div class="line">         ? <span class="number">0</span></div><div class="line">        <span class="comment">// larger than default for default empty table. It's already</span></div><div class="line">        <span class="comment">// supposed to be at default size.</span></div><div class="line">        : DEFAULT_CAPACITY;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</div><div class="line">        ensureExplicitCapacity(minCapacity);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 将容器最小化到存储元素容量</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</div><div class="line">        elementData = (size == <span class="number">0</span>)</div><div class="line">          ? EMPTY_ELEMENTDATA</div><div class="line">          : Arrays.copyOf(elementData, size);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ArrayList怎么-删除数据，为什么访问速度快，删除新增速度慢-？"><a href="#ArrayList怎么-删除数据，为什么访问速度快，删除新增速度慢-？" class="headerlink" title="ArrayList怎么 删除数据，为什么访问速度快，删除新增速度慢 ？"></a>ArrayList怎么 删除数据，为什么访问速度快，删除新增速度慢 ？</h2><p>问：那它是怎么样删除元素的？您上面说到ArrayList访问元素速度较快，但是新增和删除的速度较慢，为什么呢？</p>
<p>答：</p>
<ul>
<li>通过源码我们可以得知，ArrayList删除元素时，先获取对应的删除元素，然后把要删除元素对应索引index后的元素逐一往前移动1位，最后将最后一个存储元素清空并返回删除元素，以此达到删除元素的效果。</li>
<li>当我们通过下标的方式去访问元素时，我们假设访问一个元素所花费的时间为K，则通过下标一步到位的方式访问元素，时间则为1K，用“大O”表示法表示，则时间复杂度为O(1)。所以ArrayList的访问数据的数据是比较快的。</li>
<li>当我们去添加元素<code>add(E e)</code>时，我们是把元素添加至末尾，不需要移动元素，此时的时间复杂度为O(1)，但我们把元素添加到指定位置，最坏情况下，我们将元素添加至第一个位置<code>add(int index, E element)</code>，则整个ArrayList的n-1个元素都要往前移动位置，导致底层数组发生n-1次复制。通常情况下，我们说的时间复杂度都是按最坏情况度量的，此时的时间复杂度为O(n)。删除元素同理，删除最后一个元素不需要移动元素，时间复杂度为O(1)，但删除第一个元素，则需要移动n-1个元素，最坏情况下的时间复杂度也是O(n)。</li>
<li>所以ArrayList访问元素速度较快，但是新增和删除的速度较慢。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 将元素添加至末尾</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="comment">// 确保底层数组容量，如果容量不足，则扩容</span></div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">    elementData[size++] = e;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 将元素添加至指定下标位置</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">     <span class="comment">// 检查下标是否在合法范围内</span></div><div class="line">    rangeCheckForAdd(index);</div><div class="line">    <span class="comment">// 确保底层数组容量，如果容量不足，则扩容</span></div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">    <span class="comment">// 将要添加的元素下标后的元素通过复制的方式逐一往后移动，腾出对应index下标的存储位置</span></div><div class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</div><div class="line">                     size - index);</div><div class="line">    <span class="comment">// 将新增元素存储至指定下标索引index</span></div><div class="line">    elementData[index] = element;</div><div class="line">    <span class="comment">// ArrayList的大小 + 1</span></div><div class="line">    size++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 通过下标索引的方式删除元素</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="comment">// 检查下标是否在合法范围内</span></div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    modCount++;</div><div class="line">    <span class="comment">// 直接通过下标去访问底层数组的元素</span></div><div class="line">    E oldValue = elementData(index);</div><div class="line"></div><div class="line">    <span class="comment">// 计算数组需要移动的元素个数</span></div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        <span class="comment">// 将要删除的元素下标后的元素通过复制的方式逐一往前移动</span></div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</div><div class="line">    <span class="comment">//将底层数组长度减1，并清空最后一个存储元素。</span></div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></div><div class="line">    <span class="comment">// 返回移除元素</span></div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ArrayList是线程安全的吗？"><a href="#ArrayList是线程安全的吗？" class="headerlink" title="ArrayList是线程安全的吗？"></a>ArrayList是线程安全的吗？</h2><p>问：ArrayList是线程安全的吗？</p>
<p>答：ArrayList不是线程安全的，如果多个线程同时对同一个ArrayList更改数据的话，会导致数据不一致或者数据污染。如果出现线程不安全的操作时，ArrayList会尽可能的抛出<code>ConcurrentModificationException</code>防止数据异常，当我们在对一个ArrayList进行遍历时，在遍历期间，我们是不能对ArrayList进行添加，修改，删除等更改数据的操作的，否则也会抛出<code>ConcurrentModificationException</code>异常，此为fail-fast（快速失败）机制。从源码上分析，我们在<code>add,remove,clear</code>等更改ArrayList数据时，都会导致modCount的改变，当<code>expectedModCount != modCount</code>时，则抛出<code>ConcurrentModificationException</code>。如果想要线程安全，可以考虑使用Vector、CopyOnWriteArrayList。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * AbstractList.Itr 的迭代器实现</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></div><div class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></div><div class="line">    <span class="comment">//期望的modCount</span></div><div class="line">    <span class="keyword">int</span> expectedModCount = modCount;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> cursor != size;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        checkForComodification();</div><div class="line">        <span class="keyword">int</span> i = cursor;</div><div class="line">        <span class="keyword">if</span> (i &gt;= size)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">        Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</div><div class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        cursor = i + <span class="number">1</span>;</div><div class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">        checkForComodification();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ArrayList.<span class="keyword">this</span>.remove(lastRet);</div><div class="line">            cursor = lastRet;</div><div class="line">            lastRet = -<span class="number">1</span>;</div><div class="line">            expectedModCount = modCount;</div><div class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span> </span>&#123;</div><div class="line">        Objects.requireNonNull(consumer);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = ArrayList.<span class="keyword">this</span>.size;</div><div class="line">        <span class="keyword">int</span> i = cursor;</div><div class="line">        <span class="keyword">if</span> (i &gt;= size) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">final</span> Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</div><div class="line">        <span class="keyword">if</span> (i &gt;= elementData.length) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</div><div class="line">            consumer.accept((E) elementData[i++]);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// update once at end of iteration to reduce heap write traffic</span></div><div class="line">        cursor = i;</div><div class="line">        lastRet = i - <span class="number">1</span>;</div><div class="line">        checkForComodification();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>如果在初始化的时候知道ArrayList的初始容量，请一开始就指定容量<code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(20);</code>,如果一开始不知道容量，中途才得知，请调用<code>list.ensureCapacity(20);</code>来扩充容量，如果数据已经添加完毕，但仍需要保存在内存中一段时间，请调用<code>list.trimToSize()</code>将容器最小化到存储元素容量，进而消除这些存储空间浪费。</li>
<li>ArrayList是以1.5倍的容量去扩容的，如初始容量是10，则容量依次递增扩充为：15，22，33，49。扩容后把原始数据从旧数组复制至新数组中。</li>
<li>ArrayList访问元素速度较快，下标方式访问元素，时间复杂度为O(1)，添加与删除速度较慢，时间复杂度均为O(n)。</li>
<li>ArrayList不是线程安全的，但是在发生并发行为时，它会尽可能的抛出<code>ConcurrentModificationException</code>，此为fail-fast机制。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> ArrayList </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础数据类型 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Maven仓库理解和优先级]]></title>
      <url>/2017/09/03/Maven-Priority/</url>
      <content type="html"><![CDATA[<p><img src="/images/maven-logo.png" alt="此处输入图片的描述"></p>
<p><strong>5 Seven 2017</strong></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用 maven 也有一段时间了，有时候在配置 repository,mirror,profile的时候，总会导致 jar 拉取不到。所以认真的分析了 maven 获取 jar 包时候的优先级。<br><a id="more"></a></p>
<h2 id="Maven-仓库的分类"><a href="#Maven-仓库的分类" class="headerlink" title="Maven 仓库的分类"></a>Maven 仓库的分类</h2><p>仓库分类：本地仓库和远程仓库。Maven根据坐标寻找构件的时候，它先会查看本地仓库，如果本地仓库存在构件，则直接使用；如果没有，则从远程仓库查找，找到后，下载到本地。</p>
<p>1）本地仓库<br>默认情况下，每个用户在自己的用户目录下都有一个路径名为.m2/repository/的仓库目录。我们也可以在 settings.xml 文件配置本地仓库的地址</p>
<p>2）远程仓库<br>本地仓库好比书房，而远程仓库就像是书店。对于Maven来说，每个用户只有一个本地仓库，但是可以配置多个远程仓库。<br>下·</p>
<blockquote>
<p>我们可以在 pom 文件配置多个 repository，但是随着项目越来也多我们每次都要在 pom 文件配置比较麻烦，所以我们可以在<br>settings 文件配置 profile （私服）。这样我们每次创建新项目的时候就可以不用配置 repository。</p>
</blockquote>
<p>3）中央仓库<br>Maven必须要知道至少一个可用的远程仓库，中央仓库就是这样一个默认的远程仓库，Maven 默认有一个 super pom 文件。<br>maven super pom 文件位置<br>D:\apache-maven-3.0.4\lib 下的 maven-model-builder-3.0.4.jar 中的 org/apache/maven/model/pom-4.0.0.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">··· 省略其他</div><div class="line">  <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Central Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.maven.apache.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></div><div class="line">···</div></pre></td></tr></table></figure></p>
<p>这个时候我们就明白了，我们在 settings 文件配置一个 mirror 的 mirrorOf 为 central 的镜像就会替代 ‘中央仓库’ 的原因了。</p>
<h3 id="Maven-镜像"><a href="#Maven-镜像" class="headerlink" title="Maven 镜像"></a>Maven 镜像</h3><p>镜像（Mirroring）是冗余的一种类型，一个磁盘上的数据在另一个磁盘上存在一个完全相同的副本即为镜像。<br>为什么配置镜像?</p>
<blockquote>
<p>1.一句话，你有的我也有，你没有的我也有。（拥有远程仓库的所有 jar，包括远程仓库没有的 jar）<br>2.还是一句话，我跑的比你快。（有时候远程仓库获取 jar 的速度可能比镜像慢，这也是为什么我们一般要配置中央仓库的原因，外国的 maven 仓库一般获取速度比较慢）</p>
</blockquote>
<p>如果你配置 maven 镜像不是为了以上两点，那基本就不用配置镜像了。<br><strong>注意:当远程仓库被镜像匹配到的，则在获取 jar 包将从镜像仓库获取，而不是我们配置的 repository 仓库, repository 将失去作用</strong></p>
<h4 id="mirrorOf-标签"><a href="#mirrorOf-标签" class="headerlink" title="mirrorOf 标签"></a>mirrorOf 标签</h4><p>mirrorOf 标签里面放置的是 repository 配置的 id,为了满足一些复杂的需求，Maven还支持更高级的镜像配置：</p>
<pre><code>external:* = 不在本地仓库的文件才从该镜像获取
repo,repo1 = 远程仓库 repo 和 repo1 从该镜像获取
*,!repo1 =  所有远程仓库都从该镜像获取，除 repo1 远程仓库以外
* = 所用远程仓库都从该镜像获取
</code></pre><h3 id="私服"><a href="#私服" class="headerlink" title="私服"></a>私服</h3><p>私服是一种特殊的远程Maven仓库，它是架设在局域网内的仓库服务，私服一般被配置为互联网远程仓库的镜像，供局域网内的Maven用户使用。<br>当Maven需要下载构件的时候，先向私服请求，如果私服上不存在该构件，则从外部的远程仓库下载，同时缓存在私服之上，然后为Maven下载请求提供下载服务，另外，对于自定义或第三方的jar可以从本地上传到私服，供局域网内其他maven用户使用。<br>优点主要有：</p>
<pre><code>1. 节省外网宽带
2. 加速Maven构建
3. 部署第三方构件：可以将公司项目的 jar 发布到私服上，方便项目与项目之间的调用
4. 提高稳定性、增强控制：原因是外网不稳定
5. 降低中央仓库的负荷：原因是中央仓库访问量太大
</code></pre><p><strong>上面大概介绍了 Maven 仓库概念，接下来我们进入正题</strong></p>
<h2 id="Maven-仓库优先级"><a href="#Maven-仓库优先级" class="headerlink" title="Maven 仓库优先级"></a>Maven 仓库优先级</h2><p>为了方便测试，我准备了以下几个仓库</p>
<ul>
<li>172.16.xxx.xxx  远程仓库 （私服）</li>
<li>dev.xxx.wiki 远程仓库  （远程）</li>
<li>localhost 仓库 是我自己在本机搭建的一个仓库 （镜像）</li>
<li>maven.aliyun.com 中央仓库（中央）</li>
</ul>
<h3 id="本地仓库优先级"><a href="#本地仓库优先级" class="headerlink" title="本地仓库优先级"></a>本地仓库优先级</h3><p><img src="/images/example.png" alt="此处输入图片的描述"><br>Maven 本地仓库拥有该包，而远程、镜像、中央、私服都不包含该包。我们来看下 Maven 是怎么获取的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">.......</div><div class="line"></div><div class="line"><span class="comment">// 使用本地仓库，优先级(priority)为 10</span></div><div class="line">[DEBUG] Using local repository at E:\OperSource</div><div class="line">[DEBUG] Using manager EnhancedLocalRepositoryManager with priority <span class="number">10.0</span> <span class="keyword">for</span> E:\OperSource</div><div class="line">[INFO] Scanning <span class="keyword">for</span> projects..</div><div class="line"></div><div class="line">........</div><div class="line"></div><div class="line">[INFO] Installing C:\Users\swipal\Desktop\abc\demo\target\demo-<span class="number">1.0</span>-SNAPSHOT.jar to E:\OperSource\com\cjf\demo\<span class="number">1.0</span>-SNAPSHOT\demo-<span class="number">1.0</span>-SNAPSHOT.jar</div><div class="line">[DEBUG] Writing tracking file E:\OperSource\com\cjf\demo\<span class="number">1.0</span>-SNAPSHOT\_remote.repositories</div><div class="line">[INFO] Installing C:\Users\swipal\Desktop\abc\demo\pom.xml to E:\OperSource\com\cjf\demo\<span class="number">1.0</span>-SNAPSHOT\demo-<span class="number">1.0</span>-SNAPSHOT.pom</div><div class="line">[DEBUG] Writing tracking file E:\OperSource\com\cjf\demo\<span class="number">1.0</span>-SNAPSHOT\_remote.repositories</div><div class="line">[DEBUG] Installing com.cjf:demo:<span class="number">1.0</span>-SNAPSHOT/maven-metadata.xml to E:\OperSource\com\cjf\demo\<span class="number">1.0</span>-SNAPSHOT\maven-metadata-local.xml</div><div class="line">[DEBUG] Installing com.cjf:demo/maven-metadata.xml to E:\OperSource\com\cjf\demo\maven-metadata-local.xml</div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line">[INFO] BUILD SUCCESS</div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line">[INFO] Total time: <span class="number">1.874</span> s</div><div class="line">[INFO] Finished at: <span class="number">2017</span>-<span class="number">07</span>-<span class="number">07</span>T10:<span class="number">37</span>:<span class="number">32</span>+<span class="number">08</span>:<span class="number">00</span></div><div class="line">[INFO] Final Memory: <span class="number">23</span>M/<span class="number">219</span>M</div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line"></div><div class="line">Process finished with exit code <span class="number">0</span></div></pre></td></tr></table></figure></p>
<p>从上面可以看出 Maven 一开始就使用本地仓库，并将本地仓库的优先级定制为 10 , 最后 jar 包也在本地仓库找到，Maven 成功打包。</p>
<h3 id="远程仓库优先级"><a href="#远程仓库优先级" class="headerlink" title="远程仓库优先级"></a>远程仓库优先级</h3><p>前面我们知道了，本地仓库的优先级是最高的，现在我们继续研究远程仓库的优先级（以下的所有例子，都默认本地仓库不拥有我们需要的包）</p>
<p>这一次我们默认配置 <strong>profile</strong>（私服）为 172.16.xxx.xxx 远程仓库, <strong>repository</strong> 为 dev.xxx.wiki 远程仓库,<strong>mirror</strong> 为本地 localhost 仓库，还配置了一个 <strong>mirrorOf  为 central</strong> 远程仓库为 maven.aliyun.com 的中央仓库,</p>
<p>以下是配置信息<br>settings.xml 文件<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">······</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span> </div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">mirror</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>localhost<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Public Repositories<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>   <span class="comment">&lt;!--拦截 pom 文件配置的 repository--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </div><div class="line">  <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span>  </div><div class="line">  </div><div class="line">  <span class="tag">&lt;<span class="name">mirror</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>localhost2<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Public Repositories<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>foo2<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>   <span class="comment">&lt;!--配置一个拦截 foo2 的远程仓库的镜像--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/repository/maven-snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </div><div class="line">  <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span>  </div><div class="line">  </div><div class="line">  <span class="tag">&lt;<span class="name">mirror</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>  <span class="comment">&lt;!--覆盖 Maven 默认的配置的中央仓库--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </div><div class="line">  <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span> </div><div class="line"> </div><div class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!--配置私服--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span> </div><div class="line">  <span class="tag">&lt;<span class="name">profile</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span> </div><div class="line">      <span class="tag">&lt;<span class="name">repository</span>&gt;</span> </div><div class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>public<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Public Repositories<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://172.16.xxx.xxx:8081/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </div><div class="line">      <span class="tag">&lt;/<span class="name">repository</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span> </div><div class="line">      <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span> </div><div class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>public<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Public Repositories<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://172.16.xxx.xxx:8081/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </div><div class="line">      <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span> </div><div class="line">  <span class="tag">&lt;/<span class="name">profile</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></div><div class="line"></div><div class="line">······</div></pre></td></tr></table></figure></p>
<p>pom.xml 文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!--xxx-cif-api 存在 172.16.xxx.xxx 仓库--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xxx.cif<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxx-cif-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!--Chapter1 存在 localhost 仓库--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.cjf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Chapter1<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">&lt;!--配置远程仓库--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Public Repositories<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://dev.xxx.wiki:8081/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></div></pre></td></tr></table></figure>
<p>以下是 Maven 拉取包的日志<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line">······· 省略部分日志信息</div><div class="line"></div><div class="line">[DEBUG] Using local repository at E:\OperSource</div><div class="line">[DEBUG] Using manager EnhancedLocalRepositoryManager with priority <span class="number">10.0</span> <span class="keyword">for</span> E:\OperSource</div><div class="line">[INFO] Scanning <span class="keyword">for</span> projects...</div><div class="line"></div><div class="line"><span class="comment">// 从这里可以看出我们配置的镜像替代了我们在 pom 配置的远程仓库</span></div><div class="line">[DEBUG] <span class="function">Using mirror <span class="title">localhost</span> <span class="params">(http://localhost:<span class="number">8081</span>/repository/maven-<span class="keyword">public</span>/)</span> <span class="keyword">for</span> <span class="title">foo</span> <span class="params">(http://dev.xxx.wiki:<span class="number">8081</span>/nexus/content/groups/<span class="keyword">public</span>/)</span>.</span></div><div class="line">替代了默认的中央仓库</div><div class="line">[DEBUG] Using mirror <span class="title">alimaven</span> <span class="params">(http://maven.aliyun.com/nexus/content/groups/<span class="keyword">public</span>/)</span> <span class="keyword">for</span> <span class="title">central</span> <span class="params">(https://repo.maven.apache.org/maven2)</span>.</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 从这里可以看出 Maven 使用哪些 dependencies 和 plugins 的地址，我们可以看出优先级最高的是 172.16.xxx.xxx,然后就是 localhost 最后才是 maven.aliyun.com</span></div><div class="line"></div><div class="line"><span class="comment">// 注意：alimaven (http://maven.aliyun.com/nexus/content/groups/public/, default, releases) 从这里可以看出中央仓库只能获取 releases 包，所有的 snapshots 包都不从中央仓库获取。（可以看前面 central 的配置信息）</span></div><div class="line">[DEBUG] === PROJECT BUILD PLAN ================================================</div><div class="line">[DEBUG] Project:       com.cjf:demo:<span class="number">1.0</span>-SNAPSHOT</div><div class="line">[DEBUG] Dependencies (collect): []</div><div class="line">[DEBUG] Dependencies (resolve): [compile, runtime, test]</div><div class="line"></div><div class="line">[DEBUG] Repositories (dependencies): [<span class="keyword">public</span> (http:<span class="comment">//172.16.xxx.xxx:8081/nexus/content/groups/public/, default, releases+snapshots), localhost (http://localhost:8081/repository/maven-public/, default, releases+snapshots), alimaven (http://maven.aliyun.com/nexus/content/groups/public/, default, releases)]</span></div><div class="line"></div><div class="line">[DEBUG] Repositories (plugins)     : [<span class="keyword">public</span> (http:<span class="comment">//172.16.xxx.xxx:8081/nexus/content/groups/public, default, releases+snapshots), alimaven (http://maven.aliyun.com/nexus/content/groups/public/, default, releases)]</span></div><div class="line"></div><div class="line"></div><div class="line">[DEBUG] =======================================================================</div><div class="line"><span class="comment">// 寻找本地是否有 maven-metadata.xml 配置文件 ，从这里可以看出寻找不到（后面会详细讲该文件作用）</span></div><div class="line">[DEBUG] Could not find metadata com.xxx.cif:xxx-cif-api:<span class="number">0.0</span>.1-SNAPSHOT/maven-metadata.<span class="function">xml in <span class="title">local</span> <span class="params">(E:\OperSource)</span></span></div><div class="line"></div><div class="line"><span class="comment">// 由于寻找不到 Maven 只能从我们配置的远程仓库寻找，由于 Maven 也不知道那个仓库才有，所以同时寻找两个仓库</span></div><div class="line">[DEBUG] Using transporter WagonTransporter with priority -1.0 <span class="keyword">for</span> http:<span class="comment">//172.16.xxx.xxx:8081/nexus/content/groups/public/</span></div><div class="line">[DEBUG] Using transporter WagonTransporter with priority -1.0 <span class="keyword">for</span> http:<span class="comment">//localhost:8081/repository/maven-public/</span></div><div class="line">[DEBUG] Using connector BasicRepositoryConnector with priority 0.0 <span class="keyword">for</span> http:<span class="comment">//localhost:8081/repository/maven-public/</span></div><div class="line">[DEBUG] Using connector BasicRepositoryConnector with priority 0.0 <span class="keyword">for</span> http:<span class="comment">//172.16.xxx.xxx:8081/nexus/content/groups/public/</span></div><div class="line">Downloading: http:<span class="comment">//172.16.xxx.xxx:8081/nexus/content/groups/public/com/xxx/cif/xxx-cif-api/0.0.1-SNAPSHOT/maven-metadata.xml</span></div><div class="line">Downloading: http:<span class="comment">//localhost:8081/repository/maven-public/com/xxx/cif/xxx-cif-api/0.0.1-SNAPSHOT/maven-metadata.xml</span></div><div class="line">[DEBUG] Writing tracking file E:\OperSource\com\xxx\cif\xxx-cif-api\0.0.1-SNAPSHOT\resolver-status.properties</div><div class="line"></div><div class="line"><span class="comment">// 从这里可以看出在 172.16.xxx.xxx 找到  xxx-cif-api 的 maven-metadata.xml 文件并下载下来</span></div><div class="line">Downloaded: http:<span class="comment">//172.16.xxx.xxx:8081/nexus/content/groups/public/com/xxx/cif/xxx-cif-api/0.0.1-SNAPSHOT/maven-metadata.xml (781 B at 7.0 KB/sec)</span></div><div class="line"></div><div class="line"><span class="comment">// 追踪文件，resolver-status.properties 配置了 jar 包下载地址和时间</span></div><div class="line">[DEBUG] Writing tracking file E:\OperSource\com\xxx\cif\xxx-cif-api\0.0.1-SNAPSHOT\resolver-status.properties</div><div class="line">[DEBUG] Could not find metadata com.xxx.cif:xxx-cif-api:0.0.1-SNAPSHOT/maven-metadata.xml in <span class="title">localhost</span> <span class="params">(http://localhost:<span class="number">8081</span>/repository/maven-<span class="keyword">public</span>/)</span></div><div class="line"></div><div class="line"><span class="comment">// 在 localhost 远程仓库寻找不到 xxx-cif-api 的 maven-metadata.xml</span></div><div class="line">[DEBUG] Could not find metadata com.xxx.cif:xxx-cif-api:0.0.1-SNAPSHOT/maven-metadata.xml in <span class="title">local</span> <span class="params">(E:\OperSource)</span></div><div class="line"></div><div class="line"><span class="comment">// 跳过的远程请求 </span></div><div class="line">[DEBUG] Skipped remote request <span class="keyword">for</span> com.xxx.cif:xxx-cif-api:0.0.1-SNAPSHOT/maven-metadata.xml, already updated during <span class="keyword">this</span> session.</div><div class="line">[DEBUG] Skipped remote request <span class="keyword">for</span> com.xxx.cif:xxx-cif-api:0.0.1-SNAPSHOT/maven-metadata.xml, already updated during <span class="keyword">this</span> session.</div><div class="line"></div><div class="line"><span class="comment">// 默认以后获取 xxx-cif-api 的时候将不在从 localhost 寻找了，除非强制获取才会再次从 localhost 寻找这个包</span></div><div class="line">[DEBUG] Failure to find com.xxx.cif:xxx-cif-api:0.0.1-SNAPSHOT/maven-metadata.xml in http:<span class="comment">//localhost:8081/repository/maven-public/ was cached in the local repository, resolution will not be reattempted until the update interval of localhost has elapsed or updates are forced</span></div><div class="line"></div><div class="line"><span class="comment">// 将 172.16.xxx.xxx 优先级升为 0 ，并下载 xxx-cif-api 的 pom 文件</span></div><div class="line">[DEBUG] Using transporter WagonTransporter with priority -1.0 <span class="keyword">for</span> http:<span class="comment">//172.16.xxx.xxx:8081/nexus/content/groups/public/</span></div><div class="line">[DEBUG] Using connector BasicRepositoryConnector with priority 0.0 <span class="keyword">for</span> http:<span class="comment">//172.16.xxx.xxx:8081/nexus/content/groups/public/</span></div><div class="line">Downloading: http:<span class="comment">//172.16.xxx.xxx:8081/nexus/content/groups/public/com/xxx/cif/xxx-cif-api/0.0.1-SNAPSHOT/xxx-cif-api-0.0.1-20170515.040917-89.pom</span></div><div class="line">Downloaded: http:<span class="comment">//172.16.xxx.xxx:8081/nexus/content/groups/public/com/xxx/cif/xxx-cif-api/0.0.1-SNAPSHOT/xxx-cif-api-0.0.1-20170515.040917-89.pom (930 B at 82.6 KB/sec)</span></div><div class="line"></div><div class="line"><span class="comment">// _remote.repositories 记录的以后使用那个远程仓库获取 （ps:这个文件作用我要不是很清楚作用，以上观点是自己推测出来的。）</span></div><div class="line">[DEBUG] Writing tracking file E:\OperSource\com\xxx\cif\xxx-cif-api\0.0.1-SNAPSHOT\_remote.repositories</div><div class="line">[DEBUG] Writing tracking file E:\OperSource\com\xxx\cif\xxx-cif-api\0.0.1-SNAPSHOT\xxx-cif-api-0.0.1-20170515.040917-89.pom.lastUpdated</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 后面获取 Chapter1 包的流程跟 com.xxx.cif 是一样的，不过最后是在 localhost 寻找到而已，所以这分日志就不贴出来了。</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 最后在下载包的时候，都到对应的仓库下载</span></div><div class="line">[DEBUG] Using transporter WagonTransporter with priority -1.0 <span class="keyword">for</span> http:<span class="comment">//172.16.xxx.xxx:8081/nexus/content/groups/public/</span></div><div class="line">[DEBUG] Using connector BasicRepositoryConnector with priority 0.0 <span class="keyword">for</span> http:<span class="comment">//172.16.xxx.xxx:8081/nexus/content/groups/public/</span></div><div class="line">Downloading: http:<span class="comment">//172.16.xxx.xxx:8081/nexus/content/groups/public/com/xxx/cif/xxx-cif-api/0.0.1-SNAPSHOT/xxx-cif-api-0.0.1-20170515.040917-89.jar</span></div><div class="line">Downloading: http:<span class="comment">//172.16.xxx.xxx:8081/nexus/content/groups/public/com/xxx/util/xxx-util/0.0.1-SNAPSHOT/xxx-util-0.0.1-20170514.091041-31.jar</span></div><div class="line">Downloaded: http:<span class="comment">//172.16.xxx.xxx:8081/nexus/content/groups/public/com/xxx/util/xxx-util/0.0.1-SNAPSHOT/xxx-util-0.0.1-20170514.091041-31.jar (26 KB at 324.2 KB/sec)</span></div><div class="line">Downloaded: http:<span class="comment">//172.16.xxx.xxx:8081/nexus/content/groups/public/com/xxx/cif/xxx-cif-api/0.0.1-SNAPSHOT/xxx-cif-api-0.0.1-20170515.040917-89.jar (68 KB at 756.6 KB/sec)</span></div><div class="line">[DEBUG] Writing tracking file E:\OperSource\com\xxx\cif\xxx-cif-api\0.0.1-SNAPSHOT\_remote.repositories</div><div class="line">[DEBUG] Writing tracking file E:\OperSource\com\xxx\cif\xxx-cif-api\0.0.1-SNAPSHOT\xxx-cif-api-0.0.1-20170515.040917-89.jar.lastUpdated</div><div class="line">[DEBUG] Writing tracking file E:\OperSource\com\xxx\util\xxx-util\0.0.1-SNAPSHOT\_remote.repositories</div><div class="line">[DEBUG] Writing tracking file E:\OperSource\com\xxx\util\xxx-util\0.0.1-SNAPSHOT\xxx-util-0.0.1-20170514.091041-31.jar.lastUpdated</div><div class="line">[DEBUG] Using transporter WagonTransporter with priority -1.0 <span class="keyword">for</span> http:<span class="comment">//localhost:8081/repository/maven-public/</span></div><div class="line">[DEBUG] Using connector BasicRepositoryConnector with priority 0.0 <span class="keyword">for</span> http:<span class="comment">//localhost:8081/repository/maven-public/</span></div><div class="line">Downloading: http:<span class="comment">//localhost:8081/repository/maven-public/com/cjf/Chapter1/0.0.1-SNAPSHOT/Chapter1-0.0.1-20170708.092339-1.jar</span></div><div class="line">Downloaded: http:<span class="comment">//localhost:8081/repository/maven-public/com/cjf/Chapter1/0.0.1-SNAPSHOT/Chapter1-0.0.1-20170708.092339-1.jar (8 KB at 167.0 KB/sec)</span></div><div class="line">[DEBUG] Writing tracking file E:\OperSource\com\cjf\Chapter1\0.0.1-SNAPSHOT\_remote.repositories</div><div class="line">[DEBUG] Writing tracking file E:\OperSource\com\cjf\Chapter1\0.0.1-SNAPSHOT\Chapter1-0.0.1-20170708.092339-1.jar.lastUpdated</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">[INFO] Installing C:\Users\swipal\Desktop\abc\demo\target\demo-1.0-SNAPSHOT.jar to E:\OperSource\com\cjf\demo\1.0-SNAPSHOT\demo-1.0-SNAPSHOT.jar</div><div class="line">[DEBUG] Writing tracking file E:\OperSource\com\cjf\demo\1.0-SNAPSHOT\_remote.repositories</div><div class="line">[INFO] Installing C:\Users\swipal\Desktop\abc\demo\pom.xml to E:\OperSource\com\cjf\demo\1.0-SNAPSHOT\demo-1.0-SNAPSHOT.pom</div><div class="line">[DEBUG] Writing tracking file E:\OperSource\com\cjf\demo\1.0-SNAPSHOT\_remote.repositories</div><div class="line">[DEBUG] Installing com.cjf:demo:1.0-SNAPSHOT/maven-metadata.xml to E:\OperSource\com\cjf\demo\1.0-SNAPSHOT\maven-metadata-local.xml</div><div class="line">[DEBUG] Installing com.cjf:demo/maven-metadata.xml to E:\OperSource\com\cjf\demo\maven-metadata-local.xml</div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line">[INFO] BUILD SUCCESS</div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line">[INFO] Total time: 10.549 s</div><div class="line">[INFO] Finished at: 2017-07-09T18:13:20+08:00</div><div class="line">[INFO] Final Memory: 26M/219M</div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line"></div><div class="line">·······</div></pre></td></tr></table></figure></p>
<p>好了，看了这么多的配置文件信息和日志信息，我们也总结一下 Maven 远程仓库优先级了。</p>
<p>主要有以下几点：<br>1.从日志信息我们得出这几种maven仓库的优先级别为</p>
<blockquote>
<p>本地仓库 &gt; 私服 （profile）&gt; 远程仓库（repository）和 镜像 （mirror） &gt; 中央仓库 （central）</p>
</blockquote>
<p>2.镜像是一个特殊的配置，其实镜像等同与远程仓库，没有匹配远程仓库的镜像就毫无作用（如 foo2）。<br>3.总结上面所说的，Maven 仓库的优先级就是 <strong>私服和远程仓库</strong> 的对比，没有其它的仓库类型。为什么这么说是因为，镜像等同远程，而中央其实也是 maven super xml 配置的一个repository 的一个而且。所以 maven 仓库真正的优先级为 </p>
<blockquote>
<p>本地仓库 &gt; 私服（profile）&gt; 远程仓库（repository）</p>
</blockquote>
<h2 id="maven-metadata-xml-文件"><a href="#maven-metadata-xml-文件" class="headerlink" title="maven-metadata.xml 文件"></a>maven-metadata.xml 文件</h2><p>Maven Repository Metadata 可用于表示：</p>
<pre><code>1. 一个没有版本的工件：它提供有关该工件的可用版本的信息
2. 快照伪像：它提供有关快照的精确信息
3. 包含Maven插件工件的组：它提供了有关此组中可用插件的信息。
</code></pre><p>元数据文件名是：</p>
<pre><code>远程存储库中的 maven-metadata.xml，
maven-metadata- &lt;repo-id&gt;.xml在本地存储库中，用于具有repo-id标识符的存储库中的元标记。
</code></pre><p>以上是 Maven 官网对该文件的解释。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>问题：有时候我们更新最新包的时候，会发现最新的包被拉取下来的，但是项目使用的包还是旧的包。所以我们要分析下是什么原因导致的。</p>
<p>首先我们先大概的了解下 maven-metadata.xml  文件。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">metadata</span> <span class="attr">modelVersion</span>=<span class="string">"1.1.0"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.cjf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Chapter1<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">versioning</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">snapshot</span>&gt;</span>                               <span class="comment">&lt;!--当前版本下的最新快照信息--&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">timestamp</span>&gt;</span>20170710.071727<span class="tag">&lt;/<span class="name">timestamp</span>&gt;</span> <span class="comment">&lt;!--快照的时间戳--&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">buildNumber</span>&gt;</span>6<span class="tag">&lt;/<span class="name">buildNumber</span>&gt;</span>           <span class="comment">&lt;!--构件号--&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">snapshot</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">lastUpdated</span>&gt;</span>20170710071727<span class="tag">&lt;/<span class="name">lastUpdated</span>&gt;</span><span class="comment">&lt;!--metadata文件被更新的时间--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">snapshotVersions</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">snapshotVersion</span>&gt;</span>                      <span class="comment">&lt;!--当前版本下可用的子快照版本信息--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">extension</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">extension</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>0.0.1-20170710.071727-6<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="comment">&lt;!--子快照版本的信息--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">updated</span>&gt;</span>20170710071727<span class="tag">&lt;/<span class="name">updated</span>&gt;</span>     <span class="comment">&lt;!--这个子快照版本的更新时间--&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">snapshotVersion</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">snapshotVersion</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">extension</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">extension</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>0.0.1-20170710.071727-6<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">updated</span>&gt;</span>20170710071727<span class="tag">&lt;/<span class="name">updated</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">snapshotVersion</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">snapshotVersions</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">versioning</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">metadata</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>其中 lastUpdated 是最中要的一个属性，Maven 更新工程的 jar包时，会比较 lastUpdated 时间戳值，哪个值更大，就以哪个文件为准。</p>
<p>接下来我们看下 Maven 为我们生成了那些文件<br><img src="http://orbs83j4x.bkt.clouddn.com/20170710163449.png" alt="此处输入图片的描述"><br>我们可以看到 maven-metadata.xml 一共有三个</p>
<pre><code>1. maven-metadata-local.xml 本地的元数据, Maven install 的时候就会生成。
2. maven-metadata-snapshots.xml Maven deploy 时会生成
3. maven-metadata-localhost.xml 远程仓库获取的时候生成 (repository 的 id = localhost)
</code></pre><p>以上的文件其实都是 Maven 的过渡文件而已</p>
<ol>
<li>例如 maven-metadata-snapshots 就是 Maven deploy 先从远程仓库对应包的 maven-metadata.xml 下载下来，然后修改快照信息后在上传到远程仓库上。</li>
<li>例如 maven-metadata-localhost 的作用是在 Maven 在拉取包的时候，会先跟本地 maven-metadata-local 比较下 lastUpdated 时间戳值，值大用哪个。如果是 Mavne <strong>强制更新</strong> 的时候(没有强制更新是不会) 会下载远程的 maven-metadata.xml 比较<strong>远程，本地，和之前远程保存下来的 maven-metadata 文件</strong>。</li>
</ol>
<p>所以有时候 maven 库上的 jar 包已经更新，而我们总是拉取不到 maven 的包原因就是本地的 maven-metadata-local 的 lastUpdated 比较大。</p>
<p>我们验证下 Maven deploy 例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[INFO] --- maven-deploy-plugin:<span class="number">2.8</span>.2:deploy (<span class="keyword">default</span>-deploy) @ Chapter1 ---</div><div class="line"><span class="comment">// 先从远程下载快照 maven-metadata.xml</span></div><div class="line">Downloading: http:<span class="comment">//localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/0.0.1-SNAPSHOT/maven-metadata.xml</span></div><div class="line">Downloaded: http:<span class="comment">//localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/0.0.1-SNAPSHOT/maven-metadata.xml (768 B at 3.3 KB/sec)</span></div><div class="line"><span class="comment">// 将项目的 jar 和 pom 文件更新到远程仓库</span></div><div class="line">Uploading: http:<span class="comment">//localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/0.0.1-SNAPSHOT/Chapter1-0.0.1-20170710.121310-15.jar</span></div><div class="line">Uploaded: http:<span class="comment">//localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/0.0.1-SNAPSHOT/Chapter1-0.0.1-20170710.121310-15.jar (8 KB at 14.1 KB/sec)</span></div><div class="line">Uploading: http:<span class="comment">//localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/0.0.1-SNAPSHOT/Chapter1-0.0.1-20170710.121310-15.pom</span></div><div class="line">Uploaded: http:<span class="comment">//localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/0.0.1-SNAPSHOT/Chapter1-0.0.1-20170710.121310-15.pom (2 KB at 2.0 KB/sec)</span></div><div class="line">Downloading: http:<span class="comment">//localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/maven-metadata.xml</span></div><div class="line">Downloaded: http:<span class="comment">//localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/maven-metadata.xml (275 B at 1.6 KB/sec)</span></div><div class="line"><span class="comment">// 上传  maven-metadata.xml 到远程仓库</span></div><div class="line">Uploading: http:<span class="comment">//localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/0.0.1-SNAPSHOT/maven-metadata.xml</span></div><div class="line">Uploaded: http:<span class="comment">//localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/0.0.1-SNAPSHOT/maven-metadata.xml (768 B at 1.0 KB/sec)</span></div><div class="line">Uploading: http:<span class="comment">//localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/maven-metadata.xml</span></div><div class="line">Uploaded: http:<span class="comment">//localhost:8081/repository/maven-snapshots/com/cjf/Chapter1/maven-metadata.xml (275 B at 0.4 KB/sec)</span></div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line">[INFO] BUILD SUCCESS</div><div class="line">[INFO] ------------------------------------------------------------------------</div><div class="line">[INFO] Total time: <span class="number">5.231</span> s</div><div class="line">[INFO] Finished at: <span class="number">2017</span>-<span class="number">07</span>-<span class="number">10</span>T20:<span class="number">13</span>:<span class="number">13</span>+<span class="number">08</span>:<span class="number">00</span></div><div class="line">[INFO] Final Memory: <span class="number">19</span>M/<span class="number">226</span>M</div><div class="line">[INFO] ------------------------------------------------------------------------</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>原本以为两天就写好这篇文章，在自己理清思路的时候总是被自己绕晕了。比如在 Nexus 的 Central 配置的中央仓库获取，和 maven-metadata.xml 是如何比较的。</p>
<p>如果以上文章有误，等博客的评论系统搭建起来后欢迎大家指认出来。</p>
]]></content>
      
        <categories>
            
            <category> Maven </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LogBack 使用]]></title>
      <url>/2017/09/03/Logback/</url>
      <content type="html"><![CDATA[<p><img src="https://logback.qos.ch/images/logos/lblogo.jpg" alt="此处输入图片的描述"><br><strong>26 Seven 2017</strong></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前项目一直使用 logback ,现在大概写下了 logback 基础配置。</p>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>LogBack</code>是一个日志框架，它是Log4j作者Ceki的又一个日志组件。</p>
<p><code>LogBack,Slf4j,Log4j</code>之间的关系</p>
<p>slf4j是The Simple Logging Facade for Java的简称，是一个简单日志门面抽象框架，它本身只提供了日志Facade API和一个简单的日志类实现，一般常配合<code>Log4j</code>，<code>LogBack</code>，<code>java.util.logging</code>使用。Slf4j作为应用层的Log接入时，程序可以根据实际应用场景动态调整底层的日志实现框架(Log4j/LogBack/JdkLog…)；</p>
<p>LogBack和Log4j都是开源日记工具库，LogBack是Log4j的改良版本，比Log4j拥有更多的特性，同时也带来很大性能提升。</p>
<p>LogBack官方建议配合Slf4j使用，这样可以灵活地替换底层日志框架。</p>
<p>LogBack的结构<br>LogBack分为3个组件，logback-core, logback-classic 和 logback-access。<br>其中logback-core提供了LogBack的核心功能，是另外两个组件的基础。<br>logback-classic则实现了Slf4j的API，所以当想配合Slf4j使用时，则需要引入这个包。<br>logback-access是为了集成Servlet环境而准备的，可提供HTTP-access的日志接口。</p>
<p>Log的行为级别：<br>OFF、<br>FATAL、<br>ERROR、<br>WARN、<br>INFO、<br>DEBUG、<br>ALL<br>从下向上，当选择了其中一个级别，则该级别向下的行为是不会被打印出来。<br>举个例子，当选择了INFO级别，则INFO以下的行为则不会被打印出来。</p>
<h2 id="获取-Logger-对象"><a href="#获取-Logger-对象" class="headerlink" title="获取 Logger 对象"></a>获取 Logger 对象</h2><p><img src="/images/example.png" alt="此处输入图片的描述"></p>
<p>我们先从获取 logger 对象开始<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Logger logger = LoggerFactory.getLogger(xxx.class.getName());</div></pre></td></tr></table></figure></p>
<p>LoggerFactory 是 slf4j 的日志工厂，获取 logger 方法就来自这里。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">以下代码摘自：org.slf4j.<span class="function">LoggerFactory</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getLogger</span><span class="params">(String name)</span> &#123;</div><div class="line">    ILoggerFactory iLoggerFactory = getILoggerFactory();</div><div class="line">    <span class="keyword">return</span> iLoggerFactory.getLogger(name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法里面有分为两个过程。第一个过程是获取ILoggerFactory，就是真正的日志工厂。第二个过程就是从真正的日志工厂中获取logger。<br>接下来我们看下到底是怎么获取的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">以下代码摘自：org.slf4j.<span class="function">LoggerFactory</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> ILoggerFactory <span class="title">getILoggerFactory</span><span class="params">()</span> &#123;</div><div class="line"><span class="keyword">if</span> (INITIALIZATION_STATE == UNINITIALIZED) &#123;</div><div class="line">  INITIALIZATION_STATE = ONGOING_INITIALIZATION;</div><div class="line">  <span class="comment">// 第一次调用会去加载 StaticLoggerBinder.class 文件来决定 LoggerFactory 的实现类</span></div><div class="line">  <span class="comment">// （补充下：不同日志包下都有 StaticLoggerBinder 这个类文件，这个会决定 LoggerFactory 初始化那种类型的日志）</span></div><div class="line">  performInitialization();</div><div class="line">&#125;</div><div class="line"><span class="comment">// INITIALIZATION_STATE 值判断是否有加载初始化过 ILoggerFactory 实例。</span></div><div class="line"><span class="keyword">switch</span> (INITIALIZATION_STATE) &#123;</div><div class="line">  <span class="keyword">case</span> SUCCESSFUL_INITIALIZATION:</div><div class="line">    <span class="comment">// 返回对应的 ILoggerFactory 实例</span></div><div class="line">    <span class="keyword">return</span> StaticLoggerBinder.getSingleton().getLoggerFactory();</div><div class="line">  <span class="keyword">case</span> NOP_FALLBACK_INITIALIZATION:</div><div class="line">    <span class="comment">// 当加载不到一个 StaticLoggerBinder 时，会走这里</span></div><div class="line">    <span class="comment">// 返回一个 NOPLoggerFactory 实例</span></div><div class="line">    <span class="keyword">return</span> NOP_FALLBACK_FACTORY;</div><div class="line">  <span class="keyword">case</span> FAILED_INITIALIZATION:</div><div class="line">    <span class="comment">// 初始化异常</span></div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(UNSUCCESSFUL_INIT_MSG);</div><div class="line">  <span class="keyword">case</span> ONGOING_INITIALIZATION:</div><div class="line">    <span class="comment">// support re-entrant behavior.</span></div><div class="line">    <span class="comment">// See also http://bugzilla.slf4j.org/show_bug.cgi?id=106</span></div><div class="line">    <span class="keyword">return</span> TEMP_FACTORY;</div><div class="line">&#125;</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unreachable code"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来我们来看下是怎么加载 StaticLoggerBinder.class 文件的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">以下代码摘自：org.slf4j.<span class="function">LoggerFactory</span></div><div class="line"></div><div class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span> &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">// 加载 StaticLoggerBinder</span></div><div class="line">      Set staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet();</div><div class="line">      reportMultipleBindingAmbiguity(staticLoggerBinderPathSet);</div><div class="line">      <span class="comment">// 最后会随机选择一个StaticLoggerBinder.class来创建一个单例</span></div><div class="line">      StaticLoggerBinder.getSingleton();</div><div class="line">      <span class="comment">// 改变 INITIALIZATION_STATE 值，表示成功初始化 Factory。</span></div><div class="line">      <span class="comment">// 并且以后在获取 Logger 的时候并不会再次加载该方法</span></div><div class="line">      INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION;</div><div class="line">      reportActualBinding(staticLoggerBinderPathSet);</div><div class="line">      emitSubstituteLoggerWarning();</div><div class="line">    &#125; <span class="keyword">catch</span> (NoClassDefFoundError ncde) &#123;</div><div class="line">      String msg = ncde.getMessage();</div><div class="line">      <span class="keyword">if</span> (messageContainsOrgSlf4jImplStaticLoggerBinder(msg)) &#123;</div><div class="line">        <span class="comment">// 加载不到 StaticLoggerBinder 文件</span></div><div class="line">        INITIALIZATION_STATE = NOP_FALLBACK_INITIALIZATION;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        failedBinding(ncde);</div><div class="line">        <span class="keyword">throw</span> ncde;</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (java.lang.NoSuchMethodError nsme) &#123;</div><div class="line">      String msg = nsme.getMessage();</div><div class="line">      <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.indexOf(<span class="string">"org.slf4j.impl.StaticLoggerBinder.getSingleton()"</span>) != -<span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">// 初始化异常</span></div><div class="line">        INITIALIZATION_STATE = FAILED_INITIALIZATION;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">throw</span> nsme;</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">      failedBinding(e);</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected initialization failure"</span>, e);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p> 加载 StaticLoggerBinder.class<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">以下代码摘自：org.slf4j.LoggerFactory.findPossibleStaticLoggerBinderPathSet</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> String STATIC_LOGGER_BINDER_PATH = <span class="string">"org/slf4j/impl/StaticLoggerBinder.class"</span>;</div><div class="line"></div><div class="line">···</div><div class="line"><span class="keyword">if</span> (loggerFactoryClassLoader == <span class="keyword">null</span>) &#123;</div><div class="line">    paths = ClassLoader.getSystemResources(STATIC_LOGGER_BINDER_PATH);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    paths = loggerFactoryClassLoader</div><div class="line">            .getResources(STATIC_LOGGER_BINDER_PATH);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">while</span> (paths.hasMoreElements()) &#123;</div><div class="line">    URL path = (URL) paths.nextElement();</div><div class="line">    staticLoggerBinderPathSet.add(path);</div><div class="line">  &#125;</div><div class="line">···</div></pre></td></tr></table></figure></p>
<p>当项目中存在多个StaticLoggerBinder.class文件时，运行项目会出现以下日志：<br>（这里获取的规则就近原则，如果在 maven 先配置 slf4j 而后面在配置 logback，则这里初始化的是 slf4j）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SLF4J: Class path contains multiple SLF4J bindings.</div><div class="line">SLF4J: Found binding in [jar:file:/E:/OperSource/org/slf4j/slf4j-log4j12/<span class="number">1.7</span>.12/slf4j-log4j12-<span class="number">1.7</span>.12.jar!/org/slf4j/impl/StaticLoggerBinder.class]</div><div class="line">SLF4J: Found binding in [jar:file:/E:/OperSource/ch/qos/logback/logback-classic/<span class="number">1.1</span>.3/logback-classic-<span class="number">1.1</span>.3.jar!/org/slf4j/impl/StaticLoggerBinder.class]</div><div class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#multiple_bindings for an explanation.</span></div><div class="line">SLF4J: Actual binding is of type [org.slf4j.impl.Log4jLoggerFactory]</div></pre></td></tr></table></figure></p>
<p>返回实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">以下代码摘自：org.slf4j.LoggerFactory.getILoggerFactory</div><div class="line"></div><div class="line">StaticLoggerBinder.getSingleton().getLoggerFactory();</div></pre></td></tr></table></figure></p>
<h2 id="LogBack-配置"><a href="#LogBack-配置" class="headerlink" title="LogBack 配置"></a>LogBack 配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">"true"</span> <span class="attr">scanPeriod</span>=<span class="string">"60 seconds"</span> <span class="attr">debug</span>=<span class="string">"false"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 项目名称配置 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">contextName</span>&gt;</span>example<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 属性 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"APP_Name"</span> <span class="attr">value</span>=<span class="string">"example"</span> /&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 统一的时间格式，用于日志头输出 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">timestamp</span> <span class="attr">key</span>=<span class="string">"timeStyle"</span> <span class="attr">datePattern</span>=<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>/&gt;</span></div><div class="line">    <span class="comment">&lt;!--配置控制台输出,开发环境有--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- encoder 默认配置为PatternLayoutEncoder --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;timeStyle&#125;] [%cn] %-5level %logger&#123;35&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!--文件输出配置--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"FILE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>../logs/$&#123;APP_Name&#125;_run.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.FixedWindowRollingPolicy"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>../logs/$&#123;APP_Name&#125;_run.%i.log.zip<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">minIndex</span>&gt;</span>1<span class="tag">&lt;/<span class="name">minIndex</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">maxIndex</span>&gt;</span>10<span class="tag">&lt;/<span class="name">maxIndex</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>10MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;timeStyle&#125;] [%cn] %-5level %logger&#123;35&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"BUSINESS_FILE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>../logs/$&#123;APP_Name&#125;_business.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.FixedWindowRollingPolicy"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>../logs/$&#123;APP_Name&#125;_business.%i.business.zip<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">minIndex</span>&gt;</span>1<span class="tag">&lt;/<span class="name">minIndex</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">maxIndex</span>&gt;</span>10<span class="tag">&lt;/<span class="name">maxIndex</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>10MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;timeStyle&#125;] [%cn] %-5level %logger&#123;35&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span><span class="comment">&lt;!-- 只打印错误日志 --&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>WARE<span class="tag">&lt;/<span class="name">level</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 异步输出 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"ASYNC"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.AsyncAppender"</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">discardingThreshold</span>&gt;</span>0<span class="tag">&lt;/<span class="name">discardingThreshold</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为256 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">queueSize</span>&gt;</span>256<span class="tag">&lt;/<span class="name">queueSize</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 添加附加的appender,最多只能添加一个 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"FILE"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"BUSINESS_ASYNC"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.AsyncAppender"</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">discardingThreshold</span>&gt;</span>0<span class="tag">&lt;/<span class="name">discardingThreshold</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为256 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">queueSize</span>&gt;</span>256<span class="tag">&lt;/<span class="name">queueSize</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 添加附加的appender,最多只能添加一个 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"BUSINESS_FILE"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 为数据库开启显示sql --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.cjf.example.repository"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.cjf"</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!--日志的root目录，用于定位日志输出级别--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"ASYNC"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div></pre></td></tr></table></figure>
<p>上面就是一个常用的日志配置模版，下面就从跟节点来解析每个节点</p>
<p><strong>1.configuration</strong><br>scan：当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。<br>scanPeriod：监测配置文件是否有修改的时间间隔，默认 60s。<br>debug：是否打印 logback 内部日志，默认 false.<br><strong>2.contextName</strong> 项目名称<br>logger 上下文容器名称，默认 ‘default’，用于区分不同应用程序的记录。（可以在日志输出的时候将项目名称打印处理方便系统间交互 比如上面配置的 <code>%cn</code>）<br><strong>3.property</strong> 设置变量<br>定义变量后，可以使<code>${}</code>来使用变量。<br><strong>4.timestamp</strong> 设置时间戳格式<br>key:标识此<timestamp> 的名字；datePattern：设置将当前时间（解析配置文件的时间）转换为字符串的模式，遵循Java.txt.SimpleDateFormat的格式。<br><strong>5.logger</strong><br>用来设置某一个包或者具体的某一个类的日志打印级别、以及指定<appender>。<loger>仅有一个name属性，一个可选的level和一个可选的addtivity属性。<br>name: 用来指定受此loger约束的某一个包或者具体的某一个类。<br>level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。如果未设置此属性，那么当前loger将会继承上级的级别。<br>addtivity:是否向上级loger传递打印信息。默认是true。<br>loger可以包含零个或多个appender-ref元素，标识这个appender将会添加到这个loger。<br><strong>6.root</strong><br>也是 loger 元素，但是它是根 loger。只有一个 level 属性，应为已经被命名为 <code>“root”</code>.<br>root 可以包含零个或多个 appender-ref 元素，标识这个 appender 将会添加到这个 loger。</loger></appender></timestamp></p>
<h3 id="什么是-Appender？"><a href="#什么是-Appender？" class="headerlink" title="什么是 Appender？"></a>什么是 Appender？</h3><p>logback 将日志记录事件写入到名为 appender 的组件的任务,不同 appender 决定了日志的记录方式。<br>appender 有多种实现的方式，下面简单介绍几种比较常用的配置。 <a href="https://logback.qos.ch/manual/appenders.html" target="_blank" rel="external">更多详情请参考官方文档</a></p>
<p><strong>ConsoleAppender</strong><br>把日志添加到控制台，有以下子节点：<br>  encoder：对日志进行格式化<br>  target：字符串 System.out 或者 System.err ，默认 System.out;<br>  withJansi：日志彩色输出</p>
<p>例如<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </div><div class="line">  </div><div class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span>  </div><div class="line">      <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;timeStyle&#125;] [%cn] %-5level %logger&#123;35&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span>  </div><div class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span>  </div><div class="line">  </div><div class="line">  <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span> /&gt;</span>  </div><div class="line">  <span class="tag">&lt;/<span class="name">root</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>RollingFileAppender</strong><br>滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件。<br>file：被写入的文件名，可以是相对目录，也可以是绝对目录，如果上级目录不存在会自动创建，没有默认值。<br>append：如果是 true，日志被追加到文件结尾，如果是 false，清空现存文件，默认是true。<br>encoder：对记录事件进行格式化。<br>rollingPolicy：当发生滚动时，决定 RollingFileAppender 的行为，涉及文件移动和重命名。<br>triggeringPolicy：告知 RollingFileAppender 合适激活滚动。<br>prudent：当为true时，不支持FixedWindowRollingPolicy。支持TimeBasedRollingPolicy，但是有两个限制，1不支持也不允许文件压缩，2不能设置file属性，必须留空。</p>
<p>　<br>rollingPolicy 有两种类型，分别是 TimeBasedRollingPolicy，FixedWindowRollingPolicy。</p>
<p>例如 TimeBasedRollingPolicy 配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--输出到文件--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"file"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;log.path&#125;<span class="tag">&lt;/<span class="name">file</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>logback.%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">totalSizeCap</span>&gt;</span>1GB<span class="tag">&lt;/<span class="name">totalSizeCap</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>fileNamePattern 定义了日志的切分方式——把每一天的日志归档到一个文件中<br>maxHistory 表示只保留最近30天的日志，以防止日志填满整个磁盘空间。<br>totalSizeCap 用来指定日志文件的上限大小，例如设置为1GB的话，那么到了这个值，就会删除旧的日志。</p>
<p>例如 FixedWindowRollingPolicy 配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"FILE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>../logs/$&#123;APP_Name&#125;_run.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.FixedWindowRollingPolicy"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>../logs/$&#123;APP_Name&#125;_run.%i.log.zip<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">minIndex</span>&gt;</span>1<span class="tag">&lt;/<span class="name">minIndex</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">maxIndex</span>&gt;</span>10<span class="tag">&lt;/<span class="name">maxIndex</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>10MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;timeStyle&#125;] [%cn] %-5level %logger&#123;35&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>这里多了一个 SizeBasedTriggeringPolicy 触发机制，但 log 文件大于 10MB 的时候，就开始执行 rolling。<br>minIndex 和 maxIndex 表示保存日志数量，但大于 maxIndex 的时候，会开始删除旧的日志。</p>
<blockquote>
<p>必须包含“%i”例如，假设最小值和最大值分别为1和2，命名模式为<br>mylog%i.log,会产生归档文件mylog1.log和mylog2.log。还可以指定文件压缩选项，例如，mylog%i.log.gz<br>或者 没有log%i.log.zip</p>
</blockquote>
<h3 id="AsyncAppender-异步输出"><a href="#AsyncAppender-异步输出" class="headerlink" title="AsyncAppender 异步输出"></a>AsyncAppender 异步输出</h3><p>这里就不写了，可以<a href="http://blog.csdn.net/ChenJie2000/article/details/8902727" target="_blank" rel="external">参考</a>文章。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于没有深入去了解 logback ,许多内容都是网上摘来的，写文章的时候也很费劲。思路不清晰。</p>
]]></content>
      
        <categories>
            
            <category> LogBack </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LogBack </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
