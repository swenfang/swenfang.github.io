<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ShenWenFang</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://swenfang.github.io/"/>
  <updated>2019-05-12T15:11:32.186Z</updated>
  <id>http://swenfang.github.io/</id>
  
  <author>
    <name>ShenWenFang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线程面试题</title>
    <link href="http://swenfang.github.io/2019/05/12/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://swenfang.github.io/2019/05/12/面试总结/线程面试题/</id>
    <published>2019-05-12T13:55:28.167Z</published>
    <updated>2019-05-12T15:11:32.186Z</updated>
    
    <content type="html"><![CDATA[<p>1、多线程有什么用？</p><p>1）发挥多核CPU的优势</p><p>随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程”同时”运行罢了。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。</p><a id="more"></a><p>2）防止阻塞</p><p>从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。</p><p>3）便于建模</p><p>这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。</p><p>2、创建线程的方式</p><blockquote><ul><li>继承 Thread 类创建线程</li><li>实现 Runnable 接口创建线程</li><li>实现 Callable 和 Future 创建线程</li></ul><p>比较：</p><p>实现 Runnable 接口，还可以继承其他类，在这种方式下多线程共享一个 target 对象，所以适合多个相同的线程来处理同一份资源的情况；但是它编程稍微复杂，若想访问当前线程必须使用 Thread.currentThread() 方法。</p><p>继承 Thread 类，代码编写简单，当前 Thread 可用 this 获取，但是它不能再继承其他类。</p></blockquote><p>3、start()方法和run()方法的区别</p><blockquote><ol><li>start() 可以启动一个新线程，run()不能</li><li>start()不能被重复调用，run()可以</li><li>start()中的run代码可以不执行完就继续执行下面的代码，即进行了线程切换。直接调用run方法必须等待其代码全部执行完才能继续执行下面的代码。</li><li>start() 实现了多线程，run()没有实现多线程。</li></ol></blockquote><p>4、Runnable接口和Callable接口的区别</p><blockquote><p>1)Runnable是自从java1.1就有了，而Callable是1.5之后才加上去的</p><p>2)Callable规定的方法是call(),Runnable规定的方法是run()</p><p>3)Callable的任务执行后可返回值，而Runnable的任务是不能返回值(是void)</p><p>4)call方法可以抛出异常，run方法不可以</p><p>5)运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</p><p>6)加入线程池运行，Runnable使用ExecutorService的execute方法，Callable使用submit方法。Callable接口也是位于java.util.concurrent包中。Callable接口的定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt;</span>&#123;</div><div class="line">&gt;<span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>; </div><div class="line">&gt;&#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><blockquote><p>Callable中的call()方法类似Runnable的run()方法，就是前者有返回值，后者没有。当将一个Callable的对象传递给ExecutorService的submit方法，则该call方法自动在一个线程上执行，并且会返回执行结果Future对象。同样，将Runnable的对象传递给ExecutorService的submit方法，则该run方法自动在一个线程上执行，并且会返回执行结果Future对象，但是在该Future对象上调用get方法，将返回null。</p></blockquote><p>5、CyclicBarrier和CountDownLatch的区别</p><blockquote><p>两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：</p><ol><li>CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行。</li><li>CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务。</li><li>CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了。</li></ol></blockquote><p>6、volatile的作用和原理</p><blockquote><p><strong>作用：</strong></p><ol><li>volatile保证变量对所有线程的可见性：当volatile变量被修改，新值对所有线程会立即更新。或者理解为多线程环境下使用volatile修饰的变量的值一定是最新的。</li><li>jdk1.5以后volatile完全避免了指令重排优化。</li></ol></blockquote><p>7、什么是线程安全</p><p>又是一个理论的问题，各式各样的答案有很多，我给出一个个人认为解释地最好的：如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。</p><p>这个问题有值得一提的地方，就是线程安全也是有几个级别的：</p><p>1）不可变</p><p>像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用</p><p>2）绝对线程安全</p><p>不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet</p><p>3）相对线程安全</p><p>相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。</p><p>4）线程非安全</p><p>这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类，点击这里了解为什么不安全。</p><p>8、Java中如何获取到线程dump文件</p><p>死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步：</p><p>1）获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java</p><p>2）打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid</p><p>另外提一点，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈。</p><p>9、一个线程如果出现了运行时异常会怎么样</p><p>如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放</p><p>10、如何在两个线程之间共享数据</p><p>通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的</p><p>11、sleep方法和wait方法有什么区别</p><p>这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器</p><p>12、生产者消费者模型的作用是什么</p><p>这个问题很理论，但是很重要：</p><p>1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用</p><p>2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约</p><p>13、ThreadLocal有什么用</p><p>简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了</p><p>14、为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用</p><p>这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁</p><p>15、wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别</p><p>wait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于：wait()方法立即释放对象监视器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器。</p><p>16、为什么要使用线程池</p><p>避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。点击这里学习线程池详解。</p><p>17、怎么检测一个线程是否持有对象监视器</p><p>我也是在网上看到一道多线程面试题才知道有方法可以判断某个线程是否持有对象监视器：Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着”某条线程”指的是当前线程。</p><p>18、synchronized和ReentrantLock的区别</p><p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：</p><p>（1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</p><p>（2）ReentrantLock可以获取各种锁的信息</p><p>（3）ReentrantLock可以灵活地实现多路通知</p><p>另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。</p><p>19、ConcurrentHashMap的并发度是什么</p><p>ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？</p><p>20、ReadWriteLock是什么</p><p>首先明确一下，不是说ReentrantLock不好，只是ReentrantLock某些时候有局限。如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。</p><p>因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p><p>21、FutureTask是什么</p><p>这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。</p><p>22、Linux环境下如何查找哪个线程使用CPU最长</p><p>这是一个比较偏实践的问题，这种问题我觉得挺有意义的。可以这么做：</p><p>（1）获取项目的pid，jps或者ps -ef | grep java，这个前面有讲过</p><p>（2）top -H -p pid，顺序不能改变</p><p>这样就可以打印出当前的项目，每条线程占用CPU时间的百分比。注意这里打出的是LWP，也就是操作系统原生线程的线程号，我笔记本山没有部署Linux环境下的Java工程，因此没有办法截图演示，网友朋友们如果公司是使用Linux环境部署项目的话，可以尝试一下。</p><p>使用”top -H -p pid”+”jps pid”可以很容易地找到某条占用CPU高的线程的线程堆栈，从而定位占用CPU高的原因，一般是因为不当的代码操作导致了死循环。</p><p>最后提一点，”top -H -p pid”打出来的LWP是十进制的，”jps pid”打出来的本地线程号是十六进制的，转换一下，就能定位到占用CPU高的线程的当前线程堆栈了。</p><p>23、Java编程写一个会导致死锁的程序</p><p>第一次看到这个题目，觉得这是一个非常好的问题。很多人都知道死锁是怎么一回事儿：线程A和线程B相互等待对方持有的锁导致程序无限死循环下去。当然也仅限于此了，问一下怎么写一个死锁的程序就不知道了，这种情况说白了就是不懂什么是死锁，懂一个理论就完事儿了，实践中碰到死锁的问题基本上是看不出来的。</p><p>真正理解什么是死锁，这个问题其实不难，几个步骤：</p><p>1）两个线程里面分别持有两个Object对象：lock1和lock2。这两个lock作为同步代码块的锁；</p><p>2）线程1的run()方法中同步代码块先获取lock1的对象锁，Thread.sleep(xxx)，时间不需要太多，50毫秒差不多了，然后接着获取lock2的对象锁。这么做主要是为了防止线程1启动一下子就连续获得了lock1和lock2两个对象的对象锁</p><p>3）线程2的run)(方法中同步代码块先获取lock2的对象锁，接着获取lock1的对象锁，当然这时lock1的对象锁已经被线程1锁持有，线程2肯定是要等待线程1释放lock1的对象锁的</p><p>这样，线程1”睡觉”睡完，线程2已经获取了lock2的对象锁了，线程1此时尝试获取lock2的对象锁，便被阻塞，此时一个死锁就形成了。代码就不写了，占的篇幅有点多，Java多线程7：死锁这篇文章里面有，就是上面步骤的代码实现。</p><p>点击这里提供了一个死锁的案例。</p><p>24、怎么唤醒一个阻塞的线程</p><p>如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</p><p>25、不可变对象对多线程有什么帮助</p><p>前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。</p><p>26、什么是多线程的上下文切换</p><p>多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。</p><p>27、如果你提交任务时，线程池队列已满，这时会发生什么</p><p>这里区分一下：</p><p>1）如果使用的是无界队列LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务</p><p>2）如果使用的是有界队列比如ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，会根据maximumPoolSize的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue继续满，那么则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy</p><p>28、Java中用到的线程调度算法是什么</p><p>抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</p><p>29、Thread.sleep(0)的作用是什么</p><p>这个问题和上面那个问题是相关的，我就连在一起了。由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。</p><p>30、什么是自旋</p><p>很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p><p>31、什么是Java内存模型</p><p>Java内存模型定义了一种多线程访问Java内存的规范。Java内存模型要完整讲不是这里几句话能说清楚的，我简单总结一下Java内存模型的几部分内容：</p><p>1）Java内存模型将内存分为了主内存和工作内存。类的状态，也就是类之间共享的变量，是存储在主内存中的，每次Java线程用到这些主内存中的变量的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去</p><p>2）定义了几个原子操作，用于操作主内存和工作内存中的变量</p><p>3）定义了volatile变量的使用规则</p><p>4）happens-before，即先行发生原则，定义了操作A必然先行发生于操作B的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码、一个释放锁unlock的动作一定先行发生于后面对于同一个锁进行锁定lock的动作等等，只要符合这些规则，则不需要额外做同步措施，如果某段代码不符合所有的happens-before规则，则这段代码一定是线程非安全的</p><p>32、什么是CAS</p><p>CAS，全称为Compare and Swap，即比较-替换。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。更多CAS详情请点击这里学习。</p><p>33、什么是乐观锁和悲观锁</p><p>1）乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</p><p>2）悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。</p><p>点击这里了解更多乐观锁与悲观锁详情。</p><p>34、什么是AQS</p><p>简单说一下AQS，AQS全称为AbstractQueuedSychronizer，翻译过来应该是抽象队列同步器。</p><p>如果说java.util.concurrent的基础是CAS的话，那么AQS就是整个Java并发包的核心了，ReentrantLock、CountDownLatch、Semaphore等等都用到了它。AQS实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队列，前面一个线程使用ReentrantLock好了，则双向队列实际上的第一个Entry开始运行。</p><p>AQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，开发者可以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。</p><p>35、单例模式的线程安全性</p><p>老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下：</p><p>1）饿汉式单例模式的写法：线程安全</p><p>2）懒汉式单例模式的写法：非线程安全</p><p>3）双检锁单例模式的写法：线程安全</p><p>36、Semaphore有什么作用</p><p>Semaphore就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。</p><p>37、Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？</p><p>这是我之前的一个困惑，不知道大家有没有想过这个问题。某个方法中如果有多条语句，并且都在操作同一个类变量，那么在多线程环境下不加锁，势必会引发线程安全问题，这很好理解，但是size()方法明明只有一条语句，为什么还要加锁？</p><p>关于这个问题，在慢慢地工作、学习中，有了理解，主要原因有两点：</p><p>1）同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性</p><p>2）CPU执行代码，执行的不是Java代码，这点很关键，一定得记住。Java代码最终是被翻译成机器码执行的，机器码才是真正可以和硬件电路交互的代码。即使你看到Java代码只有一行，甚至你看到Java代码编译之后生成的字节码也只有一行，也不意味着对于底层来说这句语句的操作只有一个。一句”return count”假设被翻译成了三句汇编语句执行，一句汇编语句和其机器码做对应，完全可能执行完第一句，线程就切换了。</p><p>38、线程类的构造方法、静态块是被哪个线程调用的</p><p>这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。</p><p>如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：</p><p>1）Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的</p><p>2）Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的</p><p>39、同步方法和同步块，哪个是更好的选择</p><p>同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越小越好。</p><p>借着这一条，我额外提一点，虽说同步的范围越少越好，但是在Java虚拟机中还是存在着一种叫做锁粗化的优化方法，这种方法就是把同步范围变大。这是有用的，比方说StringBuffer，它是一个线程安全的类，自然最常用的append()方法是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁-&gt;解锁，这对性能不利，因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作，将多次的append的操作扩展到append方法的头尾，变成一个大的同步块，这样就减少了加锁–&gt;解锁的次数，有效地提升了代码执行的效率。</p><p>40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？</p><p>这是我在并发编程网上看到的一个问题，把这个问题放在最后一个，希望每个人都能看到并且思考一下，因为这个问题非常好、非常实际、非常专业。关于这个问题，个人看法是：</p><p>1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换</p><p>2）并发不高、任务执行时间长的业务要区分开看：</p><p>a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务</p><p>b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换</p><p>c）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考其他有关线程池的文章。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、多线程有什么用？&lt;/p&gt;
&lt;p&gt;1）发挥多核CPU的优势&lt;/p&gt;
&lt;p&gt;随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程”同时”运行罢了。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。&lt;/p&gt;
    
    </summary>
    
      <category term="基础面试题" scheme="http://swenfang.github.io/categories/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="基础面试题" scheme="http://swenfang.github.io/tags/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>日志框架面试题</title>
    <link href="http://swenfang.github.io/2019/05/12/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://swenfang.github.io/2019/05/12/面试总结/日志框架面试题/</id>
    <published>2019-05-12T13:53:46.473Z</published>
    <updated>2019-05-12T15:11:25.499Z</updated>
    
    <content type="html"><![CDATA[<h2 id="更快的执行速度"><a href="#更快的执行速度" class="headerlink" title="更快的执行速度"></a>更快的执行速度</h2><p>基于我们先前在log4j上的工作，logback 重写了内部的实现，在某些特定的场景上面，甚至可以比之前的速度快上10倍。在保证logback的组件更加快速的同时，同时所需的内存更加少。</p><a id="more"></a><h2 id="充分的测试"><a href="#充分的测试" class="headerlink" title="充分的测试"></a>充分的测试</h2><p>Logback 历经了几年，数不清小时数的测试。尽管log4j也是测试过的，但是Logback的测试更加充分，跟log4j不在同一个级别。我们认为，这正是人们选择Logback而不是log4j的最重要的原因。人们都希望即使在恶劣的条件下，你的登录依然稳定而可靠。</p><h2 id="logback-classic-非常自然的实现了SLF4J"><a href="#logback-classic-非常自然的实现了SLF4J" class="headerlink" title="logback-classic 非常自然的实现了SLF4J"></a>logback-classic 非常自然的实现了SLF4J</h2><p>logback-classic中的登陆类自然的实现了SLF4J。当你使用logback-classic作为底层实现时，涉及到LF4J日记系统的问题你完全不需要考虑。更进一步来说，由于 logback-classic强烈建议使用SLF4J作为客户端日记系统实现，如果需要切换到log4j或者其他，你只需要替换一个jar包即可，不需要去改变那些通过</p><p>SLF4J API 实现的代码。这可以大大减少更换日记系统的工作量。</p><h2 id="自动重新载入配置文件"><a href="#自动重新载入配置文件" class="headerlink" title="自动重新载入配置文件"></a>自动重新载入配置文件</h2><p>Logback-classic可以<a href="http://logback.qos.ch/manual/configuration.html#autoScan" target="_blank" rel="external">在配置文件被修改后，自动重新载入</a>。这个扫描过程很快，无资源争用，并且可以动态扩展支持在上百个线程之间每秒上百万个调用。它和应用服务器结合良好，并且在JEE环境通用，因为它不会调用创建一个单独的线程来做扫描。</p><h2 id="优雅地从I-O错误中恢复"><a href="#优雅地从I-O错误中恢复" class="headerlink" title="优雅地从I/O错误中恢复"></a>优雅地从I/O错误中恢复</h2><p>FileAppender和它的子类，包括RollingFileAppender，可以优雅的从I/O错误中恢复。所以，如果一个文件服务器临时宕机，你再也不需要重启你的应用，而日志功能就能正常工作。当文件服务器恢复工作，logback相关的appender就会透明地和快速的从上一个错误中恢复。</p><h2 id="自动清除旧的日志归档文件"><a href="#自动清除旧的日志归档文件" class="headerlink" title="自动清除旧的日志归档文件"></a>自动清除旧的日志归档文件</h2><p>通过设置<a href="http://logback.qos.ch/manual/appenders.html#TimeBasedRollingPolicy" target="_blank" rel="external">TimeBasedRollingPolicy</a> 或者 <a href="http://logback.qos.ch/manual/appenders.html#SizeAndTimeBasedFNATP" target="_blank" rel="external">SizeAndTimeBasedFNATP</a>的 maxHistory 属性，你就可以控制日志归档文件的最大数量。如果你的回滚策略是每月回滚的，并且你希望保存一年的日志，那么只需简单的设置maxHistory属性为12。对于12个月之前的归档日志文件将被自动清除。</p><h2 id="自动压缩归档日志文件"><a href="#自动压缩归档日志文件" class="headerlink" title="自动压缩归档日志文件"></a>自动压缩归档日志文件</h2><p><a href="http://logback.qos.ch/manual/appenders.html#RollingFileAppender" target="_blank" rel="external">RollingFileAppender</a>可以在回滚操作中，自动压缩归档日志文件。压缩通常是异步执行的，所以即使是很大的日志文件，你的应用都不会因此而被阻塞。</p><h2 id="谨慎模式"><a href="#谨慎模式" class="headerlink" title="谨慎模式"></a>谨慎模式</h2><p>在<a href="http://logback.qos.ch/manual/appenders.html#prudent" target="_blank" rel="external">谨慎模式</a>中，在多个JVM中运行的多个FileAppender实例，可以安全的写入统一个日志文件。谨慎模式可以在一定的限制条件下应用于RollingFileAppender。</p><h2 id="Lilith"><a href="#Lilith" class="headerlink" title="Lilith"></a>Lilith</h2><p><a href="http://lilith.huxhorn.de/" target="_blank" rel="external">Lilith</a>是logback的一个记录和访问事件查看器。它相当于log4j的 chainsaw，但是Lilith设计的目的是处理大量的日志记录。</p><h2 id="配置文件中的条件处理"><a href="#配置文件中的条件处理" class="headerlink" title="配置文件中的条件处理"></a>配置文件中的条件处理</h2><p>开发者通常需要在不同的目标环境中变换logback的配置文件，例如开发环境，测试环境和生产环境。这些配置文件大体是一样的，除了某部分会有不同。为了避免重复，logback支持<a href="http://logback.qos.ch/manual/configuration.html#conditional" target="_blank" rel="external">配置文件中的条件处理</a>，只需使用<if>,<then>和<else>，那么同一个配置文件就可以在不同的环境中使用了。</else></then></if></p><h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><p>Logback拥有远比log4j更丰富的<a href="http://logback.qos.ch/manual/filters.html" target="_blank" rel="external">过滤能力</a>。例如，让我们假设，有一个相当重要的商业应用部署在生产环境。考虑到大量的交易数据需要处理，记录级别被设置为WARN，那么只有警告和错误信息才会被记录。现在，想象一下，你在开发环境遇到了一个臭虫，但是在测试平台中却很难发现，因为一些环境之间(生产环境/测试环境)的未知差异。</p><p>使用log4j，你只能选择在生产系统中降低记录的级别到DEBUG，来尝试发现问题。但是很不幸，这会生成大量的日志记录，让分析变得困难。更重要的是，多余的日志记录会影响到生产环境的性能。</p><p>使用logback，你可以选择保留只所有用户的WARN级别的日志，而除了某个用户，例如Alice，而她就是问题的相关用户。当Alice登录系统，她就会以DEBUG级别被记录，而其他用户仍然是以WARN级别来记录日志。这个功能，可以通过在配置文件的XML中添加4行。请在<a href="http://logback.qos.ch/manual/filters.html#TurboFilter" target="_blank" rel="external">相关章节</a>中查找MDCFilter</p><h2 id="SiftingAppender"><a href="#SiftingAppender" class="headerlink" title="SiftingAppender"></a>SiftingAppender</h2><p><a href="http://logback.qos.ch/manual/appenders.html#SiftingAppender" target="_blank" rel="external">SiftingAppender</a>是一个全能的追加器。它可以基于任何给定的实时属性分开（或者筛选）日志。例如，SiftingAppender可以基于用户会话分开日志事件，这样，可以为每一个用户建立一个独立的日志文件。</p><h2 id="堆栈轨迹信息包含包的数据"><a href="#堆栈轨迹信息包含包的数据" class="headerlink" title="堆栈轨迹信息包含包的数据"></a><strong>堆栈轨迹信息包含包的数据</strong></h2><p>当logback打印一个异常，堆栈轨迹信息将包含包的相关数据。下面是一个通过 <a href="http://logback.qos.ch/demo.html" target="_blank" rel="external">logback-demo</a> 生成的堆栈信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="number">14</span>:<span class="number">28</span>:<span class="number">48.835</span> [btpool0-<span class="number">7</span>] INFO  c.q.l.demo.prime.PrimeAction - <span class="number">99</span> is not a valid value</div><div class="line">java.lang.Exception: <span class="number">99</span> is invalid</div><div class="line">  at ch.qos.logback.demo.prime.PrimeAction.execute(PrimeAction.java:<span class="number">28</span>) [classes/:na]</div><div class="line">  at org.apache.struts.action.RequestProcessor.processActionPerform(RequestProcessor.java:<span class="number">431</span>) [struts-<span class="number">1.2</span>.9.jar:<span class="number">1.2</span>.9]</div><div class="line">  at org.apache.struts.action.RequestProcessor.process(RequestProcessor.java:<span class="number">236</span>) [struts-<span class="number">1.2</span>.9.jar:<span class="number">1.2</span>.9]</div><div class="line">  at org.apache.struts.action.ActionServlet.doPost(ActionServlet.java:<span class="number">432</span>) [struts-<span class="number">1.2</span>.9.jar:<span class="number">1.2</span>.9]</div><div class="line">  at javax.servlet.http.HttpServlet.service(HttpServlet.java:<span class="number">820</span>) [servlet-api-<span class="number">2.5</span>-<span class="number">6.1</span>.12.jar:<span class="number">6.1</span>.12]</div><div class="line">  at org.mortbay.jetty.servlet.ServletHolder.handle(ServletHolder.java:<span class="number">502</span>) [jetty-<span class="number">6.1</span>.12.jar:<span class="number">6.1</span>.12]</div><div class="line">  at ch.qos.logback.demo.UserServletFilter.doFilter(UserServletFilter.java:<span class="number">44</span>) [classes/:na]</div><div class="line">  at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:<span class="number">1115</span>) [jetty-<span class="number">6.1</span>.12.jar:<span class="number">6.1</span>.12]</div><div class="line">  at org.mortbay.jetty.servlet.ServletHandler.handle(ServletHandler.java:<span class="number">361</span>) [jetty-<span class="number">6.1</span>.12.jar:<span class="number">6.1</span>.12]</div><div class="line">  at org.mortbay.jetty.webapp.WebAppContext.handle(WebAppContext.java:<span class="number">417</span>) [jetty-<span class="number">6.1</span>.12.jar:<span class="number">6.1</span>.12]</div><div class="line">  at org.mortbay.jetty.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:<span class="number">230</span>) [jetty-<span class="number">6.1</span>.12.jar:<span class="number">6.1</span>.12]</div></pre></td></tr></table></figure><p>从上面的信息，你可以发现这个应用使用Struts 1.2.9 而且是使用 jetty 6.1.12部署的。所以，堆栈轨迹信息将快速的告诉读者，关于异常发生的类还有包和包的版本。当你的客户发送一个堆栈轨迹信息给你，作为一个开发人员，你就不需要让他们告诉你他们正在使用的包的版本。这项信息已经包括在堆栈轨迹信息中。详细请参考  <a href="http://logback.qos.ch/manual/layouts.html#xThrowable" target="_blank" rel="external">“%xThrowable” conversion word</a>.</p><p>这项功能可以非常有帮助的说明，有些用户误以为这是<a href="http://www.jetbrains.net/devnet/message/5259058" target="_blank" rel="external">IDE的功能</a>。</p><h2 id="Log-back-access模块，提供了通过HTTP访问日志的能力，是logback不可或缺的部分"><a href="#Log-back-access模块，提供了通过HTTP访问日志的能力，是logback不可或缺的部分" class="headerlink" title="Log-back-access模块，提供了通过HTTP访问日志的能力，是logback不可或缺的部分"></a>Log-back-access模块，提供了通过HTTP访问日志的能力，是logback不可或缺的部分</h2><p>最后但绝非最不重要的是，作为logback发布包的一部分，logback-access模块可与Jetty或者Tomcat进行集成，提供了非常丰富而强大的通过HTTP访问日志的功能。因为logback-access模块是logback初期设计方案中的一部分，因此，所有你所喜欢的logback-classic模块所提供的全部特性logback-access同样也具备。</p><h2 id="logback的优点"><a href="#logback的优点" class="headerlink" title="logback的优点"></a>logback的优点</h2><ul><li>内核重写、测试充分、初始化内存加载更小，这一切让logback性能和log4j相比有诸多倍的提升</li><li>logback非常自然地直接实现了slf4j，这个严格来说算不上优点，只是这样，再理解slf4j的前提下会很容易理解logback，也同时很容易用其他日志框架替换logback</li><li>logback有比较齐全的200多页的文档</li><li>logback当配置文件修改了，支持自动重新加载配置文件，扫描过程快且<strong>安全</strong>，它并不需要另外创建一个扫描线程</li><li>支持自动去除旧的日志文件，可以控制已经产生日志文件的最大数量</li></ul><h2 id="logback加载"><a href="#logback加载" class="headerlink" title="logback加载"></a>logback加载</h2><p>我们简单分析一下logback加载过程，当我们使用logback-classic.jar时，应用启动，那么logback会按照如下顺序进行扫描：</p><ul><li>在系统配置文件System Properties中寻找是否有logback.configurationFile对应的value</li><li>在classpath下寻找是否有logback.groovy（即logback支持groovy与xml两种配置方式）</li><li>在classpath下寻找是否有logback-test.xml</li><li>在classpath下寻找是否有logback.xml</li></ul><p>以上任何一项找到了，就不进行后续扫描，按照对应的配置进行logback的初始化，具体代码实现可见ch.qos.logback.classic.util.ContextInitializer类的findURLOfDefaultConfigurationFile方法。</p><p>当所有以上四项都找不到的情况下，logback会调用ch.qos.logback.classic.BasicConfigurator的configure方法，构造一个ConsoleAppender用于向控制台输出日志，默认日志输出格式为”%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n”。</p><h2 id="logback的configuration"><a href="#logback的configuration" class="headerlink" title="logback的configuration"></a>logback的configuration</h2><p>logback的重点应当是Appender、Logger、Pattern，在这之前先简单了解一下logback的<configuration>，<configuration>只有三个属性：</configuration></configuration></p><ul><li>scan：当scan被设置为true时，当配置文件发生改变，将会被重新加载，默认为true</li><li>scanPeriod：检测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认为毫秒，当scan=true时这个值生效，默认时间间隔为1分钟</li><li>debug：当被设置为true时，将打印出logback内部日志信息，实时查看logback运行信息，默认为false</li></ul><h2 id="与"><a href="#与" class="headerlink" title="与"></a><logger>与<root></root></logger></h2><p>先从最基本的<logger>与<root>开始。</root></logger></p><p><strong><logger>用来设置某一个包或者具体某一个类的日志打印级别、以及指定<appender></appender></logger></strong>。<logger>可以包含零个或者多个<appender-ref>元素，标识这个appender将会添加到这个logger。<logger>仅有一个name属性、一个可选的level属性和一个可选的additivity属性：</logger></appender-ref></logger></p><ul><li>name：用来指定受此logger约束的某一个包或者具体的某一个类</li><li>level：用来设置打印级别，五个常用打印级别从低至高依次为TRACE、DEBUG、INFO、WARN、ERROR，如果未设置此级别，那么当前logger会继承上级的级别</li><li>additivity：是否向上级logger传递打印信息，默认为true</li></ul><p><root>也是<logger>元素，但是它是根logger，只有一个level属性，因为它的name就是root。</logger></root></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;更快的执行速度&quot;&gt;&lt;a href=&quot;#更快的执行速度&quot; class=&quot;headerlink&quot; title=&quot;更快的执行速度&quot;&gt;&lt;/a&gt;更快的执行速度&lt;/h2&gt;&lt;p&gt;基于我们先前在log4j上的工作，logback 重写了内部的实现，在某些特定的场景上面，甚至可以比之前的速度快上10倍。在保证logback的组件更加快速的同时，同时所需的内存更加少。&lt;/p&gt;
    
    </summary>
    
      <category term="基础面试题" scheme="http://swenfang.github.io/categories/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="基础面试题" scheme="http://swenfang.github.io/tags/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Jdk1.7与 jdk1.8的区别和最新的特征</title>
    <link href="http://swenfang.github.io/2019/05/12/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/Jdk1.7%E4%B8%8E%20jdk1.8%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E6%9C%80%E6%96%B0%E7%9A%84%E7%89%B9%E5%BE%81/"/>
    <id>http://swenfang.github.io/2019/05/12/面试总结/Jdk1.7与 jdk1.8的区别和最新的特征/</id>
    <published>2019-05-12T13:50:51.557Z</published>
    <updated>2019-05-12T15:10:15.917Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jdk7的新特性"><a href="#jdk7的新特性" class="headerlink" title="jdk7的新特性"></a>jdk7的新特性</h2><p>jdk7的新特性方面主要有下面几方面的增强</p><a id="more"></a><h3 id="二进制变量的表示"><a href="#二进制变量的表示" class="headerlink" title="二进制变量的表示"></a>二进制变量的表示</h3><blockquote><p>二进制变量的表示,支持将整数类型用二进制来表示，用0b开头。</p><p>所有整数int、short、long、byte都可以用二进制表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;<span class="keyword">byte</span> aByte = (<span class="keyword">byte</span>) <span class="number">0b00100001</span>;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h3 id="Switch语句支持String类型"><a href="#Switch语句支持String类型" class="headerlink" title="Switch语句支持String类型"></a>Switch语句支持String类型</h3><h3 id="Try-with-resource语句"><a href="#Try-with-resource语句" class="headerlink" title="Try-with-resource语句"></a>Try-with-resource语句</h3><p>参考博客：<a href="http://www.cnblogs.com/aspirant/p/8621848.html" target="_blank" rel="external">try-with-resources语句</a> </p><blockquote><p>try-with-resources语句是一种声明了一种或多种资源的try语句。资源是指在程序用完了之后必须要关闭的对象。try-with-resources语句保证了每个声明了的资源在语句结束的时候都会被关闭。任何实现了java.lang.AutoCloseable接口的对象，和实现了java.io.Closeable接口的对象，都可以当做资源使用。</p></blockquote><h3 id="Catch多个异常"><a href="#Catch多个异常" class="headerlink" title="Catch多个异常"></a>Catch多个异常</h3><blockquote><p>在Java 7中，catch代码块得到了升级，用以在单个catch块中处理多个异常。如果你要捕获多个异常并且它们包含相似的代码，使用这一特性将会减少代码重复度。下面用一个例子来理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;<span class="keyword">catch</span>(IOException | SQLException | Exception ex)&#123;</div><div class="line">&gt;     logger.error(ex);</div><div class="line">&gt;     <span class="keyword">throw</span> <span class="keyword">new</span> MyException(ex.getMessage());</div><div class="line">&gt;&#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h3 id="数字类型的下划线表示"><a href="#数字类型的下划线表示" class="headerlink" title="数字类型的下划线表示"></a>数字类型的下划线表示</h3><blockquote><p>数字类型的下划线表示 更友好的表示方式，不过要注意下划线添加的一些标准。</p><p>字面常量数字里加下划线的规则：下划线只能在数字之间，在数字的开始或结束一定不能使用下划线。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingUnderscoreInNumericLiterals</span> </span>&#123;</div><div class="line">&gt;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">&gt;        <span class="keyword">int</span> int_num = <span class="number">1_00_00_000</span>;</div><div class="line">&gt;        System.out.println(<span class="string">"int num:"</span> + int_num);</div><div class="line">&gt;</div><div class="line">&gt;        <span class="keyword">long</span> long_num = <span class="number">1_00_00_000</span>;</div><div class="line">&gt;        System.out.println(<span class="string">"long num:"</span> + long_num);</div><div class="line">&gt;</div><div class="line">&gt;        <span class="keyword">float</span> float_num = <span class="number">2.10_001F</span>;</div><div class="line">&gt;        System.out.println(<span class="string">"float num:"</span> + float_num);</div><div class="line">&gt;</div><div class="line">&gt;        <span class="keyword">double</span> double_num = <span class="number">2.10_12_001</span>;</div><div class="line">&gt;        System.out.println(<span class="string">"double num:"</span> + double_num);</div><div class="line">&gt;    &#125;</div><div class="line">&gt;&#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h3 id="泛型实例的创建简化"><a href="#泛型实例的创建简化" class="headerlink" title="泛型实例的创建简化"></a>泛型实例的创建简化</h3><blockquote><p>泛型实例的创建可以通过类型推断来简化 可以去掉后面new部分的泛型类型，只用&lt;&gt;就可以了。</p></blockquote><h3 id="并发工具增强"><a href="#并发工具增强" class="headerlink" title="并发工具增强"></a>并发工具增强</h3><blockquote><p>并发工具增强： fork-join框架最大的增强，充分利用多核特性，将大问题分解成各个子问题，由多个cpu可以同时解决多个子问题，最后合并结果，继承RecursiveTask，实现compute方法，然后调用fork计算，最后用join合并结果。    </p></blockquote><p>参考自己写的例子：<a href="http://www.cnblogs.com/aspirant/p/8622584.html" target="_blank" rel="external">Java7 Fork-Join 框架：任务切分，并行处理</a></p><h2 id="JDK1-8的新特性"><a href="#JDK1-8的新特性" class="headerlink" title="JDK1.8的新特性"></a>JDK1.8的新特性</h2><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190506104625-683894.jpg" alt=""></p><h3 id="接口的默认和静态方法"><a href="#接口的默认和静态方法" class="headerlink" title="接口的默认和静态方法"></a>接口的默认和静态方法</h3><blockquote><p>Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 default关键字即可，这个特征又叫做扩展方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JDK8Interface</span> </span>&#123;</div><div class="line">&gt;    <span class="comment">// static修饰符定义静态方法  </span></div><div class="line">&gt;    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;  </div><div class="line">&gt;        System.out.println(<span class="string">"接口中的静态方法"</span>);  </div><div class="line">&gt;    &#125;  </div><div class="line">&gt;    <span class="comment">// default修饰符定义默认方法  </span></div><div class="line">&gt;    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">defaultMethod</span><span class="params">()</span> </span>&#123;  </div><div class="line">&gt;        System.out.println(<span class="string">"接口中的默认方法"</span>);  </div><div class="line">&gt;    &#125;  </div><div class="line">&gt;&#125;  </div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><blockquote><p>Lambda 表达式：(例如： (x, y) -&gt; { return x + y; } ;λ表达式有三部分组成：参数列表，箭头（-&gt;），以及一个表达式或语句块。)</p><p>参考博客: <a href="http://www.cnblogs.com/LvLoveYuForever/p/6697982.html" target="_blank" rel="external">lambda表达式详解</a>; </p><p><a href="https://www.jianshu.com/p/40f833bf2c48" target="_blank" rel="external">函数式接口和Lambda表达式深入理解</a></p><p>在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;Collections.sort(names, (String a, String b) -&gt; &#123;</div><div class="line">&gt;      <span class="keyword">return</span> b.compareTo(a);</div><div class="line">&gt;&#125;);</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h3 id="方法与构造函数引用"><a href="#方法与构造函数引用" class="headerlink" title="方法与构造函数引用"></a>方法与构造函数引用</h3><blockquote><p>Java 8 允许你使用 : 关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;converter = something::startsWith;</div><div class="line">&gt;String converted = converter.convert(<span class="string">"Java"</span>);</div><div class="line">&gt;System.out.println(converted);</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><blockquote><p>所谓的函数式接口，当然首先是一个接口，然后就是在这个接口里面只能有一个抽象方法。</p></blockquote><h3 id="Annotation-注解"><a href="#Annotation-注解" class="headerlink" title="Annotation 注解"></a>Annotation 注解</h3><blockquote><p>Annotation 注解：支持多重注解：</p><p>很多时候一个注解需要在某一位置多次使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;YourAnnotation</div><div class="line">&gt;<span class="meta">@YourAnnotation</span></div><div class="line">&gt;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">&gt;    <span class="comment">//TODO</span></div><div class="line">&gt;&#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h3 id="新的日期时间-API"><a href="#新的日期时间-API" class="headerlink" title="新的日期时间 API"></a>新的日期时间 API</h3><blockquote><p>Java 8新的Date-Time API (JSR 310)受Joda-Time的影响，提供了新的java.time包，可以用来替代</p><p>java.util.Date和java.util.Calendar。一般会用到Clock、LocaleDate、LocalTime、LocaleDateTime、ZonedDateTime、Duration这些类，对于时间日期的改进还是非常不错的。</p></blockquote><h3 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h3><blockquote><p>Base64编码是一种常见的字符编码，可以用来作为电子邮件或Web Service附件的传输编码。</p><p>在Java 8中，Base64编码成为了Java类库的标准。Base64类同时还提供了对URL、MIME友好的编码器与解码器。</p></blockquote><h3 id="JavaScript引擎Nashorn"><a href="#JavaScript引擎Nashorn" class="headerlink" title="JavaScript引擎Nashorn"></a>JavaScript引擎Nashorn</h3><blockquote><p>Nashorn允许在JVM上开发运行JavaScript应用，允许Java与JavaScript相互调用。</p></blockquote><h3 id="Stream的使用"><a href="#Stream的使用" class="headerlink" title="Stream的使用"></a>Stream的使用</h3><blockquote><p>Stream API是把真正的函数式编程风格引入到Java中。其实简单来说可以把Stream理解为MapReduce，当然Google的MapReduce的灵感也是来自函数式编程。她其实是一连串支持连续、并行聚集操作的元素。从语法上看，也很像linux的管道、或者链式编程，代码写起来简洁明了，非常酷帅！</p></blockquote><h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><blockquote><p>Java 8引入Optional类来防止空指针异常，Optional类最先是由Google的Guava项目引入的。Optional类实际上是个容器：它可以保存类型T的值，或者保存null。使用Optional类我们就不用显式进行空指针检查了。</p></blockquote><h3 id="扩展注解的支持"><a href="#扩展注解的支持" class="headerlink" title="扩展注解的支持"></a>扩展注解的支持</h3><blockquote><p>Java 8扩展了注解的上下文，几乎可以为任何东西添加注解，包括局部变量、泛型类、父类与接口的实现，连方法的异常也能添加注解。</p></blockquote><h3 id="并行（parallel）数组"><a href="#并行（parallel）数组" class="headerlink" title="并行（parallel）数组"></a>并行（parallel）数组</h3><blockquote><p>支持对数组进行并行处理，主要是parallelSort()方法，它可以在多核机器上极大提高数组排序的速度。</p></blockquote><h3 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h3><blockquote><p>Java 8将方法的参数名加入了字节码中，这样在运行时通过反射就能获取到参数名，只需要在编译时使用-parameters参数。</p><p>新的Java1.8对IO做了升级：</p><p>关于IO/NIO 新IO的对比，请参考：<a href="http://www.cnblogs.com/aspirant/p/8630283.html" target="_blank" rel="external">Java NIO：IO与NIO的区别 -阿里面试题</a></p><p>还对CurrentHashMap做了升级，请参考：<a href="http://www.cnblogs.com/aspirant/p/8623864.html" target="_blank" rel="external">ConcurrentHashMap原理分析（1.7与1.8）</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;jdk7的新特性&quot;&gt;&lt;a href=&quot;#jdk7的新特性&quot; class=&quot;headerlink&quot; title=&quot;jdk7的新特性&quot;&gt;&lt;/a&gt;jdk7的新特性&lt;/h2&gt;&lt;p&gt;jdk7的新特性方面主要有下面几方面的增强&lt;/p&gt;
    
    </summary>
    
      <category term="基础面试题" scheme="http://swenfang.github.io/categories/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="基础面试题" scheme="http://swenfang.github.io/tags/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Mybaties 面试题</title>
    <link href="http://swenfang.github.io/2019/05/12/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/Mybaties%20%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://swenfang.github.io/2019/05/12/面试总结/Mybaties 面试题/</id>
    <published>2019-05-12T13:48:03.030Z</published>
    <updated>2019-05-12T15:10:54.970Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hibernate与MyBatis的异同"><a href="#Hibernate与MyBatis的异同" class="headerlink" title="Hibernate与MyBatis的异同"></a>Hibernate与MyBatis的异同</h2><p>相同点：<br>Hibernate与MyBatis都可以是通过SessionFactoryBuider由XML配置文件生成SessionFactory，然后由SessionFactory 生成Session，最后由Session来开启执行事务和SQL语句。其中SessionFactoryBuider，SessionFactory，Session的生命周期都是差不多的。Hibernate和MyBatis都支持JDBC和JTA事务处理。</p><a id="more"></a><p>Mybatis优势：<br>MyBatis可以进行更为细致的SQL优化，可以减少查询字段。<br>MyBatis容易掌握，而Hibernate门槛较高。<br>Hibernate优势：<br>Hibernate的DAO层开发比MyBatis简单，Mybatis需要维护SQL和结果映射。<br>Hibernate对对象的维护和缓存要比MyBatis好，对增删改查的对象的维护要方便。<br>Hibernate数据库移植性很好，MyBatis的数据库移植性不好，不同的数据库需要写不同SQL。<br>Hibernate有更好的二级缓存机制，可以使用第三方缓存。MyBatis本身提供的缓存机制不佳。</p><h2 id="Hibernate与MyBatis在sql优化方面异同"><a href="#Hibernate与MyBatis在sql优化方面异同" class="headerlink" title="Hibernate与MyBatis在sql优化方面异同"></a>Hibernate与MyBatis在sql优化方面异同</h2><p>Hibernate的查询会将表中的所有字段查询出来，这一点会有性能消耗。Hibernate也可以自己写SQL来指定需要查询的字段，但这样就破坏了Hibernate开发的简洁性。<br>而Mybatis的SQL是手动编写的，所以可以按需求指定查询的字段。<br>Hibernate HQL语句的调优需要将SQL打印出来，而Hibernate的SQL被很多人嫌弃因为太丑了。<br>MyBatis的SQL是自己手动写的所以调整方便。但Hibernate具有自己的日志统计。Mybatis本身不带日志统计，使用Log4j进行日志记录。</p><h2 id="Hibernate与MyBatis对象管理对比"><a href="#Hibernate与MyBatis对象管理对比" class="headerlink" title="Hibernate与MyBatis对象管理对比"></a>Hibernate与MyBatis对象管理对比</h2><p>Hibernate 是完整的对象/关系映射解决方案，它提供了对象状态管理（state management）的功能，使开发者不再需要理会底层数据库系统的细节。也就是说，相对于常见的 JDBC/SQL 持久层方案中需要管理 SQL 语句，Hibernate采用了更自然的面向对象的视角来持久化 Java 应用中的数据。<br>换句话说，使用 Hibernate 的开发者应该总是关注对象的状态（state），不必考虑 SQL 语句的执行。这部分细节已经由 Hibernate 掌管妥当，只有开发者在进行系统性能调优的时候才需要进行了解。而MyBatis在这一块没有文档说明，用户需要对对象自己进行详细的管理。</p><h2 id="Mybatis分层结构"><a href="#Mybatis分层结构" class="headerlink" title="Mybatis分层结构"></a>Mybatis分层结构</h2><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190426111417-279991.jpg" alt=""></p><h2 id="MyBatis-编程步骤"><a href="#MyBatis-编程步骤" class="headerlink" title="MyBatis 编程步骤"></a>MyBatis 编程步骤</h2><ol><li>创建 SqlSessionFactory</li><li>通过 SqlSessionFactory 获取 SqlSession</li><li>通过 SqlSession 执行数据库操作</li><li>提交事务</li><li>关闭会话</li></ol><h2 id="讲下MyBatis的缓存"><a href="#讲下MyBatis的缓存" class="headerlink" title="讲下MyBatis的缓存"></a>讲下MyBatis的缓存</h2><p>MyBatis的缓存分为一级缓存和二级缓存,一级缓存放在session里面,默认就有,二级缓存放在它的命名空间里,默认是不打开的,使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache></cache></p><h2 id="Mybatis的一级、二级缓存"><a href="#Mybatis的一级、二级缓存" class="headerlink" title="Mybatis的一级、二级缓存"></a>Mybatis的一级、二级缓存</h2><ol><li>一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</li><li>二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache> ；</cache></li><li>对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</li></ol><h2 id="Mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis是如何进行分页的？分页插件的原理是什么？"></a>Mybatis是如何进行分页的？分页插件的原理是什么？</h2><ol><li>Mybatis使用RowBounds对象进行分页，也可以直接编写sql实现分页，也可以使用Mybatis的分页插件。</li><li>分页插件的原理：实现Mybatis提供的接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql。</li></ol><p>举例：select <em> from student，拦截sql后重写为：select t.</em> from （select * from student）t limit 0，10</p><h2 id="Mybatis都有哪些Executor执行器？它们之间的区别是什么？"><a href="#Mybatis都有哪些Executor执行器？它们之间的区别是什么？" class="headerlink" title="Mybatis都有哪些Executor执行器？它们之间的区别是什么？"></a>Mybatis都有哪些Executor执行器？它们之间的区别是什么？</h2><p>Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。<br> SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。<br> ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。<br> BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。<br> 作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内</p><h2 id="简述Mybatis的插件运行原理，以及如何编写一个插件？"><a href="#简述Mybatis的插件运行原理，以及如何编写一个插件？" class="headerlink" title="简述Mybatis的插件运行原理，以及如何编写一个插件？"></a>简述Mybatis的插件运行原理，以及如何编写一个插件？</h2><ol><li>Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis通过动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</li><li>实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</li></ol><h2 id="Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？"><a href="#Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？" class="headerlink" title="Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？"></a>Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？</h2><ol><li>Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能。</li><li>Mybatis提供了9种动态sql标签：trim|where|set|foreach|if|choose|when|otherwise|bind。</li><li>其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。</li></ol><h2 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h2><p>1）#{}是预编译处理，${}是字符串替换。</p><p>2）Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</p><p>3）Mybatis在处理${}时，就是把${}替换成变量的值。</p><p>4）使用#{}可以有效的防止SQL注入，提高系统安全性。</p><h2 id="字段与数据库列名不一致"><a href="#字段与数据库列名不一致" class="headerlink" title="字段与数据库列名不一致"></a>字段与数据库列名不一致</h2><ul><li>为查询出的字段起别名，保证名称与类中属性名相同(缺点：在查询字段过多的情况下会降低代码可读性且导致重复代码增多)</li><li>因为Mybatis映射的原理就是通过返回的数据库字段名找实体类的setXxx方法进行对应注入，故可以采用让实体类set方法名对应数据库字段名</li><li>(推荐)利用XxxMapper.xml的sql标签(同解决方案一原理相同,将方案一提取封装,简化操作)</li><li>(推荐)使用resultMap手动映射一个数据结果的封装规则</li></ul><h2 id="Statement和PrepareStatement的区别"><a href="#Statement和PrepareStatement的区别" class="headerlink" title="Statement和PrepareStatement的区别"></a>Statement和PrepareStatement的区别</h2><p>PreparedStatement：表示预编译的 SQL 语句的对象。<br> （1）PrepareStatement可以使用占位符，是预编译的，批处理比Statement效率高<br> （2）在对数据库只执行一次性存取的时侯，用 Statement 对象进行处理。<br> （3）PreparedStatement的第一次执行消耗是很高的. 它的性能体现在后面的重复执行</p><h2 id="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"><a href="#为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？" class="headerlink" title="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"></a>为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h2><p>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p><h2 id="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"></a>Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h2><p>1）Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。</p><p>2）它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p><h2 id="MyBatis与Hibernate有哪些不同？"><a href="#MyBatis与Hibernate有哪些不同？" class="headerlink" title="MyBatis与Hibernate有哪些不同？"></a>MyBatis与Hibernate有哪些不同？</h2><ol><li>Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。</li><li>Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。</li><li>Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的缺点是学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。</li></ol><p>总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。</p><h2 id="MyBatis的好处是什么？"><a href="#MyBatis的好处是什么？" class="headerlink" title="MyBatis的好处是什么？"></a>MyBatis的好处是什么？</h2><ol><li>MyBatis把sql语句从Java源程序中独立出来，放在单独的XML文件中编写，给程序的维护带来了很大便利。</li><li>MyBatis封装了底层JDBC API的调用细节，并能自动将结果集转换成Java Bean对象，大大简化了Java数据库编程的重复工作。</li><li>因为MyBatis需要程序员自己去编写sql语句，程序员可以结合数据库自身的特点灵活控制sql语句，因此能够实现比Hibernate等全自动orm框架更高的查询效率，能够完成复杂查询。</li></ol><h2 id="简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"><a href="#简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？" class="headerlink" title="简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"></a>简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</h2><p>Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，<parametermap>标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。<resultmap>标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个<select>、<insert>、<update>、<delete>标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。</delete></update></insert></select></resultmap></parametermap></p><h2 id="什么是MyBatis的接口绑定-有什么好处"><a href="#什么是MyBatis的接口绑定-有什么好处" class="headerlink" title="什么是MyBatis的接口绑定,有什么好处"></a>什么是MyBatis的接口绑定,有什么好处</h2><p>接口映射就是在MyBatis中任意定义接口,然后把接口里面的方法和SQL语句绑定,我们直接调用接口方法就可以,这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置.</p><h2 id="接口绑定有几种实现方式-分别是怎么实现的"><a href="#接口绑定有几种实现方式-分别是怎么实现的" class="headerlink" title="接口绑定有几种实现方式,分别是怎么实现的?"></a>接口绑定有几种实现方式,分别是怎么实现的?</h2><p>接口绑定有两种实现方式,一种是通过注解绑定,就是在接口的方法上面加上@Select@Update等注解里面包含Sql语句来绑定,另外一种就是通过xml里面写SQL来绑定,在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名.</p><h2 id="什么情况下用注解绑定-什么情况下用xml绑定？"><a href="#什么情况下用注解绑定-什么情况下用xml绑定？" class="headerlink" title="什么情况下用注解绑定,什么情况下用xml绑定？"></a>什么情况下用注解绑定,什么情况下用xml绑定？</h2><p>当Sql语句比较简单时候,用注解绑定；当SQL语句比较复杂时候,用xml绑定,一般用xml绑定的比较多</p><h2 id="MyBatis实现一对一有几种方式-具体怎么操作的？"><a href="#MyBatis实现一对一有几种方式-具体怎么操作的？" class="headerlink" title="MyBatis实现一对一有几种方式?具体怎么操作的？"></a>MyBatis实现一对一有几种方式?具体怎么操作的？</h2><p>有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次,通过在resultMap里面配置association节点配置一对一的类就可以完成;嵌套查询是先查一个表,根据这个表里面的结果的外键id,去再另外一个表里面查询数据,也是通过association配置,但另外一个表的查询通过select属性配置。</p><h2 id="Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？"><a href="#Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？" class="headerlink" title="Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？"></a>Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？</h2><p>能，Mybatis不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把selectOne()修改为selectList()即可；多对多查询，其实就是一对多查询，只需要把selectOne()修改为selectList()即可。</p><p>关联对象查询，有两种实现方式，一种是单独发送一个sql去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用join查询，一部分列是A对象的属性值，另外一部分列是关联对象B的属性值，好处是只发一个sql查询，就可以把主对象和其关联对象查出来。</p><h2 id="MyBatis里面的动态Sql是怎么设定的-用什么语法"><a href="#MyBatis里面的动态Sql是怎么设定的-用什么语法" class="headerlink" title="MyBatis里面的动态Sql是怎么设定的?用什么语法?"></a>MyBatis里面的动态Sql是怎么设定的?用什么语法?</h2><p>MyBatis里面的动态Sql一般是通过if节点来实现,通过OGNL语法来实现,但是如果要写的完整,必须配合where,trim节点,where节点是判断包含节点有内容就插入where,否则不插入,trim节点是用来判断如果动态语句是以and 或or开始,那么会自动把这个and或者or取掉。</p><h2 id="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h2><p>第一种是使用<resultmap>标签，逐一定义列名和对象属性名之间的映射关系。</resultmap></p><p>第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。</p><p>有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p><h2 id="Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？"><a href="#Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？" class="headerlink" title="Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？"></a>Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？</h2><p>还有很多其他的标签，<resultmap>、<parametermap>、<sql>、<include>、<selectkey>，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中<sql>为sql片段标签，通过<include>标签引入sql片段，<selectkey>为不支持自增的主键生成策略标签。</selectkey></include></sql></selectkey></include></sql></parametermap></resultmap></p><h2 id="当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定pojo？"><a href="#当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定pojo？" class="headerlink" title="当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定pojo？"></a>当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定pojo？</h2><ol><li>通过在查询的sql语句中定义字段名的别名。</li><li>通过<resultmap>来映射字段名和实体类属性名的一一对应的关系。</resultmap></li></ol><h2 id="模糊查询like语句该怎么写"><a href="#模糊查询like语句该怎么写" class="headerlink" title="模糊查询like语句该怎么写"></a>模糊查询like语句该怎么写</h2><ol><li>在java中拼接通配符，通过#{}赋值</li><li>在Sql语句中拼接通配符 （不安全 会引起Sql注入）</li></ol><h2 id="通常一个Xml映射文件，都会写一个Dao接口与之对应-Dao的工作原理，是否可以重载？"><a href="#通常一个Xml映射文件，都会写一个Dao接口与之对应-Dao的工作原理，是否可以重载？" class="headerlink" title="通常一个Xml映射文件，都会写一个Dao接口与之对应, Dao的工作原理，是否可以重载？"></a>通常一个Xml映射文件，都会写一个Dao接口与之对应, Dao的工作原理，是否可以重载？</h2><p>不能重载，因为通过Dao寻找Xml对应的sql的时候全限名+方法名的保存和寻找策略。接口工作原理为jdk动态代理原理，运行时会为dao生成proxy，代理对象会拦截接口方法，去执行对应的sql返回数据。</p><h2 id="Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？"><a href="#Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？" class="headerlink" title="Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？"></a>Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？</h2><p>虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在任何地方，Mybatis都可以正确识别。原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A标签时，B标签已经存在，A标签也就可以正常解析完成了。</p><h2 id="Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"><a href="#Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？" class="headerlink" title="Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"></a>Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</h2><p>不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。原因就是namespace+id是作为Map&lt;String, MappedStatement&gt;的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。</p><h2 id="Mybatis中如何执行批处理？"><a href="#Mybatis中如何执行批处理？" class="headerlink" title="Mybatis中如何执行批处理？"></a>Mybatis中如何执行批处理？</h2><p>使用BatchExecutor完成批处理。</p><h2 id="Mybatis都有哪些Executor执行器？它们之间的区别是什么？-1"><a href="#Mybatis都有哪些Executor执行器？它们之间的区别是什么？-1" class="headerlink" title="Mybatis都有哪些Executor执行器？它们之间的区别是什么？"></a>Mybatis都有哪些Executor执行器？它们之间的区别是什么？</h2><p>Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。1）SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。2）ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map3）BatchExecutor：完成批处理。</p><h2 id="Mybatis中如何指定使用哪一种Executor执行器？"><a href="#Mybatis中如何指定使用哪一种Executor执行器？" class="headerlink" title="Mybatis中如何指定使用哪一种Executor执行器？"></a>Mybatis中如何指定使用哪一种Executor执行器？</h2><p>在Mybatis配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数。</p><h2 id="Mybatis执行批量插入，能返回数据库主键列表吗？"><a href="#Mybatis执行批量插入，能返回数据库主键列表吗？" class="headerlink" title="Mybatis执行批量插入，能返回数据库主键列表吗？"></a>Mybatis执行批量插入，能返回数据库主键列表吗？</h2><p>能，JDBC都能，Mybatis当然也能。</p><h2 id="Mybatis是否可以映射Enum枚举类？"><a href="#Mybatis是否可以映射Enum枚举类？" class="headerlink" title="Mybatis是否可以映射Enum枚举类？"></a>Mybatis是否可以映射Enum枚举类？</h2><p>Mybatis可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。</p><h2 id="如何获取自动生成的-主-键值？"><a href="#如何获取自动生成的-主-键值？" class="headerlink" title="如何获取自动生成的(主)键值？"></a>如何获取自动生成的(主)键值？</h2><p>配置文件设置usegeneratedkeys 为true</p><h2 id="在mapper中如何传递多个参数？"><a href="#在mapper中如何传递多个参数？" class="headerlink" title="在mapper中如何传递多个参数？"></a>在mapper中如何传递多个参数？</h2><p>1）直接在方法中传递参数，xml文件用#{0} #{1}来获取</p><p>2）使用 @param 注解:这样可以直接在xml文件中通过#{name}来获取</p><h2 id="resultType-resultMap的区别？"><a href="#resultType-resultMap的区别？" class="headerlink" title="resultType resultMap的区别？"></a>resultType resultMap的区别？</h2><ol><li>类的名字和数据库相同时，可以直接设置resultType参数为Pojo类</li><li>若不同，需要设置resultMap 将结果名字和Pojo名字进行转换</li></ol><h2 id="使用MyBatis的mapper接口调用时有哪些要求？"><a href="#使用MyBatis的mapper接口调用时有哪些要求？" class="headerlink" title="使用MyBatis的mapper接口调用时有哪些要求？"></a>使用MyBatis的mapper接口调用时有哪些要求？</h2><ol><li>Mapper接口方法名和mapper.xml中定义的每个sql的id相同</li><li>Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同</li><li>Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同</li><li>Mapper.xml文件中的namespace即是mapper接口的类路径。</li></ol><h2 id="JDBC-编程有哪些不足？MyBatis-是如何解决的？"><a href="#JDBC-编程有哪些不足？MyBatis-是如何解决的？" class="headerlink" title="JDBC 编程有哪些不足？MyBatis 是如何解决的？"></a>JDBC 编程有哪些不足？MyBatis 是如何解决的？</h2><ol><li>数据库的连接创建、释放频繁，从而影响性能，mybatis 通过配置 SqlMapConfig.xml 文件使用连接池的方式解决了数据库连接创建和释放频繁所造成的性能影响。</li><li>大量的 sql 存在于代码之中，造成代码的可维护性低。mybatis 只用 xml 文件对 sql 进行统一管理，方便维护。</li><li>jdbc 操作中存在参数时，需要准确的定位参数的位置和对应占位符的个数，否则会出错。mybatis 通过提供参数对象的方式解决了该问题。</li><li>sql 语句在编写时，如果存在动态条件则不容易处理。mybatis 提供动态 sql 编写机制，时用户可以根据自己传入参数的情况进行 sql 语句的动态编写。</li><li>对查询时返回的结果集处理是一件比较麻烦的事情，而随着查询结果的改变，处理结果集的代码也随之改变。mybatis 通过把结果集映射成对应的 java 对象，解决了结果集处理麻烦的问题。</li></ol><h2 id="MyBatis-和-Hibernate-的区别"><a href="#MyBatis-和-Hibernate-的区别" class="headerlink" title="MyBatis 和 Hibernate 的区别"></a>MyBatis 和 Hibernate 的区别</h2><p>总体来说 mybatis 和 hibernate 都属于持久层框架。就目前主流的 ORM 框架而言，hibernate 数据全自动 ORM 实现，而 mybatis 属于半自动 ORM 实现。他们最直观的区别在于：<br>hibernate 完整的实现了对象到数据库结构的映射，也就是说在使用 hibernate 的时候，你可以不需要关心数据库结构，而仅仅只用知道数据库结构对应的对象即可，hibernate 提供了一系列的操作使你所有的数据库操作转换成对象的操作，而 hibernate 在执行操作的时候会自动的帮你生成对应的 sql 并执行，并把返回的结果集封装成对应的对象返回。<br>而 mybatis 在实现是仅仅是对结果集进行了对象的封装返回，而执行的 sql 需要开发人员自己去实现。</p><p>虽然 hibernate 是全自动 ORM 框架，但是在某些情况下并不是那么好用，比如：</p><ol><li>在某些情况下，数据库权限没有全部开放，只能执行部分 sql 操作的时候。</li><li>数据库查询操作十分繁琐，sql 执行很复杂，为了提供效率，需要对 sql 进行优化。</li><li>数据库查询需要用到存储过程时。</li></ol><p>等等以上情况在使用 hibernate 时就不能应付了。这时使用 mybatis 则是一个不错的选择。但是如果存在多数据库访问的情况下，hibernate 会是一个更好的选择，而 mybatis 在操作多数据库时，同一个数据库操作需要实现不同的 sql。</p><h2 id="Mybatis中设计模式"><a href="#Mybatis中设计模式" class="headerlink" title="Mybatis中设计模式"></a>Mybatis中设计模式</h2><ul><li>Builder模式，例如SqlSessionFactoryBuilder、XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder、CacheBuilder；</li><li>工厂模式，例如SqlSessionFactory、ObjectFactory、MapperProxyFactory；</li><li>单例模式，例如ErrorContext和LogFactory；</li><li>代理模式，Mybatis实现的核心，比如MapperProxy、ConnectionLogger，用的jdk的动态代理；还有executor.loader包使用了cglib或者javassist达到延迟加载的效果；</li><li>组合模式，例如SqlNode和各个子类ChooseSqlNode等；</li><li>模板方法模式，例如BaseExecutor和SimpleExecutor，还有BaseTypeHandler和所有的子类例如IntegerTypeHandler；</li><li>适配器模式，例如Log的Mybatis接口和它对jdbc、log4j等各种日志框架的适配实现；</li><li>装饰者模式，例如Cache包中的cache.decorators子包中等各个装饰者的实现；</li><li>迭代器模式，例如迭代器模式PropertyTokenizer<br>详<a href="https://blog.csdn.net/qq_16713463/article/details/78110354" target="_blank" rel="external">MyBatis设计模式</a></li></ul><h2 id="Mybatis比IBatis比较大的几个改进是什么？"><a href="#Mybatis比IBatis比较大的几个改进是什么？" class="headerlink" title="Mybatis比IBatis比较大的几个改进是什么？"></a>Mybatis比IBatis比较大的几个改进是什么？</h2><ol><li>有接口绑定,包括注解绑定sql和xml绑定Sql</li><li>动态sql由原来的节点配置变成OGNL表达式3） 在一对一,一对多的时候引进了association,在一对多的时候引入了collection节点,不过都是在resultMap里面配置</li></ol><h2 id="IBatis和MyBatis在核心处理类分别叫什么？"><a href="#IBatis和MyBatis在核心处理类分别叫什么？" class="headerlink" title="IBatis和MyBatis在核心处理类分别叫什么？"></a>IBatis和MyBatis在核心处理类分别叫什么？</h2><p>IBatis里面的核心处理类交SqlMapClient,MyBatis里面的核心处理类叫做SqlSession。</p><h2 id="IBatis和MyBatis在细节上的不同有哪些？"><a href="#IBatis和MyBatis在细节上的不同有哪些？" class="headerlink" title="IBatis和MyBatis在细节上的不同有哪些？"></a>IBatis和MyBatis在细节上的不同有哪些？</h2><ol><li><p>在sql里面变量命名有原来的#变量# 变成了#{变量}</p></li><li><p>原来的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$变量$</div></pre></td></tr></table></figure><p>变成了${变量}</p></li><li><p>原来在sql节点里面的class都换名字交type</p></li><li><p>原来的queryForObject queryForList 变成了selectOne selectList5）原来的别名设置在映射文件里面放在了核心配置文件里</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Hibernate与MyBatis的异同&quot;&gt;&lt;a href=&quot;#Hibernate与MyBatis的异同&quot; class=&quot;headerlink&quot; title=&quot;Hibernate与MyBatis的异同&quot;&gt;&lt;/a&gt;Hibernate与MyBatis的异同&lt;/h2&gt;&lt;p&gt;相同点：&lt;br&gt;Hibernate与MyBatis都可以是通过SessionFactoryBuider由XML配置文件生成SessionFactory，然后由SessionFactory 生成Session，最后由Session来开启执行事务和SQL语句。其中SessionFactoryBuider，SessionFactory，Session的生命周期都是差不多的。Hibernate和MyBatis都支持JDBC和JTA事务处理。&lt;/p&gt;
    
    </summary>
    
      <category term="基础面试题" scheme="http://swenfang.github.io/categories/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="基础面试题" scheme="http://swenfang.github.io/tags/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>全文检索面试题</title>
    <link href="http://swenfang.github.io/2019/05/12/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://swenfang.github.io/2019/05/12/面试总结/全文检索面试题/</id>
    <published>2019-05-12T13:46:33.929Z</published>
    <updated>2019-05-12T15:11:13.597Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么要用全文搜索搜索引擎"><a href="#为什么要用全文搜索搜索引擎" class="headerlink" title="为什么要用全文搜索搜索引擎"></a>为什么要用全文搜索搜索引擎</h3><p>我们的所有数据在数据库里面都有，而且 Oracle、SQL Server 等数据库里也能提供查询检索或者聚类分析功能，直接通过数据库查询不就可以了吗？确实，我们大部分的查询功能都可以通过数据库查询获得，如果查询效率低下，还可以通过建数据库索引，优化SQL等方式进行提升效率，甚至通过引入缓存来加快数据的返回速度。如果数据量更大，就可以分库分表来分担查询压力。</p><a id="more"></a><p>那为什么还要全文搜索引擎呢？我们主要从以下几个原因分析：</p><ul><li><strong>数据类型</strong> 全文索引搜索支持非结构化数据的搜索，可以更好地快速搜索大量存在的任何单词或单词组的非结构化文本。 例如 Google，百度类的网站搜索，它们都是根据网页中的关键字生成索引，我们在搜索的时候输入关键字，它们会将该关键字即索引匹配到的所有网页返回；还有常见的项目中应用日志的搜索等等。对于这些非结构化的数据文本，关系型数据库搜索不是能很好的支持。</li><li><strong>索引的维护</strong> 一般传统数据库，全文检索都实现的很鸡肋，因为一般也没人用数据库存文本字段。进行全文检索需要扫描整个表，如果数据量大的话即使对SQL的语法优化，也收效甚微。建立了索引，但是维护起来也很麻烦，对于 insert 和 update 操作都会重新构建索引。</li></ul><p>什么时候使用全文搜索引擎：</p><ol><li>搜索的数据对象是大量的非结构化的文本数据。</li><li>文件记录量达到数十万或数百万个甚至更多。</li><li>支持大量基于交互式文本的查询。</li><li>需求非常灵活的全文搜索查询。</li><li>对高度相关的搜索结果的有特殊需求，但是没有可用的关系数据库可以满足。</li><li>对不同记录类型、非文本数据操作或安全事务处理的需求相对较少的情况。</li></ol><h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>Lucene，Solr， ElasticSearch它们的索引建立都是根据<strong>倒排索引</strong>的方式生成索引，何谓倒排索引？</p><p>维基百科<br>倒排索引（英语：Inverted index），也常被称为反向索引、置入档案或反向档案，是一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。它是文档检索系统中最常用的数据结构。</p><h3 id="何为-Lucene"><a href="#何为-Lucene" class="headerlink" title="何为 Lucene ?"></a>何为 Lucene ?</h3><p>Lucene是一个Java全文搜索引擎，完全用Java编写。Lucene不是一个完整的应用程序，而是一个代码库和API，可以很容易地用于向应用程序添加搜索功能。</p><p>Lucene通过简单的API提供强大的功能：</p><p><strong>可扩展的高性能索引</strong></p><ul><li>在现代硬件上超过150GB /小时</li><li>小RAM要求 - 只有1MB堆</li><li>增量索引与批量索引一样快</li><li>索引大小约为索引文本大小的20-30％</li></ul><p><strong>强大，准确，高效的搜索算法</strong></p><ul><li>排名搜索 - 首先返回最佳结果</li><li>许多强大的查询类型：短语查询，通配符查询，邻近查询，范围查询等</li><li>现场搜索（例如标题，作者，内容）</li><li>按任何字段排序</li><li>使用合并结果进行多索引搜索</li><li>允许同时更新和搜索</li><li>灵活的分面，突出显示，连接和结果分组</li><li>快速，内存效率和错误容忍的建议</li><li>可插拔排名模型，包括矢量空间模型和Okapi BM25</li><li>可配置存储引擎（编解码器）</li></ul><p><strong>跨平台解决方案</strong></p><ul><li>作为Apache许可下的开源软件提供 ，允许您在商业和开源程序中使用Lucene</li><li>100％-pure Java</li><li>可用的其他编程语言中的实现是索引兼容的</li></ul><p><strong>Apache软件基金会</strong>在Apache软件基金会提供的开源软件项目的Apache社区的支持。</p><p>但是Lucene只是一个框架，要充分利用它的功能，需要使用JAVA，并且在程序中集成Lucene。需要很多的学习了解，才能明白它是如何运行的，熟练运用Lucene确实非常复杂。</p><h3 id="何为-Solr"><a href="#何为-Solr" class="headerlink" title="何为 Solr"></a>何为 Solr</h3><p>Apache Solr是一个基于名为Lucene的Java库构建的开源搜索平台。它以用户友好的方式提供Apache Lucene的搜索功能。作为一个行业参与者近十年，它是一个成熟的产品，拥有强大而广泛的用户社区。它提供分布式索引，复制，负载平衡查询以及自动故障转移和恢复。如果它被正确部署然后管理得好，它就能够成为一个高度可靠，可扩展且容错的搜索引擎。很多互联网巨头，如Netflix，eBay，Instagram和亚马逊（CloudSearch）都使用Solr，因为它能够索引和搜索多个站点。</p><p>主要功能列表包括：</p><ul><li>全文搜索</li><li>突出</li><li>分面搜索</li><li>实时索引</li><li>动态群集</li><li>数据库集成</li><li>NoSQL功能和丰富的文档处理（例如Word和PDF文件）</li></ul><h3 id="何为-ElasticSearch"><a href="#何为-ElasticSearch" class="headerlink" title="何为 ElasticSearch"></a>何为 ElasticSearch</h3><p>Elasticsearch是一个开源（Apache 2许可证），是一个基于Apache Lucene库构建的RESTful搜索引擎。</p><p>Elasticsearch是在Solr之后几年推出的。它提供了一个分布式，多租户能力的全文搜索引擎，具有HTTP Web界面（REST）和无架构JSON文档。Elasticsearch的官方客户端库提供Java，Groovy，PHP，Ruby，Perl，Python，.NET和Javascript。</p><p>分布式搜索引擎包括可以划分为分片的索引，并且每个分片可以具有多个副本。每个Elasticsearch节点都可以有一个或多个分片，其引擎也可以充当协调器，将操作委派给正确的分片。</p><p>Elasticsearch可通过近实时搜索进行扩展。其主要功能之一是多租户。</p><p>主要功能列表包括：</p><ul><li>分布式搜索</li><li>多租户</li><li>分析搜索</li><li>分组和聚合</li></ul><h3 id="Lucene-是什么？"><a href="#Lucene-是什么？" class="headerlink" title="Lucene 是什么？"></a>Lucene 是什么？</h3><p>Lucene即全文检索。全文检索是计算机程序通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置。当用户查询时根据建立的索引查找，类似于通过字典的检索字表查字的过程。</p><p>Lucene是一个基于Java的全文信息检索工具包，它不是一个完整的搜索应用程序，而是为你的应用程序提供索引和搜索功能。Lucene 目前是 Apache Jakarta(雅加达) 家族中的一个开源项目。也是目前最为流行的基于Java开源全文检索工具包。目前已经有很多应用程序的搜索功能是基于 Lucene ，比如Eclipse 帮助系统的搜索功能。Lucene能够为文本类型的数据建立索引，所以你只要把你要索引的数据格式转化的文本格式，Lucene 就能对你的文档进行索引和搜索。</p><h3 id="Solr-是什么？"><a href="#Solr-是什么？" class="headerlink" title="Solr 是什么？"></a>Solr 是什么？</h3><p>Apache Solr是一个高性能，基于Lucene的全文搜索服务器。<br>Solr是Apache下的一个开源项目，采用Java开发，只需要进行配置就可以实现全文检索服务。<br>Solr提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展，并对索引、搜索性能进行了优化。<br>做为一款搜索引擎，solr不具备爬虫一样采集信息的能力，而是专注于信息的存储和检索。<br>许多朋友误认为solr是数据库，从广义上讲也可认为是数据库，但是它和传统意义上的数据库还是有些区别的。<br>相信使用过关系型数据库的朋友们一定都做过搜索的功能，比如：有100条记录，我想搜索记录中含有“云计算”字段的记录，可以使用关系型数据库提供的“模糊搜索”的功能。“模糊搜索”能不能满足你的要求呢？如果记录数小，100条、1000条记录当然没问题。但是，如果有100万条、1000万条甚至上亿，那么“模糊搜索”的效果就会大大折扣。而这时，我们就需要用到solr等搜索引擎了。</p><p>Solr易于加入到 Web 应用程序中。Solr 提供了层面搜索(就是统计)、命中醒目显示并且支持多种输出格式（包括XML/XSLT 和JSON等格式）。它易于安装和配置，而且附带了一个基于HTTP 的管理界面。可以使用 Solr 的表现优异的基本搜索功能，也可以对它进行扩展从而满足企业的需要。Solr的特性包括：<br>• 高级的全文搜索功能<br>• 专为高通量的网络流量进行的优化<br>• 基于开放接口（XML和HTTP）的标准<br>• 综合的HTML管理界面<br>• 可伸缩性－能够有效地复制到另外一个Solr搜索服务器<br>• 使用XML配置达到灵活性和适配性<br>• 可扩展的插件体系</p><h3 id="Solr-和-Lucene的区别"><a href="#Solr-和-Lucene的区别" class="headerlink" title="Solr 和 Lucene的区别"></a>Solr 和 Lucene的区别</h3><p>Solr与Lucene的关系</p><p>Solr与Lucene 并不是竞争对立关系，恰恰相反Solr 依存于Lucene，因为Solr底层的核心技术是使用Lucene 来实现的，Solr和Lucene的本质区别有以下三点：搜索服务器，企业级和管理。Lucene本质上是搜索库，不是独立的应用程序，而Solr是。Lucene专注于搜索底层的建设，而Solr专注于企业应用。Lucene不负责支撑搜索服务所必须的管理，而Solr负责。所以说，一句话概括 Solr: Solr是Lucene面向企业搜索应用的扩展。</p><p>Solr与Lucene的开发成本<br>\1. 使用Lucene实现<br>单独使用Lucene实现站内搜索需要开发的工作量较大，主要表现在：索引维护、索引性能优化、搜索性能优化等，因此不建议采用。<br>\2. 使用solr实现<br>基于Solr实现站内搜索扩展性较好并且可以减少程序员的工作量，因为Solr提供了较为完备的搜索引擎解决方案，因此在门户、论坛等系统中常用此方案。</p><h3 id="Solr在Lucene上的扩展"><a href="#Solr在Lucene上的扩展" class="headerlink" title="Solr在Lucene上的扩展"></a>Solr在Lucene上的扩展</h3><p>• 一个真正的拥有动态字段(Dynamic Field)和唯一键(Unique Key)的数据模式(Data Schema)<br>• 对Lucene查询语言的强大扩展！<br>• 支持对结果进行动态的分组和过滤<br>• 高级的，可配置的文本分析<br>• 高度可配置和可扩展的缓存机制<br>• 性能优化<br>• 支持通过XML进行外部配置<br>• 拥有一个管理界面<br>• 可监控的日志<br>• 支持高速增量式更新(Fast incremental Updates)和快照发布(Snapshot Distribution)</p><h3 id="lucene-针对它的搜索方式有哪些"><a href="#lucene-针对它的搜索方式有哪些" class="headerlink" title="lucene 针对它的搜索方式有哪些"></a>lucene 针对它的搜索方式有哪些</h3><p>词项查询(TermQuery)/布尔查询(BooleanQuery)/短语查询(PhraseQuery)/范围查询(RangeQuery)/百搭查询(WildardQuery)/FuzzQuery(模糊)</p><h3 id="什么是Lucene数据结构"><a href="#什么是Lucene数据结构" class="headerlink" title="什么是Lucene数据结构"></a>什么是Lucene数据结构</h3><p> (倒排索引)</p><h3 id="Lucene如何计算文档的相关性"><a href="#Lucene如何计算文档的相关性" class="headerlink" title="Lucene如何计算文档的相关性"></a>Lucene如何计算文档的相关性</h3><p>向量空间模型,布尔模型</p><h3 id="什么是细分市场"><a href="#什么是细分市场" class="headerlink" title="什么是细分市场"></a>什么是细分市场</h3><p>指数的一部分</p><h3 id="如何将文本编入索引"><a href="#如何将文本编入索引" class="headerlink" title="如何将文本编入索引"></a>如何将文本编入索引</h3><p> (分析器,标记器)</p><h3 id="Lucene查询语法是什么样的"><a href="#Lucene查询语法是什么样的" class="headerlink" title="Lucene查询语法是什么样的"></a>Lucene查询语法是什么样的</h3><p>布尔查询,提升,模糊搜索</p><h3 id="Lucene和Solr和Elasticsearch的区别"><a href="#Lucene和Solr和Elasticsearch的区别" class="headerlink" title="Lucene和Solr和Elasticsearch的区别"></a>Lucene和Solr和Elasticsearch的区别</h3><p>Lucene：</p><p>Lucene是apache下的一个子项目，是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎。官网地址：<a href="https://lucene.apache.org/" target="_blank" rel="external">https://lucene.apache.org/</a></p><p>Solr</p><p>Solr是一个高性能，采用Java5开发，基于Lucene的全文搜索服务器。同时对其进行了扩展，提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的全文搜索引擎。官网地址：<a href="http://lucene.apache.org/solr/" target="_blank" rel="external">http://lucene.apache.org/solr/</a></p><p>Elasticsearch</p><p>Elasticsearch跟Solr一样，也是一个基于Lucene的搜索服务器，它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。官网地址：<a href="https://www.elastic.co/products/elasticsearch" target="_blank" rel="external">https://www.elastic.co/products/elasticsearch</a></p><h3 id="Solr的优缺点"><a href="#Solr的优缺点" class="headerlink" title="Solr的优缺点"></a>Solr的优缺点</h3><p>优点</p><p>1.Solr有一个更大、更成熟的用户、开发和贡献者社区。</p><p>2.支持添加多种格式的索引，如：HTML、PDF、微软 Office 系列软件格式以及 JSON、XML、CSV 等纯文本格式。</p><p>3.Solr比较成熟、稳定。</p><p>4.不考虑建索引的同时进行搜索，速度更快。</p><p>缺点</p><p>1.建立索引时，搜索效率下降，实时索引搜索效率不高。</p><h3 id="Elasticsearch-与-Solr-的比较"><a href="#Elasticsearch-与-Solr-的比较" class="headerlink" title="Elasticsearch 与 Solr 的比较"></a>Elasticsearch 与 Solr 的比较</h3><p>1.二者安装都很简单；</p><p>2.Solr 利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能;</p><p>3.Solr 支持更多格式的数据，而 Elasticsearch 仅支持json文件格式；</p><p>4.Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能多有第三方插件提供；</p><p>5.Solr 在传统的搜索应用中表现好于 Elasticsearch，但在处理实时搜索应用时效率明显低于 Elasticsearch。</p><p>6.Solr 是传统搜索应用的有力解决方案，但 Elasticsearch 更适用于新兴的实时搜索应用。</p><p>使用案例：</p><p>1.维基百科使用Elasticsearch来进行全文搜做并高亮显示关键词，以及提供search-as-you-type、did-you-mean等搜索建议功能。</p><p>2.英国卫报使用Elasticsearch来处理访客日志，以便能将公众对不同文章的反应实时地反馈给各位编辑。</p><p>3.StackOverflow将全文搜索与地理位置和相关信息进行结合，以提供more-like-this相关问题的展现。</p><p>4.GitHub使用Elasticsearch来检索超过1300亿行代码。</p><p>5.每天，Goldman Sachs使用它来处理5TB数据的索引，还有很多投行使用它来分析股票市场的变动。</p><h3 id="solr如何实现搜索的"><a href="#solr如何实现搜索的" class="headerlink" title="solr如何实现搜索的"></a>solr如何实现搜索的</h3><p>倒排索引，先抽取文档中词，并建立词与文档id的映射关系，然后查询的时候会根据词去查询文档id，并查询出文档</p><h3 id="Solr过滤器"><a href="#Solr过滤器" class="headerlink" title="Solr过滤器"></a>Solr过滤器</h3><p>Solr的过滤器对接收到的标记流（TokenStream ）做额外的处理过滤查询，在查询时设置</p><h3 id="Solr原理"><a href="#Solr原理" class="headerlink" title="Solr原理"></a>Solr原理</h3><p>Solr是基于Lucene开发的全文检索服务器，而Lucene就是一套实现了全文检索的api，其本质就是一个全文检索的过程。全文检索就是把原始文档根据一定的规则拆分成若干个关键词，然后根据关键词创建索引，当查询时先查询索引找到对应的关键词，并根据关键词找到对应的文档，也就是查询结果，最终把查询结果展示给用户的过程</p><h3 id="Solr基于什么"><a href="#Solr基于什么" class="headerlink" title="Solr基于什么"></a>Solr基于什么</h3><p>基于lucene搜索库的一个搜索引擎框架，lucene是一个开放源码的全文检索引擎工具包</p><h3 id="solr怎么设置搜索结果排名靠前"><a href="#solr怎么设置搜索结果排名靠前" class="headerlink" title="solr怎么设置搜索结果排名靠前"></a>solr怎么设置搜索结果排名靠前</h3><p>设置文档中域的boost值，值越高相关性越高，排名就靠前</p><h3 id="IK分词器原理"><a href="#IK分词器原理" class="headerlink" title="IK分词器原理"></a>IK分词器原理</h3><p>本质上是词典分词，在内存中初始化一个词典，然后在分词过程中逐个读取字符，和字典中的字符相匹配，把文档中的所有词语拆分出来的过程</p><h3 id="solr的索引查询为什么比数据库要快"><a href="#solr的索引查询为什么比数据库要快" class="headerlink" title="solr的索引查询为什么比数据库要快"></a>solr的索引查询为什么比数据库要快</h3><p>Solr使用的是Lucene API实现的全文检索。全文检索本质上是查询的索引。而数据库中并不是所有的字段都建立的索引，更何况如果使用like查询时很大的可能是不使用索引，所以使用solr查询时要比查数据库快</p><h3 id="solr索引库个别数据索引丢失怎么办"><a href="#solr索引库个别数据索引丢失怎么办" class="headerlink" title="solr索引库个别数据索引丢失怎么办"></a>solr索引库个别数据索引丢失怎么办</h3><p>首先Solr是不会丢失个别数据的。如果索引库中缺少数据，那就向索引库中添加</p><h3 id="Lucene索引优化"><a href="#Lucene索引优化" class="headerlink" title="Lucene索引优化"></a>Lucene索引优化</h3><p>直接使用Lucene实现全文检索已经是过时的方案，推荐使用solr。Solr已经提供了完整的全文检索解决方案</p><h3 id="多张表的数据导入solr-解决id冲突"><a href="#多张表的数据导入solr-解决id冲突" class="headerlink" title="多张表的数据导入solr(解决id冲突)"></a>多张表的数据导入solr(解决id冲突)</h3><p>在schema.xml中添加uuid，然后solrconfig那边修改update的部分，改为使用uuid生成</p><h3 id="solr如何分词，新增词和禁用词如何解决"><a href="#solr如何分词，新增词和禁用词如何解决" class="headerlink" title="solr如何分词，新增词和禁用词如何解决"></a>solr如何分词，新增词和禁用词如何解决</h3><p>schema.xml文件中配置一个IK分词器，然后域指定分词器为IK</p><p>新增词添加到词典配置文件中ext.dic，禁用词添加到禁用词典配置文件中stopword.dic，然后在schema.xml文件中配置禁用词典：<filter class="solr.StopFilterFactory" ignore="true" words="/禁止词文件目录"></filter></p><h3 id="solr多条件组合查询"><a href="#solr多条件组合查询" class="headerlink" title="solr多条件组合查询"></a>solr多条件组合查询</h3><p>创建多个查询对象，指定他们的组合关系，Occur.MUST（必须满足and），Occur.SHOULD（应该满足or），Occur.MUST_NOT（必须不满足not）</p><h3 id="elasticsearch-了解多少，说说你们公司-es-的集群架构，索引数据大小，分片有多少，以及一些调优手段。elasticsearch-的倒排索引是什么。"><a href="#elasticsearch-了解多少，说说你们公司-es-的集群架构，索引数据大小，分片有多少，以及一些调优手段。elasticsearch-的倒排索引是什么。" class="headerlink" title="elasticsearch 了解多少，说说你们公司 es 的集群架构，索引数据大小，分片有多少，以及一些调优手段。elasticsearch 的倒排索引是什么。"></a>elasticsearch 了解多少，说说你们公司 es 的集群架构，索引数据大小，分片有多少，以及一些调优手段。elasticsearch 的倒排索引是什么。</h3><p>ElasticSearch（简称ES）是一个分布式、Restful的搜索及分析服务器，设计用于分布式计算；能够达到实时搜索，稳定，可靠，快速。和Apache Solr一样，它也是基于Lucence的索引服务器，而ElasticSearch对比Solr的优点在于：</p><p>轻量级：安装启动方便，下载文件之后一条命令就可以启动。</p><p>Schema free：可以向服务器提交任意结构的JSON对象，Solr中使用schema.xml指定了索引结构。</p><p>多索引文件支持：使用不同的index参数就能创建另一个索引文件，Solr中需要另行配置。</p><p>分布式：Solr Cloud的配置比较复杂。</p><p>倒排索引是实现“单词-文档矩阵”的一种具体存储形式，通过倒排索引，可以根据单词快速获取包含这个单词的文档列表。倒排索引主要由两个部分组成：“单词词典”和“倒排文件”。</p><h3 id="elasticsearch-索引数据多了怎么办，如何调优，部署。"><a href="#elasticsearch-索引数据多了怎么办，如何调优，部署。" class="headerlink" title="elasticsearch 索引数据多了怎么办，如何调优，部署。"></a>elasticsearch 索引数据多了怎么办，如何调优，部署。</h3><p>使用bulk API</p><p>初次索引的时候，把 replica 设置为 0</p><p>增大 threadpool.index.queue_size</p><p>增大 indices.memory.index_buffer_size</p><p>增大 index.translog.flush_threshold_ops</p><p>增大 index.translog.sync_interval</p><p>增大 index.engine.robin.refresh_interval</p><p><a href="http://www.jianshu.com/p/5eeeeb4375d4" target="_blank" rel="external">http://www.jianshu.com/p/5eeeeb4375d4</a></p><h3 id="lucence-内部结构是什么"><a href="#lucence-内部结构是什么" class="headerlink" title="lucence 内部结构是什么"></a>lucence 内部结构是什么</h3><p>索引(Index)： 在Lucene中一个索引是放在一个文件夹中的。 如上图，同一文件夹中的所有的文件构成一个Lucene索引。</p><p>段(Segment)： 一个索引可以包含多个段，段与段之间是独立的，添加新文档可以生成新的段，不同的段可以合并。</p><p>segments.gen和segments_X是段的元数据文件，也即它们保存了段的属性信息。</p><p>文档(Document)： 文档是我们建索引的基本单位，不同的文档是保存在不同的段中的，一个段可以包含多篇文档。</p><p>新添加的文档是单独保存在一个新生成的段中，随着段的合并，不同的文档合并到同一个段中。</p><p>域(Field)：</p><p>一篇文档包含不同类型的信息，可以分开索引，比如标题，时间，正文，作者等，都可以保存在不同的域里。 不同域的索引方式可以不同，在真正解析域的存储的时候，我们会详细解读。</p><p>词(Term)：</p><p>词是索引的最小单位，是经过词法分析和语言处理后的字符串。</p><h3 id="solr和lucene的区别"><a href="#solr和lucene的区别" class="headerlink" title="solr和lucene的区别"></a>solr和lucene的区别</h3><p>Solr和Lucene的本质区别有以下三点：搜索服务器，企业级和管理。Lucene本质上是搜索库，不是独立的应用程序，而Solr是。Lucene专注于搜索底层的建设，而Solr专注于企业应用。Lucene不负责支撑搜索服务所必须的管理，而Solr负责。所以说，一句话概括Solr: Solr是Lucene面向企业搜索应用的扩展</p><p>Lucene: 是一个索引与搜索类库，而不是完整的程序。</p><p>Solr：是一个高性能，采用Java5开发，基于Lucene的一个独立的企业级搜索应用服务器，它对外提供类似于Web-service的API接口。</p><h3 id="solr-实现全文检索"><a href="#solr-实现全文检索" class="headerlink" title="solr 实现全文检索"></a>solr 实现全文检索</h3><p>  索引流程：客户端—》solr 服务器(发送post请求,xml文档包含filed，solr实现对索引的维护)</p><pre><code>搜索流程：客户端---》solr 服务器(发送get 请求，服务器返回一个xml 文档)</code></pre><h3 id="solr和lucene之间的区别"><a href="#solr和lucene之间的区别" class="headerlink" title="solr和lucene之间的区别"></a>solr和lucene之间的区别</h3><p>​    lucene全文检索的工具包,jar包</p><pre><code>solr     全文检索服务器,单独运行的servlet容器</code></pre><h3 id="Elasticsearch-vs-Solr的选择"><a href="#Elasticsearch-vs-Solr的选择" class="headerlink" title="Elasticsearch vs. Solr的选择"></a>Elasticsearch vs. Solr的选择</h3><p>由于Lucene的复杂性，一般很少会考虑它作为搜索的第一选择，排除一些公司需要自研搜索框架，底层需要依赖Lucene。所以这里我们重点分析 Elasticsearch 和 Solr。</p><p>Elasticsearch vs. Solr。哪一个更好？他们有什么不同？你应该使用哪一个？</p><p><strong>历史比较</strong></p><p>Apache Solr是一个成熟的项目，拥有庞大而活跃的开发和用户社区，以及Apache品牌。Solr于2006年首次发布到开源，长期以来一直占据着搜索引擎领域，并且是任何需要搜索功能的人的首选引擎。它的成熟转化为丰富的功能，而不仅仅是简单的文本索引和搜索； 如分面，分组，强大的过滤，可插入的文档处理，可插入的搜索链组件，语言检测等。</p><p>Solr 在搜索领域占据了多年的主导地位。然后，在2010年左右，Elasticsearch成为市场上的另一种选择。那时候，它远没有Solr那么稳定，没有Solr的功能深度，没有思想分享，品牌等等。</p><p>Elasticsearch虽然很年轻，但它也自己的一些优势，Elasticsearch 建立在更现代的原则上，针对更现代的用例，并且是为了更容易处理大型索引和高查询率而构建的。此外，由于它太年轻，没有社区可以合作，它可以自由地向前推进，而不需要与其他人（用户或开发人员）达成任何共识或合作，向后兼容，或任何其他更成熟的软件通常必须处理。</p><p>因此，它在Solr之前就公开了一些非常受欢迎的功能(例如，接近实时搜索，英文：Near Real-Time Search)。从技术上讲，NRT搜索的能力确实来自Lucene，它是 Solr 和 Elasticsearch 使用的基础搜索库。具有讽刺意味的是，因为 Elasticsearch 首先公开了NRT搜索，所以人们将NRT搜索与Elasticsearch 联系在一起，尽管 Solr 和 Lucene 都是同一个 Apache 项目的一部分，因此，人们会首先期望 Solr 具有如此高要求的功能。</p><p><strong>特征差异比较</strong></p><p>这两个搜索引擎都是流行的，先进的的开源搜索引擎。它们都是围绕核心底层搜索库 - Lucene构建的 - 但它们又是不同的。像所有东西一样，每个都有其优点和缺点，根据您的需求和期望，每个都可能更好或更差。Solr和Elasticsearch都在快速发展，所以，话不多说，先来看下它们的差异清单：</p><table><thead><tr><th><strong>特征</strong></th><th><strong>Solr/SolrCloud</strong></th><th><strong>Elasticsearch</strong></th></tr></thead><tbody><tr><td>社区和开发者</td><td>Apache 软件基金和社区支持</td><td>单一商业实体及其员工</td></tr><tr><td>节点发现</td><td>Apache Zookeeper，在大量项目中成熟且经过实战测试</td><td>Zen内置于Elasticsearch本身，需要专用的主节点才能进行分裂脑保护</td></tr><tr><td>碎片放置</td><td>本质上是静态，需要手动工作来迁移分片，从Solr 7开始 - Autoscaling API允许一些动态操作</td><td>动态，可以根据群集状态按需移动分片</td></tr><tr><td>高速缓存</td><td>全局，每个段更改无效</td><td>每段，更适合动态更改数据</td></tr><tr><td>分析引擎性能</td><td>非常适合精确计算的静态数据</td><td>结果的准确性取决于数据放置</td></tr><tr><td>全文搜索功能</td><td>基于Lucene的语言分析，多建议，拼写检查，丰富的高亮显示支持</td><td>基于Lucene的语言分析，单一建议API实现，高亮显示重新计算</td></tr><tr><td>全文搜索功能</td><td>基于Lucene的语言分析，多建议，拼写检查，丰富的高亮显示支持</td><td>基于Lucene的语言分析，单一建议API实现，高亮显示重新计算</td></tr><tr><td>DevOps支持</td><td>尚未完全，但即将到来</td><td>非常好的API</td></tr><tr><td>非平面数据处理</td><td>嵌套文档和父-子支持</td><td>嵌套和对象类型的自然支持允许几乎无限的嵌套和父-子支持</td></tr><tr><td>查询DSL</td><td>JSON（有限），XML（有限）或URL参数</td><td>JSON</td></tr><tr><td>索引/收集领导控制</td><td>领导者安置控制和领导者重新平衡甚至可以节点上的负载</td><td>不可能</td></tr><tr><td>机器学习</td><td>内置 - 在流聚合之上，专注于逻辑回归和学习排名贡献模块</td><td>商业功能，专注于异常和异常值以及时间序列数据</td></tr></tbody></table><p><strong>综合比较</strong></p><p>另外，我们在从以下几个方面来分析下：</p><ul><li>近几年的流行趋势 我们查看一下这两种产品的Google搜索趋势。谷歌趋势表明，与 Solr 相比，Elasticsearch具有很大的吸引力，但这并不意味着Apache Solr已经死亡。虽然有些人可能不这么认为，但Solr仍然是最受欢迎的搜索引擎之一，拥有强大的社区和开源支持。</li></ul><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190416110409-779428.jpg" alt=""></p><ul><li>安装和配置 与Solr相比，Elasticsearch易于安装且非常轻巧。此外，您可以在几分钟内安装并运行Elasticsearch。 但是，如果Elasticsearch管理不当，这种易于部署和使用可能会成为一个问题。基于JSON的配置很简单，但如果要为文件中的每个配置指定注释，那么它不适合您。 总的来说，如果您的应用使用的是JSON，那么Elasticsearch是一个更好的选择。否则，请使用Solr，因为它的schema.xml和solrconfig.xml都有很好的文档记录。</li><li>社区 Solr拥有更大，更成熟的用户，开发者和贡献者社区。ES虽拥有的规模较小但活跃的用户社区以及不断增长的贡献者社区。 Solr是真正的开源社区代码。任何人都可以为Solr做出贡献，并且根据优点选出新的Solr开发人员（也称为提交者）。Elasticsearch在技术上是开源的，但在精神上却不那么重要。任何人都可以看到来源，任何人都可以更改它并提供贡献，但只有Elasticsearch的员工才能真正对Elasticsearch进行更改。 Solr贡献者和提交者来自许多不同的组织，而Elasticsearch提交者来自单个公司。</li><li>成熟度 Solr更成熟，但ES增长迅速，我认为它稳定。</li><li>文档 Solr在这里得分很高。它是一个非常有据可查的产品，具有清晰的示例和API用例场景。 Elasticsearch的文档组织良好，但它缺乏好的示例和清晰的配置说明。</li></ul><p><strong>总结</strong></p><p>那么，到底是Solr还是Elasticsearch？有时很难找到明确的答案。无论您选择Solr还是Elasticsearch，首先需要了解正确的用例和未来需求。总结他们的每个属性。</p><p>记住：</p><ul><li>由于易于使用，Elasticsearch在新开发者中更受欢迎。但是，如果您已经习惯了与Solr合作，请继续使用它，因为迁移到Elasticsearch没有特定的优势。</li><li>如果除了搜索文本之外还需要它来处理分析查询，Elasticsearch是更好的选择。</li><li>如果需要分布式索引，则需要选择Elasticsearch。对于需要良好可伸缩性和性能的云和分布式环境，Elasticsearch是更好的选择。</li><li>两者都有良好的商业支持（咨询，生产支持，整合等）</li><li>两者都有很好的操作工具，尽管Elasticsearch因其易于使用的API而更多地吸引了DevOps人群，因此可以围绕它创建一个更加生动的工具生态系统。</li><li>Elasticsearch在开源日志管理用例中占据主导地位，许多组织在Elasticsearch中索引它们的日志以使其可搜索。虽然Solr现在也可以用于此目的，但它只是错过了这一想法。</li><li>Solr仍然更加面向文本搜索。另一方面，Elasticsearch 通常用于过滤和分组 - 分析查询工作负载 - 而不一定是文本搜索。Elasticsearch 开发人员在 Lucene 和 Elasticsearch 级别上投入了大量精力使此类查询更高效(降低内存占用和CPU使用)。因此，对于不仅需要进行文本搜索，而且需要复杂的搜索时间聚合的应用程序，Elasticsearch是一个更好的选择。</li><li>Elasticsearch更容易上手，一个下载和一个命令就可以启动一切。Solr传统上需要更多的工作和知识，但Solr最近在消除这一点上取得了巨大的进步，现在只需努力改变它的声誉。</li><li>在性能方面，它们大致相同。我说“大致”，因为没有人做过全面和无偏见的基准测试。对于95％的用例，任何一种选择在性能方面都会很好，剩下的5％需要用它们的特定数据和特定的访问模式来测试这两种解决方案。</li><li>从操作上讲，Elasticsearch使用起来比较简单 - 它只有一个进程。Solr在其类似Elasticsearch的完全分布式部署模式SolrCloud中依赖于Apache ZooKeeper。ZooKeeper是超级成熟，超级广泛使用等等，但它仍然是另一个活跃的部分。也就是说，如果您使用的是Hadoop，HBase，Spark，Kafka或其他一些较新的分布式软件，您可能已经在组织的某个地方运行ZooKeeper。</li><li>虽然Elasticsearch内置了类似ZooKeeper的组件Xen，但ZooKeeper可以更好地防止有时在Elasticsearch集群中出现的可怕的裂脑问题。公平地说，Elasticsearch开发人员已经意识到这个问题，并致力于改进Elasticsearch的这个方面。</li><li>如果您喜欢监控和指标，那么使用Elasticsearch，您将会进入天堂。这个东西比新年前夜在时代广场可以挤压的人有更多的指标！Solr暴露了关键指标，但远不及Elasticsearch那么多。</li></ul><p>总之，两者都是功能丰富的搜索引擎，只要设计和实现得当，它们或多或少都能提供相同的性能。本篇文章的总体内容大致如下图，该图由园友ReyCG精心绘制并提供。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么要用全文搜索搜索引擎&quot;&gt;&lt;a href=&quot;#为什么要用全文搜索搜索引擎&quot; class=&quot;headerlink&quot; title=&quot;为什么要用全文搜索搜索引擎&quot;&gt;&lt;/a&gt;为什么要用全文搜索搜索引擎&lt;/h3&gt;&lt;p&gt;我们的所有数据在数据库里面都有，而且 Oracle、SQL Server 等数据库里也能提供查询检索或者聚类分析功能，直接通过数据库查询不就可以了吗？确实，我们大部分的查询功能都可以通过数据库查询获得，如果查询效率低下，还可以通过建数据库索引，优化SQL等方式进行提升效率，甚至通过引入缓存来加快数据的返回速度。如果数据量更大，就可以分库分表来分担查询压力。&lt;/p&gt;
    
    </summary>
    
      <category term="基础面试题" scheme="http://swenfang.github.io/categories/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="基础面试题" scheme="http://swenfang.github.io/tags/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>数据库面试题</title>
    <link href="http://swenfang.github.io/2019/05/12/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://swenfang.github.io/2019/05/12/面试总结/数据库面试题/</id>
    <published>2019-05-12T13:37:12.391Z</published>
    <updated>2019-05-12T15:11:20.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p><a id="more"></a><h2 id="数据库ACID"><a href="#数据库ACID" class="headerlink" title="数据库ACID"></a>数据库ACID</h2><h3 id="1-原子性（Atomicity）"><a href="#1-原子性（Atomicity）" class="headerlink" title="1. 原子性（Atomicity）"></a>1. 原子性（Atomicity）</h3><blockquote><p>原子性是指事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败。比如在同一个事务中的SQL语句，要么全部执行成功，要么全部执行失败。</p></blockquote><p>　　回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p><h3 id="2-一致性（Consistency）"><a href="#2-一致性（Consistency）" class="headerlink" title="2. 一致性（Consistency）"></a>2. 一致性（Consistency）</h3><blockquote><p>事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</p></blockquote><p>以转账为例子，A向B转账，假设转账之前这两个用户的钱加起来总共是2000，那么A向B转账之后，不管这两个账户怎么转，A用户的钱和B用户的钱加起来的总额还是2000，这个就是事务的一致性。</p><h3 id="3-隔离性（Isolation）"><a href="#3-隔离性（Isolation）" class="headerlink" title="3. 隔离性（Isolation）"></a>3. 隔离性（Isolation）</h3><blockquote><p>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p></blockquote><p>　　即要达到这么一种效果：对于任意两个并发的事务 T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前就已经结束，要么在 T1 结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p><h3 id="4-持久性（Durability）"><a href="#4-持久性（Durability）" class="headerlink" title="4. 持久性（Durability）"></a>4. 持久性（Durability）</h3><blockquote><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复。</div></pre></td></tr></table></figure><p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p><ul><li>只有满足一致性，事务的执行结果才是正确的。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时要只要能满足原子性，就一定能满足一致性。</li><li>在并发的情况下，多个事务并发执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li><li>事务满足持久化是为了能应对数据库奔溃的情况。</li></ul><p><a href="https://github.com/frank-lam/fullstack-tutorial/blob/master/notes/assets/a58e294a-615d-4ea0-9fbf-064a6daec4b2-1534474592177.png" target="_blank" rel="external"><img src="https://github.com/frank-lam/fullstack-tutorial/raw/master/notes/assets/a58e294a-615d-4ea0-9fbf-064a6daec4b2-1534474592177.png" alt="img"></a></p><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><h3 id="1-串行化-Serializable"><a href="#1-串行化-Serializable" class="headerlink" title="1. 串行化 (Serializable)"></a>1. 串行化 (Serializable)</h3><p>　　所有事务一个接着一个的执行，这样可以避免幻读 (phantom read)，对于基于锁来实现并发控制的数据库来说，串行化要求在执行范围查询的时候，需要获取范围锁，如果不是基于锁实现并发控制的数据库，则检查到有违反串行操作的事务时，需回滚该事务。</p><h3 id="2-可重复读-Repeated-Read"><a href="#2-可重复读-Repeated-Read" class="headerlink" title="2. 可重复读 (Repeated Read)"></a>2. 可重复读 (Repeated Read)</h3><p>　　所有被 Select 获取的数据都不能被修改，这样就可以避免一个事务前后读取数据不一致的情况。但是却没有办法控制幻读，因为这个时候其他事务不能更改所选的数据，但是可以增加数据，即前一个事务有读锁但是没有范围锁，为什么叫做可重复读等级呢？那是因为该等级解决了下面的不可重复读问题。</p><p>　　引申：现在主流数据库都使用 MVCC 并发控制，使用之后RR（可重复读）隔离级别下是不会出现幻读的现象。</p><h3 id="3-读已提交-Read-Committed"><a href="#3-读已提交-Read-Committed" class="headerlink" title="3. 读已提交 (Read Committed)"></a>3. 读已提交 (Read Committed)</h3><p>　　被读取的数据可以被其他事务修改，这样可能导致不可重复读。也就是说，事务读取的时候获取读锁，但是在读完之后立即释放(不需要等事务结束)，而写锁则是事务提交之后才释放，释放读锁之后，就可能被其他事务修改数据。该等级也是 SQL Server 默认的隔离等级。</p><h3 id="4-读未提交-Read-Uncommitted"><a href="#4-读未提交-Read-Uncommitted" class="headerlink" title="4. 读未提交 (Read Uncommitted)"></a>4. 读未提交 (Read Uncommitted)</h3><p>　　最低的隔离等级，允许其他事务看到没有提交的数据，会导致脏读。</p><p><strong>总结</strong></p><ul><li>四个级别逐渐增强，每个级别解决一个问题，每个级别解决一个问题，事务级别遇到，性能越差，大多数环境(Read committed 就可以用了)</li></ul><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻影读</th></tr></thead><tbody><tr><td>未提交读</td><td>√</td><td>√</td><td>√</td></tr><tr><td>提交读</td><td>×</td><td>√</td><td>√</td></tr><tr><td>可重复读</td><td>×</td><td>×</td><td>√</td></tr><tr><td>可串行化</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>　对于初学者来说我们通常不关注存储引擎，但是 MySQL 提供了多个存储引擎，包括处理事务安全表的引擎和处理非事务安全表的引擎。在 MySQL 中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>　　MySQL 中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。存储引擎说白了就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。</p><p>　　例如，如果你在研究大量的临时数据，你也许需要使用内存存储引擎。内存存储引擎能够在内存中存储所有的表格数据。又或者，你也许需要一个支持事务处理的数据库（以确保事务处理不成功时数据的回退能力）。</p><blockquote><p>在MySQL中有很多存储引擎，每种存储引擎大相径庭，那么又改如何选择呢？</p></blockquote><p>　　<code>MySQL 5.5</code> 以前的默认存储引擎是 <code>MyISAM</code>, <code>MySQL 5.5</code> 之后的默认存储引擎是 <code>InnoDB</code></p><p>　　不同存储引起都有各自的特点，为适应不同的需求，需要选择不同的存储引擎，所以首先考虑这些存储引擎各自的功能和兼容。</p><h3 id="1-MyISAM"><a href="#1-MyISAM" class="headerlink" title="1. MyISAM"></a>1. MyISAM</h3><p>MySQL 5.5 版本之前的默认存储引擎，在 <code>5.0</code> 以前最大表存储空间最大 <code>4G</code>，<code>5.0</code> 以后最大 <code>256TB</code>。</p><p>Myisam 存储引擎由 <code>.myd</code>（数据）和 <code>.myi</code>（索引文件）组成，<code>.frm</code>文件存储表结构（所以存储引擎都有）</p><p><strong>特性</strong></p><ul><li>并发性和锁级别 （对于读写混合的操作不好，为表级锁，写入和读互斥）</li><li>表损坏修复</li><li>Myisam 表支持的索引类型（全文索引）</li><li>Myisam 支持表压缩（压缩后，此表为只读，不可以写入。使用 myisampack 压缩）</li></ul><p><strong>应用场景</strong></p><ul><li>没有事务</li><li>只读类应用（插入不频繁，查询非常频繁）</li><li>空间类应用（唯一支持空间函数的引擎）</li><li>做很多 count 的计算</li></ul><h3 id="2-InnoDB"><a href="#2-InnoDB" class="headerlink" title="2. InnoDB"></a>2. InnoDB</h3><p>MySQL 5.5 及之后版本的默认存储引擎</p><p><strong>特性</strong></p><ul><li>InnoDB为事务性存储引擎</li><li>完全支持事物的 ACID 特性</li><li>Redo log （实现事务的持久性） 和 Undo log（为了实现事务的原子性，存储未完成事务log，用于回滚）</li><li>InnoDB支持行级锁</li><li>行级锁可以最大程度的支持并发</li><li>行级锁是由存储引擎层实现的</li></ul><p><strong>应用场景</strong></p><ul><li>可靠性要求比较高，或者要求事务</li><li>表更新和查询都相当的频繁，并且行锁定的机会比较大的情况。</li></ul><h3 id="3-CSV"><a href="#3-CSV" class="headerlink" title="3. CSV"></a>3. CSV</h3><p><strong>文件系统存储特点</strong></p><ul><li>数据以文本方式存储在文件中</li><li><code>.csv</code>文件存储表内容</li><li><code>.csm</code>文件存储表的元数据，如表状态和数据量</li><li><code>.frm</code>存储表的结构</li></ul><p><strong>CSV存储引擎特点</strong></p><ul><li>以 CSV 格式进行数据存储</li><li>所有列必须都是不能为 NULL</li><li>不支持索引</li><li>可以对数据文件直接编辑（其他引擎是二进制存储，不可编辑）</li></ul><p><strong>引用场景</strong></p><ul><li>作为数据交换的中间表</li></ul><h3 id="4-Archive"><a href="#4-Archive" class="headerlink" title="4. Archive"></a>4. Archive</h3><p><strong>特性</strong></p><ul><li>以 zlib 对表数据进行压缩，磁盘 I/O 更少</li><li>数据存储在ARZ为后缀的文件中（表文件为 <code>a.arz</code>，<code>a.frm</code>）</li><li>只支持 insert 和 select 操作（不可以 delete 和 update，会提示没有这个功能）</li><li>只允许在自增ID列上加索引</li></ul><p><strong>应用场景</strong></p><ul><li>日志和数据采集类应用</li></ul><h3 id="5-Memory"><a href="#5-Memory" class="headerlink" title="5. Memory"></a>5. Memory</h3><p>特性</p><ul><li>也称为 HEAP 存储引擎，所以数据保存在内存中（数据库重启后会导致数据丢失）</li><li>支持 HASH 索引（等值查找应选择 HASH）和 BTree 索引（范围查找应选择）</li><li>所有字段都为固定长度，varchar(10) == char(10)</li><li>不支持 BLOG 和 TEXT 等大字段</li><li>Memory 存储使用表级锁（性能可能不如 innodb）</li><li>最大大小由 <code>max_heap_table_size</code> 参数决定</li><li>Memory存储引擎默认表大小只有 <code>16M</code>，可以通过调整 <code>max_heap_table_size</code> 参数</li></ul><p>应用场景</p><ul><li>用于查找或是映射表，例如右边和地区的对应表</li><li>用于保存数据分析中产生的中间表</li><li>用于缓存周期性聚合数据的结果表</li></ul><p><strong>注意：</strong> Memory 数据易丢失，所以要求数据可再生</p><h3 id="6-Federated"><a href="#6-Federated" class="headerlink" title="6. Federated"></a>6. Federated</h3><p><strong>特性</strong></p><ul><li>提供了访问远程 MySQL 服务器上表的方法</li><li>本地不存储数据，数据全部放在远程服务器上</li></ul><p><strong>使用 Federated</strong></p><p>默认是禁止的。如果需要启用，需要在启动时增加Federated参数</p><h3 id="问：独立表空间和系统表空间应该如何抉择"><a href="#问：独立表空间和系统表空间应该如何抉择" class="headerlink" title="问：独立表空间和系统表空间应该如何抉择"></a>问：独立表空间和系统表空间应该如何抉择</h3><p><strong>两者比较</strong></p><ul><li>系统表空间：无法简单的收缩大小（这很恐怖，会导致 ibdata1 一直增大，即使删除了数据也不会变小）</li><li>独立表空间：可以通过 optimize table 命令收缩系统文件</li><li>系统表空间：会产生I/O瓶颈（因为只有一个文件）</li><li>独立表空间：可以向多个文件刷新数据</li></ul><p><strong>总结</strong> 强烈建议：对Innodb引擎使用独立表空间（mysql5.6版本以后默认是独立表空间）</p><p><strong>系统表转移为独立表的步骤（非常繁琐）</strong></p><ul><li>使用 mysqldump 导出所有数据库表数据</li><li>停止 mysql 服务，修改参数，并且删除Innodb相关文件</li><li>重启 mysql 服务，重建mysql系统表空间</li><li>重新导入数据</li></ul><h3 id="问：如何选择存储引擎"><a href="#问：如何选择存储引擎" class="headerlink" title="问：如何选择存储引擎"></a>问：如何选择存储引擎</h3><p><strong>参考条件：</strong></p><ul><li>是否需要事务</li><li>是否可以热备份</li><li>崩溃恢复</li><li>存储引擎的特有特性</li></ul><p><strong>重要一点：</strong> 不要混合使用存储引擎 <strong>强烈推荐：</strong> Innodb</p><h3 id="问：MyISAM和InnoDB引擎的区别"><a href="#问：MyISAM和InnoDB引擎的区别" class="headerlink" title="问：MyISAM和InnoDB引擎的区别"></a>问：MyISAM和InnoDB引擎的区别</h3><p><strong>区别：</strong></p><ul><li>MyISAM 不支持外键，而 InnoDB 支持</li><li>MyISAM 是非事务安全型的，而 InnoDB 是事务安全型的。</li><li>MyISAM 锁的粒度是表级，而 InnoDB 支持行级锁定。</li><li>MyISAM 支持全文类型索引，而 InnoDB 不支持全文索引。</li><li>MyISAM 相对简单，所以在效率上要优于 InnoDB，小型应用可以考虑使用 MyISAM。</li><li>MyISAM 表是保存成文件的形式，在跨平台的数据转移中使用 MyISAM 存储会省去不少的麻烦。</li><li>InnoDB 表比 MyISAM 表更安全，可以在保证数据不会丢失的情况下，切换非事务表到事务表（alter table tablename type=innodb）。</li></ul><p><strong>应用场景：</strong></p><ul><li>MyISAM 管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的 SELECT 查询，那么 MyISAM 是更好的选择。</li><li>InnoDB 用于事务处理应用程序，具有众多特性，包括 ACID 事务支持。如果应用中需要执行大量的 INSERT 或 UPDATE 操作，则应该使用 InnoDB，这样可以提高多用户并发操作的性能。</li></ul><h3 id="问：为什么不建议-InnoDB-使用亿级大表"><a href="#问：为什么不建议-InnoDB-使用亿级大表" class="headerlink" title="问：为什么不建议 InnoDB 使用亿级大表"></a>问：为什么不建议 InnoDB 使用亿级大表</h3><p>仅作拓展延伸，详情请转向：<a href="http://xiaorui.cc/2016/12/08/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AEinnodb%E4%BD%BF%E7%94%A8%E4%BA%BF%E7%BA%A7%E5%A4%A7%E8%A1%A8/" target="_blank" rel="external">为什么不建议innodb使用亿级大表 | 峰云就她了</a></p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>特性</td><td>说明</td><td>InnoDB</td><td>MyISAM</td><td>MEMORY</td></tr><tr><td>B树索引 (B-tree indexes)</td><td>自增ID物理连续性更高， 二叉树，红黑树高度不可控</td><td>√</td><td>√</td><td>√</td></tr><tr><td>R树索引 (R-tree indexes)</td><td>空间索引</td><td></td><td>√</td><td></td></tr><tr><td>哈希索引 (Hash indexes)</td><td>无法做范围查询</td><td>√</td><td></td><td>√</td></tr><tr><td>全文索引 (Full-text indexes)</td><td></td><td>√</td><td>√</td></tr></tbody></table><h4 id="B-Tree-索引"><a href="#B-Tree-索引" class="headerlink" title="B+Tree 索引"></a>B+Tree 索引</h4><p>B+Tree 索引是大多数 MySQL 存储引擎的默认索引类型。</p><p>因为不再需要进行全表扫描，只需要对树进行搜索即可，因此查找速度快很多。除了用于查找，还可以用于排序和分组。</p><p>可以指定多个列作为索引列，多个索引列共同组成键。</p><h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><p>InnoDB 引擎有一个特殊的功能叫 “自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找</p><h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE</p><h4 id="空间数据索引（R-Tree）"><a href="#空间数据索引（R-Tree）" class="headerlink" title="空间数据索引（R-Tree）"></a>空间数据索引（R-Tree）</h4><p>MyISAM 存储引擎支持空间数据索引，可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p><h4 id="mysql中的索引类型有哪些，可以从哪些角度来看？"><a href="#mysql中的索引类型有哪些，可以从哪些角度来看？" class="headerlink" title="mysql中的索引类型有哪些，可以从哪些角度来看？"></a>mysql中的索引类型有哪些，可以从哪些角度来看？</h4><p><strong>从数据结构角度</strong></p><p>1、B+树索引(O(log(n)))：关于B+树索引，可以参考 <a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="external">MySQL索引背后的数据结构及算法原理</a></p><p>2、hash索引：<br>a 仅仅能满足”=”,”IN”和”&lt;=&gt;”查询，不能使用范围查询<br>b 其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引<br>c 只有Memory存储引擎显示支持hash索引</p><p>3、FULLTEXT索引（现在MyISAM和InnoDB引擎都支持了）</p><p>4、R-Tree索引（用于对GIS数据类型创建SPATIAL索引）</p><p><strong>从物理存储角度</strong></p><p>1、聚集索引（clustered index）聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个 </p><p>2、非聚集索引（non-clustered index） 聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续 </p><p><strong>从逻辑角度</strong></p><p>1、主键索引：主键索引是一种特殊的唯一索引，不允许有空值</p><p>2、普通索引或者单列索引 : 即一个索引只包含单个列，一个表可以有多个单列索引</p><p>3、多列索引（复合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合</p><p>4、唯一索引或者非唯一索引</p><p>5、空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。<br>MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建</p><h3 id="索引的缺点"><a href="#索引的缺点" class="headerlink" title="索引的缺点"></a>索引的缺点</h3><ul><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</li><li>索引需要占用物理空间，除了数据表占用数据空间之外，每一个索引还要占一定的物理空间，如果建立聚簇索引，那么需要的空间就会更大</li><li>当对表中的数据进行增加、删除和修改的时候，索引也需要维护，降低数据维护的速度</li></ul><h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><ul><li>创建唯一性索引，保证数据库表中每一行数据的唯一性</li><li>大大加快数据的检索速度，这是创建索引的最主要的原因</li><li>加速数据库表之间的连接，特别是在实现数据的参考完整性方面特别有意义</li><li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间</li><li>通过使用索引，可以在查询中使用优化隐藏器，提高系统的性能</li></ul><h3 id="在什么情况下适合建立索引"><a href="#在什么情况下适合建立索引" class="headerlink" title="在什么情况下适合建立索引"></a>在什么情况下适合建立索引</h3><ul><li>为经常出现在关键字order by、group by、distinct后面的字段，建立索引。</li><li>在union等集合操作的结果集字段上，建立索引。其建立索引的目的同上。</li><li>为经常用作查询选择 where 后的字段，建立索引。</li><li>在经常用作表连接 join 的属性上，建立索引。</li><li>考虑使用索引覆盖。对数据很少被更新的表，如果用户经常只查询其中的几个字段，可以考虑在这几个字段上建立索引，从而将表的扫描改变为索引的扫描。</li></ul><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><ul><li><p>如果MySQL估计使用<strong>全表扫秒比使用索引快</strong>，则不适用索引。</p><p>例如，如果列key均匀分布在1和100之间，下面的查询使用索引就不是很好：select * from table_name where key&gt;1 and key&lt;90;</p></li><li><p>如果<strong>条件中有or</strong>，即使其中有条件带索引也不会使用</p><p>例如：select * from table_name where key1=’a’ or key2=’b’;如果在key1上有索引而在key2上没有索引，则该查询也不会走索引</p></li><li><p>复合索引，如果索引列<strong>不是复合索引的第一部分</strong>，则不使用索引（即不符合最左前缀）</p><p>例如，复合索引为(key1,key2),则查询select * from table_name where key2=’b’;将不会使用索引</p></li><li><p>如果<strong>like是以 % 开始的</strong>，则该列上的索引不会被使用。</p><p>例如select * from table_name where key1 like ‘%a’；该查询即使key1上存在索引，也不会被使用如果列类型是字符串，那一定要在条件中使用引号引起来，否则不会使用索引</p></li><li><p>如果列为字符串，则where条件中必须将字符常量值加引号，否则即使该列上存在索引，也不会被使用。</p><p>例如,select * from table_name where key1=1;如果key1列保存的是字符串，即使key1上有索引，也不会被使用。</p></li><li><p>如果使用MEMORY/HEAP表，并且where条件中不使用“=”进行索引列，那么不会用到索引，head表只有在“=”的条件下才会使用索引</p></li></ul><h4 id="左连接和右连接区别"><a href="#左连接和右连接区别" class="headerlink" title="左连接和右连接区别"></a>左连接和右连接区别</h4><blockquote><p>左连接where只影向右表，右连接where只影响左表。</p></blockquote><h3 id="MySQL-主从复制原理"><a href="#MySQL-主从复制原理" class="headerlink" title="MySQL 主从复制原理"></a>MySQL 主从复制原理</h3><blockquote><p>主库将变更写入 binlog 日志，然后从库连接到主库之后，从库有一个 IO 线程，将主库的 binlog 日志拷贝到自己本地，写入一个 relay 中继日志中。接着从库中有一个 SQL 线程会从中继日志读取 binlog，然后执行 binlog 日志中的内容，也就是在自己本地再次执行一遍 SQL，这样就可以保证自己跟主库的数据是一样的。</p></blockquote><h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><h2 id="Mysql-的分页-SQL-语句"><a href="#Mysql-的分页-SQL-语句" class="headerlink" title="Mysql 的分页 SQL 语句"></a>Mysql 的分页 SQL 语句</h2><p>select * from tablename limit m,n(n是指从第m+1条开始，取n条)</p><h2 id="下面提供几个查询优化的建议。"><a href="#下面提供几个查询优化的建议。" class="headerlink" title="下面提供几个查询优化的建议。"></a>下面提供几个查询优化的建议。</h2><h2 id="使用explain分析查询语句"><a href="#使用explain分析查询语句" class="headerlink" title="使用explain分析查询语句"></a>使用explain分析查询语句</h2><p>前面已经演示过如何使用<code>explain</code>命令分析查询语句了，这里再解释一下其中几个有参考价值的字段的含义：</p><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>select_type表示查询中每个select子句的类型，一般有下面几个值:</p><ul><li>simple 简单SELECT,不使用UNION或子查询等。</li><li>primary 查询中若包含任何复杂的子部分,最外层的select被标记为PRIMARY。</li><li>union union中的第二个或后面的SELECT语句。</li><li>dependent union union 中的第二个或后面的SELECT语句，取决于外面的查询。</li><li>union result union 的结果。</li><li>subquery子查询中的第一个SELECT。</li><li>dependent subquery子查询中的第一个SELECT，取决于外面的查询。</li><li>derived派生表的SELECT, FROM子句的子查询。</li><li>uncacheable subquery一个子查询的结果不能被缓存，必须重新评估外链接的第一行。</li></ul><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>type表示MySQL在表中找到所需行的方式，又称“访问类型”，常用的类型有：</p><p>ALL, index,  range, ref, eq_ref, const, system, NULL。</p><p>从左到右，性能从差到好。</p><ul><li>ALL： Full Table Scan，MySQL将遍历全表以找到匹配的行。</li><li>index: Full Index Scan，index与ALL区别为index类型只遍历索引树。</li><li>range: 只检索给定范围的行，使用一个索引来选择行。</li><li>ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。</li><li>eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件。</li><li>const: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。 如将主键置于where列表中，MySQL就能将该查询转换为一个常量。</li><li>NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。</li></ul><h3 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h3><p>key列显示MySQL实际决定使用的键（索引），如果没有选择索引，键是NULL。</p><h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p>possible_keys指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上如果存在索引则该索引将被列出，但不一定被查询使用。</p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>ref表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。</p><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>rows表示MySQL根据表统计信息，以及索引选用的情况，找到所需记录需要读取的行数。这个行数是估算的值，实际行数可能不同。</p><h2 id="声明NOT-NULL"><a href="#声明NOT-NULL" class="headerlink" title="声明NOT NULL"></a>声明NOT NULL</h2><p>当数据列被声明为NOT NULL以后，在查询的时候就不需要判断是否为NULL，由于减少了判断，可以降低复杂性，提高查询速度。</p><p>如果要表示数据列为空，可以使用0等代替。</p><h2 id="考虑使用数值类型代替字符串"><a href="#考虑使用数值类型代替字符串" class="headerlink" title="考虑使用数值类型代替字符串"></a>考虑使用数值类型代替字符串</h2><p>MySQL对数值类型的处理速度要远远快于字符串，而且数值类型往往更加节省空间。</p><p>例如对于“Male”和“Female”可以用“0”和“1”进行代替。</p><h2 id="考虑使用ENUM类型"><a href="#考虑使用ENUM类型" class="headerlink" title="考虑使用ENUM类型"></a>考虑使用ENUM类型</h2><p>如果你的数据列的取值是确定有限的，可以使用ENUM类型代替字符串。因为MySQL会把这些值表示为一系列对应的数字，这样处理的速度会提高很多。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> shirts (</div><div class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">40</span>),</div><div class="line">    <span class="keyword">size</span> ENUM(<span class="string">'x-small'</span>, <span class="string">'small'</span>, <span class="string">'medium'</span>, <span class="string">'large'</span>, <span class="string">'x-large'</span>)</div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> shirts (<span class="keyword">name</span>, <span class="keyword">size</span>) <span class="keyword">VALUES</span> (<span class="string">'dress shirt'</span>,<span class="string">'large'</span>), (<span class="string">'t-shirt'</span>,<span class="string">'medium'</span>),</div><div class="line">  (<span class="string">'polo shirt'</span>,<span class="string">'small'</span>);</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, <span class="keyword">size</span> <span class="keyword">FROM</span> shirts <span class="keyword">WHERE</span> <span class="keyword">size</span> = <span class="string">'medium'</span>;</div></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>索引是一个单独的，存储在磁盘上的数据结构，索引对数据表中一列或者多列值进行排序，索引包含着对数据表中所有数据的引用指针。</p><p>本教程从MySQL开始讲起，又介绍了MySQL中索引的使用，最后提供了使用索引的几条原则和优化查询的几个方法。</p><h2 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h2><h2 id="oracle中row-id理解"><a href="#oracle中row-id理解" class="headerlink" title="oracle中row_id理解"></a>oracle中row_id理解</h2><p>ORACLE的row_id是一个伪列,其个是为18个字节可将这18个字节用6363来划分,分别表示段编号,数据文件编号,数据块</p><h2 id="嵌入式数据库和传统数据库的区别"><a href="#嵌入式数据库和传统数据库的区别" class="headerlink" title="嵌入式数据库和传统数据库的区别"></a>嵌入式数据库和传统数据库的区别</h2><p>嵌入式数据库主要像：SQLite、</p><p>传统数据库服务器：SQL Server、Oracle、MySQL</p><p>嵌入式数据库：SQLite的主要特点：</p><ol><li>支持事件，不需要配置，不需要安装，也不需要管理员；</li><li>支持大部分SQL92；</li><li>一个完整的数据库保存在磁盘上面一个文件，同一个数据库文件可以在不同机器上面使用，最大支持数据库到2T，字符和BLOB的支持仅限制于可用内存；</li><li>整个系统少于3万行代码，少于250KB的内存占用(gcc)，大部分应用比目前常见的客户端/服务端的数据库快，没有其它依赖</li><li>源代码开放，代码95%有较好的注释，简单易用的API。官方带有TCL的编译版本。</li></ol><p>关系数据库特点：</p><ol><li>更好的安全性、多用户管理</li><li>强大的数据管理能力，如索引、视图等关系对象</li><li>强大的数据库编程式的设计，像T-SQL、存储过程、游标</li><li>丰富的数据类型</li></ol><h2 id="Inserted和deleted的含义"><a href="#Inserted和deleted的含义" class="headerlink" title="Inserted和deleted的含义"></a>Inserted和deleted的含义</h2><p>inserted表反映插入或更新操作时插入的记录</p><p>deleted表反映删除或更新操作时删除的记录</p><h2 id="函数和过程的区别"><a href="#函数和过程的区别" class="headerlink" title="函数和过程的区别"></a>函数和过程的区别</h2><p>存储过程：</p><ul><li>一般用于在数据库中完成特定的业务或任务</li><li>可以定义返回类型，也可以不定义返回类型</li><li>SQL语句中不可以调用</li></ul><p>函数：</p><ul><li>一般用于特定的数据查询或数据转转换处理</li><li>申请时必须要定义返回类型，且程序体中必须定义return语句</li><li>不能独立执行，必须作为表达式的一部分调用</li><li>SQL语句中可以调用</li></ul><h2 id="数据库优化的方案"><a href="#数据库优化的方案" class="headerlink" title="数据库优化的方案"></a>数据库优化的方案</h2><p>建立主键，为数据库创建索引，建立存储过程，触发器，可提高查询速度。</p><h2 id="Oracle中有哪几种索引"><a href="#Oracle中有哪几种索引" class="headerlink" title="Oracle中有哪几种索引"></a>Oracle中有哪几种索引</h2><ol><li><strong>单列索引与复合索引：</strong>一个索引可以由一个或多个列组成，用来创建索引的列被称为“索引列”。单列索引是基于单列所创建的索引，复合索引是基于两列或者多列所创建的索引。</li><li><strong>唯一索引与非唯一索引：</strong>唯一索引是索引列值不能重复的索引，非唯一索引是索引列可以重复的索引。无论是唯一索引还是非唯一索引，索引列都允许取NULL值。默认情况下，Oracle创建的索引是不唯一索引。</li><li><strong>B树索引：</strong>B树索引是按B树算法组织并存放索引数据的，所以B树索引主要依赖其组织并存放索引数据的算法来实现快速检索功能。</li><li><strong>位图索引：</strong>位图索引在多列查询时，可以对两个列上的位图进行AND和OR操作，达到更好的查询效果。</li><li><strong>函数索引：</strong>Oracle中不仅能够直接对表中的列创建索引，还可以对包含列的函数或表达式创建索引，这种索引称为“位图索引</li></ol><h2 id="数据库索引的优点和缺点"><a href="#数据库索引的优点和缺点" class="headerlink" title="数据库索引的优点和缺点"></a>数据库索引的优点和缺点</h2><p>优点：</p><ol><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li><li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li><li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li><li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li><li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li></ol><p>缺点：</p><ol><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li><li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li></ol><h2 id="触发器有几种"><a href="#触发器有几种" class="headerlink" title="触发器有几种"></a>触发器有几种</h2><p>共2种，一种DML触发，就是遇到DML事件时触发执行，像insert\update\delete。一种DDL触发，遇到DDL事件时触发，像Login Datatabase、更改数据库状态、create语句等。</p><h2 id="oracle中除了数据库备份，还有什么方法备份"><a href="#oracle中除了数据库备份，还有什么方法备份" class="headerlink" title="oracle中除了数据库备份，还有什么方法备份"></a>oracle中除了数据库备份，还有什么方法备份</h2><p>Oracle数据库有三种标准的备份方法，它们分别是导出/导入(EXP/IMP)、热备份和冷备份。导出备份是一种逻辑备份，冷备份和热备份是物理备份。</p><p>10G有几种新功能进行备份，像数据磅</p><h2 id="写出删除表中重复记录的语句oracle"><a href="#写出删除表中重复记录的语句oracle" class="headerlink" title="写出删除表中重复记录的语句oracle"></a>写出删除表中重复记录的语句oracle</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">delete</span> <span class="keyword">from</span> people</div><div class="line"><span class="keyword">where</span> peopleId <span class="keyword">in</span> (<span class="keyword">select</span> peopleId <span class="keyword">from</span> people <span class="keyword">group</span> <span class="keyword">by</span> peopleId <span class="keyword">having</span> <span class="keyword">count</span>(peopleId) &gt; <span class="number">1</span>) <span class="keyword">and</span> <span class="keyword">rowid</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">min</span>(<span class="keyword">rowid</span>) <span class="keyword">from</span>   people <span class="keyword">group</span> <span class="keyword">by</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是事务&quot;&gt;&lt;a href=&quot;#什么是事务&quot; class=&quot;headerlink&quot; title=&quot;什么是事务&quot;&gt;&lt;/a&gt;什么是事务&lt;/h2&gt;&lt;p&gt;事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。&lt;/p&gt;
    
    </summary>
    
      <category term="基础面试题" scheme="http://swenfang.github.io/categories/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="基础面试题" scheme="http://swenfang.github.io/tags/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot和SpringCloud面试题</title>
    <link href="http://swenfang.github.io/2019/05/12/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/SpringBoot%E5%92%8CSpringCloud%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://swenfang.github.io/2019/05/12/面试总结/SpringBoot和SpringCloud面试题/</id>
    <published>2019-05-12T13:33:19.918Z</published>
    <updated>2019-05-12T15:11:09.067Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring-Boot-与-Spring-的区别"><a href="#Spring-Boot-与-Spring-的区别" class="headerlink" title="Spring Boot 与 Spring 的区别"></a>Spring Boot 与 Spring 的区别</h3><ul><li>Spring Boot可以建立独立的Spring应用程序；</li><li>内嵌了如Tomcat，Jetty和Undertow这样的容器，也就是说可以直接跑起来，用不着再做部署工作了。</li><li>无需再像Spring那样搞一堆繁琐的xml文件的配置；</li><li>可以自动配置Spring；</li><li>提供了一些现有的功能，如度量工具，表单数据验证以及一些外部配置这样的一些第三方功能；</li><li>提供的POM可以简化Maven的配置；</li></ul><a id="more"></a><h3 id="SpringBoot-的自动配置是怎么做的"><a href="#SpringBoot-的自动配置是怎么做的" class="headerlink" title="SpringBoot 的自动配置是怎么做的"></a>SpringBoot 的自动配置是怎么做的</h3><blockquote><p>Spring boot 的所有自动化配置的实现都在 spring-boot-autoconfigure 依赖中，通过@EnableAutoConfiguration 核心注解初始化，并扫描 ClassPath 目录中自动配置类对应依赖。并对对应的组件依赖按一定规则获取默认配置并自动初始化所需要的 Bean。</p></blockquote><p>先答为什么需要自动配置？<br>顾名思义，自动配置的意义是利用这种模式代替了配置 XML 繁琐模式。以前使用 Spring MVC ，需要进行配置组件扫描、调度器、视图解析器等，使用 Spring Boot 自动配置后，只需要添加 MVC 组件即可自动配置所需要的 Bean。所有自动配置的实现都在 spring-boot-autoconfigure 依赖中，包括 Spring MVC 、Data 和其它框架的自动配置。</p><p>接着答spring-boot-autoconfigure 依赖的工作原理?<br>spring-boot-autoconfigure 依赖的工作原理很简单，通过 @EnableAutoConfiguration 核心注解初始化，并扫描 ClassPath 目录中自动配置类对应依赖。比如工程中有木有添加 Thymeleaf 的 Starter 组件依赖。如果有，就按按一定规则获取默认配置并自动初始化所需要的 Bean。</p><p>ioc的思想最核心的地方在于，<strong>资源不由使用资源的双方管理，而由不使用资源的第三方管理</strong>，这可以带来很多好处： </p><ul><li>第一，资源集中管理，实现资源的可配置和易管理。 </li><li>第二，降低了使用资源双方的依赖程度，也就是我们说的耦合度。</li></ul><h3 id="什么是springboot"><a href="#什么是springboot" class="headerlink" title="什么是springboot"></a>什么是springboot</h3><pre><code>用来简化spring应用的初始搭建以及开发过程 使用特定的方式来进行配置（properties或yml文件） 创建独立的spring引用程序 main方法运行嵌入的Tomcat 无需部署war文件简化maven配置自动配置spring添加对应功能starter自动化配置               </code></pre><h3 id="springboot常用的starter有哪些"><a href="#springboot常用的starter有哪些" class="headerlink" title="springboot常用的starter有哪些"></a>springboot常用的starter有哪些</h3><pre><code>spring-boot-starter-web 嵌入tomcat和web开发需要servlet与jsp支持spring-boot-starter-data-jpa 数据库支持spring-boot-starter-data-redis redis数据库支持spring-boot-starter-data-solr solr支持mybatis-spring-boot-starter 第三方的mybatis集成starter      </code></pre><h3 id="springboot自动配置的原理"><a href="#springboot自动配置的原理" class="headerlink" title="springboot自动配置的原理"></a>springboot自动配置的原理</h3><pre><code>在spring程序main方法中 添加@SpringBootApplication或者@EnableAutoConfiguration会自动去maven中读取每个starter中的spring.factories文件  该文件里配置了所有需要被创建spring容器中的bean</code></pre><h3 id="springboot读取配置文件的方式"><a href="#springboot读取配置文件的方式" class="headerlink" title="springboot读取配置文件的方式"></a>springboot读取配置文件的方式</h3><pre><code>springboot默认读取配置文件为application.properties或者是application.yml    </code></pre><h3 id="springboot集成mybatis的过程"><a href="#springboot集成mybatis的过程" class="headerlink" title="springboot集成mybatis的过程"></a>springboot集成mybatis的过程</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">添加mybatis的starter maven依赖</div><div class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">在mybatis的接口中 添加@Mapper注解</div><div class="line">在application.yml配置数据源信息</div></pre></td></tr></table></figure><p>​        </p><h3 id="springboot如何添加【修改代码】自动重启功能"><a href="#springboot如何添加【修改代码】自动重启功能" class="headerlink" title="springboot如何添加【修改代码】自动重启功能"></a>springboot如何添加【修改代码】自动重启功能</h3><p>添加开发者工具集=====spring-boot-devtools</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure><p>SpringBoot2.0新增什么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">1.支持 Java9</div><div class="line"></div><div class="line">2.基于 Spring5 构建</div><div class="line"></div><div class="line">3.Tomcat 升级到 8.5</div><div class="line"></div><div class="line">4.Flyway 升级到 5</div><div class="line"></div><div class="line">5.Hibernate 升级到 5.2</div><div class="line"></div><div class="line">6.Thymeleaf 升级到 3</div></pre></td></tr></table></figure><p>​        </p><h3 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h3><pre><code>以前的模式是 所有的代码在同一个工程中 部署在同一个服务器中 同一个项目的不同模块不同功能互相抢占资源微服务 将工程根据不同的业务规则拆分成微服务 微服务部署在不同的机器上 服务之间进行相互调用Java微服务的框架有 dubbo（只能用来做微服务），spring cloud（提供了服务的发现，断路器等）</code></pre><h3 id="springcloud如何实现服务的注册和发现"><a href="#springcloud如何实现服务的注册和发现" class="headerlink" title="springcloud如何实现服务的注册和发现"></a>springcloud如何实现服务的注册和发现</h3><pre><code>服务在发布时 指定对应的服务名（服务名包括了IP地址和端口） 将服务注册到注册中心（eureka或者zookeeper）这一过程是springcloud自动实现 只需要在main方法添加@EnableDisscoveryClient  同一个服务修改端口就可以启动多个实例调用方法：传递服务名称通过注册中心获取所有的可用实例 通过负载均衡策略调用（ribbon和feign）对应的服务</code></pre><h3 id="ribbon和feign区别"><a href="#ribbon和feign区别" class="headerlink" title="ribbon和feign区别"></a>ribbon和feign区别</h3><pre><code>Ribbon添加maven依赖 spring-starter-ribbon 使用@RibbonClient(value=&quot;服务名称&quot;) 使用RestTemplate调用远程服务对应的方法feign添加maven依赖 spring-starter-feign 服务提供方提供对外接口 调用方使用 在接口上使用@FeignClient(&quot;指定服务名&quot;)</code></pre><h3 id="Ribbon和Feign的区别："><a href="#Ribbon和Feign的区别：" class="headerlink" title="Ribbon和Feign的区别："></a>Ribbon和Feign的区别：</h3><pre><code>Ribbon和Feign都是用于调用其他服务的，不过方式不同。1.启动类使用的注解不同，Ribbon用的是@RibbonClient，Feign用的是@EnableFeignClients。2.服务的指定位置不同，Ribbon是在@RibbonClient注解上声明，Feign则是在定义抽象方法的接口中使用@FeignClient声明。3.调用方式不同，Ribbon需要自己构建http请求，模拟http请求然后使用RestTemplate发送给其他服务，步骤相当繁琐。Feign则是在Ribbon的基础上进行了一次改进，采用接口的方式，将需要调用的其他服务的方法定义成抽象方法即可，不需要自己构建http请求。不过要注意的是抽象方法的注解、方法签名要和提供服务的方法完全一致。</code></pre><h3 id="springcloud断路器的作用"><a href="#springcloud断路器的作用" class="headerlink" title="springcloud断路器的作用"></a>springcloud断路器的作用</h3><pre><code>当一个服务调用另一个服务由于网络原因或者自身原因出现问题时 调用者就会等待被调用者的响应 当更多的服务请求到这些资源时导致更多的请求等待 这样就会发生连锁效应（雪崩效应） 断路器就是解决这一问题            断路器有完全打开状态                    一定时间内 达到一定的次数无法调用 并且多次检测没有恢复的迹象 断路器完全打开，那么下次请求就不会请求到该服务            半开                    短时间内 有恢复迹象 断路器会将部分请求发给该服务 当能正常调用时 断路器关闭            关闭                    当服务一直处于正常状态 能正常调用 断路器关闭</code></pre><h3 id="服务注册发现组件Eureka工作原理"><a href="#服务注册发现组件Eureka工作原理" class="headerlink" title="服务注册发现组件Eureka工作原理"></a>服务注册发现组件Eureka工作原理</h3><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190412111608-386935.jpg" alt=""></p><h3 id="服务网关组件Zuul工作原理"><a href="#服务网关组件Zuul工作原理" class="headerlink" title="服务网关组件Zuul工作原理"></a>服务网关组件Zuul工作原理</h3><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190412111643-879260.jpg" alt=""></p><h3 id="跨域时序图"><a href="#跨域时序图" class="headerlink" title="跨域时序图"></a>跨域时序图</h3><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190412111757-854161.jpg" alt=""></p><h3 id="Eureka与Ribbon整合工作原理"><a href="#Eureka与Ribbon整合工作原理" class="headerlink" title="Eureka与Ribbon整合工作原理"></a>Eureka与Ribbon整合工作原理</h3><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190412111845-373920.jpg" alt=""></p><h3 id="解决分布式一致性"><a href="#解决分布式一致性" class="headerlink" title="解决分布式一致性"></a>解决分布式一致性</h3><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190412111915-868350.jpg" alt=""></p><h3 id="级联故障流程"><a href="#级联故障流程" class="headerlink" title="级联故障流程"></a>级联故障流程</h3><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190412111943-135952.jpg" alt=""></p><h3 id="断路器组件Hystrix工作原理"><a href="#断路器组件Hystrix工作原理" class="headerlink" title="断路器组件Hystrix工作原理"></a>断路器组件Hystrix工作原理</h3><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190412112020-566111.jpg" alt=""></p><h3 id="分布式追踪Sleuth工作原理"><a href="#分布式追踪Sleuth工作原理" class="headerlink" title="分布式追踪Sleuth工作原理"></a>分布式追踪Sleuth工作原理</h3><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190412112049-558890.jpg" alt=""></p><h3 id="SpringBoot自动配置工作原理"><a href="#SpringBoot自动配置工作原理" class="headerlink" title="SpringBoot自动配置工作原理"></a>SpringBoot自动配置工作原理</h3><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190412112116-418572.jpg" alt=""></p><h3 id="什么是SpringCloud"><a href="#什么是SpringCloud" class="headerlink" title="什么是SpringCloud"></a>什么是SpringCloud</h3><p>Spring cloud流应用程序启动器是基于Spring Boot的Spring集成应用程序，提供与外部系统的集成。Spring cloud Task，一个生命周期短暂的微服务框架，用于快速构建执行有限数据处理的应用程序。</p><h3 id="使用Spring-Cloud有什么优势"><a href="#使用Spring-Cloud有什么优势" class="headerlink" title="使用Spring Cloud有什么优势"></a>使用Spring Cloud有什么优势</h3><p>使用Spring Boot开发分布式微服务时，我们面临以下问题</p><ul><li>与分布式系统相关的复杂性-这种开销包括网络问题，延迟开销，带宽问题，安全问题。</li><li>服务发现-服务发现工具管理群集中的流程和服务如何查找和互相交谈。它涉及一个服务目录，在该目录中注册服务，然后能够查找并连接到该目录中的服务。</li><li>冗余-分布式系统中的冗余问题。</li><li>负载平衡 –负载平衡改善跨多个计算资源的工作负荷，诸如计算机，计算机集群，网络链路，<a href="https://www.baidu.com/s?wd=%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="external">中央处理单元</a>，或磁盘驱动器的分布。</li><li>性能-问题 由于各种运营开销导致的性能问题。</li><li>部署复杂性-Devops技能的要求。</li></ul><h3 id="服务注册和发现是什么意思？Spring-Cloud如何实现？"><a href="#服务注册和发现是什么意思？Spring-Cloud如何实现？" class="headerlink" title="服务注册和发现是什么意思？Spring Cloud如何实现？"></a>服务注册和发现是什么意思？Spring Cloud如何实现？</h3><p>当我们开始一个项目时，我们通常在属性文件中进行所有的配置。随着越来越多的服务开发和部署，添加和修改这些属性变得更加复杂。有些服务可能会下降，而某些位置可能会发生变化。手动更改属性可能会产生问题。 Eureka服务注册和发现可以在这种情况下提供帮助。由于所有服务都在Eureka服务器上注册并通过调用Eureka服务器完成查找，因此无需处理服务地点的任何更改和处理。</p><h3 id="负载平衡的意义什么"><a href="#负载平衡的意义什么" class="headerlink" title="负载平衡的意义什么"></a>负载平衡的意义什么</h3><p>在计算中，负载平衡可以改善跨计算机，计算机集群，网络链接，中央处理单元或磁盘驱动器等多种计算资源的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间并避免任何单一资源的过载。使用多个组件进行负载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉及专用软件或硬件，例如<a href="https://www.baidu.com/s?wd=%E5%A4%9A%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="external">多层交换机</a>或域名系统服务器进程。</p><h3 id="什么是Hystrix？它如何实现容错？"><a href="#什么是Hystrix？它如何实现容错？" class="headerlink" title="什么是Hystrix？它如何实现容错？"></a>什么是Hystrix？它如何实现容错？</h3><p>Hystrix是一个延迟和容错库，旨在隔离远程系统，服务和第三方库的访问点，当出现故障是<a href="https://www.baidu.com/s?wd=%E4%B8%8D%E5%8F%AF%E9%81%BF%E5%85%8D&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="external">不可避免</a>的故障时，停止级联故障并在复杂的分布式系统中实现弹性。</p><p>通常对于使用微服务架构开发的系统，涉及到许多微服务。这些微服务彼此协作。</p><p>思考以下微服务</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190412112805-800691.jpg" alt=""></p><p>假设如果上图中的微服务9失败了，那么使用传统方法我们将传播一个异常。但这仍然会导致整个系统崩溃。</p><p>随着微服务数量的增加，这个问题变得更加复杂。微服务的数量可以高达1000.这是hystrix出现的地方 我们将使用Hystrix在这种情况下的Fallback方法功能。我们有两个服务employee-consumer使用由employee-consumer公开的服务。</p><p>简化图如下所示</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190412112825-592667.jpg" alt=""></p><p>现在假设由于某种原因，employee-producer公开的服务会抛出异常。我们在这种情况下使用Hystrix定义了一个回退方法。这种后备方法应该具有与公开服务相同的返回类型。如果暴露服务中出现异常，则回退方法将返回一些值。</p><h3 id="什么是Hystrix断路器？我们需要它吗？"><a href="#什么是Hystrix断路器？我们需要它吗？" class="headerlink" title="什么是Hystrix断路器？我们需要它吗？"></a>什么是Hystrix断路器？我们需要它吗？</h3><p>由于某些原因，employee-consumer公开服务会引发异常。在这种情况下使用Hystrix我们定义了一个回退方法。如果在公开服务中发生异常，则回退方法返回一些默认值。</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190412112904-253034.jpg" alt=""></p><p>如果firstPage method() 中的异常继续发生，则Hystrix电路将中断，并且员工使用者将一起跳过firtsPage方法，并直接调用回退方法。 断路器的目的是给第一页方法或第一页方法可能调用的其他方法留出时间，并导致异常恢复。可能发生的情况是，在负载较小的情况下，导致异常的问题有更好的恢复机会 。</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190412112922-392868.jpg" alt=""></p><h3 id="什么是Netflix-Feign？它的优点是什么？"><a href="#什么是Netflix-Feign？它的优点是什么？" class="headerlink" title="什么是Netflix Feign？它的优点是什么？"></a>什么是Netflix Feign？它的优点是什么？</h3><p>Feign是受到Retrofit，JAXRS-2.0和WebSocket启发的java客户端联编程序。Feign的第一个目标是将约束分母的复杂性统一到http apis，而不考虑其稳定性。在employee-consumer的例子中，我们使用了employee-producer使用REST模板公开的REST服务。</p><p>但是我们必须编写大量代码才能执行以下步骤</p><ul><li>使用功能区进行负载平衡。</li><li>获取服务实例，然后获取基本URL。</li><li>利用REST模板来使用服务。 前面的代码如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerControllerClient</span> </span>&#123;</div><div class="line"> </div><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="keyword">private</span> LoadBalancerClient loadBalancer;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getEmployee</span><span class="params">()</span> <span class="keyword">throws</span> RestClientException, IOException </span>&#123;</div><div class="line"> </div><div class="line">    ServiceInstance serviceInstance=loadBalancer.choose(<span class="string">"employee-producer"</span>);</div><div class="line"> </div><div class="line">    System.out.println(serviceInstance.getUri());</div><div class="line"> </div><div class="line">    String baseUrl=serviceInstance.getUri().toString();</div><div class="line"> </div><div class="line">    baseUrl=baseUrl+<span class="string">"/employee"</span>;</div><div class="line"> </div><div class="line">    RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</div><div class="line">    ResponseEntity&lt;String&gt; response=<span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">    response=restTemplate.exchange(baseUrl,</div><div class="line">            HttpMethod.GET, getHeaders(),String.class);</div><div class="line">    &#125;<span class="keyword">catch</span> (Exception ex)</div><div class="line">    &#123;</div><div class="line">        System.out.println(ex);</div><div class="line">    &#125;</div><div class="line">    System.out.println(response.getBody());</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>之前的代码，有像NullPointer这样的例外的机会，并不是最优的。我们将看到如何使用Netflix Feign使呼叫变得更加轻松和清洁。如果Netflix Ribbon依赖关系也在类路径中，那么Feign默认也会负责负载平衡。</p><h3 id="什么是Spring-Cloud-Bus？我们需要它吗？"><a href="#什么是Spring-Cloud-Bus？我们需要它吗？" class="headerlink" title="什么是Spring Cloud Bus？我们需要它吗？"></a>什么是Spring Cloud Bus？我们需要它吗？</h3><p>考虑以下情况：我们有多个应用程序使用Spring Cloud Config读取属性，而Spring Cloud Config从GIT读取这些属性。</p><p>下面的例子中多个员工生产者模块从</p><h3 id="什么是微服务架构"><a href="#什么是微服务架构" class="headerlink" title="什么是微服务架构"></a>什么是微服务架构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">   1.微服务是系统架构上的一种设计风格，他的主旨是将一个原本独立的系统拆分成多个小型服务</div><div class="line"></div><div class="line">2.这些小型服务都在各自独立的进程中运行</div><div class="line"></div><div class="line">3.服务之间通过基于HTTP的RESTful API进行通信协作</div><div class="line"></div><div class="line">4.被拆分的每个微服务都围绕系统中的某一项或一些耦合度较高的业务功能进行构建</div><div class="line"></div><div class="line">5.并且每个微服务都维护着自身的数据存储，业务开发，自动化测试案例以及独立部署机制</div><div class="line"></div><div class="line">6.由于有了轻量级的通信协作基础，所以这些微服务可以使用不同的语言来编写</div></pre></td></tr></table></figure><h3 id="微服务之间是如何独立通讯的？"><a href="#微服务之间是如何独立通讯的？" class="headerlink" title="微服务之间是如何独立通讯的？"></a>微服务之间是如何独立通讯的？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">同步：RPC,REST等；使用HTTP的RESTful API或轻量级的消息发送协议，实现信息传递与服务调用的触发。</div><div class="line"></div><div class="line">异步：消息队列，要考虑可靠传输，高性能，以及编程模型的编号等；通过在轻量级的消息总线上传递消息，类似Rabbitmq等一些提供可靠异步</div><div class="line"></div><div class="line">交换的中间件。</div></pre></td></tr></table></figure><h3 id="谈谈你对SpringBoot-SpringCloud的理解"><a href="#谈谈你对SpringBoot-SpringCloud的理解" class="headerlink" title="谈谈你对SpringBoot,SpringCloud的理解"></a>谈谈你对SpringBoot,SpringCloud的理解</h3><h3 id="什么是服务熔断，什么是服务降级？"><a href="#什么是服务熔断，什么是服务降级？" class="headerlink" title="什么是服务熔断，什么是服务降级？"></a>什么是服务熔断，什么是服务降级？</h3><p>扇出与雪崩响应：</p><p>多位微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其他微服务，这就是所谓的”扇处”。如果扇处的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃—所谓的”雪崩效应”。</p><p>服务熔断：</p><p>熔断机制是应对雪崩效应的一种微服务链路保护机制！！！当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回“错误”的响应信息。当检测到该节点微服务调用响应正常后恢复链路。在SpringCloud框架里熔断机制通过Hystrix实现。Hystrix会监控微服务调用的状况，当失败的调用到一定阈值就会启动熔断机制(默认是5秒内20次调用失败就会启动熔断机制)。但服务熔断来处理雪崩效应是非常可怕的，不可取的。第一如果有多个方法，对应的FallBack方法也会随之膨胀；第二异常处理与业务逻辑高耦合，完全不符合Spring AOP面向切面的思想。</p><p>服务降级：</p><p>整体资源快不够了，忍痛将某些服务先关掉，待渡过难关，再开启回来。服务降级处理是在客户端(消费者)完成的与服务端没有关系。</p><p>个人感觉：多个微服务之间进行调用，假设微服务A调用微服务B和微服务C,微服务B和微服务C又调用其他微服务，这就是所谓的“扇出”。如果扇出链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃—所谓的“雪崩效应”。</p><p>服务熔断和服务降级都是为了解决雪崩效应，只是二者实现方式不同：</p><p>服务熔断在服务提供端，进行服务降级，进而熔断该节点微服务的调用，快速返回“失败”的响应信息。当检测到 该节点微服务调用响应正常恢复链路。当失败的次数达到一定阈值就会启动熔断机制服务降级，处理方式在客户端完成与服务端有没有关系，整体资源快不够了，忍痛将某些服务先关掉，待度过难关再开启回来。</p><p>服务监控：htstrix dashbord</p><h3 id="微服务的优缺点？"><a href="#微服务的优缺点？" class="headerlink" title="微服务的优缺点？"></a>微服务的优缺点？</h3><p>优点：</p><p>每个服务足够内聚，足够小，代码容易理解这样能聚焦一个指定的业务功能或业务需求</p><p>开发简单、开发效率提高，一个服务可能就是专一的只干一件事。</p><p>微服务能够被小团队独立开发，这个团队可以使2到5人的开发人员组成。</p><p>微服务是松耦合的，是有功能意义的服务，无论实在开发阶段或部署阶段都是独立的。</p><p>微服务能使用不同的语言开发。</p><p>微服务只是业务逻辑的代码，不会和HTML,CSS或其他界面组件混合。</p><p>每个微服务都有自己的存储能力，可以有自己的数据库。也可以有统一的数据库。</p><p>缺点：</p><p>开发人员要处理分布式系统的复杂性</p><p>多服务运维难度，随着服务的增加，运维的压力也在增加</p><p>系统部署依赖</p><p>服务间通信成本</p><p>数据一致性</p><p>系统集成测试</p><p>性能监控</p><h3 id="分布式事务？"><a href="#分布式事务？" class="headerlink" title="分布式事务？"></a>分布式事务？</h3><p>使用lcn</p><h3 id="谈谈你所知道的微服务技术栈有哪些？"><a href="#谈谈你所知道的微服务技术栈有哪些？" class="headerlink" title="谈谈你所知道的微服务技术栈有哪些？"></a>谈谈你所知道的微服务技术栈有哪些？</h3><h3 id="什么是springboot-1"><a href="#什么是springboot-1" class="headerlink" title="什么是springboot"></a>什么是springboot</h3><p>Spring Boot的宗旨并非要重写Spring或是替代Spring,而是希望通过设计大量的自动化配置等方式来简化Spring原有样板化的配置，用来简化Spring初始构建以及开发工程的，使用特定的方式来进行配置</p><ol><li>大量的自动化配置来简化Spring原有样板化的配置，</li><li>简化Maven配置，是依赖管理变得更加简单(添加对应功能的starter)，</li><li>快速开发(创建独立的Spring引用程序，main方法运行)，</li><li>轻松部署(内嵌的tomcat，不需要部署war文件，直接运行jar文件)</li></ol><h3 id="SpringBoot自动配置的原理"><a href="#SpringBoot自动配置的原理" class="headerlink" title="SpringBoot自动配置的原理"></a>SpringBoot自动配置的原理</h3><p>在spring程序main方法中 添加@SpringBootApplication或者@EnableAutoConfiguration会自动去maven中读取每个starter中的spring.factories文件  该文件里配置了所有需要被创建spring容器中的bean</p><h3 id="springboot读取配置文件的方式-1"><a href="#springboot读取配置文件的方式-1" class="headerlink" title="springboot读取配置文件的方式"></a>springboot读取配置文件的方式</h3><p>springboot默认读取配置文件为application.properties或者是application.yml</p><h3 id="springCloud如何实现服务的注册和发现的"><a href="#springCloud如何实现服务的注册和发现的" class="headerlink" title="springCloud如何实现服务的注册和发现的"></a>springCloud如何实现服务的注册和发现的</h3><p>服务在发布时 指定对应的服务名（服务名包括了IP地址和端口） 将服务注册到注册中心（eureka或者zookeeper）这一过程是springcloud自动实现 只需要在main方法添加@EnableDisscoveryClient  同一个服务修改端口就可以启动多个实例调用方法：传递服务名称通过注册中心获取所有的可用实例 通过负载均衡策略调用（ribbon和feign）对应的服务</p><h3 id="对外服务接口带有Request参数的请求，带有Header信息的请求，带有RequestBody的请求以及请求响应体是一个对象的请求，Spring-Cloud-Feign接口调用如何绑定参数？"><a href="#对外服务接口带有Request参数的请求，带有Header信息的请求，带有RequestBody的请求以及请求响应体是一个对象的请求，Spring-Cloud-Feign接口调用如何绑定参数？" class="headerlink" title="对外服务接口带有Request参数的请求，带有Header信息的请求，带有RequestBody的请求以及请求响应体是一个对象的请求，Spring Cloud Feign接口调用如何绑定参数？"></a>对外服务接口带有Request参数的请求，带有Header信息的请求，带有RequestBody的请求以及请求响应体是一个对象的请求，Spring Cloud Feign接口调用如何绑定参数？</h3><p>注意：在各参数绑定时，@RequestParam,@RequestHeader等可以指定参数名称的注解，它的value不能少。在SpringMVC程序中，这些注解会根据参数名作为默认值，但是在Feign中绑定参数必须通过value属性来指明具体的参数名，不然抛异常，value不能少。</p><h3 id="Feign与Ribbon，Hystrix的关系"><a href="#Feign与Ribbon，Hystrix的关系" class="headerlink" title="Feign与Ribbon，Hystrix的关系"></a>Feign与Ribbon，Hystrix的关系</h3><p>Feign的客户端负载均衡是通过SpringCloud Ribbon实现的，所以可以直接通过配置Ribbon客户端的方式来自定义各个服务客户端的参数。Feign引入了服务保护与容错的工具Hystix,默认情况下，Feign将所有Feign客户端方法都封装到Hystrix命令中进行服务保护。</p><h3 id="Ribbon全局配置，Ribbon指定服务配置，Ribbon重要的配置参数，Ribbon重试机制"><a href="#Ribbon全局配置，Ribbon指定服务配置，Ribbon重要的配置参数，Ribbon重试机制" class="headerlink" title="Ribbon全局配置，Ribbon指定服务配置，Ribbon重要的配置参数，Ribbon重试机制"></a>Ribbon全局配置，Ribbon指定服务配置，Ribbon重要的配置参数，Ribbon重试机制</h3><p>Ribbon全局配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ribbon.ConnectTimeout = 500</div><div class="line">ribbon.ReadTimeout = 5000</div></pre></td></tr></table></figure><p>Ribbon指定服务配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">在SpringCloud Feign中针对各个服务客户端进行个性化配置的方式与在SpringCloud Ribbon的配置方式是一样的，都采用&lt;Client&gt;.ribbon.key=value的格式进行设置。服务名就是@FeignClients指定的name或value。</div></pre></td></tr></table></figure><p>Ribbon重要的配置参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#建立连接的超时时间</div><div class="line">HELLO-SERVICE.ribbon.ConnectTimeout = 500</div><div class="line">#连接超时时间</div><div class="line">HELLO-SERVICE.ribbon.ReadTimeout = 2000</div><div class="line">#所有操作都重试</div><div class="line">HELLO-SERVICE.ribbon.OkToRetryOnAllOperations = true</div><div class="line">#重试发生，更换节点数最大值</div><div class="line">HELLO-SERVICE.ribbon.MaxAutoRetriesNextServer = 2</div><div class="line">#单个节点重试最大值</div><div class="line">HELLO-SERVICE.ribbon.MaxAutoRetries = 1</div></pre></td></tr></table></figure><p>重试机制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">SpringCloud Feign默认实现了重试机制，重试时间计算方式。Feign重试机制默认关闭，以免和ribbon冲突。</div><div class="line">ribbon:</div><div class="line">ReadTimeout: 3000</div><div class="line">ConnectTimeout: 3000</div><div class="line">MaxAutoRetries: 1 #同一台实例最大重试次数,不包括首次调用</div><div class="line">MaxAutoRetriesNextServer: 1 #重试负载均衡其他的实例最大重试次数,不包括首次调用</div><div class="line">OkToRetryOnAllOperations: false  #是否所有操作都重试 </div><div class="line">根据上面的参数计算重试的次数：MaxAutoRetries+MaxAutoRetriesNextServer+(MaxAutoRetries *MaxAutoRetriesNextServer) 即重试3次则一共产生4次调用。如果在重试期间，时间超过了hystrix的超时时间，便会立即执行熔断，fallback。所以要根据上面配置的参数计算hystrix的超时时间，使得在重试期间不能达到hystrix的超时时间，不然重试机制就会没有意义</div><div class="line">hystrix超时时间的计算： </div><div class="line">(1 + MaxAutoRetries + MaxAutoRetriesNextServer) * ReadTimeout 即按照以上的配置 hystrix的超时时间应该配置为 （1+1+1）*3=9秒</div><div class="line">当ribbon超时后且hystrix没有超时，便会采取重试机制。当OkToRetryOnAllOperations设置为false时，只会对get请求进行重试。如果设置为true，便会对所有的请求进行重试，如果是put或post等写操作，如果服务器接口没做幂等性，会产生不好的结果，所以OkToRetryOnAllOperations慎用。如果不配置ribbon的重试次数，默认会重试一次</div><div class="line">注意：</div><div class="line">默认情况下,GET方式请求无论是连接异常还是读取异常,都会进行重试</div><div class="line">非GET方式请求,只有连接异常时,才会进行重试</div></pre></td></tr></table></figure><h3 id="Ribbon超时与Hystrix超时区别"><a href="#Ribbon超时与Hystrix超时区别" class="headerlink" title="Ribbon超时与Hystrix超时区别"></a>Ribbon超时与Hystrix超时区别</h3><p>让Hystrix超时时间大于Ribbon超时时间,否则Hystrix命令直接熔断，重试机制就没意义了</p><h3 id="服务降级，服务容错，断路器三者关系"><a href="#服务降级，服务容错，断路器三者关系" class="headerlink" title="服务降级，服务容错，断路器三者关系"></a>服务降级，服务容错，断路器三者关系</h3><p>服务降级是服务容错的重要功能，服务降级的实现只需为Feign客户端定义接口编写一个具体的接口实现类，每个重写方法的实现逻辑都可以用来定义相应的服务降级逻辑。每一个服务接口的断路器实际就是实现类中重写函数的实现。</p><h3 id="Zuul网关服务主要解决的问题"><a href="#Zuul网关服务主要解决的问题" class="headerlink" title="Zuul网关服务主要解决的问题"></a>Zuul网关服务主要解决的问题</h3><p>从运维人员角度看：</p><p>客户端请求通过F5,Nginx等设施的路由和负载均衡分配后，被转发到不同的服务实例上。当有实例增减或是IP地址变动时，运维人员需要手工维护路由规则和服务实例。当系统复杂时，就需要一套机制有效降低维护路由规则与服务实例列表的难度。    </p><p>从开发人员角度看：</p><p>为了保证对外服务的安全性，所有对外的微服务接口往往都会有一定的权限校验机制。为了防止客户端在发起请求时被篡改等安全方面的考虑，需要签名校验，对校验的修改，扩展，优化，就需要解决各个前置校验的冗余问题。</p><p>API网关是整个微服务架构系统的入口，所有的外部客户端访问都需要经过他来进行调度和过滤。它处理要实现请求路由，负载均衡，校验过滤等功能之外，还需要更多的能力，比如与服务治理框架结合，请求转发时的熔断机制，服务的聚合等一系列高级功能。</p><h3 id="Zuul如何维护路由规则和服务实例列表，如何解决签名校验，登录校验在微服务架构中的冗余问题"><a href="#Zuul如何维护路由规则和服务实例列表，如何解决签名校验，登录校验在微服务架构中的冗余问题" class="headerlink" title="Zuul如何维护路由规则和服务实例列表，如何解决签名校验，登录校验在微服务架构中的冗余问题"></a>Zuul如何维护路由规则和服务实例列表，如何解决签名校验，登录校验在微服务架构中的冗余问题</h3><p>服务实例列表的维护：Zuul与服务治理框架整合，将自身注册为服务治理下的应用，从服务中心获取所有其他微服务的实例信息。</p><p>路由规则的维护：Zuul默认会通过以服务名的作为contextPath的方式来创建路由映射。</p><p>校验逻辑在本质上与微服务应用自身的业务没有多大关系，完全可以把它们独立成一个单独的服务存在，只是这个微服务不是给各个微服务调用，而是在API网关服务上进行统一调用来对微服务接口做前置过滤，以实现对微服务接口的拦截和过滤。Zuul提供了一套过滤器机制，通过创建各种过滤器，然后指定哪些规则的请求需要执行校验逻辑，只有通过的校验才会被路由到具体的微服务接口，不然返回错误信息。</p><h3 id="Zuul的请求过滤功能-安全校验，权限控制"><a href="#Zuul的请求过滤功能-安全校验，权限控制" class="headerlink" title="Zuul的请求过滤功能(安全校验，权限控制)"></a>Zuul的请求过滤功能(安全校验，权限控制)</h3><p>通过继承ZuulFilter抽象类并重写了下面4个方法，来实现自定义的过滤器</p><p>filterType:过滤器类型，决定过滤器在请求的哪个生命周期中执行，具体如下：</p><p>pre:可以在请求被路由之前调用</p><p>routing:在路由请求时被调用</p><p>post:在routing和error过滤器之后被调用</p><p>error:处理请求时发生错误时被调用</p><p>filterOrder:过滤器执行顺序，当请求存在多个过滤器时，需要根据该方法返回值依次执行，数值越小优先级越高</p><p>shouldFilter:判断该过滤器是否需要被执行。实际中我们利用这个函数来制定过滤器的有效范围</p><p>run:过滤器具体的执行逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</div><div class="line">        RequestContext ctx = RequestContext.getCurrentContext();</div><div class="line">        HttpServletRequest request = ctx.getRequest();</div><div class="line">        logger.info(<span class="string">"send &#123;&#125; request to &#123;&#125;"</span> + request.getMethod(), request.getRequestURL().toString());</div><div class="line">        Object accessToken = request.getParameter(<span class="string">"accessToken"</span>);</div><div class="line">        <span class="keyword">if</span> (accessToken == <span class="keyword">null</span>) &#123;</div><div class="line">            logger.warn(<span class="string">"access token is empty!"</span>);</div><div class="line">            ctx.setSendZuulResponse(<span class="keyword">false</span>);<span class="comment">//不对请求进行路由</span></div><div class="line">            ctx.setResponseStatusCode(<span class="number">401</span>);<span class="comment">//设置错误码</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//请求返回值为null</span></div><div class="line">        &#125;</div><div class="line">        logger.info(<span class="string">"access token ok"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//实际返回值路由成功后的返回值</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="Zuul两个核心功能"><a href="#Zuul两个核心功能" class="headerlink" title="Zuul两个核心功能"></a>Zuul两个核心功能</h3><p>1.作为系统的统一入口，屏蔽了系统内部各个微服务的细节</p><p>2.可以与服务治理框架结合，实现自动化的服务实例以及负载均衡的路由转发功能</p><p>3.可以实现接口的权限校验与微服务业务逻辑的解耦。</p><p>4.通过网关中的过滤器，在各个生命周期中去校验请求的内容，将原本在对外服务层做的校验前移，保证了微服务的无状态性，同时降低了微服务的测试难度，让服务本身更专注业务逻辑的处理。</p><h3 id="Zuul完成路由工作原理"><a href="#Zuul完成路由工作原理" class="headerlink" title="Zuul完成路由工作原理"></a>Zuul完成路由工作原理</h3><p>Zuul与服务治理框架整合，在其帮助下，API网关服务本身就已经维护了系统中所有serviceId与实例地址的映射关系。当有外部请求到达API网关的时候，根据请求的url路径找到最佳匹配的path规则，API网关就可以知道要将该请求路由到哪个具体的serviceId上去。由于在API网关中已经知道serviceId对应服务实例的地址清单，那么只需要通过Ribbon的负载均衡策略，直接在这些实例清单中选择一个具体的实例进行转发就能完成路由工作。</p><h3 id="Zuul对Cookie和头信息的处理"><a href="#Zuul对Cookie和头信息的处理" class="headerlink" title="Zuul对Cookie和头信息的处理"></a>Zuul对Cookie和头信息的处理</h3><p>默认情况下，SpringCloud Zuul在请求路由时，会过滤掉HTTP请求头信息的一些敏感信息，防止他们被传递到下游的外部服务器。默认的敏感头信息通过zuul.sensitiveHeaders参数定义，包括Cookie，Set-Cookie，Authorization三个属性。Cookie在Zuul网关中默认是不会传递的，引发问题：Web应用无法实现登录和鉴权。</p><p>全局设置：</p><p>zuul.sensitive-headers=            #是所有经过zuul的敏感头信息有效</p><p>指定路由设置：</p><p>zuul.routes.<routename>.sensitive-headers=                #对指定路由开启自定义敏感头</routename></p><p>zuul.routes.<routename>.custom-sensitive-headers=true    #将指定路由的敏感头设置为空</routename></p><h3 id="Zuul异常处理"><a href="#Zuul异常处理" class="headerlink" title="Zuul异常处理"></a>Zuul异常处理</h3><p>SpringBoot全局异常处理</p><p>实现SendErrorFilter过滤器的处理异常响应结果</p><h3 id="Zuul动态加载"><a href="#Zuul动态加载" class="headerlink" title="Zuul动态加载"></a>Zuul动态加载</h3><p>微服务架构中，由于API网关服务担负着外部访问统一入口的重任，与其他应用不同，任务关闭应用和重启应用的操作都会使系统对外服务停止，对于高可用的系统来说绝对不能被允许。所以网关服务必须具备动态更新内部逻辑的能力，比如动态修改路由规则，动态添加/删除过滤器等。</p><p>动态路由：对于路由规则的控制几乎都可以在配置文件中完成，所以很自然的将它与SpringCloud Config动态刷新机制联系到一起。只需将API网关服务的配置文件通过Config连接的Git仓库存储和管理，就能轻松实现动态刷新路由规则的功能。</p><p>/routes     接口来获取当前网关上的路由规则</p><p>/refresh 接口发送POST请求来刷新配置信息</p><p>动态过滤器；</p><h3 id="Config-分布式配置中心"><a href="#Config-分布式配置中心" class="headerlink" title="Config:分布式配置中心"></a>Config:分布式配置中心</h3><h3 id="Config介绍"><a href="#Config介绍" class="headerlink" title="Config介绍"></a>Config介绍</h3><p>为分布式系统中的微服务应用提供集中化的外部配置支持，分为服务端与客户端。其中服务端也称为分布式配置中心，用来连接配置仓库并未客户端提供获取配置信心，加密/解密信息等访问接口；而客户端则是微服务架构中的各个微服务应用或基础设施，通过指定的配置中心来管理应用资源与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。</p><h3 id="客户端应用从配置管理中获取配置信息的执行流程"><a href="#客户端应用从配置管理中获取配置信息的执行流程" class="headerlink" title="客户端应用从配置管理中获取配置信息的执行流程"></a>客户端应用从配置管理中获取配置信息的执行流程</h3><p>1.客户端应用启动时，根据bootstrap.properties中配置的应用名{application},环境名{profile},分支名{label}，向Config Server请求获取配置信息</p><p>2.Config Server根据自己维护的Git仓库信息和客户端传递过来的配置定位信息去查找配置信息</p><p>3.通过git clone命令将找到的配置信息下载到Config Server的文件系统中</p><p>4.Config Server创建Spring的ApplicationContext实例，并从Git本地仓库中加载配置文件，最后将这些配置内容读取出来返回给客户端应用</p><p>5.客户端应用在获得外部配置文件后加载到客户端的ApplicationContext实例中，该配置内容的优先级大于客户端jar包内部的配置内容，所以jar包中重复的内容将不再被加载</p><h3 id="Git配置仓库，SVN配置仓库，本地仓库，高可用配置"><a href="#Git配置仓库，SVN配置仓库，本地仓库，高可用配置" class="headerlink" title="Git配置仓库，SVN配置仓库，本地仓库，高可用配置"></a>Git配置仓库，SVN配置仓库，本地仓库，高可用配置</h3><p>高可用配置两种方式：传统模式(不需要注册中心),服务模式(将Config Server作为一个普通的微服务应用，微服务应用通过配置中心的服务名获取配置信息)</p><h4 id="健康监测属性覆盖"><a href="#健康监测属性覆盖" class="headerlink" title="健康监测属性覆盖"></a>健康监测属性覆盖</h4><p>Config Server可以使用属性覆盖Git配置的属性信息，可以为SpringCloud应用配置一些共同属性或默认属性</p><h3 id="安全保护，加密解密，高可用配置"><a href="#安全保护，加密解密，高可用配置" class="headerlink" title="安全保护，加密解密，高可用配置"></a>安全保护，加密解密，高可用配置</h3><p>加密解密：对称加密与非对称加密</p><p>配置文件中数据库的用户名与密码等敏感信息不应该对外暴露，就可以使用加密方式，对密码用户名进行加密。当微服务客户端加载配置时，配置中心会自动为带有{cipher}前缀的值进行解密。</p><p>高可用配置-服务端：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="attr">        server:</span></div><div class="line"><span class="attr">  port:</span> <span class="number">13001</span></div><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  application:</span></div><div class="line"><span class="attr">name:</span> <span class="string">config-server</span></div><div class="line"><span class="attr">  cloud:</span></div><div class="line"><span class="attr">config:</span></div><div class="line">  <span class="attr">server:</span></div><div class="line"><span class="attr">git:</span></div><div class="line">  <span class="attr">uri:</span> <span class="attr">https://gitee.com/SunYanGang/cloud-config-server.git</span></div><div class="line">  <span class="attr">search-paths:</span> <span class="string">/SunYanGang/cloud-config-server</span></div><div class="line">  <span class="attr">password:</span> <span class="string">mayun_6688</span></div><div class="line">  <span class="attr">username:</span> <span class="number">18811748164</span></div></pre></td></tr></table></figure><p>高可用配置-客户端：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="attr">   eureka:</span></div><div class="line"><span class="attr">  client:</span></div><div class="line"><span class="attr">fetch-registry:</span> <span class="literal">true</span></div><div class="line"><span class="attr">register-with-eureka:</span> <span class="literal">true</span></div><div class="line"><span class="attr">service-url:</span></div><div class="line">  <span class="attr">defaultZone:</span> <span class="attr">http://eurekaserver01:8080/eureka,http://eurekaserver02:8081/eureka,http://eurekaserver03:8082/eureka</span></div><div class="line"><span class="attr">server:</span></div><div class="line"><span class="attr">  port:</span> <span class="number">12001</span></div><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  application:</span></div><div class="line"><span class="attr">name:</span> <span class="string">api-gateway</span>               <span class="comment">#指定应用名称</span></div><div class="line"><span class="attr">  cloud:</span></div><div class="line"><span class="attr">config:</span></div><div class="line">  <span class="attr">profile:</span> <span class="string">dev</span>                  <span class="comment">#指定配置文件的环境</span></div><div class="line">  <span class="attr">label:</span> <span class="string">master</span>                 <span class="comment">#指定git</span></div><div class="line">  <span class="attr">discovery:</span></div><div class="line"><span class="attr">enabled:</span> <span class="literal">true</span>               <span class="comment">#开启通过服务来访问Config Server的功能</span></div><div class="line"><span class="attr">service-id:</span> <span class="string">config-server</span>   <span class="comment">#指定服务中心注册的服务名</span></div><div class="line"><span class="attr">management:</span></div><div class="line"><span class="attr">  security:</span></div><div class="line"><span class="attr">enabled:</span> <span class="literal">false</span></div><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  client:</span></div><div class="line"><span class="attr">service-url:</span></div><div class="line">  <span class="attr">defaultZone:</span> <span class="attr">http://eurekaserver01:8080/eureka,http://eurekaserver02:8081/eureka,http://eurekaserver03:8082/eureka</span></div><div class="line"><span class="attr">fetch-registry:</span> <span class="literal">true</span></div><div class="line"><span class="attr">register-with-eureka:</span> <span class="literal">true</span></div></pre></td></tr></table></figure><h3 id="失败快速响应与重试"><a href="#失败快速响应与重试" class="headerlink" title="失败快速响应与重试"></a>失败快速响应与重试</h3><p>SpringCloud Config的客户端会预先加载很多其他信息，然后再开始连接Config Server进行属性的注入。连接Config Server发费较长的时间，所以我们希望快速知道当前应用是否能顺利地从Config Server获取到配置信息。还有重试机制，避免一些间歇性问题引起的失败导致客户端应用无法启动的情况。</p><h3 id="获取远程配置"><a href="#获取远程配置" class="headerlink" title="获取远程配置"></a>获取远程配置</h3><p>application:应用名</p><p>profile:应用环境</p><p>label:分支名</p><p>通过客户端配置方式加载的内容如下：</p><p>spring.application.name:对应配置文件中的{application}内容</p><p>spring.application.name:对应配置文件中的{application}内容</p><p>spring.cloud.config.label:对应分支内容，如不配置，默认为master</p><h3 id="动态刷新配置"><a href="#动态刷新配置" class="headerlink" title="动态刷新配置"></a>动态刷新配置</h3><p>配置中心的客户端pom.xml文件新增 spring-boot-starter-actuator监控模块，其中包含了/refresh端点的实现，该端点将用于实现客户端应用配置信息的重新获取与刷新。</p><p>POST请求向客户端发送 http:<em>//配置中心客户端：端口/refresh</em></p><h3 id="consul-eureka-ribbon-hystrix-feign-zuul-config-bus-rabbitmq-理解与问题"><a href="#consul-eureka-ribbon-hystrix-feign-zuul-config-bus-rabbitmq-理解与问题" class="headerlink" title="consul,eureka,ribbon,hystrix,feign,zuul,config,bus(rabbitmq)理解与问题"></a>consul,eureka,ribbon,hystrix,feign,zuul,config,bus(rabbitmq)理解与问题</h3><h4 id="Eureka理论："><a href="#Eureka理论：" class="headerlink" title="Eureka理论："></a>Eureka理论：</h4><p>1.服务治理：为了解决微服务架构中的服务实例维护问题(传统的一个服务调用另一个服务，需要静态配置另一个服务的接口路径，一旦IP，端口等变化，需要手工修改)，产生了大量的服务治理框架和产品。这些框架和产品的实现都是围绕着服务注册和服务发现机制来完成对微服务应用实例的自动化管理。</p><p>服务注册：服务治理框架通常会构建一个注册中心，每个注册单元向注册中心登记自己提供的服务，将主机与端口号，版本号，协议等一些附加信息告知注册中心，注册中心按照服务名组织服务清单。当服务都注册到注册中心并启动后，注册中心还需要以心跳的方式检测清单中的服务是否可用，若不可用则从服务清单中剔除，达到排除故障服务的效果。</p><p>服务发现：由于在服务治理框架下运作，服务之间的调用不再通过具体的实例地址来实现，而是通过向服务名发起请求调用实现。所以服务调用方在调用其他服务的时候，并不知道具体的服务实例位置。因此调用方需要向注册中心咨询服务，并获取所有的服务实例清单，以实现对具体的服务实例的访问。调用其他服务的时候，可能对应多个服务实例，服务调用方从这多个实例中以某种轮询策略取出一个位置来进行服务调用，就是客户端负载均衡。实际框架为了性能等因素，不会采用每次想服务注册中心获取服务的方式，并且不同的应用场景在缓存和服务剔除等机制上也会有一些不同的实现策略。</p><p>2.Eureka:</p><p>Eureka服务端，也称为服务注册中心。支持高可用配置，提供良好的服务实例可用性，可以应对多种不同的故障场景。如果Eureka以集群模式部署，当集群中有分片出现故障时，那么Eureka就转入自我保护模式。它允许分片故障期间继续提供服务的发现与注册，当故障分片恢复运行时，集群中的分片会把他们的状态再次同步回来。</p><p>Eureka客户端，主要处理服务注册和发现的。(重点：服务续约，刷新服务状态)客户端服务通过注解和参数配置的方式，嵌入在客户端应用程序的代码中，在应用程序运行时，Eureka客户端向注册中心注册自身提供的服务并周期性地发送心跳来更新它的服务租约。同时，它也能从服务端查询当前注册的服务信息并把它们缓存到本地并周期性地刷新服务状态。</p><p>3.服务治理基础架构的三个核心要素：</p><p>服务注册中心：提供服务注册和发现的功能</p><p>服务提供者：提供服务的应用，自身注册到注册中心，以便其他服务发现和调用</p><p>服务消费者：从注册中心获取服务，从而使消费者可以知道去何处调用所需要的服务</p><p>4.服务提供者，服务消费者，服务注册中心各自重要的通信行为</p><p>注意服务续约，服务剔除，自我保护，服务获取，服务同步，服务续约和服务剔除有关系，服务剔除和服务注册中心自我保护有关系获取服务缓存到本地有个更新时间间隔。</p><p>4.1 服务提供者：</p><p>服务注册：服务提供者在启动服务时发送Rest请求将自己注册到服务注册中心，同时带上自身的一些元数据信息。注册中心接到Rest请求后，将元数据信息存储到双层Map中，其中第一层的key是服务名，第二层的key是具体服务的实例名。</p><p>服务同步：指”高可用的注册中心”集群中多个注册中心之间的同步，当服务提供者发送注册请求到一个注册中心时，该注册中心会将请求转发给集群中相连的其他注册中心，从而实现注册中心之间服务的同步。</p><p>服务续约：服务提供者会维护一个心跳用来持续告诉注册中心自己还活着，防止服务注册中心将该服务实例从服务列表中剔除。有两个比较重要的属性：续租任务的调用时间间隔，默认30s（客户端定义）;服务失效的时间间隔，默认90s（服务端定义）</p><p>4.2 服务消费者：</p><p>获取服务：启动服务消费者的时候，它会发送一个REST请求给服务注册中心，来获取上面注册的服务清单。为了性能考虑，服务注册注册中心会维护一个只读的服务清单来返回给客户端，同时客户端缓存清单会每隔30s更新一次。    </p><p>服务调用：服务消费者在获取到服务清单后，通过服务名可以获取具体提供服务的实例名和该实例的元数据信息。在Ribbon中会采用默认的轮询方式进行调用，从而实现客户端的负载均衡。</p><p>服务下线：关闭和重启服务实例，包括正常关闭和非正常关闭。</p><p>4.3 服务注册中心：</p><p>失效剔除：服务注册中心启动时创建定时任务，每隔一段时间（默认60s）将清单中超时(默认90s)没有续约的服务剔除出去。对于服务正常下线，会告诉注册中心，而服务由于内存溢出，网络故障等原因使得服务不能正常工作，注册中心并不会收到“服务下线”的请求。</p><p>自我保护：服务注册中心在运行期间统计心跳失败比例，若是网络延迟不稳定导致，则会将当前实例注册信息保护起来，不让服务实例过期而被服务剔除。 但会引发问题：消费者拿到已不存在发服务实例报错，因此客户端必须要有容错机制，比如请求重试，断路器等机制。</p><p>4.4 Eureka Client负责下面的任务：</p><p>向Eureka Server注册服务实例</p><p>向Eureka Server服务租约</p><p>当服务关闭时向Eureka Server取消租约</p><p>查询Eureka Server中的服务实例列表</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Spring-Boot-与-Spring-的区别&quot;&gt;&lt;a href=&quot;#Spring-Boot-与-Spring-的区别&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot 与 Spring 的区别&quot;&gt;&lt;/a&gt;Spring Boot 与 Spring 的区别&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Spring Boot可以建立独立的Spring应用程序；&lt;/li&gt;
&lt;li&gt;内嵌了如Tomcat，Jetty和Undertow这样的容器，也就是说可以直接跑起来，用不着再做部署工作了。&lt;/li&gt;
&lt;li&gt;无需再像Spring那样搞一堆繁琐的xml文件的配置；&lt;/li&gt;
&lt;li&gt;可以自动配置Spring；&lt;/li&gt;
&lt;li&gt;提供了一些现有的功能，如度量工具，表单数据验证以及一些外部配置这样的一些第三方功能；&lt;/li&gt;
&lt;li&gt;提供的POM可以简化Maven的配置；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="基础面试题" scheme="http://swenfang.github.io/categories/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="基础面试题" scheme="http://swenfang.github.io/tags/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Redis 面试题</title>
    <link href="http://swenfang.github.io/2019/05/12/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/Redis%20%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://swenfang.github.io/2019/05/12/面试总结/Redis 面试题/</id>
    <published>2019-05-12T13:31:31.310Z</published>
    <updated>2019-05-12T15:11:03.339Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、什么是Redis"><a href="#1、什么是Redis" class="headerlink" title="1、什么是Redis?"></a><strong>1、什么是Redis?</strong></h2><p>答：Redis全称为：Remote Dictionary Server（远程数据服务），是一个基于内存的高性能key-value数据库。</p><a id="more"></a><h2 id="2、Redis的数据类型？"><a href="#2、Redis的数据类型？" class="headerlink" title="2、Redis的数据类型？"></a><strong>2、Redis的数据类型？</strong></h2><p>答：Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</p><p>我们实际项目中比较常用的是string，hash如果你是Redis中高级用户，还需要加上下面几种数据结构HyperLogLog、Geo、Pub/Sub。</p><p>如果你说还玩过Redis Module，像BloomFilter，RedisSearch，Redis-ML，面试官得眼睛就开始发亮了。</p><h2 id="3、使用Redis有哪些好处？"><a href="#3、使用Redis有哪些好处？" class="headerlink" title="3、使用Redis有哪些好处？"></a><strong>3、使用Redis有哪些好处？</strong></h2><p>(1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</p><p>(2) 支持丰富数据类型，支持string，list，set，Zset，hash等</p><p>(3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</p><p>(4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</p><h2 id="4、Redis相比Memcached有哪些优势？"><a href="#4、Redis相比Memcached有哪些优势？" class="headerlink" title="4、Redis相比Memcached有哪些优势？"></a><strong>4、Redis相比Memcached有哪些优势？</strong></h2><p>(1) Memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</p><p>(2) Redis的速度比Memcached快很多</p><p>(3) Redis可以持久化其数据</p><h2 id="5、Memcache与Redis的区别都有哪些？"><a href="#5、Memcache与Redis的区别都有哪些？" class="headerlink" title="5、Memcache与Redis的区别都有哪些？"></a><strong>5、Memcache与Redis的区别都有哪些？</strong></h2><p>(1)、存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis有部份存在硬盘上，这样能保证数据的持久性。</p><p>(2)、数据支持类型 Memcache对数据类型支持相对简单。 Redis有复杂的数据类型。</p><p>(3)、使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。 Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</p><h2 id="6、Redis是单进程单线程的？"><a href="#6、Redis是单进程单线程的？" class="headerlink" title="6、Redis是单进程单线程的？"></a><strong>6、Redis是单进程单线程的？</strong></h2><p>答：Redis是单进程单线程的，redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。</p><h2 id="7、一个字符串类型的值能存储最大容量是多少？"><a href="#7、一个字符串类型的值能存储最大容量是多少？" class="headerlink" title="7、一个字符串类型的值能存储最大容量是多少？"></a><strong>7、一个字符串类型的值能存储最大容量是多少？</strong></h2><p>答：512M</p><h2 id="8、Redis的持久化机制是什么？各自的优缺点？"><a href="#8、Redis的持久化机制是什么？各自的优缺点？" class="headerlink" title="8、Redis的持久化机制是什么？各自的优缺点？"></a><strong>8、Redis的持久化机制是什么？各自的优缺点？</strong></h2><p>Redis提供两种持久化机制RDB和AOF机制:</p><p>1）RDB(Redis DataBase)持久化方式： 是指用数据集快照的方式(半持久化模式)记录redis数据库的所有键值对,在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复。</p><p>优点：</p><p>1.只有一个文件dump.rdb，方便持久化。</p><p>2.容灾性好，一个文件可以保存到安全的磁盘。</p><p>3.性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以是IO最大化。(使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了redis的高性能) 4.相对于数据集大时，比AOF的启动效率更高。</p><p>缺点：</p><p>1.数据安全性低。(RDB是间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)</p><p>2）AOF(Append-only file)持久化方式： 是指所有的命令行记录以redis命令请求协议的格式(完全持久化存储)保存为aof文件。</p><p>优点：</p><p>1.数据安全，aof持久化可以配置appendfsync属性，有always，每进行一次命令操作就记录到aof文件中一次。</p><p>2.通过append模式写文件，即使中途服务器宕机，可以通过redis-check-aof工具解决数据一致性问题。</p><p>3.AOF机制的rewrite模式。(AOF文件没被rewrite之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的flushall）)</p><p>缺点：</p><p>1.AOF文件比RDB文件大，且恢复速度慢。</p><p>2.数据集大的时候，比rdb启动效率低。</p><h2 id="9、Redis常见性能问题和解决方案："><a href="#9、Redis常见性能问题和解决方案：" class="headerlink" title="9、Redis常见性能问题和解决方案："></a><strong>9、Redis常见性能问题和解决方案：</strong></h2><p>(1) Master最好不要写内存快照，如果Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务。</p><p>(2) 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次</p><p>(3) 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内</p><p>(4) 尽量避免在压力很大的主库上增加从库</p><p>(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3…这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。</p><h2 id="10、redis过期键的删除策略？"><a href="#10、redis过期键的删除策略？" class="headerlink" title="10、redis过期键的删除策略？"></a><strong>10、redis过期键的删除策略？</strong></h2><p>(1)、定时删除:在设置键的过期时间的同时，创建一个定时器(timer). 让定时器在键的过期时间来临时，立即执行对键的删除操作。</p><p>(2)、惰性删除:放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键;如果没有过期，就返回该键。</p><p>(3)、定期删除:每隔一段时间程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</p><h2 id="11、Redis的回收策略（淘汰策略）"><a href="#11、Redis的回收策略（淘汰策略）" class="headerlink" title="11、Redis的回收策略（淘汰策略）?"></a><strong>11、Redis的回收策略（淘汰策略）?</strong></h2><p>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</p><p>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</p><p>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</p><p>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</p><p>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</p><p>no-enviction（驱逐）：禁止驱逐数据</p><p>注意这里的6种机制，volatile和allkeys规定了是对已设置过期时间的数据集淘汰数据还是从全部数据集淘汰数据，后面的lru、ttl以及random是三种不同的淘汰策略，再加上一种no-enviction永不回收的策略。</p><p>使用策略规则：</p><p>1、如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru</p><p>2、如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random</p><h2 id="12、为什么edis需要把所有数据放到内存中？"><a href="#12、为什么edis需要把所有数据放到内存中？" class="headerlink" title="12、为什么edis需要把所有数据放到内存中？"></a><strong>12、为什么edis需要把所有数据放到内存中？</strong></h2><p>答：Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p><h2 id="13、Redis的同步机制了解么？"><a href="#13、Redis的同步机制了解么？" class="headerlink" title="13、Redis的同步机制了解么？"></a><strong>13、Redis的同步机制了解么？</strong></h2><p>答：Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</p><h2 id="14、Pipeline有什么好处，为什么要用pipeline？"><a href="#14、Pipeline有什么好处，为什么要用pipeline？" class="headerlink" title="14、Pipeline有什么好处，为什么要用pipeline？"></a>14、Pipeline有什么好处，为什么要用pipeline？</h2><p>答：可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。</p><h2 id="15、是否使用过Redis集群，集群的原理是什么？"><a href="#15、是否使用过Redis集群，集群的原理是什么？" class="headerlink" title="15、是否使用过Redis集群，集群的原理是什么？"></a>15、是否使用过Redis集群，集群的原理是什么？</h2><p>(1)、Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。</p><p>(2)、Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</p><h2 id="16、Redis集群方案什么情况下会导致整个集群不可用？"><a href="#16、Redis集群方案什么情况下会导致整个集群不可用？" class="headerlink" title="16、Redis集群方案什么情况下会导致整个集群不可用？"></a>16、Redis集群方案什么情况下会导致整个集群不可用？</h2><p>答：有A，B，C三个节点的集群,在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少5501-11000这个范围的槽而不可用。</p><h2 id="17、Redis支持的Java客户端都有哪些？官方推荐用哪个？"><a href="#17、Redis支持的Java客户端都有哪些？官方推荐用哪个？" class="headerlink" title="17、Redis支持的Java客户端都有哪些？官方推荐用哪个？"></a>17、Redis支持的Java客户端都有哪些？官方推荐用哪个？</h2><p>答：Redisson、Jedis、lettuce等等，官方推荐使用Redisson。</p><h2 id="18、Jedis与Redisson对比有什么优缺点？"><a href="#18、Jedis与Redisson对比有什么优缺点？" class="headerlink" title="18、Jedis与Redisson对比有什么优缺点？"></a>18、Jedis与Redisson对比有什么优缺点？</h2><p>答：Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p><h2 id="19、Redis如何设置密码及验证密码？"><a href="#19、Redis如何设置密码及验证密码？" class="headerlink" title="19、Redis如何设置密码及验证密码？"></a>19、Redis如何设置密码及验证密码？</h2><p>设置密码：config set requirepass 123456</p><p>授权密码：auth 123456</p><h2 id="20、说说Redis哈希槽的概念？"><a href="#20、说说Redis哈希槽的概念？" class="headerlink" title="20、说说Redis哈希槽的概念？"></a>20、说说Redis哈希槽的概念？</h2><p>答：Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。</p><h2 id="21、Redis集群的主从复制模型是怎样的？"><a href="#21、Redis集群的主从复制模型是怎样的？" class="headerlink" title="21、Redis集群的主从复制模型是怎样的？"></a>21、Redis集群的主从复制模型是怎样的？</h2><p>答：为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有N-1个复制品.</p><h2 id="22、Redis集群会有写操作丢失吗？为什么？"><a href="#22、Redis集群会有写操作丢失吗？为什么？" class="headerlink" title="22、Redis集群会有写操作丢失吗？为什么？"></a>22、Redis集群会有写操作丢失吗？为什么？</h2><p>答：Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</p><h2 id="23、Redis集群之间是如何复制的？"><a href="#23、Redis集群之间是如何复制的？" class="headerlink" title="23、Redis集群之间是如何复制的？"></a>23、Redis集群之间是如何复制的？</h2><p>答：异步复制</p><h2 id="24、Redis集群最大节点个数是多少？"><a href="#24、Redis集群最大节点个数是多少？" class="headerlink" title="24、Redis集群最大节点个数是多少？"></a>24、Redis集群最大节点个数是多少？</h2><p>答：16384个。</p><h2 id="25、Redis集群如何选择数据库？"><a href="#25、Redis集群如何选择数据库？" class="headerlink" title="25、Redis集群如何选择数据库？"></a>25、Redis集群如何选择数据库？</h2><p>答：Redis集群目前无法做数据库选择，默认在0数据库。</p><h2 id="26、怎么测试Redis的连通性？"><a href="#26、怎么测试Redis的连通性？" class="headerlink" title="26、怎么测试Redis的连通性？"></a>26、怎么测试Redis的连通性？</h2><p>答：使用ping命令。</p><h2 id="27、怎么理解Redis事务？"><a href="#27、怎么理解Redis事务？" class="headerlink" title="27、怎么理解Redis事务？"></a>27、怎么理解Redis事务？</h2><p>答：</p><p>1）事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p><p>2）事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p><h2 id="28、Redis事务相关的命令有哪几个？"><a href="#28、Redis事务相关的命令有哪几个？" class="headerlink" title="28、Redis事务相关的命令有哪几个？"></a>28、Redis事务相关的命令有哪几个？</h2><p>答：MULTI、EXEC、DISCARD、WATCH</p><h2 id="29、Redis-key的过期时间和永久有效分别怎么设置？"><a href="#29、Redis-key的过期时间和永久有效分别怎么设置？" class="headerlink" title="29、Redis key的过期时间和永久有效分别怎么设置？"></a>29、Redis key的过期时间和永久有效分别怎么设置？</h2><p>答：EXPIRE和PERSIST命令。</p><h2 id="30、Redis如何做内存优化？"><a href="#30、Redis如何做内存优化？" class="headerlink" title="30、Redis如何做内存优化？"></a>30、Redis如何做内存优化？</h2><p>答：尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面.</p><h2 id="31、Redis回收进程如何工作的？"><a href="#31、Redis回收进程如何工作的？" class="headerlink" title="31、Redis回收进程如何工作的？"></a>31、Redis回收进程如何工作的？</h2><p>答：一个客户端运行了新的命令，添加了新的数据。Redi检查内存使用情况，如果大于maxmemory的限制, 则根据设定好的策略进行回收。一个新的命令被执行，等等。所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</p><h2 id="32、都有哪些办法可以降低Redis的内存使用情况呢？"><a href="#32、都有哪些办法可以降低Redis的内存使用情况呢？" class="headerlink" title="32、都有哪些办法可以降低Redis的内存使用情况呢？"></a>32、都有哪些办法可以降低Redis的内存使用情况呢？</h2><p>答：如果你使用的是32位的Redis实例，可以好好利用Hash,list,sorted set,set等集合类型数据，因为通常情况下很多小的Key-Value可以用更紧凑的方式存放到一起。</p><h2 id="33、Redis的内存用完了会发生什么？"><a href="#33、Redis的内存用完了会发生什么？" class="headerlink" title="33、Redis的内存用完了会发生什么？"></a>33、Redis的内存用完了会发生什么？</h2><p>答：如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以将Redis当缓存来使用配置淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。</p><h2 id="34、一个Redis实例最多能存放多少的keys？List、Set、Sorted-Set他们最多能存放多少元素？"><a href="#34、一个Redis实例最多能存放多少的keys？List、Set、Sorted-Set他们最多能存放多少元素？" class="headerlink" title="34、一个Redis实例最多能存放多少的keys？List、Set、Sorted Set他们最多能存放多少元素？"></a>34、一个Redis实例最多能存放多少的keys？List、Set、Sorted Set他们最多能存放多少元素？</h2><p>答：理论上Redis可以处理多达232的keys，并且在实际中进行了测试，每个实例至少存放了2亿5千万的keys。我们正在测试一些较大的值。任何list、set、和sorted set都可以放232个元素。换句话说，Redis的存储极限是系统中的可用内存值。</p><h2 id="35、MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？"><a href="#35、MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？" class="headerlink" title="35、MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？"></a>35、MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？</h2><p>答：Redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</p><p>相关知识：Redis提供6种数据淘汰策略：</p><p>voltile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</p><p>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</p><p>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</p><p>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</p><p>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</p><p>no-enviction（驱逐）：禁止驱逐数据</p><h2 id="36、Redis最适合的场景？"><a href="#36、Redis最适合的场景？" class="headerlink" title="36、Redis最适合的场景？"></a>36、Redis最适合的场景？</h2><p>（1）、会话缓存（Session Cache）</p><p>最常用的一种使用Redis的情景是会话缓存（session cache）。用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？ 幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。</p><p>（2）、全页缓存（FPC）</p><p>除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。 再次以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。 此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p><p>（3）、队列</p><p>Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。 如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看。</p><p>（4），排行榜/计数器</p><p>Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可： 当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行： ZRANGE user_scores 0 10 WITHSCORES Agora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到。</p><p>（5）、发布/订阅</p><p>最后（但肯定不是最不重要的）是Redis的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统！</p><h2 id="37、假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#37、假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="37、假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>37、假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h2><p>答：使用keys指令可以扫出指定模式的key列表。</p><p>对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？</p><p>这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p><h2 id="38、如果有大量的key需要设置同一时间过期，一般需要注意什么？"><a href="#38、如果有大量的key需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="38、如果有大量的key需要设置同一时间过期，一般需要注意什么？"></a>38、如果有大量的key需要设置同一时间过期，一般需要注意什么？</h2><p>答：如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。</p><h2 id="39、使用过Redis做异步队列么，你是怎么用的？"><a href="#39、使用过Redis做异步队列么，你是怎么用的？" class="headerlink" title="39、使用过Redis做异步队列么，你是怎么用的？"></a>39、使用过Redis做异步队列么，你是怎么用的？</h2><p>答：一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。</p><p>如果对方追问可不可以不用sleep呢？</p><p>list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。如果对方追问能不能生产一次消费多次呢？使用pub/sub主题订阅者模式，可以实现1:N的消息队列。</p><p>如果对方追问pub/sub有什么缺点？</p><p>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如RabbitMQ等。</p><p>如果对方追问redis如何实现延时队列？</p><p>我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。到这里，面试官暗地里已经对你竖起了大拇指。但是他不知道的是此刻你却竖起了中指，在椅子背后。</p><h2 id="40、使用过Redis分布式锁么，它是什么回事？"><a href="#40、使用过Redis分布式锁么，它是什么回事？" class="headerlink" title="40、使用过Redis分布式锁么，它是什么回事？"></a>40、使用过Redis分布式锁么，它是什么回事？</h2><p>先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。</p><p>这时候对方会告诉你说你回答得不错，然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？</p><p>这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，然后回答：我记得set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！对方这时会显露笑容，心里开始默念：摁，这小子还不错。</p><h2 id="41、memcached-和-redis-使用场景及优缺点对比"><a href="#41、memcached-和-redis-使用场景及优缺点对比" class="headerlink" title="41、memcached 和 redis 使用场景及优缺点对比"></a>41、memcached 和 redis 使用场景及优缺点对比</h2><p><strong>简述</strong></p><p>memcached 和 redis 都很类似：都是内存型数据库，数据保存在内存中，通过tcp直接存取，优势是速度快，并发高，缺点是数据类型有限，查询功能不强，一般用作缓存。</p><p>那么题主说 memcached 的事情 redis 都可以做，那么为什么 memcached 还有人用？那是因为它们两者并不是完全可以相互替代的，它们也有各自的长短优缺点</p><p><strong>Memcached的优点：</strong></p><p>Memcached可以利用多核优势，单实例吞吐量极高，可以达到几十万QPS（取决于key、value的字节大小以及服务器硬件性能，日常环境中QPS高峰大约在4-6w左右）。</p><p>适用于最大程度扛量，有效为服务器减压。</p><p>支持直接配置为session handle。</p><p>配置维护的坑比较少。</p><p><strong>Memcached的局限性：</strong></p><p>数据结构很简单单一，只支持简单的key/value数据结构，不像Redis可以支持丰富的数据类型。</p><p>无法进行持久化，数据不能备份，只能用于缓存使用，且重启后数据全部丢失。</p><p>无法进行数据同步，不能将MC中的数据迁移到其他MC实例中。</p><p>Memcached内存分配采用Slab</p><p>Allocation机制管理内存，value大小分布差异较大时会造成内存利用率降低，并引发低利用率时依然出现踢出等问题。需要用户注重value设计。</p><p>memcached服务端原生不支持水平扩展，必须在客户端编写缓存分布策略来实现分布式缓存，并且由于无法进行数据同步，因此生产环境中出现单机故障时可能会影响部分业务运行。</p><p><strong>Redis的优点：</strong></p><p>支持多种数据结构，比如 string（字符串）、</p><p>list(双向链表)、dict(hash表)、set(集合）、zset(排序set)、hyperloglog（基数估算）等等。</p><p>支持持久化操作，可以进行aof及rdb数据持久化到磁盘，从而进行数据备份或数据恢复等操作，较好的防止数据丢失的手段。</p><p>支持通过Replication进行数据复制，通过master-slave机制，可以实时进行数据的同步复制，支持多级复制和增量复制，master-slave机制是Redis进行HA的重要手段。</p><p>单线程请求，所有命令串行执行，并发情况下不需要考虑数据一致性问题。</p><p>支持pub/sub消息订阅机制，可以用来进行消息订阅与通知。</p><p>支持简单的事务需求，但业界使用场景很少，并不成熟。</p><p><strong>Redis的局限性：</strong></p><p>Redis只能使用单线程，性能受限于CPU性能，故单实例CPU最高才可能达到5-6wQPS每秒（取决于数据结构，数据大小以及服务器硬件性能，日常环境中QPS高峰大约在1-2w左右）。</p><p>支持简单的事务需求，但业界使用场景很少，并不成熟，既是优点也是缺点。</p><p>Redis在string类型上会消耗较多内存，可以使用dict（hash表）压缩存储以降低内存耗用。</p><p><strong>总结</strong></p><p>在我看来，Redis在很多方面具备数据库的特征，或者说就是一个数据库系统，而Memcached只是简单的K/V缓存。</p><p>而且到底是用 redis 还是 memcached 这个还是看需求，因为单纯是做缓存的话，memcached已经足够应付绝大部分的需求，redis 的出现只是提供了一个更加好的选择，但是不代表redis就能完全替代 memcached ，还是那句话，看你的需求是怎么样的。</p><p>按照技术的新旧来讲，redis 比 memcached 还更加新，但是成熟醒来说，memcached 应该更加好，再说现在潮流也有开始转投 mongodb了，因为redis 的数据库特征，mongodb更胜一筹。</p><p>很多公司的缓存策略中使用memcached的还是占大多数的，再者是redis，最后才是mongodb，发现没有，最新的技术在公司团队的应用还是需要时间的，旧的技术策略还是很多公司团队在用，因为技术成型而且稳定性要好，这也是memcached比redis要被提及的更多的原因。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、什么是Redis&quot;&gt;&lt;a href=&quot;#1、什么是Redis&quot; class=&quot;headerlink&quot; title=&quot;1、什么是Redis?&quot;&gt;&lt;/a&gt;&lt;strong&gt;1、什么是Redis?&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;答：Redis全称为：Remote Dictionary Server（远程数据服务），是一个基于内存的高性能key-value数据库。&lt;/p&gt;
    
    </summary>
    
      <category term="基础面试题" scheme="http://swenfang.github.io/categories/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="基础面试题" scheme="http://swenfang.github.io/tags/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JVM 面试题</title>
    <link href="http://swenfang.github.io/2019/05/12/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/JVM%20%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://swenfang.github.io/2019/05/12/面试总结/JVM 面试题/</id>
    <published>2019-05-12T13:30:02.699Z</published>
    <updated>2019-05-12T15:10:26.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM-内存结构"><a href="#JVM-内存结构" class="headerlink" title="JVM 内存结构"></a>JVM 内存结构</h2><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190512092851-297873.jpg" alt=""></p><a id="more"></a><blockquote><p>主要由 Java 堆，JVM栈，方法区，本地方法栈和程序计数器组成。</p></blockquote><ul><li>方法区：主要存储类结构信息、常量、静态变量、即时编译器编译后的代码等数据。</li><li>Java堆：主要存放对象实例，给对象分配内存。</li><li>JVM栈：主要描述 Java 方法执行的内存模型，用于存储局部变量表、操作栈、动态链接、方法出口等信息。</li><li>本地方法栈：为虚拟机使用到的Native方法服务。</li><li>程序计数器：当前线程所执行的字节码的行号指示器。</li></ul><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>类的加载全过程：==加载，验证，准备，解析和初始==化这五个阶段。</p><p><strong>加载：</strong><br>==通过一个类的全限定名来获取其定义的二进制字节流，并将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构，在Java堆中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为对方法区中这些数据的访问入口==。</p><p>可以通过一些渠道加载 class 文件</p><ul><li>从本地系统中直接加载</li><li>通过网络下载.class文件</li><li>从zip，jar等归档文件中加载.class文件</li><li>从专有数据库中提取.class文件</li><li>将Java源文件动态编译为.class文件</li><li></li></ul><p><strong>验证：</strong><br>==目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全==。</p><p>验证阶段大致会完成4个阶段的检验动作：</p><ul><li><strong>文件格式验证</strong>：验证字节流是否符合Class文件格式的规范；例如：是否以<code>0xCAFEBABE</code>开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li><li><strong>元数据验证</strong>：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了<code>java.lang.Object</code>之外。</li><li><strong>字节码验证</strong>：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li><strong>符号引用验证</strong>：确保解析动作能正确执行</li></ul><p><strong>准备：</strong><br>==为类变量分配内存并设置类的初始值的阶段==</p><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p><ol><li>这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</li><li>这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</li></ol><p>假设一个类变量的定义为：public static int value = 3；(如果变量用 final 修饰，则是初始化为3，并将 3 存放常量池中)</p><p>那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的public static指令是在程序编译后，存放于类构造器<clinit>（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。 </clinit></p><p><strong>解析：</strong><br>==解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程==</p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</p><p>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><p><strong>初始化：</strong><br>==为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化==</p><h2 id="GC回收机制"><a href="#GC回收机制" class="headerlink" title="GC回收机制"></a>GC回收机制</h2><p><strong>在什么时候</strong></p><p>首先需要知道，GC又分为minor GC 和 Full Gc(也称为Major GC)。Java 堆内存分为新生代和老年代，新生代中又分为1个Eden区域 和两个 Survivor区域。</p><p>那么对于 Minor GC 的触发条件：大多数情况下，直接在 Eden 区中进行分配。如果 Eden区域没有足够的空间，那么就会发起一次 Minor GC；对于 Full GC（Major GC）的触发条件：也是如果老年代没有足够空间的话，那么就会进行一次 Full GC。</p><p>Ps：能说明minor gc/full gc的触发条件、OOM的触发条件，降低GC的调优的策略。 </p><blockquote><p>eden满了minor gc，升到老年代的对象大于老年代剩余空间full gc，或者小于时被HandlePromotionFailure参数强制full gc；gc与非gc时间耗时超过了GCTimeRatio的限制引发OOM，调优诸如通过NewRatio控制新生代老年代比例，通过MaxTenuringThreshold控制进入老年前生存次数等……</p></blockquote><p><strong>对什么东西</strong></p><p>判断对象是否存活一般有两种方式：</p><p>引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。 </p><p>可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。</p><blockquote><p>从GC Roots搜索不到，而且经过第一次标记、清理后，仍然没有复活的对象。 </p></blockquote><p><strong>做什么事情</strong></p><blockquote><p>主要做了清理对象，整理内存的工作。Java堆分为新生代和老年代，采用了不同的回收方式。例如新生代采用了复制算法，老年代采用了标记整理法。在新生代中，分为一个Eden 区域和两个Survivor区域，真正使用的是一个Eden区域和一个Survivor区域，GC的时候，会把存活的对象放入到另外一个Survivor区域中，然后再把这个Eden区域和Survivor区域清除。那么对于老年代，采用的是标记整理法，首先标记出存活的对象，然后再移动到一端。这样也有利于减少内存碎片。</p></blockquote><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p><p>双亲委派模型意义：</p><ul><li>当不同类加载器加载同一份 class 文件时，JVM 会存在两个独立的对象。（系统类防止内存中出现多份同样的字节码）</li><li>保证Java程序安全稳定运行</li></ul><h2 id="JVM-调优及参数"><a href="#JVM-调优及参数" class="headerlink" title="JVM 调优及参数"></a>JVM 调优及参数</h2><blockquote><p><strong>参数</strong></p><p>-Xms：初始堆大小</p><p>-Xmx ：最大堆大小 此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存</p><p>-Xmn ：年轻代大小 整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</p><p>-XX:NewSize：设置年轻代大小</p><p>-XX:MaxNewSize：年轻代最大值</p><p>-XX:NewRatio 年老代与年轻代的比值</p><p>-XX:SurvivorRatio：设置年轻代中Eden区与Survivor区的大小比值</p><p>-XX:MaxTenuringThreshold：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代的存活时间，增加在年轻代即被回收的概论。</p><p>-XX:PermSize：设置持久带</p><p>-XX:MaxPermSize：设置持久代最大值</p><p><strong>调优</strong></p><p>JVM调优主要是针对内存管理方面的调优，包括<strong>控制各个代的大小，GC策略</strong>。由于GC开始垃圾回收时会挂起应用线程，严重影响了性能，调优的目是为了尽量降低GC所导致的应用线程暂停时间、 减少Full GC次数。</p><p>关键参数：-Xms -Xmx 、-Xmn 、-XX:SurvivorRatio、-XX:MaxTenuringThreshold、-XX:PermSize、-XX:MaxPermSize</p><p>（1）-Xms、 -Xmx 通常设置为相同的值，避免运行时要不断扩展JVM内存，这个值决定了JVM heap所能使用的最大内存。</p><p>（2）-Xmn 决定了新生代空间的大小，新生代Eden、S0、S1三个区域的比率可以通过-XX:SurvivorRatio来控制(假如值为 4  表示：Eden:S0:S1 = 4:3:3 )</p><p>（3）-XX:MaxTenuringThreshold 控制对象在经过多少次minor GC之后进入老年代，此参数只有在Serial 串行GC时有效。</p><p>（4）-XX:PermSize、-XX:MaxPermSize 用来控制方法区的大小，通常设置为相同的值。</p></blockquote><h2 id="java对象创建过程"><a href="#java对象创建过程" class="headerlink" title="java对象创建过程"></a>java对象创建过程</h2><ol><li><p>jvm遇到一条新建对象的指令时首先去检查这个指令的参数是否能在常量池中定义到一个类的符号引用。然后加载这个类（类加载过程在后边讲）</p></li><li><p>为对象分配内存。一种办法“指针碰撞”、一种办法“空闲列表”，最终常用的办法“本地线程缓冲分配(TLAB)”</p></li><li><p>将除对象头外的对象内存空间初始化为0</p></li><li><p>对对象头进行必要设置</p></li></ol><h2 id="java对象结构"><a href="#java对象结构" class="headerlink" title="java对象结构"></a>java对象结构</h2><p>java对象由三个部分组成：对象头、实例数据、对齐填充。</p><p>对象头由两部分组成，第一部分存储对象自身的运行时数据：哈希码、GC分代年龄、锁标识状态、线程持有的锁、偏向线程ID（一般占32/64 bit）。第二部分是指针类型，指向对象的类元数据类型（即对象代表哪个类）。如果是数组对象，则对象头中还有一部分用来记录数组长度。</p><p>实例数据用来存储对象真正的有效信息（包括父类继承下来的和自己定义的）</p><p>对齐填充：jvm要求对象起始地址必须是8字节的整数倍（8字节对齐）</p><h2 id="java对象的定位方式"><a href="#java对象的定位方式" class="headerlink" title="java对象的定位方式"></a>java对象的定位方式</h2><p>句柄池、直接指针。</p><h2 id="如何判断对象可以被回收"><a href="#如何判断对象可以被回收" class="headerlink" title="如何判断对象可以被回收"></a>如何判断对象可以被回收</h2><ol><li><p>引用计数（有bug 不能解决循环引用的问题）</p></li><li><p>可达性分析:</p><p>可选做GC Roots的对象包括以下几种：</p><p>虚拟机栈（栈帧中局部变量表）中引用的数据</p><p>方法区中静态属性引用的对象（static）</p><p>方法区中常量引用的对象（final）</p><p>本地方法栈（native方法）中引用的对象</p></li></ol><h2 id="引用的分类"><a href="#引用的分类" class="headerlink" title="引用的分类"></a>引用的分类</h2><p>强引用：GC时不会被回收</p><p>软引用：描述有用但不是必须的对象，在发生内存溢出异常之前被回收</p><p>弱引用：描述有用但不是必须的对象，在下一次GC时被回收</p><p>虚引用（幽灵引用/幻影引用）:无法通过虚引用获得对象，用PhantomReference实现虚引用，虚引用用来在GC时返回一个通知。</p><h2 id="判断一个对象应该被回收"><a href="#判断一个对象应该被回收" class="headerlink" title="判断一个对象应该被回收"></a>判断一个对象应该被回收</h2><ol><li><p>该对象没有与GC Roots相连</p></li><li><p>该对象没有重写finalize()方法或finalize()已经被执行过则直接回收（第一次标记）否则将对象加入到F-Queue队列中（优先级很低的队列）在这里finalize()方法被执行，之后进行第二次标记，如果对象仍然应该被GC则GC，否则移除队列。（在finalize方法中，对象很可能和其他 GC Roots中的某一个对象建立了关联，finalize方法只会被调用一次，且不推荐使用finalize方法）</p></li></ol><h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>方法区回收价值很低，主要回收废弃的常量和无用的类。</p><p>如何判断无用的类：</p><ol><li><p>该类所有实例都被回收（java堆中没有该类的对象）</p></li><li><p>加载该类的ClassLoader已经被回收</p></li><li><p>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方利用反射访问该类</p></li></ol><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><ol><li><p>标记-清除 先标记再清除、效率不高、产生碎片。</p></li><li><p>复制算法 内存划分为大小相等的两块，每次只使用一块，当这一块用完了就将对象中存活的对象复制到另一块上边。 效率较高、有内存被空闲不能完全利用。 商业虚拟机目前使用这种算法回收新生代。用8:1:1来分配eden:From Survivor: To　Survivo，即可以使用90%的对象，survivor空间不够时需要老年代分配担保 </p></li><li><p>标记-整理 标记之后将所有存活的对象向一端移动，不产生碎片</p></li></ol><h2 id="OopMap、安全点、安全区域、抢先式中断、主动中断"><a href="#OopMap、安全点、安全区域、抢先式中断、主动中断" class="headerlink" title="OopMap、安全点、安全区域、抢先式中断、主动中断"></a>OopMap、安全点、安全区域、抢先式中断、主动中断</h2><p>OopMap：一组特定的数据结构，记录数据引用（用来判断哪些对象是存活的）</p><p>安全点：在特定位置生成OopMap，这些位置成为安全点，只有在安全点才能暂停进行GC</p><p>安全区域：一段代码中引用关系不会变化，这一段代码称为安全区域（扩展的安全点）</p><p>抢先式中断:GC是所有线程都中断、把不在安全点上的线程重新启动跑到安全点上。</p><p>主动式中断：多线程去轮询一个标志位，当发现标志位为真时则自动挂起（标志位为真的位置应该与安全点位置重合）</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>Serial:新生代复制算法（单线程）STW，老年代标记整理。STW</p><p>ParNew:新生代复制算法（多线程）STW，老年代标记整理。STW</p><p>Parrallel Scavenge：新生代收集器，专注于吞吐量<br>吞吐量 = 运行用户代码时间/(运行用户代码时间 P+ GC时间)</p><p>CMS（Concurrent Mark Sweep）收集器：以获取最短回收时间为目标的收集器。<br>分为四个步骤</p><ol><li>初始标记：STW 很快，用来标记GC Roots能直接关联到的对象</li><li>并发标记：并行</li><li>重新标记：并行，修正并发标记中产生变动的对象记录</li><li>并发清理<br>CMS对CPU资源敏感、无法处理浮动垃圾、用标记清除实现有内存碎片</li></ol><p>G1(Garbage-First)<br>整体看来采用标记整理，局部看来(Region之间)采用复制算法。G1将整个java堆分成许多Region，跟踪各个Region里垃圾的回收价值大小，优先回收价值大的Region.<br>步骤：初始标记、并发标记、最终标记、筛选回收。除了最后一步都和CMS差不多</p><h2 id="自动化内存分配是怎么分配的"><a href="#自动化内存分配是怎么分配的" class="headerlink" title="自动化内存分配是怎么分配的"></a>自动化内存分配是怎么分配的</h2><p>对象主要分配在新生代的Eden区（新生代）上，如果启用了TLAB(本地线程分配缓冲)就分配在TLAB上，大对象（比如很长的数组）直接进入老年代，长期存活的对象进入老年代（参考对象头中的年代值）<br>动态对象年龄判定（如果在survivor空间中相同年龄所有对象的大小总和大于等于survivor空间的一半，则年龄大于或等于该年龄的对象直接进入老年代）</p><h2 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h2><p>在Minor GC之前，jvm会检查老年代最大可用连续空间是否大于新生代所有对象的空间。如果成立，则Minor GC是安全的。否则</p><ol><li>jvm设置不允许担保失败则立刻Full GC </li><li>jvm设置允许担保失败则检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则进行一次冒险的Minor GC 否则Full GC</li></ol><p>PS: Full GC 其实是为了让老年代腾出更多空间</p><h2 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h2><ol><li>Class文件是一组以8位字节（1byte = 8bit）为基础单位的二进制流，中间没有任何分隔符，遇1个字节以上的数据，采用高地址对应低字节来分割存储。</li><li>class文件从前到后依次是<br>魔数、版本号、常量池计数、常量池、访问标识、类索引、父类索引、接口计数、接口表、字段计数、字段表、方法计数、方法表、属性计数、属性表。</li><li>常量池从1开始计数，存储两样东西：字面量（Literal）和符号引用。字面量可以理解为常量（文本字符串、声明为final的变量）符号引用则包括以下几种：类和接口的全限定名、字段的名称和描述（字段可以理解为在class内，方法外声明的那些变量）、方法的名称和描述。</li><li>class中字符串、方法名的长度（占用byte的个数）用一个2字节的int来表示，即方法名和字符串最大长度为 2^16 * 1字节 = 64KB 也就是说，超过这个长度的方法名或者字符创（”xxxxx”）将无法编译</li><li>访问标识<br>占两个字节，用来标识是否 public abstract interface final 注解 枚举  等等 </li><li>类索引、父类索引<br>确定类的全限定名和父类的全限定名</li><li>字段… 这段以后再总结吧</li></ol><h2 id="类加载时机、什么时候类会加载"><a href="#类加载时机、什么时候类会加载" class="headerlink" title="类加载时机、什么时候类会加载"></a>类加载时机、什么时候类会加载</h2><p>类在内存中的整个生命周期包括<br>加载<br>链接： 验证、准备、解析<br>初始化<br>使用<br>卸载<br>除解析外所有步骤依次执行，解析可能会发生在初始化之后（多态，动态绑定）</p><p>什么时候会加载？</p><ol><li>遇到***指令的时候，即new对象了，调用类静态字段（fina定义的除外且有初值的除外 ）、静态方法</li><li>反射调用</li><li>初始化一个类时需要先初始化其父类</li><li>jvm启动时加载的包含main()的那个类</li><li>jdk1.7中反射调用方法。。。没看懂。。。</li></ol><h2 id="类加载过程-1"><a href="#类加载过程-1" class="headerlink" title="类加载过程"></a>类加载过程</h2><ol><li>通过一个类的全限定名获取定义这个类的二进制字节流<br>包括：.class 、jar、 网络、 甚至实时生成(动态代理 java.lang.reflect.Proxy)、其他文件（jsp）…</li><li>将这个字节流所代表的类的静态数据结构存储在方法区中（转换成了动态结构）</li><li>在内存中生成一个代表该类的java.lang.Class对象，作为方法区中所有访问该类的数据访问入口</li></ol><h2 id="类验证过程"><a href="#类验证过程" class="headerlink" title="类验证过程"></a>类验证过程</h2><ol><li>文件格式验证</li></ol><p>Class文件是否符合规范，当前虚拟机版本是否能处理</p><ol start="2"><li>元数据验证</li></ol><p>进行语义分析：是否有父类、是否实现了所继承的抽象类中所有方法…</p><ol start="3"><li>字节码验证</li></ol><p>通过数据流和控制流分析，语义是合法合理的，进一步的语义分析。（一个int的值没有被当成lang来写入）</p><ol start="4"><li>符号引用验证</li></ol><p>发生在将符号引用转换为直接应用的时候（解析阶段）用来检查权限，以及是否能成功解析</p><h2 id="类的准备阶段"><a href="#类的准备阶段" class="headerlink" title="类的准备阶段"></a>类的准备阶段</h2><p>正式为类变量分配内存并设置变量初始值（0和null）,只包括的类变量(static修饰)，不包括实例变量</p><h2 id="类的解析"><a href="#类的解析" class="headerlink" title="类的解析"></a>类的解析</h2><p>解析阶段是将常量池内的符号引用替换为直接引用的过程</p><p>解析的动作针对于：类或接口、字段、类方法、接口方法、方法类型、方法句柄、调用点限定符</p><p>符号引用：用一组符号（字符串）来描述所引用的目标，符号可以使任何形式的字面量，符号引用与jvm的内存布局无关，此时类可以没有加载到内存中</p><p>直接引用：可以使直接指向目标的指针、相对偏移量或一个能间接定位到目标的句柄，直接引用与内存布局相关，此时类一定已经加载到内存中了</p><h2 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h2><p>真正开始执行类中定义的java程序代码，编译器收集类中所有变量的赋值语句和静态语句块合并成&lt;clinit方法（执行该方法前一定要执行父类的方法，所以所有类中最先执行的&lt;clinit方法一定是java.lang.Objer）并执行</p><h2 id="类加载器、双亲委派模型"><a href="#类加载器、双亲委派模型" class="headerlink" title="类加载器、双亲委派模型"></a>类加载器、双亲委派模型</h2><p>对于任意一个类都需要由加载它的类加载器和这个类本身一同确立其在jvm中的唯一性（即比较两个类是否相等先要比较这两个类是否由同一个ClassLoader加载）</p><p>jvm的角度来看有两种不同的类加载器：</p><ol><li><p>启动类加载器，用C++实现，是虚拟机的一部分，负责启动&lt;java_home&gt;\lib目录中，或者用-Xbootclasspath参数指定的类</p></li><li><p>所有其他类的加载器（可以细分为扩展类加载器、应用程序类加载器），由java实现，独立于虚拟机，继承于java.lang.ClassLoader</p></li></ol><p>扩展类加载器用来加载&lt;java_home&gt;\lib\ext目录中的</p><p>双亲委派模型：当一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，二十把这个请求委派给父类加载器去完成，只有当父加载器反馈无法加载这个请求（如：它的搜索范围中没有找到所需要的类），子类才会去加载（好处就是java类随着加载器一起构成了一个优先级关系，比如我同样定义了一个java.lang.Object类最终加载出来的还是系统自带的那个。。。也有可能编译通过，拒绝加载）</p><p>启动类加载器</p><p>  |_扩展类加载器</p><p>​     |_应用程序类加载器</p><p>​         |_自定义类加载器</p><p>破坏双亲委派模型：基础类需要回调用户的代码（即要先加载用户类 比如 JNDI服务）<br>采用 线程上下文类加载器（父类请求子类的加载器去加载这个类）</p><h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p>栈帧是用来支持虚拟机进行方法调用和方法执行的数据结构，jvm运行时数据区中虚拟机栈的栈元素。栈帧中存储了：<strong>局部变量表、操作数栈、动态链接、返回地址</strong>。每个方法从调用到执行完成对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。只有栈顶的当前栈帧是有效的</p><h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2><ol><li><p>是一组变量值存储空间。用来存储方法参数和方法内部定义的局部变量。在.class中已经由code属性的max_locals项决定了局部变量表的最大容量。</p></li><li><p>局部变量表容量以变量槽（Slot）为最小单位（32/64bit）</p></li><li><p>局部变量表中第0为存储的是：方法所属对象的实例引用，即 this~~</p></li><li><p>slot可以重用，即局部变量表的空间可能会比实际所有方法中变量需要占用的空间要小，有时候把不使用的对象手动赋null，可能会有助于GC</p></li><li><p>类变量（成员变量）（class内 方法外）是默认有初值的（在类准备阶段被赋0和nul了），而方法内的变量，即局部变量是没有初值的，不能直接调用</p></li><li><p>long和double占两个slot，可以用volatile关键字修饰，防止在多线程环境下的字撕裂。</p></li></ol><h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><ol><li><p>操作数栈中每一个元素可以是任意的java类型</p></li><li><p>操作数栈中的元素数据类型必须与字节码执行指令序列严格匹配（eg:当前指令时iadd~两个int相加的指令，那么操作数栈顶必须是两个int类型！）</p></li></ol><h2 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h2><p>方法返回地址八成存的是上一个方法PC计数器的下一条指令。方法执行后有两种方式退出方法。</p><ol><li><p>正常退出</p></li><li><p>异常退出（不会给上层调用者提供返回值）</p></li></ol><p>正常退出的情况下，需要把当前栈帧出栈、恢复上层方法的局部变量表和操作数栈、把返回值（如果有）压入栈顶。调整PC计数器让它指向方法调用指令的后一条指令</p><h2 id="动态链接（多态-动态绑定-DynamicLinking）"><a href="#动态链接（多态-动态绑定-DynamicLinking）" class="headerlink" title="动态链接（多态/动态绑定 DynamicLinking）"></a>动态链接（多态/动态绑定 DynamicLinking）</h2><ol><li>语法层面简单的说，多态：有继承、有重写、父类引用指向子类对象。</li></ol><p>深层次的讲：</p><ol start="2"><li><p>每个栈帧都包含一个指向运行时常量池中改栈帧所述方法的引用（即一个符号引用，表明这个栈帧代表哪个类的哪个方法？）。在一种情况下：类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另一种情况：在方法的每一次运行时都进行解析转换为直接引用，这就是动态链接</p></li><li><p>方法调用，不等于方法执行！方法调用的目的是确定需要调用方法的哪个版本（即调用哪个类的哪个方法）</p></li><li><p>调用目标在程序代码写好后，编译期编译时就能确定的方法，就可以用静态解析，即“编译期可知，运行期不变”。包括两种方法：其一，静态方法（static 与类的类型直接关联）.其二，私有方法（private 不能被继承并重写，因此只有一个版本）</p></li></ol><p>补充：实例构造器、父类方法也可以静态解析，这四种方法统称为非虚方法（外加fina修饰的方法），所有其他的方法称为虚方法。</p><ol start="5"><li><p>分派：解析调用一定是静态过程（在运行期之前就已经确定），而分派可能是静态可能是动态的过程，即分为静态单分派、静态多分派、动态单分派、动态多分派。具体是多还是单是有分派所依据的宗量数决定；</p></li><li><p>eg</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class Human&#123; &#125;</div><div class="line">class Man extends Human&#123; &#125;</div><div class="line">class Woman extends Human&#123; &#125;</div><div class="line">public static void say(Human guy)&#123;</div><div class="line">System.out.printlun(“Human”);</div><div class="line">&#125;</div><div class="line">public static void say(Man guy)&#123;</div><div class="line">System.out.printlun(“Man”);</div><div class="line">&#125;</div><div class="line">public static void say(Woman guy)&#123;</div><div class="line">System.out.printlun(“Woman”);</div><div class="line">&#125;</div><div class="line">public static void main(String[] args)&#123;</div><div class="line">Human man= new Man();</div><div class="line">Human woman = new Woman();</div><div class="line">say(man);</div><div class="line">say(woman);</div><div class="line">&#125;</div><div class="line">//结果</div><div class="line">//Human</div><div class="line">//Human</div></pre></td></tr></table></figure></li><li><p>eg </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</div><div class="line">System.out.println(<span class="string">"Human say"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</div><div class="line">System.out.println(<span class="string">"Man say"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</div><div class="line">System.out.println(<span class="string">"Woman say"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">Human m1 = <span class="keyword">new</span> Human();</div><div class="line">Human m2 = <span class="keyword">new</span> Man(); </div><div class="line">Human m3 = <span class="keyword">new</span> Woman();</div><div class="line">m1.say();</div><div class="line">m2.say();</div><div class="line">m3.say();</div><div class="line">m3 = <span class="keyword">new</span> Man();</div><div class="line">m3.say();</div><div class="line">&#125;</div><div class="line"><span class="comment">//结果</span></div><div class="line"><span class="comment">//Human say</span></div><div class="line"><span class="comment">//Man say</span></div><div class="line"><span class="comment">//Woman say</span></div><div class="line"><span class="comment">//Man say</span></div></pre></td></tr></table></figure></li></ol><p>java中重写是动态分派，当运行期调用某个对象的方法时需经历以下几个过程： </p><ol><li><p>找到操作数栈顶的第一个元素（即当前对象）的实际类型，记为C </p></li><li><p>如果在类型C中找到了与常量中描述符和简单名称都相符的方法（方法名一样、参数类型个数一样）则进行权限访问检查，能通过检查则调用这个方法，否则返回java.lang.IllegalAccessError. </p></li><li><p>否则按照继承关系依次对C的父类进行第二步的操作。 </p></li><li><p>最终如果没有找到合适方法，抛异常~ </p></li><li><p>单分派与多分派。 </p></li></ol><p>宗量：方法的接受者与方法的参数统称为总量 A.method( XX,YY,ZZ) (A XX YY ZZ 称为method的宗量 ) </p><p>单分派：根据一个宗量对目标方法进行选择（选择哪个类、选择这个类中的哪个方法） </p><p>多分派：根据超过一个宗量对目标方法进行选择 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">eg:</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaDispath</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">Father father = <span class="keyword">new</span> Father();</div><div class="line">Father son = <span class="keyword">new</span> Son();</div><div class="line">father.choice(<span class="keyword">new</span> QQ());</div><div class="line">son.choice(<span class="keyword">new</span> _360());</div><div class="line"><span class="comment">//son.choice(new _360(),1);</span></div><div class="line">System.out.println(<span class="string">"~~~~~~~~~~~"</span>);</div><div class="line">QQ qiruiQQ = <span class="keyword">new</span> QiruiQQ();</div><div class="line">son.choice(qiruiQQ);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">QQ</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</div><div class="line">System.out.println(<span class="string">"I'm QQ"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">QiruiQQ</span> <span class="keyword">extends</span> <span class="title">QQ</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</div><div class="line">System.out.println(<span class="string">"I'm QiruiQQ"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TengxunQQ</span> <span class="keyword">extends</span> <span class="title">QQ</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</div><div class="line">System.out.println(<span class="string">"I'm TengxunQQ"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">_360</span></span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">choice</span><span class="params">(_360 arg, <span class="keyword">int</span> a)</span></span>&#123;</div><div class="line">System.out.println(<span class="string">"Man chooce 360"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">Man</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">choice</span><span class="params">(QQ arg)</span></span>&#123;</div><div class="line">QQ.say();</div><div class="line">System.out.println(<span class="string">"Father chooce QQ"</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">choice</span><span class="params">(_360 arg)</span></span>&#123;</div><div class="line">System.out.println(<span class="string">"Father chooce 360"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">choice</span><span class="params">(QQ arg)</span></span>&#123;</div><div class="line">QQ.say();</div><div class="line">System.out.println(<span class="string">"Son chooce QQ"</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">choice</span><span class="params">(_360 arg)</span></span>&#123;</div><div class="line">System.out.println(<span class="string">"Son chooce 360"</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">choice</span><span class="params">(QiruiQQ arg)</span></span>&#123;</div><div class="line">QQ.say();</div><div class="line">System.out.println(<span class="string">"Son chooce QQ"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//结果</span></div><div class="line"><span class="comment">//Father chooce 360</span></div><div class="line"><span class="comment">//I'm QQ</span></div><div class="line"><span class="comment">//Son chooce QQ</span></div><div class="line"><span class="comment">//~~~~~~~~~~~</span></div><div class="line"><span class="comment">//I'm QQ</span></div><div class="line"><span class="comment">//Son chooce QQ</span></div></pre></td></tr></table></figure><p>上边的程序运行过程时这样的： </p><p>分割线之前 </p><p>在编译期（静态分派的过程~），系统根据father和son的静态类型即Fahter和后边的方法名还有参数，决定调用 </p><p>Father.choice(360) 和Father.choice(360) </p><p>因此静态分派是多分派（超过了一个宗量） </p><p>此时是方法调用的过程 </p><p>在运行期（动态分派过程~），系统根据father和son的动态类型决定调用 </p><p>Father.choice(360) 和Son.choice(QQ)，此时是动态分派，根据实际类型去找到应该执行哪个类的哪个方法，此时根据son的动态类型Son来选择了执行Son.choice(QQ)。而不论里边的QQ传进来的到底是奇瑞QQ、还是腾讯QQ，jvm都不会去理睬，只是把它当做一个普通QQ来对待。因此动态分派只取决于方法的接受者的实际类型，与参数无关。因此java语言的动态分派是单分派（一个宗量决定）。 </p><p>分割线之后 </p><p>在分割线之后，我们尝试着在son.choice中传入了一个QiruiQQ 但是jvm还是只把它当成一个普通QQ来看待，验证了我们上边的说法。 </p><p>总的来说，java是静态多分派，动态单分派。</p><ol start="9"><li>多态是怎么实现的</li></ol><p>出于效率的考虑，我们上文中所说的那种一层层向上搜索的算法在实际中不会用到。。。</p><p>实际中为每个类在方法区的位置中搞了一个虚方法表（也有接口方法表），方法表中罗列着这个类所继承的所有方法的全限定名以及他们的引用指向，比如上文Father类的方法表中clone()方法指向java.lang.Objer.clone()的入口地址，而choice(QQ)方法，就指向自身的choice(QQ)方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JVM-内存结构&quot;&gt;&lt;a href=&quot;#JVM-内存结构&quot; class=&quot;headerlink&quot; title=&quot;JVM 内存结构&quot;&gt;&lt;/a&gt;JVM 内存结构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://blogimg.nos-eastchina1.126.net/shenwf20190512092851-297873.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="基础面试题" scheme="http://swenfang.github.io/categories/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="基础面试题" scheme="http://swenfang.github.io/tags/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>程序员如何高效率拿 offer</title>
    <link href="http://swenfang.github.io/2019/05/12/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>http://swenfang.github.io/2019/05/12/面试总结/面试总结/</id>
    <published>2019-05-12T13:13:49.094Z</published>
    <updated>2019-05-12T15:11:35.633Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190512090714-358904.jpg" alt=""></p><a id="more"></a><h2 id="面试题如何准备"><a href="#面试题如何准备" class="headerlink" title="面试题如何准备"></a>面试题如何准备</h2><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190512090815-303069.jpg" alt=""></p><p>你的简历内容可能会决定面试官要问的问题，所以准备面试题的时候，别忘了回头去看你的简历写了哪些内容，准备与该内容相关的面试题。也许你简历上写的技术（在项目中设计到的技术），你不是很熟悉，你就是用该技术最基础的东西实现最简单的功能。这也没关系，你只要认真去看你接触的这个东西一些相关的面试内容即可。因为面试官问来问去也离不开你背过的哪些关键字或词。</p><p>以下的面试题可以供大家参考：</p><p><a href="https://swenfang.github.io/2019/04/22/Spring面试题/">https://swenfang.github.io/2019/04/22/Spring面试题/</a></p><p><a href="https://swenfang.github.io/2019/05/12/面试总结/JVM">https://swenfang.github.io/2019/05/12/面试总结/JVM</a> 面试题/</p><p><a href="https://swenfang.github.io/2019/05/12/面试总结/线程面试题/">https://swenfang.github.io/2019/05/12/面试总结/线程面试题/</a></p><p><a href="https://swenfang.github.io/2019/05/12/面试总结/Redis">https://swenfang.github.io/2019/05/12/面试总结/Redis</a> 面试题/</p><p><a href="https://swenfang.github.io/2019/05/12/面试总结/数据库面试题/">https://swenfang.github.io/2019/05/12/面试总结/数据库面试题/</a></p><p><a href="https://swenfang.github.io/2019/05/12/面试总结/日志框架面试题/">https://swenfang.github.io/2019/05/12/面试总结/日志框架面试题/</a></p><p><a href="https://swenfang.github.io/2019/05/12/面试总结/Mybaties">https://swenfang.github.io/2019/05/12/面试总结/Mybaties</a> 面试题/</p><p><a href="https://swenfang.github.io/2019/05/12/面试总结/全文检索面试题/">https://swenfang.github.io/2019/05/12/面试总结/全文检索面试题/</a></p><p><a href="https://swenfang.github.io/2019/05/12/面试总结/Jdk1.7与">https://swenfang.github.io/2019/05/12/面试总结/Jdk1.7与</a> jdk1.8的区别和最新的特征/</p><h2 id="面试过程如何应对"><a href="#面试过程如何应对" class="headerlink" title="面试过程如何应对"></a>面试过程如何应对</h2><p>在被提问的过程，很多人应该会像我一样会关心一个问题。就是，面试官问我的问题我不会或者不敢确定答案的正确性怎么办？其实，技术上的问题如果你是真的不会你可以向面试官委婉的表达，即“不好意思，您说的这个问题我暂时没去了解过，回答不了您” 或者 “您说的这个问题我目前还没有遇到过，暂时不知道怎么结局，请问贵公司这边是怎样来处理这种的问题的呢？”（反问面试官的次数最多不要超过两次，这是我个人的原则）或则“不好意思，您说的这个点我暂时没有去了解。”以这种比较委婉的方式去缓和你在面试过程中的不足是比较合适的。</p><p>在言行举止方面，在面试刚开始的时候紧张是很正常，你能做的就是保持微笑，认真的去回答面试官提出的每个问题，在这个过程中，你也可以同他进行相互的交流，也就是我上面提到的访问，如果面试官问的问题你没听明白，你可以说“不好意思我不太明白您说的问题，麻烦您再给我描述一下。”如果面试官提到的问题你只知道一点点（知道是什么或知道怎么用），那么你在回答完之后，你可以说“我只知道这些”，这样说的目的让面试官知道，你只知道这些，再深入的东西我可能就回答不了。当你掌握了这些面试沟通技巧的时候，你会发现整场面试下来，自己的心情会比较轻松、愉快一些，这样你挂在脸上的微笑也会更加自然。</p><h2 id="面试技巧"><a href="#面试技巧" class="headerlink" title="面试技巧"></a>面试技巧</h2><h3 id="投递简历"><a href="#投递简历" class="headerlink" title="投递简历"></a>投递简历</h3><ul><li>技术性招聘一般都是通过 Boss 直聘<strong>、</strong>拉钩，如果工作 7、8 年以上，并且想找架构或管理方面可通过 猎聘找猎头推荐，想要内推的话可以找下 内推网 里面一般都是大厂。</li><li>投递简历一般选择在工作日投，尽量不要在周末投，一般 HR 查看简历都是前面几份筛选，如果周末投 HR 会收到很多简历也不会细心取看。</li><li>投递后一般都不会有很快反应，一般有些公司预期招聘就会在各平台发布招聘信息，后面等一个多星期或是更久才会查看收到的简历，所以一般投递后都是一个星期内才有反应。</li><li>简历最好不要准备一份，如果想要投递自己向往的公司的话，需要针对该公司所写的招聘信息对应去修改自己的简历，这样面试通知你面试的机会更大些。</li></ul><p><code>注意</code>：在还是投递简历的时候最好不要先投递自己向往的公司，先投递几家公司练练手，熟悉一下面试的流程与常问的问题，后面投递自己向往的公司获取 Office 机会比较大点。</p><h3 id="时间选择"><a href="#时间选择" class="headerlink" title="时间选择"></a>时间选择</h3><p>如果收到面试邀请，如果是早上面试最好跟 HR 预定10点过去，下午3点。这个时间点一方面自己有复习的时间，另一方面是对方公司面试官能确认已经上班。</p><h2 id="我的个人总结"><a href="#我的个人总结" class="headerlink" title="我的个人总结"></a>我的个人总结</h2><p>总体的感觉是，外包公司实在太多，所以我找工作平台的聊天中，若有公司招聘人员约我去面试的时候，我都会先问一句“请问贵公司是项目外包吗？”。一般是外包公司，我个人是选择不去面试。当然，如果你是应届毕业生或者你是很久都没有参与过面试很缺乏面试经验，那么我个人觉得你不应该放弃或丢失任何一次面试机会。因为你面试的场数越多，首先对面试题有越多的回忆和更进一步的巩固，其次应对面试官的提问你的心态会更加的淡定和自然，回答问题也会更加顺畅,有了前面的面试经验你的答案也会更加完整，最后你收到 offer 的机会就会越多。</p><p>最后想跟大家说一件非常重要的事：千里执行，始于足下。九层之台，起于累土。不管你现在身处什么样的工作环境，都要时刻记得抽出时间去学习去积累（学习你在工作中没有用到的技术，积累每天一点一点的阅读内容）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://blogimg.nos-eastchina1.126.net/shenwf20190512090714-358904.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="基础面试题" scheme="http://swenfang.github.io/categories/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="基础面试题" scheme="http://swenfang.github.io/tags/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>关于GC overhead limit exceeded</title>
    <link href="http://swenfang.github.io/2019/05/03/Java%20JVM/%E5%85%B3%E4%BA%8EGCOverheadLimitExceeded/"/>
    <id>http://swenfang.github.io/2019/05/03/Java JVM/关于GCOverheadLimitExceeded/</id>
    <published>2019-05-03T03:36:04.348Z</published>
    <updated>2019-05-03T03:44:02.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于GC-overhead-limit-exceeded"><a href="#关于GC-overhead-limit-exceeded" class="headerlink" title="关于GC overhead limit exceeded"></a>关于GC overhead limit exceeded</h1><blockquote><p>我遇到这样的问题，本地部署时抛出异常java.lang.OutOfMemoryError：GC overhead limit exceeded导致服务起不来，查看日志发现加载了太多资源到内存，本地的性能也不好，gc时间消耗的较多。<a id="more"></a>解决这种问题两种方法是，增加参数，-XX:-UseGCOverheadLimit，关闭这个特性，同时增加heap大小，-Xmx1024m。坑填了，but why？</p><p>OOM大家都知道，就是JVM内存溢出了，那GC overhead limit exceed呢？</p><p>GC overhead limt exceed检查是Hotspot VM 1.6定义的一个策略，通过统计GC时间来预测是否要OOM了，提前抛出异常，防止OOM发生。Sun 官方对此的定义是：“并行/并发回收器在GC回收时间过长时会抛出OutOfMemroyError。过长的定义是，超过98%的时间用来做GC并且回收了不到2%的堆内存。用来避免内存过小造成应用不能正常工作。“</p><p>听起来没啥用…预测OOM有啥用？起初开来这玩意只能用来Catch住释放内存资源，避免应用挂掉。后来发现一般情况下这个策略不能拯救你的应用，但是可以在应用挂掉之前做最后的挣扎，比如数据保存或者保存现场（Heap Dump）。</p><p>而且有些时候这个策略还会带来问题，比如加载某个大的内存数据时频繁OOM。</p><p>假如你也生产环境中遇到了这个问题，在不知道原因时不要简单的猜测和规避。可以通过<strong>-verbose:gc -XX:+PrintGCDetails</strong>看下到底什么原因造成了异常。<strong>通常原因都是因为old区占用过多导致频繁Full GC，最终导致GC overhead limit exceed</strong>。如果gc log不够可以借助于JProfile等工具查看内存的占用，old区是否有内存泄露。分析内存泄露还有一个方法<strong>-XX:+HeapDumpOnOutOfMemoryError</strong>，这样OOM时会自动做Heap Dump，可以拿MAT来排查了。还要留意young区，如果有过多短暂对象分配，可能也会抛这个异常。</p></blockquote><p>日志的信息不难理解，就是每次gc时打条日志，记录GC的类型，前后大小和时间。举个例子。</p><p>33.125: [GC [DefNew: 16000K-&gt;16000K(16192K), 0.0000574 secs][Tenured: 2973K-&gt;2704K(16384K), 0.1012650 secs] 18973K-&gt;2704K(32576K), 0.1015066 secs]</p><p>100.667:[Full GC [Tenured: 0K-&gt;210K(10240K), 0.0149142 secs] 4603K-&gt;210K(19456K), [Perm : 2999K-&gt;2999K(21248K)], 0.0150007 secs]</p><blockquote><p>GC和Full GC代表gc的停顿类型，Full GC代表stop-the-world。箭头两边是gc前后的区空间大小，分别是young区、tenured区和perm区，括号里是该区的总大小。冒号前面是gc发生的时间，单位是秒，从jvm启动开始计算。DefNew代表Serial收集器，为Default New Generation的缩写，类似的还有PSYoungGen，代表Parallel Scavenge收集器。这样可以通过分析日志找到导致GC overhead limit exceeded的原因，通过调节相应的参数解决问题。</p><p>文中涉及到的名词解释，</p><p>Eden Space：堆内存池，大多数对象在这里分配内存空间。</p><p>Survivor Space：堆内存池，存储在Eden Space的gc中存活下来的对象。</p><p>Tenured Generation：堆内存池，存储Survivor Space中存活过几次gc的对象。</p><p>Permanent Generation：非堆空间，存储的是class和method对象。</p><p>Code Cache：非堆空间，JVM用来存储编译和存储native code。</p></blockquote><p>最后附上GC overhead limit exceed HotSpot的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">bool print_gc_overhead_limit_would_be_exceeded = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">if</span> (is_full_gc) &#123;</div><div class="line">  <span class="keyword">if</span> (gc_cost() &gt; gc_cost_limit &amp;&amp;</div><div class="line">    free_in_old_gen &lt; (size_t) mem_free_old_limit &amp;&amp;</div><div class="line">    free_in_eden &lt; (size_t) mem_free_eden_limit) &#123;</div><div class="line">    inc_gc_overhead_limit_count();</div><div class="line">    <span class="keyword">if</span> (UseGCOverheadLimit) &#123;</div><div class="line">      <span class="keyword">if</span> (gc_overhead_limit_count() &gt;=</div><div class="line">          AdaptiveSizePolicyGCTimeLimitThreshold)&#123;</div><div class="line">        <span class="comment">// All conditions have been met for throwing an out-of-memory</span></div><div class="line">        set_gc_overhead_limit_exceeded(<span class="keyword">true</span>);</div><div class="line">        <span class="comment">// Avoid consecutive OOM due to the gc time limit by resetting</span></div><div class="line">        <span class="comment">// the counter.</span></div><div class="line">        reset_gc_overhead_limit_count();</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// The required consecutive collections which exceed the</span></div><div class="line">        <span class="comment">// GC time limit may or may not have been reached. We</span></div><div class="line">        <span class="comment">// are approaching that condition and so as not to</span></div><div class="line">        <span class="comment">// throw an out-of-memory before all SoftRef's have been</span></div><div class="line">        <span class="comment">// cleared, set _should_clear_all_soft_refs in CollectorPolicy.</span></div><div class="line">        <span class="comment">// The clearing will be done on the next GC.</span></div><div class="line">        bool near_limit = gc_overhead_limit_near();</div><div class="line">        <span class="keyword">if</span> (near_limit) &#123;</div><div class="line">          collector_policy-&gt;set_should_clear_all_soft_refs(<span class="keyword">true</span>);</div><div class="line">          <span class="keyword">if</span> (PrintGCDetails &amp;&amp; Verbose) &#123;</div><div class="line">            gclog_or_tty-&gt;print_cr(<span class="string">"  Nearing GC overhead limit, "</span></div><div class="line">              <span class="string">"will be clearing all SoftReference"</span>);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Set this even when the overhead limit will not</span></div><div class="line">    <span class="comment">// cause an out-of-memory.  Diagnostic message indicating</span></div><div class="line">    <span class="comment">// that the overhead limit is being exceeded is sometimes</span></div><div class="line">    <span class="comment">// printed.</span></div><div class="line">    print_gc_overhead_limit_would_be_exceeded = <span class="keyword">true</span>;</div><div class="line"> </div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// Did not exceed overhead limits</span></div><div class="line">    reset_gc_overhead_limit_count();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于GC-overhead-limit-exceeded&quot;&gt;&lt;a href=&quot;#关于GC-overhead-limit-exceeded&quot; class=&quot;headerlink&quot; title=&quot;关于GC overhead limit exceeded&quot;&gt;&lt;/a&gt;关于GC overhead limit exceeded&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;我遇到这样的问题，本地部署时抛出异常java.lang.OutOfMemoryError：GC overhead limit exceeded导致服务起不来，查看日志发现加载了太多资源到内存，本地的性能也不好，gc时间消耗的较多。
    
    </summary>
    
      <category term="Java JVM" scheme="http://swenfang.github.io/categories/Java-JVM/"/>
    
    
      <category term="Java JVM" scheme="http://swenfang.github.io/tags/Java-JVM/"/>
    
  </entry>
  
  <entry>
    <title>Spring 面试题</title>
    <link href="http://swenfang.github.io/2019/04/22/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://swenfang.github.io/2019/04/22/Spring面试题/</id>
    <published>2019-04-22T15:05:21.745Z</published>
    <updated>2019-04-22T15:03:31.094Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-IOC、AOP的理解、实现的原理，以及优点"><a href="#Spring-IOC、AOP的理解、实现的原理，以及优点" class="headerlink" title="Spring IOC、AOP的理解、实现的原理，以及优点"></a>Spring IOC、AOP的理解、实现的原理，以及优点</h2><blockquote><p>Spring的IoC容器是Spring的核心，Spring AOP是spring框架的重要组成部分</p><p><strong>IOC</strong></p><ul><li><strong>我的理解</strong><ul><li>正常的情况下，比如有一个类，在类里面有方法（不是静态的方法），调用类里面的方法，创建类的对象，使用对象调用方法，创建类对象的过程，需要new出来对象</li><li>通过控制反转，把对象的创建不是通过new方式实现，而是交给Spring配置创建类对象</li><li>IOC的意思是控件反转也就是由容器控制程序之间的关系，这也是spring的优点所在，把控件权交给了外部容器，之前的写法，由程序代码直接操控，而现在控制权由应用代码中转到了外部容器，控制权的转移是所谓反转。换句话说之前用new的方式获取对象，现在由spring给你至于怎么给你就是di了。</li></ul></li><li><strong>Spring IOC实现原理</strong><ul><li>创建xml配置文件，配置要创建的对象类</li><li>通过反射创建实例</li><li>获取需要注入的接口实现类并将其赋值给该接口</li></ul></li><li><strong>优点</strong><ul><li>解耦合，开发更方便组织分工</li><li>高层不依赖于底层（依赖倒置）</li><li>是应用更容易测试</li><li>因为把对象生成放在了XML里定义，所以当我们需要换一个实现子类将会变成很简单（一般这样的对象都是现实于某种接口的），只要修改XML就可以了，这样我们甚至可以实现对象的热插拨</li></ul></li></ul><p><strong>AOP</strong>(面向切面编程,主要的作用是不需要修改源代码的基础扩展功能)</p><ul><li><strong>我的理解</strong><ul><li>AOP（Aspect Oriented Programming ）称为面向切面编程，扩展功能不是修改源代码实现，在程序开发中主要用来解决一些系统层面上的问题，比如日志，事务，权限等待，Struts2的拦截器设计就是基于AOP的思想，是个比较经典的例子。</li><li>面向切面编程（aop）是对面向对象编程（oop）的补充</li><li>面向切面编程提供声明式事务管理</li><li>AOP就是典型的代理模式的体现</li></ul></li><li><strong>Spring AOP实现原理</strong><ul><li>动态代理（利用<strong>反射和动态编译</strong>将代理模式变成动态的）</li><li>JDK的动态代理<ul><li>JDK内置的Proxy动态代理可以在运行时动态生成字节码，而没必要针对每个类编写代理类</li><li>JDKProxy返回动态代理类，是目标类所实现接口的另一个实现版本，它实现了对目标类的代理（如同UserDAOProxy与UserDAOImp的关系）</li></ul></li><li>cglib动态代理<ul><li>CGLibProxy返回的动态代理类，则是目标代理类的一个子类（代理类扩展了UserDaoImpl类）</li><li>cglib继承被代理的类，重写方法，织入通知，动态生成字节码并运行</li></ul></li></ul></li><li><strong>优点</strong><ul><li>各个步骤之间的良好隔离性</li><li>源代码无关性</li><li>松耦合</li><li>易扩展</li><li>代码复用</li></ul></li></ul></blockquote><h2 id="项目中Spring-AOP用在什么地方，为什么这么用，切点，织入，通知用自己的话描述一下"><a href="#项目中Spring-AOP用在什么地方，为什么这么用，切点，织入，通知用自己的话描述一下" class="headerlink" title="项目中Spring AOP用在什么地方，为什么这么用，切点，织入，通知用自己的话描述一下"></a>项目中Spring AOP用在什么地方，为什么这么用，切点，织入，通知用自己的话描述一下</h2><blockquote><ul><li>Joinpoint（连接点）（重要）<ul><li>类里面可以被增强的方法，这些方法称为连接点</li></ul></li><li>Pointcut（切入点）（重要）<ul><li>所谓切入点是指我们要对哪些Joinpoint进行拦截的定义</li></ul></li><li>Advice（通知/增强）（重要）<ul><li>所谓通知是指拦截到Joinpoint之后所要做的事情就是通知.通知分为前置通知，后置通知，异常通知，最终通知，环绕通知（切面要完成的功能）</li></ul></li><li>Aspect（切面）<ul><li>是切入点和通知（引介）的结合</li></ul></li><li>Introduction（引介）<ul><li>引介是一种特殊的通知在不修改类代码的前提下， Introduction可以在运行期为类动态地添加一些方法或Field.</li></ul></li><li>Target（目标对象）<ul><li>代理的目标对象（要增强的类）</li></ul></li><li>Weaving（织入）<ul><li>是把增强应用到目标的过程，把advice 应用到 target的过程</li></ul></li><li>Proxy（代理）<ul><li>一个类被AOP织入增强后，就产生一个结果代理类</li></ul></li></ul><p>AOP（Aspect Oriented Programming ）称为面向切面编程，扩展功能不是修改源代码实现，在程序开发中主要用来解决一些系统层面上的问题，比如日志，事务，权限等待，Struts2的拦截器设计就是基于AOP的思想，是个比较经典的例子。</p></blockquote><h2 id="AOP动态代理2种实现原理，他们的区别是什么？"><a href="#AOP动态代理2种实现原理，他们的区别是什么？" class="headerlink" title="AOP动态代理2种实现原理，他们的区别是什么？"></a>AOP动态代理2种实现原理，他们的区别是什么？</h2><blockquote><p>动态代理与cglib实现的区别</p><ul><li>JDK动态代理只能对实现了接口的类生成代理，而不能针对类</li><li>cglib是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法因为是继承，所以该类或方法最好不要声明成final</li><li>JDK代理是不需要以来第三方的库，只要JDK环境就可以进行代理</li><li>cglib必须依赖于cglib的类库，但是它需要类来实现任何接口代理的是指定的类生成一个子类，覆盖其中的方法，是一种继承</li></ul></blockquote><h2 id="Spring事物的七种事物传播属性行为及五种隔离级别"><a href="#Spring事物的七种事物传播属性行为及五种隔离级别" class="headerlink" title="Spring事物的七种事物传播属性行为及五种隔离级别"></a>Spring事物的七种事物传播属性行为及五种隔离级别</h2><blockquote><p>Spring七个事物传播属性：</p><ol><li>PROPAGATION_REQUIRED – 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。</li><li>PROPAGATION_SUPPORTS – 支持当前事务，如果当前没有事务，就以非事务方式执行。</li><li>PROPAGATION_MANDATORY – 支持当前事务，如果当前没有事务，就抛出异常。</li><li>PROPAGATION_REQUIRES_NEW – 新建事务，如果当前存在事务，把当前事务挂起。</li><li>PROPAGATION_NOT_SUPPORTED – 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li>PROPAGATION_NEVER – 以非事务方式执行，如果当前存在事务，则抛出异常。</li><li>PROPAGATION_NESTED – 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。</li></ol><p>五个隔离级别：</p><ol><li>ISOLATION_DEFAULT 这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.另外四个与JDBC的隔离级别相对应；</li><li>ISOLATION_READ_UNCOMMITTED 这是事务最低的隔离级别，它充许别外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。<strong>(读未提交)</strong></li><li>ISOLATION_READ_COMMITTED 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。<strong>(读已提交)</strong></li><li>ISOLATION_REPEATABLE_READ 这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。它除了保证 一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生 <strong>(不可重复读)</strong>。</li><li>ISOLATION_SERIALIZABLE 这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读外，还避免了幻像读。<strong>(串行化)</strong></li></ol></blockquote><h2 id="Spring-工作流程描述"><a href="#Spring-工作流程描述" class="headerlink" title="Spring 工作流程描述"></a>Spring 工作流程描述</h2><blockquote><ol><li>用户向服务器发送请求，请求被Spring 前端控制Servelt DispatcherServlet捕获；</li><li>DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回；</li><li>DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(…)方法）</li><li>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：ttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息；数据转换：对请求消息进行数据转换。如String转换成Integer、Double等；数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等；数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中；</li><li>Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象；</li><li>根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet ；</li><li>ViewResolver 结合Model和View，来渲染视图</li><li>将渲染结果返回给客户端。</li></ol></blockquote><h2 id="为什么Spring只使用一个Servlet-DispatcherServlet-来处理所有请求？"><a href="#为什么Spring只使用一个Servlet-DispatcherServlet-来处理所有请求？" class="headerlink" title="为什么Spring只使用一个Servlet(DispatcherServlet)来处理所有请求？"></a>为什么Spring只使用一个Servlet(DispatcherServlet)来处理所有请求？</h2><blockquote><p>Spring工作流程描述<br>   为什么Spring只使用一个Servlet(DispatcherServlet)来处理所有请求？<br>提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。<br>   Spring为什么要结合使用HandlerMapping以及HandlerAdapter来处理Handler?<br>   符合面向对象中的单一职责原则，代码架构清晰，便于维护，最重要的是代码可复用性高。如HandlerAdapter可能会被用于处理多种Handler。</p></blockquote><h2 id="Spring有哪些优点"><a href="#Spring有哪些优点" class="headerlink" title="Spring有哪些优点"></a>Spring有哪些优点</h2><blockquote><p>1.轻量级：Spring在大小和透明性方面绝对属于轻量级的，基础版本的Spring框架大约只有2MB。<br>2.控制反转(IOC)：Spring使用控制反转技术实现了松耦合。依赖被注入到对象，而不是创建或寻找依赖对象。<br>3.面向切面编程(AOP)： Spring支持面向切面编程，同时把应用的业务逻辑与系统的服务分离开来。<br>4.容器：Spring包含并管理应用程序对象的配置及生命周期。<br>5.MVC框架：Spring的web框架是一个设计优良的web MVC框架，很好的取代了一些web框架。<br>6.事务管理：Spring对下至本地业务上至全局业务(JAT)提供了统一的事务管理接口。<br>7.异常处理：Spring提供一个方便的API将特定技术的异常(由JDBC, Hibernate, 或JDO抛出)转化为一致的、Unchecked异常。</p></blockquote><h2 id="什么是控制反转-IoC-？什么是依赖注入？"><a href="#什么是控制反转-IoC-？什么是依赖注入？" class="headerlink" title="什么是控制反转(IoC)？什么是依赖注入？"></a>什么是控制反转(IoC)？什么是依赖注入？</h2><blockquote><p>IoC，是 Inversion of Control 的缩写，即控制反转。</p><ul><li>上层模块不应该依赖于下层模块，它们共同依赖于一个抽象</li><li>抽象不能依赖于具体实现，具体实现依赖于抽象。</li></ul><p>注：又称为依赖倒置原则。这是设计模式六大原则之一。</p><p>DI，是 Dependency Injection 的缩写，即依赖注入。</p><ul><li>依赖注入是 IoC 的最常见形式。</li><li>容器全权负责的组件的装配，它会把符合依赖关系的对象通过 JavaBean 属性或者构造函数传递给需要的对象。</li></ul><p>依赖注入三种形式：1.构造器注入；2.setter 方法注入；3.接口注入</p></blockquote><h2 id="Spring-中的-IoC"><a href="#Spring-中的-IoC" class="headerlink" title="Spring 中的 IoC"></a>Spring 中的 IoC</h2><blockquote><p>BeanFactory 是 Spring IoC 容器的具体实现，用来包装和管理前面提到的各种 bean。BeanFactory 接口是 Spring IoC 容器的核心接口。IOC:把对象的创建、初始化、销毁交给 spring 来管理，而不是由开发者控制，实现控制反转。</p></blockquote><h2 id="什么是Spring的依赖注入"><a href="#什么是Spring的依赖注入" class="headerlink" title="什么是Spring的依赖注入"></a>什么是Spring的依赖注入</h2><blockquote><p>依赖注入，是IOC的一个方面，是个通常的概念，它有多种解释。这概念是说你不用创建对象，而只需要描述它如何被创建。你不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件需要哪些服务，之后一个容器（IOC容器）负责把他们组装起来。</p></blockquote><h2 id="有哪些不同类型的IOC（依赖注入）方式"><a href="#有哪些不同类型的IOC（依赖注入）方式" class="headerlink" title="有哪些不同类型的IOC（依赖注入）方式"></a>有哪些不同类型的IOC（依赖注入）方式</h2><blockquote><ul><li><strong>构造器依赖注入：</strong>构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</li><li><strong>Setter方法注入：</strong>Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。</li></ul><p>两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。</p></blockquote><h2 id="IOC容器是什么其优点"><a href="#IOC容器是什么其优点" class="headerlink" title="IOC容器是什么其优点"></a>IOC容器是什么其优点</h2><blockquote><p>Spring IOC负责创建对象、管理对象(通过依赖注入)、整合对象、配置对象以及管理这些对象的生命周期。<br>优点:<br>IOC或依赖注入减少了应用程序的代码量。它使得应用程序的测试很简单，因为在单元测试中不再需要单例或JNDI查找机制。简单的实现以及较少的干扰机制使得松耦合得以实现。IOC容器支持勤性单例及延迟加载服务。</p></blockquote><h2 id="BeanFactory和ApplicationContext有什么区别"><a href="#BeanFactory和ApplicationContext有什么区别" class="headerlink" title="BeanFactory和ApplicationContext有什么区别"></a>BeanFactory和ApplicationContext有什么区别</h2><blockquote><p>BeanFactory 包含了种 bean 的定义，以便在接收到客户端请求时将对应的 bean 实例化。BeanFactory 还能在实例化对象的时生成协作类之间的关系。BeanFactory 还包含了 bean 生命周期的控制，调用客户端的初始化方法（initialization methods）和销毁方法（destruction methods）。</p><p>ApplicationContext 扩展了 BeanFactory：1.提供了支持国际化的文本消息2.统一的资源文件读取方式3.已在监听器中注册的 bean 的事件</p><p>三种较常见的 ApplicationContext 实现：</p><ul><li><strong>FileSystemXmlApplicationContext ：</strong>此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。</li><li><strong>ClassPathXmlApplicationContext：</strong>此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。</li><li><strong>WebXmlApplicationContext：</strong>此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。</li></ul><p>如果使用ApplicationContext，如果配置的bean是singleton，那么不管你有没有或想不想用它，它都会被实例化。好处是可以预先加载，坏处是浪费内存。BeanFactory，当使用BeanFactory实例化对象时，配置的bean不会马上被实例化，而是等到你使用该bean的时候（getBean）才会被实例化。好处是节约内存，坏处是速度比较慢。多用于移动设备的开发。</p></blockquote><h2 id="Spring有几种配置方式？"><a href="#Spring有几种配置方式？" class="headerlink" title="Spring有几种配置方式？"></a>Spring有几种配置方式？</h2><blockquote><p>将Spring配置到应用开发中有以下三种方式：</p><ol><li>基于XML的配置</li><li>基于注解的配置</li><li>基于Java的配置</li></ol></blockquote><h2 id="请解释Spring-Bean的生命周期？"><a href="#请解释Spring-Bean的生命周期？" class="headerlink" title="请解释Spring Bean的生命周期？"></a>请解释Spring Bean的生命周期？</h2><p>对于普通的Java对象，当new的时候创建对象，当它没有任何引用的时候被垃圾回收机制回收。而由Spring IoC容器托管的对象，它们的生命周期完全由容器控制。Spring中每个Bean的生命周期如下：</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190420095615-102292.jpg" alt=""></p><ol><li><strong>实例化Bean：</strong>对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。对于ApplicationContext容器，当容器启动结束后，便实例化所有的bean。 容器通过获取BeanDefinition对象中的信息进行实例化。并且这一步仅仅是简单的实例化，并未进行依赖注入。 实例化对象被包装在BeanWrapper对象中，BeanWrapper提供了设置对象属性的接口，从而避免了使用反射机制设置属性。</li><li><strong>设置对象属性（依赖注入）：</strong>实例化后的对象被封装在BeanWrapper对象中，并且此时对象仍然是一个原生的状态，并没有进行依赖注入。 紧接着，Spring根据BeanDefinition中的信息进行依赖注入。并且通过BeanWrapper提供的设置属性的接口完成依赖注入。</li><li><strong>注入Aware接口：</strong>紧接着，Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给bean。</li><li><strong>BeanPostProcessor：</strong>当经过上述几个步骤后，bean对象已经被正确构造，但如果你想要对象被使用前再进行一些自定义的处理，就可以通过BeanPostProcessor接口实现。<br>该接口提供了两个函数：<ul><li>postProcessBeforeInitialzation( Object bean, String beanName ) 当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。 这个函数会先于InitialzationBean执行，因此称为前置处理。 所有Aware接口的注入就是在这一步完成的。</li><li>postProcessAfterInitialzation( Object bean, String beanName ) 当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。 这个函数会在InitialzationBean完成后执行，因此称为后置处理。</li></ul></li><li><strong>InitializingBean与init-method：</strong>当BeanPostProcessor的前置处理完成后就会进入本阶段。 InitializingBean接口只有一个函数：afterPropertiesSet()这一阶段也可以在bean正式构造完成前增加我们自定义的逻辑，但它与前置处理不同，由于该函数并不会把当前bean对象传进来，因此在这一步没办法处理对象本身，只能增加一些额外的逻辑。若要使用它，我们需要让bean实现该接口，并把要增加的逻辑写在该函数中。然后Spring会在前置处理完成后检测当前bean是否实现了该接口，并执行afterPropertiesSet函数。当然，Spring为了降低对客户代码的侵入性，给bean的配置提供了init-method属性，该属性指定了在这一阶段需要执行的函数名。Spring便会在初始化阶段执行我们设置的函数。init-method本质上仍然使用了InitializingBean接口。</li><li><strong>DisposableBean和destroy-method：</strong>和init-method一样，通过给destroy-method指定函数，就可以在bean销毁前执行指定的逻辑。</li></ol><h2 id="解释Spring支持的几种bean的作用域"><a href="#解释Spring支持的几种bean的作用域" class="headerlink" title="解释Spring支持的几种bean的作用域"></a>解释Spring支持的几种bean的作用域</h2><blockquote><p>Spring框架支持以下五种bean的作用域：</p><ul><li><strong>singleton :</strong> bean在每个Spring ioc 容器中只有一个实例。</li><li><strong>prototype</strong>：一个bean的定义可以有多个实例。</li><li><strong>request</strong>：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。</li><li><strong>session</strong>：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li><li><strong>global-session</strong>：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li></ul><p>缺省的Spring bean 的作用域是Singleton.</p></blockquote><h2 id="Spring框架中的单例Beans是线程安全的么？"><a href="#Spring框架中的单例Beans是线程安全的么？" class="headerlink" title="Spring框架中的单例Beans是线程安全的么？"></a>Spring框架中的单例Beans是线程安全的么？</h2><blockquote><p>Spring框架中的单例bean不是线程安全的。Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。最浅显的解决办法就是将多态bean的作用域由<strong>“singleton</strong>”变更为“<strong>prototype</strong>”。</p></blockquote><h2 id="请举例说明如"><a href="#请举例说明如" class="headerlink" title="请举例说明如"></a>请举例说明如</h2><h2 id="何在Spring中注入一个Java-Collection？"><a href="#何在Spring中注入一个Java-Collection？" class="headerlink" title="何在Spring中注入一个Java Collection？"></a>何在Spring中注入一个Java Collection？</h2><blockquote><p>Spring提供以下几种集合的配置元素：</p><ul><li><strong><list></list></strong> :   该标签用来装配可重复的list值。</li><li><strong><set></set></strong> :    该标签用来装配没有重复的set值。</li><li><strong><map></map></strong>:   该标签可用来注入键和值可以为任何类型的键值对。</li><li><strong><props></props></strong> : 该标签支持注入键和值都是字符串类型的键值对。</li></ul></blockquote><h2 id="什么是bean装配"><a href="#什么是bean装配" class="headerlink" title="什么是bean装配"></a>什么是bean装配</h2><blockquote><p>装配，或bean 装配是指在Spring 容器中把bean组装到一起，前提是容器需要知道bean的依赖关系，如何通过依赖注入来把它们装配到一起。</p></blockquote><h2 id="什么是bean的自动装配"><a href="#什么是bean的自动装配" class="headerlink" title="什么是bean的自动装配"></a>什么是bean的自动装配</h2><blockquote><p>Spring 容器能够自动装配相互合作的bean，这意味着容器不需要<constructor-arg>和<property>配置，能通过Bean工厂自动处理bean之间的协作。</property></constructor-arg></p></blockquote><h2 id="解释不同方式的自动装配"><a href="#解释不同方式的自动装配" class="headerlink" title="解释不同方式的自动装配"></a>解释不同方式的自动装配</h2><blockquote><p>有五种自动装配的方式，可以用来指导Spring容器用自动装配方式来进行依赖注入。</p><ul><li><strong>no</strong>：默认的方式是不进行自动装配，通过显式设置ref 属性来进行装配。</li><li><strong>byName：</strong>通过参数名 自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byname，之后容器试图匹配、装配和该bean的属性具有相同名字的bean。</li><li><strong>byType:：</strong>通过参数类型自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byType，之后容器试图匹配、装配和该bean的属性具有相同类型的bean。如果有多个bean符合条件，则抛出错误。</li><li><strong>constructor：这个方式类似于</strong>byType， 但是要提供给构造器参数，如果没有确定的带参数的构造器参数类型，将会抛出异常。</li><li><strong>autodetect：</strong>首先尝试使用constructor来自动装配，如果无法工作，则使用byType方式。</li></ul></blockquote><h2 id="自动装配有哪些局限性"><a href="#自动装配有哪些局限性" class="headerlink" title="自动装配有哪些局限性"></a>自动装配有哪些局限性</h2><blockquote><p>自动装配的局限性是：</p><ul><li><strong>重写</strong>： 你仍需用 <constructor-arg>和 <property> 配置来定义依赖，意味着总要重写自动装配。</property></constructor-arg></li><li><strong>基本数据类型</strong>：你不能自动装配简单的属性，如基本数据类型，String字符串，和类。</li><li><strong>模糊特性：</strong>自动装配不如显式装配精确，如果有可能，建议使用显式装配。</li></ul></blockquote><h2 id="什么是基于Java的Spring注解配置-给一些注解的例子"><a href="#什么是基于Java的Spring注解配置-给一些注解的例子" class="headerlink" title="什么是基于Java的Spring注解配置? 给一些注解的例子"></a>什么是基于Java的Spring注解配置? 给一些注解的例子</h2><blockquote><p>基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。以@Configuration 注解为例，它用来标记类可以当做一个bean的定义，被Spring IOC容器使用。另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。</p></blockquote><h2 id="什么是基于注解的容器配置"><a href="#什么是基于注解的容器配置" class="headerlink" title="什么是基于注解的容器配置"></a>什么是基于注解的容器配置</h2><blockquote><p>相对于XML文件，注解型的配置依赖于通过字节码元数据装配组件，而非尖括号的声明。开发者通过在相应的类，方法或属性上使用注解的方式，直接组件类中进行配置，而不是使用xml表述bean的装配关系。</p></blockquote><h2 id="Required-注解"><a href="#Required-注解" class="headerlink" title="@Required  注解"></a>@Required  注解</h2><blockquote><p>这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。</p></blockquote><h2 id="Autowired-注解"><a href="#Autowired-注解" class="headerlink" title="@Autowired 注解"></a>@Autowired 注解</h2><blockquote><p>@Autowired 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required一样，修饰setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。</p></blockquote><h2 id="Qualifier-注解"><a href="#Qualifier-注解" class="headerlink" title="@Qualifier 注解"></a>@Qualifier 注解</h2><blockquote><p>当有多个相同类型的bean却只有一个需要自动装配时，将@Qualifier 注解和@Autowire 注解结合使用以消除这种混淆，指定需要装配的确切的bean。</p></blockquote><h2 id="构造方法注入和设值注入有什么区别？"><a href="#构造方法注入和设值注入有什么区别？" class="headerlink" title="构造方法注入和设值注入有什么区别？"></a>构造方法注入和设值注入有什么区别？</h2><blockquote><p>请注意以下明显的区别：</p><ol><li>在设值注入方法支持大部分的依赖注入，如果我们仅需要注入int、string和long型的变量，我们不要用设值的方法注入。对于基本类型，如果我们没有注入的话，可以为基本类型设置默认值。在构造方法注入不支持大部分的依赖注入，因为在调用构造方法中必须传入正确的构造参数，否则的话为报错。</li><li>设值注入不会重写构造方法的值。如果我们对同一个变量同时使用了构造方法注入又使用了设置方法注入的话，那么构造方法将不能覆盖由设值方法注入的值。很明显，因为构造方法尽在对象被创建时调用。</li><li>在使用设值注入时有可能还不能保证某种依赖是否已经被注入，也就是说这时对象的依赖关系有可能是不完整的。而在另一种情况下，构造器注入则不允许生成依赖关系不完整的对象。</li><li>在设值注入时如果对象A和对象B互相依赖，在创建对象A时Spring会抛出sObjectCurrentlyInCreationException异常，因为在B对象被创建之前A对象是不能被创建的，反之亦然。所以Spring用设值注入的方法解决了循环依赖的问题，因对象的设值方法是在对象被创建之前被调用的。</li></ol></blockquote><h2 id="Spring框架中有哪些不同类型的事件？"><a href="#Spring框架中有哪些不同类型的事件？" class="headerlink" title="Spring框架中有哪些不同类型的事件？"></a>Spring框架中有哪些不同类型的事件？</h2><blockquote><p>Spring 提供了以下5中标准的事件：</p><ol><li><strong>上下文更新事件（ContextRefreshedEvent）</strong>：该事件会在ApplicationContext被初始化或者更新时发布。也可以在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。</li><li><strong>上下文开始事件（ContextStartedEvent）</strong>：当容器调用ConfigurableApplicationContext的Start()方法开始/重新开始容器时触发该事件。</li><li><strong>上下文停止事件（ContextStoppedEvent）</strong>：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。</li><li><strong>上下文关闭事件（ContextClosedEvent）</strong>：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。</li><li><strong>请求处理事件（RequestHandledEvent）</strong>：在Web应用中，当一个http请求（request）结束触发该事件。</li></ol></blockquote><h2 id="BeanFactory-和-ApplicationContext-有什么区别"><a href="#BeanFactory-和-ApplicationContext-有什么区别" class="headerlink" title="BeanFactory 和 ApplicationContext 有什么区别"></a>BeanFactory 和 ApplicationContext 有什么区别</h2><blockquote><p>BeanFactory 可以理解为含有bean集合的工厂类。BeanFactory 包含了种bean的定义，以便在接收到客户端请求时将对应的bean实例化。<br>BeanFactory还能在实例化对象的时生成协作类之间的关系。此举将bean自身与bean客户端的配置中解放出来。BeanFactory还包含了bean生命周期的控制，调用客户端的初始化方法（initializationmethods）和销毁方法（destruction methods）。<br>从表面上看，applicationcontext如同beanfactory一样具有bean定义、bean关联关系的设置，根据请求分发bean的功能。但applicationcontext在此基础上还提供了其他的功能。<br>提供了支持国际化的文本消息统一的资源文件读取方式已在监听器中注册的bean的事件</p></blockquote><h2 id="Spring-Bean-的生命周期"><a href="#Spring-Bean-的生命周期" class="headerlink" title="Spring Bean 的生命周期"></a>Spring Bean 的生命周期</h2><blockquote><p>Spring Bean的生命周期简单易懂。在一个bean实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个bean不在被调用时需要进行相关的析构操作，并从bean容器中移除。Spring bean factory 负责管理在spring容器中被创建的bean的生命周期。Bean的生命周期由两组回调（call back）方法组成。<br>初始化之后调用的回调方法。<br>销毁之前调用的回调方法。<br>Spring框架提供了以下四种方式来管理bean的生命周期事件： InitializingBean和DisposableBean回调接口<br>针对特殊行为的其他Aware接口<br>Bean配置文件中的Custom init()方法和destroy()方法<br>@PostConstruct和@PreDestroy注解方式</p></blockquote><h2 id="Spring-IOC-如何实现"><a href="#Spring-IOC-如何实现" class="headerlink" title="Spring IOC 如何实现"></a>Spring IOC 如何实现</h2><blockquote><p>Spring中的 org.springframework.beans包和org.springframework.context包构成了Spring框架IoC容器的基础。<br>BeanFactory 接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。ApplicationContex接口对BeanFactory（是一个子接口）进行了扩展，在BeanFactory的基础上添加了其他功能，比如与Spring的AOP更容易集成，也提供了处理messageresource的机制（用于国际化）、事件传播以及应用层的特别配置，比如针对Web应用的WebApplicationContext。<br>org.springframework.beans.factory.BeanFactory是SpringIoC容器的具体实现，用来包装和管理前面提到的各种bean。BeanFactory接口是Spring IoC 容器的核心接口。</p></blockquote><h2 id="说说-Spring-AOP"><a href="#说说-Spring-AOP" class="headerlink" title="说说 Spring AOP"></a>说说 Spring AOP</h2><blockquote><p>面向切面编程，在我们的应用中，经常需要做一些事情，但是这些事情与核心业务无关，比如，要记录所有update方法的执行时间时间，操作人等等信息，记录到日志，通过spring的AOP技术，就可以在不修改update的代码的情况下完成该需求。</p></blockquote><h2 id="Spring-AOP-实现原理"><a href="#Spring-AOP-实现原理" class="headerlink" title="Spring AOP 实现原理"></a>Spring AOP 实现原理</h2><blockquote><p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理。JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类。 如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</p></blockquote><h2 id="动态代理（cglib-与-JDK）"><a href="#动态代理（cglib-与-JDK）" class="headerlink" title="动态代理（cglib 与 JDK）"></a>动态代理（cglib 与 JDK）</h2><blockquote><p>JDK 动态代理类和委托类需要都实现同一个接口。也就是说只有实现了某个接口的类可以使用Java动态代理机制。但是，事实上使用中并不是遇到的所有类都会给你实现一个接口。因此，对于没有实现接口的类，就不能使用该机制。而CGLIB则可以实现对类的动态代理。</p></blockquote><h2 id="有几种不同类型的自动代理"><a href="#有几种不同类型的自动代理" class="headerlink" title="有几种不同类型的自动代理"></a>有几种不同类型的自动代理</h2><blockquote><p>BeanNameAutoProxyCreator</p><p>DefaultAdvisorAutoProxyCreator</p><p>Metadata autoproxying</p></blockquote><h2 id="AOP与OOP的区别"><a href="#AOP与OOP的区别" class="headerlink" title="AOP与OOP的区别"></a>AOP与OOP的区别</h2><blockquote><p>OOP面向对象编程，针对业务处理过程的实体及其属性和行为进行抽象封装，以获得更加清晰高效的逻辑单元划分。而AOP则是针对业务处理过程中的切面进行提取，它所面对的是处理过程的某个步骤或阶段，以获得逻辑过程的中各部分之间低耦合的隔离效果。这两种设计思想在目标上有着本质的差异。</p><p>举例：对于“雇员”这样一个业务实体进行封装，自然是OOP的任务，我们可以建立一个“Employee”类，并将“雇员”相关的属性和行为封装其中。而用AOP 设计思想对“雇员”进行封装则无从谈起。同样，对于“权限检查”这一动作片段进行划分，则是AOP的目标领域。OOP面向名次领域，AOP面向动词领域。总之AOP可以通过预编译方式和运行期动态代理实现在不修改源码的情况下，给程序动态同意添加功能的一项技术。</p></blockquote><h2 id="Aspect-切面"><a href="#Aspect-切面" class="headerlink" title="Aspect 切面"></a>Aspect 切面</h2><blockquote><p>AOP核心就是切面，它将多个类的通用行为封装成可重用的模块，该模块含有一组API提供横切功能。比如，一个日志模块可以被称作日志的AOP切面。根据需求的不同，一个应用程序可以有若干切面。在Spring AOP中，切面通过带有@Aspect注解的类实现。</p></blockquote><h2 id="Spring-事务实现方式"><a href="#Spring-事务实现方式" class="headerlink" title="Spring 事务实现方式"></a>Spring 事务实现方式</h2><blockquote><p>1、编码方式<br>所谓编程式事务指的是通过编码方式实现事务，即类似于JDBC编程实现事务管理。<br>2、声明式事务管理方式<br>声明式事务管理又有两种实现方式：基于xml配置文件的方式；另一个实在业务方法上进行@Transaction注解，将事务规则应用到业务逻辑中</p></blockquote><h2 id="Spring-事务底层原理"><a href="#Spring-事务底层原理" class="headerlink" title="Spring 事务底层原理"></a>Spring 事务底层原理</h2><blockquote><p>a、划分处理单元——IOC<br>由于spring解决的问题是对单个数据库进行局部事务处理的，具体的实现首相用spring中的IOC划分了事务处理单元。并且将对事务的各种配置放到了ioc容器中（设置事务管理器，设置事务的传播特性及隔离机制）。<br>b、AOP拦截需要进行事务处理的类<br>Spring事务处理模块是通过AOP功能来实现声明式事务处理的，具体操作（比如事务实行的配置和读取，事务对象的抽象），用TransactionProxyFactoryBean接口来使用AOP功能，生成proxy代理对象，通过TransactionInterceptor完成对代理方法的拦截，将事务处理的功能编织到拦截的方法中。读取ioc容器事务配置属性，转化为spring事务处理需要的内部数据结构（TransactionAttributeSourceAdvisor），转化为TransactionAttribute表示的数据对象。<br>c、对事物处理实现（事务的生成、提交、回滚、挂起）<br>spring委托给具体的事务处理器实现。实现了一个抽象和适配。适配的具体事务处理器：DataSource数据源支持、hibernate数据源事务处理支持、JDO数据源事务处理支持，JPA、JTA数据源事务处理支持。这些支持都是通过设计PlatformTransactionManager、AbstractPlatforTransaction一系列事务处理的支持。 为常用数据源支持提供了一系列的TransactionManager。<br>d、结合<br>PlatformTransactionManager实现了TransactionInterception接口，让其与TransactionProxyFactoryBean结合起来，形成一个Spring声明式事务处理的设计体系。</p></blockquote><h2 id="spring的事务有几种它的隔离级别和传播行为"><a href="#spring的事务有几种它的隔离级别和传播行为" class="headerlink" title="spring的事务有几种它的隔离级别和传播行为"></a>spring的事务有几种它的隔离级别和传播行为</h2><blockquote><p>声明式事务和编程式事务</p><p>隔离级别：</p><ol><li>DEFAULT(default)使用数据库默认的隔离级别</li><li>READ_UNCOMMITTED(read_uncommitted)会出现脏读，不可重复读和幻影读问题</li><li>READ_COMMITTED(read_committed)会出现重复读和幻影读</li><li>REPEATABLE_READ(repeatable_read)会出现幻影读</li><li>SERIALIZABLE(serialzable)最安全，但是代价最大，性能影响极其严重</li></ol><p>传播行为：</p><ol><li>REQUIRED(required)存在事务就融入该事务，不存在就创建事务</li><li>SUPPORTS(supports)存在事务就融入事务，不存在则不创建事务</li><li>MANDATORY(mandatory)存在事务则融入该事务，不存在，抛异常</li><li>REQUIRES_NEW(requirse_new)总是创建新事务</li><li>NOT_SUPPORTED(not_supported)存在事务则挂起，一直执行非事务操作</li><li>NEVER(never)总是执行非事务，如果当前存在事务则抛异常</li><li>NESTED(nested)嵌入式事务</li></ol></blockquote><h2 id="如何自定义注解实现功能"><a href="#如何自定义注解实现功能" class="headerlink" title="如何自定义注解实现功能"></a>如何自定义注解实现功能</h2><blockquote><p>创建自定义注解和创建一个接口相似，但是注解的interface关键字需要以@符号开头。<br>注解方法不能带有参数；<br>注解方法返回值类型限定为：基本类型、String、Enums、Annotation或者是这些类型的数组；<br>注解方法可以有默认值；<br>注解本身能够包含元注解，元注解被用来注解其它注解。</p></blockquote><h2 id="Spring-MVC-运行流程"><a href="#Spring-MVC-运行流程" class="headerlink" title="Spring MVC 运行流程"></a>Spring MVC 运行流程</h2><blockquote><p>1.spring mvc将所有的请求都提交给DispatcherServlet,它会委托应用系统的其他模块负责对请求 进行真正的处理工作。<br>2.DispatcherServlet查询一个或多个HandlerMapping,找到处理请求的Controller.<br>3.DispatcherServlet请请求提交到目标Controller<br>4.Controller进行业务逻辑处理后，会返回一个ModelAndView<br>5.Dispathcher查询一个或多个ViewResolver视图解析器,找到ModelAndView对象指定的视图对象<br>6.视图对象负责渲染返回给客户端。</p></blockquote><h2 id="Spring-MVC-启动流程"><a href="#Spring-MVC-启动流程" class="headerlink" title="Spring MVC 启动流程"></a>Spring MVC 启动流程</h2><blockquote><p>在 web.xml 文件中给SpringMVC的Servlet配置了load-on-startup,所以程序启动的时候会初始化 Spring MVC，在 HttpServletBean 中将配置的 contextConfigLocation属性设置到 Servlet 中，然后在FrameworkServlet 中创建了 WebApplicationContext,DispatcherServlet根据contextConfigLocation 配置的 classpath 下的 xml 文件初始化了Spring MVC 总的组件。</p></blockquote><h2 id="Spring-的单例实现原理"><a href="#Spring-的单例实现原理" class="headerlink" title="Spring 的单例实现原理"></a>Spring 的单例实现原理</h2><blockquote><p>Spring 对 Bean 实例的创建是采用单例注册表的方式进行实现的，而这个注册表的缓存是 ConcurrentHashMap 对象。</p></blockquote><h2 id="Spring-框架中用到了哪些设计模式"><a href="#Spring-框架中用到了哪些设计模式" class="headerlink" title="Spring 框架中用到了哪些设计模式"></a>Spring 框架中用到了哪些设计模式</h2><blockquote><p>代理模式—在AOP和remoting中被用的比较多。<br>单例模式—在spring配置文件中定义的bean默认为单例模式。<br>模板方法—用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。<br>前端控制器—Spring提供了DispatcherServlet来对请求进行分发。<br>视图帮助(View Helper)—Spring提供了一系列的JSP标签，高效宏来辅助将分散的代码整合在视图里。<br>依赖注入—贯穿于BeanFactory / ApplicationContext接口的核心理念。<br>工厂模式—BeanFactory用来创建对象的实例。</p></blockquote><h2 id="动态代理与cglib实现的区别"><a href="#动态代理与cglib实现的区别" class="headerlink" title="动态代理与cglib实现的区别"></a>动态代理与cglib实现的区别</h2><blockquote><p>• JDK动态代理只能对实现了接口的类生成代理，而不能针对类.<br>• CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法因为是继承，所以该类或方法最好不要声明成final。<br>• JDK代理是不需要以来第三方的库，只要JDK环境就可以进行代理<br>• CGLib 必须依赖于CGLib的类库，但是它需要类来实现任何接口代理的是指定的类生成一个子类，覆盖其中的方法，是一种继承.</p></blockquote><h2 id="Spring-MVC的工作原理Spring-MVC的工作原理"><a href="#Spring-MVC的工作原理Spring-MVC的工作原理" class="headerlink" title="Spring MVC的工作原理Spring MVC的工作原理"></a>Spring MVC的工作原理Spring MVC的工作原理</h2><blockquote><p>• 1 客户端的所有请求都交给前端控制器DispatcherServlet来处理，它会负责调用系统的其他模块来真正处理用户的请求。<br>• 2 DispatcherServlet收到请求后，将根据请求的信息(包括URL、HTTP协议方法、请求头、请求参数、Cookie等)以及HandlerMapping的配置找到处理该请求的Handler(任何一个对象都可以作为请求的Handler)。<br>• 3在这个地方Spring会通过HandlerAdapter对该处理进行封装。<br>• 4 HandlerAdapter是一个适配器，它用统一的接口对各种Handler中的方法进行调用。<br>• 5 Handler完成对用户请求的处理后，会返回一个ModelAndView对象给DispatcherServlet,ModelAndView顾名思义，包含了数据模型以及相应的视图的信息。<br>• 6 ModelAndView的视图是逻辑视图，DispatcherServlet还要借助ViewResolver完成从逻辑视图到真实视图对象的解析工作。<br>• 7 当得到真正的视图对象后，DispatcherServlet会利用视图对象对模型数据进行渲染。<br>• 8 客户端得到响应，可能是一个普通的HTML页面，也可以是XML或JSON字符串，还可以是一张图片或者一个PDF文件。</p></blockquote><h2 id="你分析过SpringMVC的源码吗？"><a href="#你分析过SpringMVC的源码吗？" class="headerlink" title="你分析过SpringMVC的源码吗？"></a>你分析过SpringMVC的源码吗？</h2><h3 id="1-MVC使用"><a href="#1-MVC使用" class="headerlink" title="1. MVC使用"></a>1. MVC使用</h3><blockquote><p>在研究源码之前，先来回顾以下springmvc 是如何配置的，这将能使我们更容易理解源码。</p></blockquote><h4 id="1-1-web-xml"><a href="#1-1-web-xml" class="headerlink" title="1.1 web.xml"></a>1.1 web.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mvc-dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 配置springMVC需要加载的配置文件</span></div><div class="line">        spring-dao.xml,spring-service.xml,spring-web.xml</div><div class="line">        Mybatis - &gt; spring -&gt; springmvc</div><div class="line">     --&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring/spring-*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mvc-dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 默认匹配所有的请求 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></div></pre></td></tr></table></figure><p>值的注意的是<code>contextConfigLocation</code>和<code>DispatcherServlet</code>(用此类来拦截请求)的引用和配置。</p><h4 id="1-2-spring-web-xml"><a href="#1-2-spring-web-xml" class="headerlink" title="1.2 spring-web.xml"></a>1.2 spring-web.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 配置SpringMVC --&gt;</span></div><div class="line"><span class="comment">&lt;!-- 1.开启SpringMVC注解模式 --&gt;</span></div><div class="line"><span class="comment">&lt;!-- 简化配置： </span></div><div class="line">    (1)自动注册DefaultAnootationHandlerMapping,AnotationMethodHandlerAdapter </div><div class="line">    (2)提供一些列：数据绑定，数字和日期的format @NumberFormat, @DateTimeFormat, xml,json默认读写支持 </div><div class="line">--&gt;</div><div class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 2.静态资源默认servlet配置</span></div><div class="line">    (1)加入对静态资源的处理：js,gif,png</div><div class="line">    (2)允许使用"/"做整体映射</div><div class="line"> --&gt;</div><div class="line"> <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></div><div class="line"></div><div class="line"> <span class="comment">&lt;!-- 3.配置jsp 显示ViewResolver --&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"viewClass"</span> <span class="attr">value</span>=<span class="string">"org.springframework.web.servlet.view.JstlView"</span> /&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span> /&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span> /&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"> <span class="comment">&lt;!-- 4.扫描web相关的bean --&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.xxx.fantj.web"</span> /&gt;</span></div></pre></td></tr></table></figure><p>值的注意的是<code>InternalResourceViewResolver</code>，它会在<code>ModelAndView</code>返回的试图名前面加上<code>prefix</code>前缀，在后面加载<code>suffix</code>指定后缀。</p><h3 id="SpringMvc主支源码分析"><a href="#SpringMvc主支源码分析" class="headerlink" title="SpringMvc主支源码分析"></a>SpringMvc主支源码分析</h3><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190421121846-805191.jpg" alt=""></p><p>上图流程总体来说可分为三大块：</p><ol><li><code>Map</code>的建立(并放入<code>WebApplicationContext</code>)</li><li><code>HttpRequest</code>请求中Url的请求拦截处理(DispatchServlet处理)</li><li>反射调用<code>Controller</code>中对应的处理方法，并返回视图</li></ol><p>本文将围绕这三块进行分析。</p><h4 id="1-Map的建立"><a href="#1-Map的建立" class="headerlink" title="1. Map的建立"></a>1. Map的建立</h4><blockquote><p>在容器初始化时会建立所有 url 和 Controller 的对应关系,保存到 Map中，那是如何保存的呢。</p></blockquote><h6 id="ApplicationObjectSupport-setApplicationContext方法"><a href="#ApplicationObjectSupport-setApplicationContext方法" class="headerlink" title="ApplicationObjectSupport #setApplicationContext方法"></a>ApplicationObjectSupport #setApplicationContext方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 初始化ApplicationContext</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initApplicationContext</span><span class="params">()</span> <span class="keyword">throws</span> ApplicationContextException </span>&#123;</div><div class="line">    <span class="keyword">super</span>.initApplicationContext();</div><div class="line">    detectHandlers();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h6 id="AbstractDetectingUrlHandlerMapping-detectHandlers-方法："><a href="#AbstractDetectingUrlHandlerMapping-detectHandlers-方法：" class="headerlink" title="AbstractDetectingUrlHandlerMapping #detectHandlers()方法："></a>AbstractDetectingUrlHandlerMapping #detectHandlers()方法：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 建立当前ApplicationContext 中的 所有Controller 和url 的对应关系</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">detectHandlers</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">        logger.debug(<span class="string">"Looking for URL mappings in application context: "</span> + getApplicationContext());</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 获取容器中的beanNames</span></div><div class="line">    String[] beanNames = (<span class="keyword">this</span>.detectHandlersInAncestorContexts ?</div><div class="line">            BeanFactoryUtils.beanNamesForTypeIncludingAncestors(getApplicationContext(), Object.class) :</div><div class="line">            getApplicationContext().getBeanNamesForType(Object.class));</div><div class="line">    <span class="comment">// 遍历 beanNames 并找到对应的 url</span></div><div class="line">    <span class="comment">// Take any bean name that we can determine URLs for.</span></div><div class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</div><div class="line">        <span class="comment">// 获取bean上的url(class上的url + method 上的 url)</span></div><div class="line">        String[] urls = determineUrlsForHandler(beanName);</div><div class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(urls)) &#123;</div><div class="line">            <span class="comment">// URL paths found: Let's consider it a handler.</span></div><div class="line">            <span class="comment">// 保存url 和 beanName 的对应关系</span></div><div class="line">            registerHandler(urls, beanName);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">                logger.debug(<span class="string">"Rejected bean name '"</span> + beanName + <span class="string">"': no URL paths identified"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="determineUrlsForHandler-方法："><a href="#determineUrlsForHandler-方法：" class="headerlink" title="determineUrlsForHandler()方法："></a>determineUrlsForHandler()方法：</h5><blockquote><p>该方法在不同的子类有不同的实现，我这里分析的是<code>DefaultAnnotationHandlerMapping</code>类的实现，该类主要负责处理<code>@RequestMapping</code>注解形式的声明。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 获取<span class="doctag">@RequestMaping</span>注解中的url</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">protected</span> String[] determineUrlsForHandler(String beanName) &#123;</div><div class="line">    ApplicationContext context = getApplicationContext();</div><div class="line">    Class&lt;?&gt; handlerType = context.getType(beanName);</div><div class="line">    <span class="comment">// 获取beanName 上的requestMapping</span></div><div class="line">    RequestMapping mapping = context.findAnnotationOnBean(beanName, RequestMapping.class);</div><div class="line">    <span class="keyword">if</span> (mapping != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 类上面有@RequestMapping 注解</span></div><div class="line">        <span class="keyword">this</span>.cachedMappings.put(handlerType, mapping);</div><div class="line">        Set&lt;String&gt; urls = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;();</div><div class="line">        <span class="comment">// mapping.value()就是获取@RequestMapping注解的value值</span></div><div class="line">        String[] typeLevelPatterns = mapping.value();</div><div class="line">        <span class="keyword">if</span> (typeLevelPatterns.length &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 获取Controller 方法上的@RequestMapping</span></div><div class="line">            String[] methodLevelPatterns = determineUrlsForHandlerMethods(handlerType);</div><div class="line">            <span class="keyword">for</span> (String typeLevelPattern : typeLevelPatterns) &#123;</div><div class="line">                <span class="keyword">if</span> (!typeLevelPattern.startsWith(<span class="string">"/"</span>)) &#123;</div><div class="line">                    typeLevelPattern = <span class="string">"/"</span> + typeLevelPattern;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">for</span> (String methodLevelPattern : methodLevelPatterns) &#123;</div><div class="line">                    <span class="comment">// controller的映射url+方法映射的url</span></div><div class="line">                    String combinedPattern = getPathMatcher().combine(typeLevelPattern, methodLevelPattern);</div><div class="line">                    <span class="comment">// 保存到set集合中</span></div><div class="line">                    addUrlsForPath(urls, combinedPattern);</div><div class="line">                &#125;</div><div class="line">                addUrlsForPath(urls, typeLevelPattern);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 以数组形式返回controller上的所有url</span></div><div class="line">            <span class="keyword">return</span> StringUtils.toStringArray(urls);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// controller上的@RequestMapping映射url为空串,直接找方法的映射url</span></div><div class="line">            <span class="keyword">return</span> determineUrlsForHandlerMethods(handlerType);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// controller上没@RequestMapping注解</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (AnnotationUtils.findAnnotation(handlerType, Controller.class) != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 获取controller中方法上的映射url</span></div><div class="line">        <span class="keyword">return</span> determineUrlsForHandlerMethods(handlerType);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>更深的细节代码就比较简单了，有兴趣的可以继续深入。</p><p>到这里，Controller和Url的映射就装配完成，下来就分析请求的处理过程。</p><h4 id="2-url的请求处理"><a href="#2-url的请求处理" class="headerlink" title="2. url的请求处理"></a>2. url的请求处理</h4><blockquote><p>我们在xml中配置了<code>DispatcherServlet</code>为调度器，所以我们就来看它的代码，可以<br>从名字上看出它是个<code>Servlet</code>,那么它的核心方法就是<code>doService()</code></p></blockquote><h5 id="DispatcherServlet-doService"><a href="#DispatcherServlet-doService" class="headerlink" title="DispatcherServlet #doService():"></a>DispatcherServlet #doService():</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 将DispatcherServlet特定的请求属性和委托 公开给&#123;<span class="doctag">@link</span> #doDispatch&#125;以进行实际调度。</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">        String requestUri = <span class="keyword">new</span> UrlPathHelper().getRequestUri(request);</div><div class="line">        logger.debug(<span class="string">"DispatcherServlet with name '"</span> + getServletName() + <span class="string">"' processing "</span> + request.getMethod() +</div><div class="line">                <span class="string">" request for ["</span> + requestUri + <span class="string">"]"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//在包含request的情况下保留请求属性的快照，</span></div><div class="line">    <span class="comment">//能够在include之后恢复原始属性。</span></div><div class="line">    Map&lt;String, Object&gt; attributesSnapshot = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;</div><div class="line">        logger.debug(<span class="string">"Taking snapshot of request attributes before include"</span>);</div><div class="line">        attributesSnapshot = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</div><div class="line">        Enumeration attrNames = request.getAttributeNames();</div><div class="line">        <span class="keyword">while</span> (attrNames.hasMoreElements()) &#123;</div><div class="line">            String attrName = (String) attrNames.nextElement();</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.cleanupAfterInclude || attrName.startsWith(<span class="string">"org.springframework.web.servlet"</span>)) &#123;</div><div class="line">                attributesSnapshot.put(attrName, request.getAttribute(attrName));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 使得request对象能供 handler处理和view处理 使用</span></div><div class="line">    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</div><div class="line">    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.localeResolver);</div><div class="line">    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.themeResolver);</div><div class="line">    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        doDispatch(request, response);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="comment">// 如果不为空，则还原原始属性快照。</span></div><div class="line">        <span class="keyword">if</span> (attributesSnapshot != <span class="keyword">null</span>) &#123;</div><div class="line">            restoreAttributesAfterInclude(request, attributesSnapshot);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到，它将请求拿到后，主要是给request设置了一些对象，以便于后续工作的处理(Handler处理和view处理)。比如<code>WebApplicationContext</code>，它里面就包含了我们在第一步完成的<code>controller</code>与<code>url</code>映射的信息。</p><h5 id="DispatchServlet-doDispatch"><a href="#DispatchServlet-doDispatch" class="headerlink" title="DispatchServlet # doDispatch()"></a>DispatchServlet # doDispatch()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 控制请求转发</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    HttpServletRequest processedRequest = request;</div><div class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">int</span> interceptorIndex = -<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">        ModelAndView mv;</div><div class="line">        <span class="keyword">boolean</span> errorView = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 1. 检查是否是上传文件</span></div><div class="line">            processedRequest = checkMultipart(request);</div><div class="line"></div><div class="line">            <span class="comment">// 2. 获取handler处理器，返回的mappedHandler封装了handlers和interceptors</span></div><div class="line">            mappedHandler = getHandler(processedRequest, <span class="keyword">false</span>);</div><div class="line">            <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// 返回404</span></div><div class="line">                noHandlerFound(processedRequest, response);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 获取HandlerInterceptor的预处理方法</span></div><div class="line">            HandlerInterceptor[] interceptors = mappedHandler.getInterceptors();</div><div class="line">            <span class="keyword">if</span> (interceptors != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interceptors.length; i++) &#123;</div><div class="line">                    HandlerInterceptor interceptor = interceptors[i];</div><div class="line">                    <span class="keyword">if</span> (!interceptor.preHandle(processedRequest, response, mappedHandler.getHandler())) &#123;</div><div class="line">                        triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, <span class="keyword">null</span>);</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line">                    interceptorIndex = i;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 3. 获取handler适配器 Adapter</span></div><div class="line">            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</div><div class="line">            <span class="comment">// 4. 实际的处理器处理并返回 ModelAndView 对象</span></div><div class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</div><div class="line"></div><div class="line">            <span class="comment">// Do we need view name translation?</span></div><div class="line">            <span class="keyword">if</span> (mv != <span class="keyword">null</span> &amp;&amp; !mv.hasView()) &#123;</div><div class="line">                mv.setViewName(getDefaultViewName(request));</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// HandlerInterceptor 后处理</span></div><div class="line">            <span class="keyword">if</span> (interceptors != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = interceptors.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">                    HandlerInterceptor interceptor = interceptors[i];</div><div class="line">                    <span class="comment">// 结束视图对象处理</span></div><div class="line">                    interceptor.postHandle(processedRequest, response, mappedHandler.getHandler(), mv);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">catch</span> (ModelAndViewDefiningException ex) &#123;</div><div class="line">            logger.debug(<span class="string">"ModelAndViewDefiningException encountered"</span>, ex);</div><div class="line">            mv = ex.getModelAndView();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">            Object handler = (mappedHandler != <span class="keyword">null</span> ? mappedHandler.getHandler() : <span class="keyword">null</span>);</div><div class="line">            mv = processHandlerException(processedRequest, response, handler, ex);</div><div class="line">            errorView = (mv != <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mv != <span class="keyword">null</span> &amp;&amp; !mv.wasCleared()) &#123;</div><div class="line">            render(mv, processedRequest, response);</div><div class="line">            <span class="keyword">if</span> (errorView) &#123;</div><div class="line">                WebUtils.clearErrorRequestAttributes(request);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">                logger.debug(<span class="string">"Null ModelAndView returned to DispatcherServlet with name '"</span> + getServletName() +</div><div class="line">                        <span class="string">"': assuming HandlerAdapter completed request handling"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 请求成功响应之后的方法</span></div><div class="line">        triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">        <span class="comment">// Trigger after-completion for thrown exception.</span></div><div class="line">        triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, ex);</div><div class="line">        <span class="keyword">throw</span> ex;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (Error err) &#123;</div><div class="line">        ServletException ex = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, err);</div><div class="line">        <span class="comment">// Trigger after-completion for thrown exception.</span></div><div class="line">        triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, ex);</div><div class="line">        <span class="keyword">throw</span> ex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="comment">// Clean up any resources used by a multipart request.</span></div><div class="line">        <span class="keyword">if</span> (processedRequest != request) &#123;</div><div class="line">            cleanupMultipart(processedRequest);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>该方法主要是</p><ol><li>通过request对象获取到<code>HandlerExecutionChain</code>，<code>HandlerExecutionChain</code>对象里面包含了拦截器interceptor和处理器handler。如果获取到的对象是空，则交给<code>noHandlerFound</code>返回404页面。</li><li>拦截器预处理，如果执行成功则进行3</li><li>获取handler适配器 Adapter</li><li>实际的处理器处理并返回 ModelAndView 对象</li></ol><blockquote><p>下面是该方法中的一些核心细节：</p></blockquote><p><code>DispatchServlet #doDispatch # noHandlerFound</code>核心源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">response.sendError(HttpServletResponse.SC_NOT_FOUND);</div></pre></td></tr></table></figure><p><code>DispatchServlet #doDispatch #getHandler</code>方法事实上调用的是<code>AbstractHandlerMapping #getHandler</code>方法,我贴出一个核心的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 拿到处理对象</span></div><div class="line">Object handler = getHandlerInternal(request);</div><div class="line">...</div><div class="line">String handlerName = (String) handler;</div><div class="line">handler = getApplicationContext().getBean(handlerName);</div><div class="line">...</div><div class="line"><span class="comment">// 返回HandlerExecutionChain对象</span></div><div class="line"><span class="keyword">return</span> getHandlerExecutionChain(handler, request);</div></pre></td></tr></table></figure><p>可以看到，它先从request里获取handler对象，这就证明了之前<code>DispatchServlet #doService</code>为什么要吧<code>WebApplicationContext</code>放入request请求对象中。</p><p>最终返回一个<code>HandlerExecutionChain</code>对象.</p><h4 id="3-反射调用处理请求的方法，返回结果视图"><a href="#3-反射调用处理请求的方法，返回结果视图" class="headerlink" title="3. 反射调用处理请求的方法，返回结果视图"></a>3. 反射调用处理请求的方法，返回结果视图</h4><blockquote><p>在上面的源码中，实际的处理器处理并返回 ModelAndView 对象调用的是<code>mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</code>这个方法。该方法由<code>AnnotationMethodHandlerAdapter #handle() #invokeHandlerMethod()</code>方法实现.</p></blockquote><h5 id="AnnotationMethodHandlerAdapter-handle-invokeHandlerMethod"><a href="#AnnotationMethodHandlerAdapter-handle-invokeHandlerMethod" class="headerlink" title="AnnotationMethodHandlerAdapter #handle() #invokeHandlerMethod()"></a><code>AnnotationMethodHandlerAdapter #handle() #invokeHandlerMethod()</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 获取处理请求的方法,执行并返回结果视图</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">invokeHandlerMethod</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></div><div class="line">        <span class="keyword">throws</span> Exception &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 1.获取方法解析器</span></div><div class="line">    ServletHandlerMethodResolver methodResolver = getMethodResolver(handler);</div><div class="line">    <span class="comment">// 2.解析request中的url,获取处理request的方法</span></div><div class="line">    Method handlerMethod = methodResolver.resolveHandlerMethod(request);</div><div class="line">    <span class="comment">// 3. 方法调用器</span></div><div class="line">    ServletHandlerMethodInvoker methodInvoker = <span class="keyword">new</span> ServletHandlerMethodInvoker(methodResolver);</div><div class="line">    ServletWebRequest webRequest = <span class="keyword">new</span> ServletWebRequest(request, response);</div><div class="line">    ExtendedModelMap implicitModel = <span class="keyword">new</span> BindingAwareModelMap();</div><div class="line">    <span class="comment">// 4.执行方法（获取方法的参数）</span></div><div class="line">    Object result = methodInvoker.invokeHandlerMethod(handlerMethod, handler, webRequest, implicitModel);</div><div class="line">    <span class="comment">// 5. 封装成mv视图</span></div><div class="line">    ModelAndView mav =</div><div class="line">            methodInvoker.getModelAndView(handlerMethod, handler.getClass(), result, implicitModel, webRequest);</div><div class="line">    methodInvoker.updateModelAttributes(handler, (mav != <span class="keyword">null</span> ? mav.getModel() : <span class="keyword">null</span>), implicitModel, webRequest);</div><div class="line">    <span class="keyword">return</span> mav;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个方法有两个重要的地方，分别是<code>resolveHandlerMethod</code>和<code>invokeHandlerMethod</code>。</p><h5 id="resolveHandlerMethod-方法"><a href="#resolveHandlerMethod-方法" class="headerlink" title="resolveHandlerMethod 方法"></a>resolveHandlerMethod 方法</h5><p><code>methodResolver.resolveHandlerMethod(request)</code>:获取controller类和方法上的<code>@requestMapping value</code>,与request的url进行匹配,找到处理request的controller中的方法.最终拼接的具体实现是<code>org.springframework.util.AntPathMatcher#combine</code>方法。</p><h5 id="invokeHandlerMethod方法"><a href="#invokeHandlerMethod方法" class="headerlink" title="invokeHandlerMethod方法"></a>invokeHandlerMethod方法</h5><blockquote><p>从名字就能看出来它是基于反射，那它做了什么呢。</p></blockquote><p>解析该方法上的参数,并调用该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//上面全都是为解析方法上的参数做准备</span></div><div class="line">...</div><div class="line"><span class="comment">// 解析该方法上的参数</span></div><div class="line">Object[] args = resolveHandlerArguments(handlerMethodToInvoke, handler, webRequest, implicitModel);</div><div class="line"><span class="comment">// 真正执行解析调用的方法</span></div><div class="line"><span class="keyword">return</span> doInvokeMethod(handlerMethodToInvoke, handler, args);</div></pre></td></tr></table></figure><h6 id="invokeHandlerMethod方法-resolveHandlerArguments方法"><a href="#invokeHandlerMethod方法-resolveHandlerArguments方法" class="headerlink" title="invokeHandlerMethod方法#resolveHandlerArguments方法"></a>invokeHandlerMethod方法#resolveHandlerArguments方法</h6><blockquote><p>代码有点长，我就简介下它做了什么事情吧。</p></blockquote><ul><li>如果这个方法的参数用的是注解，则解析注解拿到参数名，然后拿到request中的参数名，两者一致则进行赋值(详细代码在<code>HandlerMethodInvoker#resolveRequestParam</code>)，然后将封装好的对象放到args[]的数组中并返回。</li><li>如果这个方法的参数用的不是注解，则需要asm框架(底层是读取字节码)来帮助获取到参数名，然后拿到request中的参数名，两者一致则进行赋值，然后将封装好的对象放到args[]的数组中并返回。</li></ul><h6 id="invokeHandlerMethod方法-doInvokeMethod方法"><a href="#invokeHandlerMethod方法-doInvokeMethod方法" class="headerlink" title="invokeHandlerMethod方法#doInvokeMethod方法"></a>invokeHandlerMethod方法#doInvokeMethod方法</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">private <span class="built_in">Object</span> doInvokeMethod(Method method, <span class="built_in">Object</span> target, <span class="built_in">Object</span>[] args) throws Exception &#123;</div><div class="line">    <span class="comment">// 将一个方法设置为可调用，主要针对private方法</span></div><div class="line">    ReflectionUtils.makeAccessible(method);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 反射调用</span></div><div class="line">        <span class="keyword">return</span> method.invoke(target, args);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</div><div class="line">        ReflectionUtils.rethrowException(ex.getTargetException());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Should never get here"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>到这里,就可以对request请求中url对应的controller的某个对应方法进行调用了。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><blockquote><p>看完后脑子一定很乱，有时间的话还是需要自己动手调试一下。本文只是串一下整体思路，所以功能性的源码没有全部分析。</p></blockquote><p>其实理解这些才是最重要的。</p><ol><li>用户发送请求至前端控制器DispatcherServlet</li><li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。</li><li>处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</li><li>DispatcherServlet通过HandlerAdapter处理器适配器调用处理器</li><li>HandlerAdapter执行处理器(handler，也叫后端控制器)。</li><li>Controller执行完成返回ModelAndView</li><li>HandlerAdapter将handler执行结果ModelAndView返回给DispatcherServlet</li><li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li><li>ViewReslover解析后返回具体View对象</li><li>DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。</li><li>DispatcherServlet响应用户</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring-IOC、AOP的理解、实现的原理，以及优点&quot;&gt;&lt;a href=&quot;#Spring-IOC、AOP的理解、实现的原理，以及优点&quot; class=&quot;headerlink&quot; title=&quot;Spring IOC、AOP的理解、实现的原理，以及优点&quot;&gt;&lt;/a&gt;Sp
      
    
    </summary>
    
      <category term="基础面试题" scheme="http://swenfang.github.io/categories/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="基础面试题" scheme="http://swenfang.github.io/tags/%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>第 17 章 Spring MVC</title>
    <link href="http://swenfang.github.io/2019/04/21/Spring/%E7%AC%AC17%E7%AB%A0SpringMVC/"/>
    <id>http://swenfang.github.io/2019/04/21/Spring/第17章SpringMVC/</id>
    <published>2019-04-21T09:54:09.030Z</published>
    <updated>2019-04-21T15:05:37.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第-17-章-Spring-MVC"><a href="#第-17-章-Spring-MVC" class="headerlink" title="第 17 章 Spring MVC"></a>第 17 章 Spring MVC</h1><h2 id="Spring-MVC-的框架设计"><a href="#Spring-MVC-的框架设计" class="headerlink" title="Spring MVC 的框架设计"></a>Spring MVC 的框架设计</h2><a id="more"></a><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190421060506-224411.jpg" alt="Spring MVC 框架设计图"></p><p>其中带有阿拉伯数字的说明，是 MVC 框架运行的流程。处理请求先到达控制器（Controller），控制器的作用是进行请求分发，这样它会根据请求的内容去访问模型层（Model）；现今互联网系统中，数据主要从数据库和 NoSQL 中来，而且对于数据库而言往往还存在事务的机制，为了适应这种变化，设计者会将模型层再分成两层，即服务层（Service）和（DAO）;当控制器获取到由模型层返回的数据后，就将数据渲染到视图中，这样就能够展现给用户了。</p><h2 id="Spring-MVC-流程"><a href="#Spring-MVC-流程" class="headerlink" title="Spring MVC 流程"></a>Spring MVC 流程</h2><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190421074655-629111.jpg" alt=""></p><p>它是 Spring MVC 运行的全流程，其中图中的阿拉伯数字是其执行流程。在启用 Spring MVC 时，它开始初始化一些重要组件，如 DispactherServlet、HandlerAdapter的实现类 RequestMappingHandlerAdapter 等组件对象。关于这些组件的初始化，可以看 spring-webmvc-xxx.jar 的属性文件 DispatcherServlet.properties，它定义的对象都是在 Spring MVC 开始时就初始化，并且存放在 Spring IOC 容器中。</p><p>DispatcherServlet.properties 源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"># 国际化解析器</div><div class="line">org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver</div><div class="line"></div><div class="line"># 主题解析器</div><div class="line">org.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolver</div><div class="line"></div><div class="line"># HandlerMapping 实例</div><div class="line">org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\</div><div class="line">org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping</div><div class="line"></div><div class="line"># 处理器适配器</div><div class="line">org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\</div><div class="line">org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\</div><div class="line">org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter</div><div class="line"></div><div class="line"># 处理器异常解析器</div><div class="line">org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\</div><div class="line">org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\</div><div class="line">org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</div><div class="line"></div><div class="line"># 策略视图名称转换器，当你没有返回视图逻辑名称的时候，通过它可以生成默认的视图名称</div><div class="line">org.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator</div><div class="line"></div><div class="line"># 视图解析器</div><div class="line">org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver</div><div class="line"></div><div class="line"># FlashMap 管理器。</div><div class="line">org.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager</div></pre></td></tr></table></figure><p>首先这些组件会在 Spring MVC 得到初始化。</p><p>其次是开发控制器（Controller），代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</div><div class="line">    <span class="comment">//注入用户服务类</span></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> UserService userService = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 展示用户详情</span></div><div class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"details"</span>)</div><div class="line">    <span class="keyword">public</span> ModelAndV工ewdetails(Long工d)&#123;</div><div class="line">        <span class="comment">// 访问模型层得到数据</span></div><div class="line">        User user= userService.getUser(id); </div><div class="line">        <span class="comment">// 模型和视图</span></div><div class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</div><div class="line">        <span class="comment">// 定义模型视图</span></div><div class="line">        mv.setViewName(<span class="string">"user/details"</span>); </div><div class="line">        <span class="comment">// 加入数据模型</span></div><div class="line">        mv.addObject(<span class="string">"user"</span>,user);</div><div class="line">        <span class="comment">// 返回模型和视图</span></div><div class="line">        <span class="keyword">return</span> mv;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里的注解 @Controller 表明这是一个控制器，然后 @RequestMapping 代表请求路径和控制器（或其他方法）的映射关系，它会在Web 服务器启动 Spring MVC 时，被扫描到 HandlerMapping 的机制中存储，之后在用户发起请求被 DispatcherServlet 拦截后，通过 URI 和其他的条件，通过 HandlerMapper 机制就能找到对应的控制器（或其方法）进行响应。只是通过 HandlerMapping 返回的是一个 HandlerExecutionChain 对象，这个对象的源码如下。HandlerExecutionChain 对象包含一个处理器（handler）。这里的处理器是对控制器（controller）的包装，因为我们的控制器方法就可以读入 HTTP 和上下文的相关参数，然后再传递给控制器方法。而在控制器执行完成返回后，处理器又可以通过配置信息对控制器的返回结果进行处理。</p><p>处理器包含了控制器方法的逻辑，此外还有处理器的拦截器（interceptor），这样就能够通过拦截器进一步地增强处理器的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerExecutionChain</span> </span>&#123;</div><div class="line">    <span class="comment">// 日志</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(HandlerExecutionChain.class);</div><div class="line">    <span class="comment">// 处理器</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object handler;</div><div class="line">    <span class="comment">// 拦截器数组</span></div><div class="line">    <span class="keyword">private</span> HandlerInterceptor[] interceptors;</div><div class="line">    <span class="comment">// 拦截器列表</span></div><div class="line">    <span class="keyword">private</span> List&lt;HandlerInterceptor&gt; interceptorList;</div><div class="line">    <span class="comment">// 拦截器当前下标</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> interceptorIndex;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>得到了处理器（handler），还需要去运行，但是我们有普通HTTP请求，也有按 BeanName 的请求，甚至是 WebSocket ，所以还需要一个适配器去运行 HandlerExecutionChain 对象包含的处理器，就是 HandlerAdapter 接口定义的实现类，HttpRequestHandlerAdapter。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第-17-章-Spring-MVC&quot;&gt;&lt;a href=&quot;#第-17-章-Spring-MVC&quot; class=&quot;headerlink&quot; title=&quot;第 17 章 Spring MVC&quot;&gt;&lt;/a&gt;第 17 章 Spring MVC&lt;/h1&gt;&lt;h2 id=&quot;Spring-MVC-的框架设计&quot;&gt;&lt;a href=&quot;#Spring-MVC-的框架设计&quot; class=&quot;headerlink&quot; title=&quot;Spring MVC 的框架设计&quot;&gt;&lt;/a&gt;Spring MVC 的框架设计&lt;/h2&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://swenfang.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://swenfang.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://swenfang.github.io/2019/04/19/Solr/"/>
    <id>http://swenfang.github.io/2019/04/19/Solr/</id>
    <published>2019-04-19T14:29:23.948Z</published>
    <updated>2019-04-19T14:29:23.948Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CentOS安装JAVA环境（JDK 1.8）</title>
    <link href="http://swenfang.github.io/2019/04/19/CentOS/CentOS%E5%AE%89%E8%A3%85JAVA%E7%8E%AF%E5%A2%83/"/>
    <id>http://swenfang.github.io/2019/04/19/CentOS/CentOS安装JAVA环境/</id>
    <published>2019-04-19T14:25:20.366Z</published>
    <updated>2019-04-19T14:43:07.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CentOS安装JAVA环境（JDK-1-8）"><a href="#CentOS安装JAVA环境（JDK-1-8）" class="headerlink" title="CentOS安装JAVA环境（JDK 1.8）"></a>CentOS安装JAVA环境（JDK 1.8）</h1><h2 id="打开url选择jdk1-8下载"><a href="#打开url选择jdk1-8下载" class="headerlink" title="打开url选择jdk1.8下载"></a>打开url选择jdk1.8下载</h2><p><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="external">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p><p>我选择linux x64版本：</p><a id="more"></a><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419101241-441593.jpg" alt=""></p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419101543-831303.jpg" alt=""></p><p>下载以后通过命令检查安装包大小是否符合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -lht</div></pre></td></tr></table></figure><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419101640-785218.jpg" alt=""></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>（1）创建安装目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir /usr/local/java/</div></pre></td></tr></table></figure><p>（2）解压至安装目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -zxvf jdk-8u171-linux-x64.tar.gz -C /usr/local/java/</div></pre></td></tr></table></figure><h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><p>打开文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/profile</div></pre></td></tr></table></figure><p>在末尾添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">export JAVA_HOME=/usr/local/java/jdk1.8.0_171</div><div class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</div><div class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</div><div class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</div></pre></td></tr></table></figure><p>使环境变量生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source /etc/profile</div></pre></td></tr></table></figure><p>添加软链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ln -s /usr/local/java/jdk1.8.0_171/bin/java /usr/bin/java</div></pre></td></tr></table></figure><p>检查</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -version</div></pre></td></tr></table></figure><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419102013-808980.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CentOS安装JAVA环境（JDK-1-8）&quot;&gt;&lt;a href=&quot;#CentOS安装JAVA环境（JDK-1-8）&quot; class=&quot;headerlink&quot; title=&quot;CentOS安装JAVA环境（JDK 1.8）&quot;&gt;&lt;/a&gt;CentOS安装JAVA环境（JDK 1.8）&lt;/h1&gt;&lt;h2 id=&quot;打开url选择jdk1-8下载&quot;&gt;&lt;a href=&quot;#打开url选择jdk1-8下载&quot; class=&quot;headerlink&quot; title=&quot;打开url选择jdk1.8下载&quot;&gt;&lt;/a&gt;打开url选择jdk1.8下载&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我选择linux x64版本：&lt;/p&gt;
    
    </summary>
    
      <category term="CentOS" scheme="http://swenfang.github.io/categories/CentOS/"/>
    
    
      <category term="CentOS" scheme="http://swenfang.github.io/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>CentOS安装Tomcat</title>
    <link href="http://swenfang.github.io/2019/04/19/CentOS/CentOS%E5%AE%89%E8%A3%85Tomcat/"/>
    <id>http://swenfang.github.io/2019/04/19/CentOS/CentOS安装Tomcat/</id>
    <published>2019-04-19T14:25:20.366Z</published>
    <updated>2019-04-19T14:42:51.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CentOS安装Tomcat"><a href="#CentOS安装Tomcat" class="headerlink" title="CentOS安装Tomcat"></a>CentOS安装Tomcat</h1><h2 id="一-tomcat的简介"><a href="#一-tomcat的简介" class="headerlink" title="一.tomcat的简介"></a>一.tomcat的简介</h2><p>这是<strong>Apache Tomcat</strong> Servlet / JSP容器的文档包的顶级入口点 。的Apache Tomcat 8.0版实现了Servlet 3.1和JavaServer Pages 2.3 <a href="https://wiki.apache.org/tomcat/Specifications" target="_blank" rel="external">规范</a>从 <a href="https://www.jcp.org/" target="_blank" rel="external">Java社区进程</a>，并包含许多额外的功能，使开发和部署Web应用程序和Web服务的有用平台<br><a id="more"></a></p><h2 id="二-tomcat的安装"><a href="#二-tomcat的安装" class="headerlink" title="二.tomcat的安装"></a>二.tomcat的安装</h2><h3 id="1-tomcat下载"><a href="#1-tomcat下载" class="headerlink" title="1.tomcat下载"></a>1.tomcat下载</h3><p>官网地址：<a href="https://www.cnblogs.com/frankdeng/p/%E5%AE%98%E7%BD%91%E5%9C%B0%E5%9D%80%EF%BC%9Ahttp://tomcat.apache.org/" target="_blank" rel="external">http://tomcat.apache.org/</a></p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419094746-454034.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[admin@node21 software]$ wget http://mirrors.shu.edu.cn/apache/tomcat/tomcat-8/v8.0.53/bin/apache-tomcat-8.0.53.tar.gz</div><div class="line">[admin@node21 software]$ ll</div><div class="line">-rw-rw-r-- 1 admin admin   9455895 Jun 30 00:39 apache-tomcat-8.0.53.tar.gz</div></pre></td></tr></table></figure><h3 id="2-tomcat安装"><a href="#2-tomcat安装" class="headerlink" title="2.tomcat安装"></a>2.tomcat安装</h3><p>查看是否安装 JDK</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419094915-822740.jpg" alt=""></p><p>1）解压缩安装包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[admin@node21 software]$ tar zxvf apache-tomcat-8.0.53.tar.gz</div></pre></td></tr></table></figure><p>2）移动安装包到/usr/local/tomcat目录下，也可以不移动设置tomcat环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[admin@node21 software]$ sudo mv apache-tomcat-8.0.53 /usr/local/tomcat8</div></pre></td></tr></table></figure><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419094956-281396.jpg" alt=""></p><h3 id="3-启动tomcat"><a href="#3-启动tomcat" class="headerlink" title="3.启动tomcat"></a>3.启动tomcat</h3><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419095022-266452.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[admin@node21 bin]$ pwd</div><div class="line">/usr/local/tomcat8/bin</div><div class="line">[admin@node21 bin]$ ./startup.sh</div></pre></td></tr></table></figure><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419095051-652902.jpg" alt=""></p><h3 id="4-测试内部是否启动成功"><a href="#4-测试内部是否启动成功" class="headerlink" title="4.测试内部是否启动成功"></a>4.测试内部是否启动成功</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl &quot;http://47.106.180.186:8089/&quot;</div></pre></td></tr></table></figure><p><img src="C:\Users\shenwenfang\AppData\Roaming\Typora\typora-user-images\1555682470740.png" alt="1555682470740"></p><h3 id="5-WebUI访问"><a href="#5-WebUI访问" class="headerlink" title="5.WebUI访问"></a>5.WebUI访问</h3><p>tomcat默认端口8080，访问地址：<a href="http://47.106.180.186:8089/" target="_blank" rel="external">http://47.106.180.186:8089/</a>，默认页面如下</p><p><img src="C:\Users\shenwenfang\AppData\Roaming\Typora\typora-user-images\1555682033090.png" alt="1555682033090"></p><h3 id="6-停止tomcat"><a href="#6-停止tomcat" class="headerlink" title="6.停止tomcat"></a>6.停止tomcat</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[admin@node21 webapps]$ /usr/local/tomcat8/bin/shutdown.sh</div></pre></td></tr></table></figure><h2 id="三-Tomcat服务部署web应用"><a href="#三-Tomcat服务部署web应用" class="headerlink" title="三.Tomcat服务部署web应用"></a>三.Tomcat服务部署web应用</h2><p><strong>第一种方式：利用Tomcat自动部署</strong></p><p>​        利用Tomcat自动部署方式是最简单的、最常用的方式。若一个web应用结构为<strong>D:\workspace\WebApp\AppName\WEB-INF*，只要将一个Web应用的WebContent级的AppName</strong>直接扔进%Tomcat_Home%\webapps文件夹下，系统会把该web应用直接部署到Tomcat中。<strong>所以这里不再赘述</strong></p><p><strong>第二种方式：手动部署修改%Tomcat_Home%\conf\server.xml文件来部署web应用</strong></p><p>打开<strong>%Tomcat_Home%\conf\server.xml</strong>文件并在其中<host>标签里增加以下元素：</host></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Context docBase=&quot;D:\workspace\WebApp\AppName&quot; path=&quot;/XXX&quot; debug=&quot;0&quot; reloadable=&quot;false&quot; /&gt;</div></pre></td></tr></table></figure><p>然后启动Tomcat即可。</p><p><code>注意：</code></p><p>​      （1）以上代码中的<strong>workDir</strong>表示将该Web应用部署后置于的工作目录（Web应用中JSP编译成的Servlet都可在其中找到）。如果自定义web部署文件XXX.xml中未指明workdir，则web应用将默认部署在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%Tomcat_Home%\work\Catalina\localhost</div></pre></td></tr></table></figure><p>路径下新建的以XXX命名的文件夹下。（Web应用中JSP编译成的Servlet都可在其中找到）</p><p>​      （2）<strong>Context path</strong>即指定web应用的虚拟路径名。<strong>docBase</strong>指定要部署的Web应用的源路径。</p><h2 id="四-解决中文乱码及测试访问页"><a href="#四-解决中文乱码及测试访问页" class="headerlink" title="四.解决中文乱码及测试访问页"></a>四.解决中文乱码及测试访问页</h2><h3 id="1-测试修改访问页面"><a href="#1-测试修改访问页面" class="headerlink" title="1.测试修改访问页面"></a>1.测试修改访问页面</h3><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419100432-389841.jpg" alt=""></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello,世界!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><p>再次启动tomcat，输入：<a href="http://47.106.180.186:8089/hello/index.html，出现下图，发现有中文乱码现象。" target="_blank" rel="external">http://47.106.180.186:8089/hello/index.html，出现下图，发现有中文乱码现象。</a></p><h3 id="2-解决中文乱码"><a href="#2-解决中文乱码" class="headerlink" title="2.解决中文乱码"></a>2.解决中文乱码</h3><p>乱码原因：tomcat8之前，URL中参数的默认解码是ISO-8859-1，而tomcat8的默认解码为utf-8。ISO-8859-1并未包括中文字符，中文字符不能被正确解析了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CentOS安装Tomcat&quot;&gt;&lt;a href=&quot;#CentOS安装Tomcat&quot; class=&quot;headerlink&quot; title=&quot;CentOS安装Tomcat&quot;&gt;&lt;/a&gt;CentOS安装Tomcat&lt;/h1&gt;&lt;h2 id=&quot;一-tomcat的简介&quot;&gt;&lt;a href=&quot;#一-tomcat的简介&quot; class=&quot;headerlink&quot; title=&quot;一.tomcat的简介&quot;&gt;&lt;/a&gt;一.tomcat的简介&lt;/h2&gt;&lt;p&gt;这是&lt;strong&gt;Apache Tomcat&lt;/strong&gt; Servlet / JSP容器的文档包的顶级入口点 。的Apache Tomcat 8.0版实现了Servlet 3.1和JavaServer Pages 2.3 &lt;a href=&quot;https://wiki.apache.org/tomcat/Specifications&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;规范&lt;/a&gt;从 &lt;a href=&quot;https://www.jcp.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java社区进程&lt;/a&gt;，并包含许多额外的功能，使开发和部署Web应用程序和Web服务的有用平台&lt;br&gt;
    
    </summary>
    
      <category term="CentOS" scheme="http://swenfang.github.io/categories/CentOS/"/>
    
    
      <category term="CentOS" scheme="http://swenfang.github.io/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>CentOS搭建Solr7单机服务</title>
    <link href="http://swenfang.github.io/2019/04/19/CentOS/CentOS%E6%90%AD%E5%BB%BASolr7%20%E5%8D%95%E6%9C%BA%E6%9C%8D%E5%8A%A1/"/>
    <id>http://swenfang.github.io/2019/04/19/CentOS/CentOS搭建Solr7 单机服务/</id>
    <published>2019-04-19T14:25:20.346Z</published>
    <updated>2019-04-20T13:36:23.801Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CentOS搭建Solr7单机服务"><a href="#CentOS搭建Solr7单机服务" class="headerlink" title="CentOS搭建Solr7单机服务"></a>CentOS搭建Solr7单机服务</h1><h2 id="一-Solr安装环境"><a href="#一-Solr安装环境" class="headerlink" title="一.Solr安装环境"></a>一.Solr安装环境</h2><h3 id="1-官方参考文档"><a href="#1-官方参考文档" class="headerlink" title="1.官方参考文档"></a>1.官方参考文档</h3><p>Solr教程参考指南：<a href="http://lucene.apache.org/solr/guide/7_4/solr-tutorial.html" target="_blank" rel="external">http://lucene.apache.org/solr/guide/7_4/solr-tutorial.html</a></p><a id="more"></a><h3 id="2-Solr运行环境"><a href="#2-Solr运行环境" class="headerlink" title="2.Solr运行环境"></a>2.Solr运行环境</h3><p>系统要求：Java 8+      这里我们把solr服务部署到Tomacat服务器中，Tomcat安装过程参考：<a href="https://swenfang.github.io/2019/04/19/CentOS/CentOS安装Tomcat/">https://swenfang.github.io/2019/04/19/CentOS/CentOS安装Tomcat/</a></p><p><strong>在solr5以前solr的启动都有tomcat作为容器，但是从solr5以后solr内部集成jetty服务器，可以通过bin目录中脚本直接启动。就是从solr5以后跟solr4最大的区别是被发布成一个独立的应用。</strong></p><h3 id="3-Solr下载"><a href="#3-Solr下载" class="headerlink" title="3.Solr下载"></a>3.Solr下载</h3><p> 下载地址：<a href="http://archive.apache.org/dist/lucene/solr/" target="_blank" rel="external">http://archive.apache.org/dist/lucene/solr/</a></p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419093633-377825.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[admin@node21 software]$ wget http://archive.apache.org/dist/lucene/solr/7.4.0/solr-7.4.0.tgz</div><div class="line">[admin@node21 software]$ ll</div><div class="line">-rw-rw-r-- 1 admin admin 167346886 Jun 19 02:51 solr-7.4.0.tgz</div></pre></td></tr></table></figure><h2 id="二-Solr单机安装"><a href="#二-Solr单机安装" class="headerlink" title="二.Solr单机安装"></a>二.Solr单机安装</h2><h3 id="1-解压安装包"><a href="#1-解压安装包" class="headerlink" title="1. 解压安装包"></a>1. 解压安装包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[admin@node21 software]$ tar zxvf solr-7.4.0.tgz </div><div class="line">[admin@node21 software]$ ls solr-7.4.0</div><div class="line">bin CHANGES.txt contrib dist docs example licenses LICENSE.txt LUCENE_CHANGES.txt NOTICE.txt README.txt server</div></pre></td></tr></table></figure><h3 id="2-部署solr到tomcat下"><a href="#2-部署solr到tomcat下" class="headerlink" title="2.部署solr到tomcat下"></a>2.部署solr到tomcat下</h3><p>注意，这里因为我用的是solr7.4最新版，所以跟solr4版本要拷贝*.war文件，然后再启动tomcat解压的操作是不一样的 ，</p><p><strong>1）复制并重命名solr目录里的server/solr-webapp/webapp文件夹到/usr/local/tomcat8/webapps/solr</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[admin@node21 software]$ sudo cp -r solr-7.4.0/server/solr-webapp/webapp /usr/local/tomcat8/webapps/solr</div></pre></td></tr></table></figure><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419093852-618647.jpg" alt=""></p><p><strong>2）拷贝solr-7.4.0\server\lib\ext 下的jar包以及lib目录下gmetric4j-1.0.7.jar和metrics开头的jar包拷贝到 tomcat8\webapps\solr 项目的WEB-INF\lib下</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[admin@node21 software]$ sudo cp solr-7.4.0/server/lib/ext/* /usr/local/tomcat8/webapps/solr/WEB-INF/lib/</div><div class="line">[admin@node21 software]$ sudo cp solr-7.4.0/server/lib/gmetric4j-1.0.7.jar /usr/local/tomcat8/webapps/solr/WEB-INF/lib/</div><div class="line">[admin@node21 software]$ sudo cp solr-7.4.0/server/lib/metrics-*  /usr/local/tomcat8/webapps/solr/WEB-INF/lib/</div></pre></td></tr></table></figure><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419093937-207098.jpg" alt=""></p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419093955-399271.jpg" alt=""></p><p>3）<strong>创建一个索引库solrhome</strong></p><p>拷贝solr-7.4.0\server 下的solr文件夹到其它非中文目录下，重命名为solrhome，我是建立到了/usr/local/tomcat8/solrhome下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[admin@node21 software]$ sudo cp -r solr-7.4.0/server/solr /usr/local/tomcat8/solrhome</div></pre></td></tr></table></figure><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419094030-250401.jpg" alt=""></p><p>4）<strong>关联solr及索引库solrhome，</strong>需要修改tomcat里solr工程的web.xml文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[admin@node21 software]$ sudo vi /usr/local/tomcat8/webapps/solr/WEB-INF/web.xml</div></pre></td></tr></table></figure><p>找到如下代码，打开注释，修改自己的solrhome的路径/put/your/solr/home/here，我的是 /usr/local/tomcat8/solrhome 路径。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--</span></div><div class="line">  &lt;env-entry&gt;</div><div class="line">     &lt;env-entry-name&gt;solr/home&lt;/env-entry-name&gt;</div><div class="line">     &lt;env-entry-value&gt;/put/your/solr/home/here&lt;/env-entry-value&gt;</div><div class="line">     &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt;</div><div class="line">  &lt;/env-entry&gt;</div><div class="line"> --&gt;</div></pre></td></tr></table></figure><p>如下图：</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419094153-478365.jpg" alt=""></p><p>然后到最下方，将这一段注释掉，不然会报403错误，完成后保存退出（solr4部署不用注释这个）</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419094222-739442.jpg" alt=""></p><p><strong>5）拷贝solr7.4.0\server\resources下的</strong> log4j2.xml <strong>到tomcat8/webapps/solr/WEB-INF\classes，如果WEB-INF下没有classes文件那么就创建一个classes文件夹</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[admin@node21 tomcat8]$ sudo mkdir -p /usr/local/tomcat8/webapps/solr/WEB-INF/classes/</div><div class="line">[admin@node21 tomcat8]$ sudo cp -r /opt/software/solr-7.4.0/server/resources/log4j2.xml /usr/local/tomcat8/webapps/solr/WEB-INF/classes/</div></pre></td></tr></table></figure><p><strong>6）修改tomcat的bin目录下catalina.bat脚本，增加solr.log.dir系统变量，指定solr日志记录存放地址。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@node21 solr]# vi /usr/local/tomcat8/bin/catalina.sh </div><div class="line">JAVA_OPTS=&quot;$JAVA_OPTS -Dsolr.log.dir=/usr/local/tomcat8/solrhome/logs&quot;</div></pre></td></tr></table></figure><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419094314-214585.jpg" alt=""></p><h3 id="3-启动服务"><a href="#3-启动服务" class="headerlink" title="3.启动服务"></a>3.启动服务</h3><p>启动tomcat，访问需要完整路径，我的是 <a href="http://47.106.180.186:8089/solr/index.html" target="_blank" rel="external">http://47.106.180.186:8089/solr/index.html</a></p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419094507-951150.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CentOS搭建Solr7单机服务&quot;&gt;&lt;a href=&quot;#CentOS搭建Solr7单机服务&quot; class=&quot;headerlink&quot; title=&quot;CentOS搭建Solr7单机服务&quot;&gt;&lt;/a&gt;CentOS搭建Solr7单机服务&lt;/h1&gt;&lt;h2 id=&quot;一-Solr安装环境&quot;&gt;&lt;a href=&quot;#一-Solr安装环境&quot; class=&quot;headerlink&quot; title=&quot;一.Solr安装环境&quot;&gt;&lt;/a&gt;一.Solr安装环境&lt;/h2&gt;&lt;h3 id=&quot;1-官方参考文档&quot;&gt;&lt;a href=&quot;#1-官方参考文档&quot; class=&quot;headerlink&quot; title=&quot;1.官方参考文档&quot;&gt;&lt;/a&gt;1.官方参考文档&lt;/h3&gt;&lt;p&gt;Solr教程参考指南：&lt;a href=&quot;http://lucene.apache.org/solr/guide/7_4/solr-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://lucene.apache.org/solr/guide/7_4/solr-tutorial.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="CentOS" scheme="http://swenfang.github.io/categories/CentOS/"/>
    
    
      <category term="CentOS" scheme="http://swenfang.github.io/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>Java 内存区域与内存溢出异常</title>
    <link href="http://swenfang.github.io/2019/04/09/Java%20JVM/Java%20%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>http://swenfang.github.io/2019/04/09/Java JVM/Java 程序的运行机制/</id>
    <published>2019-04-09T13:38:01.763Z</published>
    <updated>2019-04-10T05:35:29.590Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-内存区域与内存溢出异常"><a href="#Java-内存区域与内存溢出异常" class="headerlink" title="Java 内存区域与内存溢出异常"></a>Java 内存区域与内存溢出异常</h1><p>对于 Java 程序员来说，把内存控制权力给了 Java 虚拟机，一旦出现了内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会成为一项异常艰难的工作。</p><a id="more"></a><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。java 虚拟机所管理的内存将会包括以下几个运行时数据区域：</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190409105825-592554.jpg" alt=""></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器是一块较小的内存，它可以看成当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-内存区域与内存溢出异常&quot;&gt;&lt;a href=&quot;#Java-内存区域与内存溢出异常&quot; class=&quot;headerlink&quot; title=&quot;Java 内存区域与内存溢出异常&quot;&gt;&lt;/a&gt;Java 内存区域与内存溢出异常&lt;/h1&gt;&lt;p&gt;对于 Java 程序员来说，把内存控制权力给了 Java 虚拟机，一旦出现了内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会成为一项异常艰难的工作。&lt;/p&gt;
    
    </summary>
    
      <category term="Java JVM" scheme="http://swenfang.github.io/categories/Java-JVM/"/>
    
    
      <category term="Java JVM" scheme="http://swenfang.github.io/tags/Java-JVM/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之ThreadLocal、Volatile、synchronized、Atomic关键字</title>
    <link href="http://swenfang.github.io/2019/04/08/java%20%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BThreadLocal%E3%80%81Volatile%E3%80%81synchronized%E3%80%81Atomic%E5%85%B3%E9%94%AE%E5%AD%97%E6%89%AB%E7%9B%B2/"/>
    <id>http://swenfang.github.io/2019/04/08/java 源码解读/并发编程之ThreadLocal、Volatile、synchronized、Atomic关键字扫盲/</id>
    <published>2019-04-08T14:53:15.275Z</published>
    <updated>2019-04-08T14:52:18.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程之ThreadLocal、Volatile、synchronized、Atomic关键字"><a href="#并发编程之ThreadLocal、Volatile、synchronized、Atomic关键字" class="headerlink" title="并发编程之ThreadLocal、Volatile、synchronized、Atomic关键字"></a>并发编程之ThreadLocal、Volatile、synchronized、Atomic关键字</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>对于ThreadLocal、Volatile、synchronized、Atomic这四个关键字，我想一提及到大家肯定都想到的是解决在多线程并发环境下资源的共享问题，但是要细说每一个的特点、区别、应用场景、内部实现等，却可能模糊不清，说不出个所以然来，所以，本文就对这几个关键字做一些作用、特点、实现上的讲解。</p><a id="more"></a><h2 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a><strong>Atomic</strong></h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h3><p>对于原子操作类，Java的concurrent并发包中主要为我们提供了这么几个常用的：AtomicInteger、AtomicLong、AtomicBoolean、AtomicReference&lt;<strong>T</strong>&gt;。<br>对于原子操作类，最大的特点是在多线程并发操作同一个资源的情况下，使用Lock-Free算法来替代锁，这样开销小、速度快，对于原子操作类是采用原子操作指令实现的，从而可以保证操作的原子性。什么是原子性？比如一个操作i++；实际上这是三个原子操作，先把i的值读取、然后修改(+1)、最后写入给i。所以使用Atomic原子类操作数，比如：i++；那么它会在这步操作都完成情况下才允许其它线程再对它进行操作，而这个实现则是通过Lock-Free+原子操作指令来确定的<br>如：<br>AtomicInteger类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">int</span> current = get();</div><div class="line">        <span class="keyword">int</span> next = current + <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (compareAndSet(current, next))</div><div class="line">            <span class="keyword">return</span> next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>而关于Lock-Free算法，则是一种新的策略替代锁来保证资源在并发时的完整性的，Lock-Free的实现有三步：</p><blockquote><p>1、循环（for(;;)、while）<br>2、CAS（CompareAndSet）<br>3、回退（return、break）</p></blockquote><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a><strong>用法</strong></h3><p>比如在多个线程操作一个count变量的情况下，则可以把count定义为AtomicInteger，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> count.get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</div><div class="line">        count.incrementAndGet();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在每个线程中通过increment()来对count进行计数增加的操作，或者其它一些操作。这样每个线程访问到的将是安全、完整的count。</p><h3 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a><strong>内部实现</strong></h3><p>采用Lock-Free算法替代锁+原子操作指令实现并发情况下资源的安全、完整、一致性</p><h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a><strong>Volatile</strong></h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a><strong>作用</strong></h3><p>Volatile可以看做是一个轻量级的synchronized，它可以在多线程并发的情况下保证变量的“可见性”，什么是可见性？就是在一个线程的工作内存中修改了该变量的值，该变量的值立即能回显到主内存中，从而保证所有的线程看到这个变量的值是一致的。所以在处理同步问题上它大显作用，而且它的开销比synchronized小、使用成本更低。 举个栗子：在写单例模式中，除了用静态内部类外，还有一种写法也非常受欢迎，就是Volatile+DCL：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</div><div class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">                    instance = <span class="keyword">new</span> Singleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样单例不管在哪个线程中创建的，所有线程都是共享这个单例的。</p><p>虽说这个Volatile关键字可以解决多线程环境下的同步问题，不过这也是相对的，因为它不具有操作的原子性，也就是它不适合在对该变量的写操作依赖于变量本身自己。举个最简单的栗子：在进行计数操作时count++，实际是count=count+1;，count最终的值依赖于它本身的值。所以使用volatile修饰的变量在进行这么一系列的操作的时候，就有并发的问题 举个栗子：因为它不具有操作的原子性，有可能1号线程在即将进行写操作时count值为4；而2号线程就恰好获取了写操作之前的值4，所以1号线程在完成它的写操作后count值就为5了，而在2号线程中count的值还为4，即使2号线程已经完成了写操作count还是为5，而我们期望的是count最终为6，所以这样就有并发的问题。而如果count换成这样：count=num+1；假设num是同步的，那么这样count就没有并发的问题的，只要最终的值不依赖自己本身。</p><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a><strong>用法</strong></h3><p>因为volatile不具有操作的原子性，所以如果用volatile修饰的变量在进行依赖于它自身的操作时，就有并发问题，如：count，像下面这样写在并发环境中是达不到任何效果的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>而要想count能在并发环境中保持数据的一致性，则可以在increment()中加synchronized同步锁修饰，改进后的为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a><strong>内部实现</strong></h3><p>汇编指令实现<br>可以看这篇详细了解：<a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.infoq.com%2Fcn%2Farticles%2Fftf-java-volatile" target="_blank" rel="external">Volatile实现原理</a></p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a><strong>synchronized</strong></h2><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a><strong>作用</strong></h3><p>synchronized叫做同步锁，是Lock的一个简化版本，由于是简化版本，那么性能肯定是不如Lock的，不过它操作起来方便，只需要在一个方法或把需要同步的代码块包装在它内部，那么这段代码就是同步的了，所有线程对这块区域的代码访问必须先持有锁才能进入，否则则拦截在外面等待正在持有锁的线程处理完毕再获取锁进入，正因为它基于这种阻塞的策略，所以它的性能不太好，但是由于操作上的优势，只需要简单的声明一下即可，而且被它声明的代码块也是具有操作的原子性。</p><h3 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a><strong>用法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</div><div class="line">        count++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (Counte.class)&#123;</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="内部实现-2"><a href="#内部实现-2" class="headerlink" title="内部实现"></a><strong>内部实现</strong></h3><p>重入锁ReentrantLock+一个Condition，所以说是Lock的简化版本，因为一个Lock往往可以对应多个Condition</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a><strong>ThreadLocal</strong></h2><h3 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a><strong>作用</strong></h3><p>关于ThreadLocal，这个类的出现并不是用来解决在多线程并发环境下资源的共享问题的，它和其它三个关键字不一样，其它三个关键字都是从线程外来保证变量的一致性，这样使得多个线程访问的变量具有一致性，可以更好的体现出资源的共享。</p><p>而ThreadLocal的设计，<strong>并不是解决资源共享的问题</strong>，而是用来提供线程内的局部变量，这样每个线程都自己管理自己的局部变量，别的线程操作的数据不会对我产生影响，互不影响，所以不存在解决资源共享这么一说，如果是解决资源共享，那么其它线程操作的结果必然我需要获取到，而ThreadLocal则是自己管理自己的，相当于封装在Thread内部了，供线程自己管理。</p><h3 id="用法-3"><a href="#用法-3" class="headerlink" title="用法"></a><strong>用法</strong></h3><p>一般使用ThreadLocal，官方建议我们定义为private static ，至于为什么要定义成静态的，这和内存泄露有关，后面再讲。 它有三个暴露的方法，set、get、remove。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;String&gt;()&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> String <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"hello"</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.num = num;</div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            threadLocal.set(String.valueOf(num));</div><div class="line">            System.out.println(<span class="string">"threadLocalValue:"</span>+threadLocal.get());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable(<span class="number">1</span>));</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable(<span class="number">2</span>));</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable(<span class="number">3</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果如下，这些ThreadLocal变量属于线程内部管理的，互不影响：</p><blockquote><p>threadLocalValue:2<br>threadLocalValue:3<br>threadLocalValue:4</p></blockquote><p>对于get方法，在ThreadLocal没有set值得情况下，默认返回null，所有如果要有一个初始值我们可以重写initialValue()方法，在没有set值得情况下调用get则返回初始值。</p><p><strong>值得注意的一点</strong>：ThreadLocal在线程使用完毕后，我们应该手动调用remove方法，移除它内部的值，这样可以防止内存泄露，当然还有设为static。</p><h3 id="内部实现-3"><a href="#内部实现-3" class="headerlink" title="内部实现"></a><strong>内部实现</strong></h3><p>ThreadLocal内部有一个静态类ThreadLocalMap，使用到ThreadLocal的线程会与ThreadLocalMap绑定，维护着这个Map对象，而这个ThreadLocalMap的作用是映射当前ThreadLocal对应的值，它key为当前ThreadLocal的弱引用：WeakReference</p><h4 id="内存泄露问题"><a href="#内存泄露问题" class="headerlink" title="内存泄露问题"></a><strong>内存泄露问题</strong></h4><p>对于ThreadLocal，一直涉及到内存的泄露问题，即当该线程不需要再操作某个ThreadLocal内的值时，应该手动的remove掉，为什么呢？我们来看看ThreadLocal与Thread的联系图：<br>此图来自网络：<br><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190407051647-962899.jpg" alt=""></p><p>其中虚线表示弱引用，从该图可以看出，一个Thread维持着一个ThreadLocalMap对象，而该Map对象的key又由提供该value的ThreadLocal对象弱引用提供，所以这就有这种情况： 如果ThreadLocal不设为static的，由于Thread的生命周期不可预知，这就导致了当系统gc时将会回收它，而ThreadLocal对象被回收了，此时它对应key必定为null，这就导致了该key对应得value拿不出来了，而value之前被Thread所引用，所以就存在key为null、value存在强引用导致这个Entry回收不了，从而导致内存泄露。</p><p>所以避免内存泄露的方法，是对于ThreadLocal要设为static静态的，除了这个，还必须在线程不使用它的值是手动remove掉该ThreadLocal的值，这样Entry就能够在系统gc的时候正常回收，而关于ThreadLocalMap的回收，会在当前Thread销毁之后进行回收。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><blockquote><p>关于Volatile关键字具有可见性，但不具有操作的原子性，而synchronized比volatile对资源的消耗稍微大点，但可以保证变量操作的原子性，保证变量的一致性，最佳实践则是二者结合一起使用。</p></blockquote><p>1、对于synchronized的出现，是解决多线程资源共享的问题，同步机制采用了“以时间换空间”的方式：访问串行化，对象共享化。同步机制是提供一份变量，让所有线程都可以访问。</p><p>2、对于Atomic的出现，是通过原子操作指令+Lock-Free完成，从而实现非阻塞式的并发问题。</p><p>3、对于Volatile，为多线程资源共享问题解决了部分需求，在非依赖自身的操作的情况下，对变量的改变将对任何线程可见。</p><p>4、对于ThreadLocal的出现，并不是解决多线程资源共享的问题，而是用来提供线程内的局部变量，省去参数传递这个不必要的麻烦，ThreadLocal采用了“以空间换时间”的方式：访问并行化，对象独享化。ThreadLocal是为每一个线程都提供了一份独有的变量，各个线程互不影响。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;并发编程之ThreadLocal、Volatile、synchronized、Atomic关键字&quot;&gt;&lt;a href=&quot;#并发编程之ThreadLocal、Volatile、synchronized、Atomic关键字&quot; class=&quot;headerlink&quot; title=&quot;并发编程之ThreadLocal、Volatile、synchronized、Atomic关键字&quot;&gt;&lt;/a&gt;并发编程之ThreadLocal、Volatile、synchronized、Atomic关键字&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;对于ThreadLocal、Volatile、synchronized、Atomic这四个关键字，我想一提及到大家肯定都想到的是解决在多线程并发环境下资源的共享问题，但是要细说每一个的特点、区别、应用场景、内部实现等，却可能模糊不清，说不出个所以然来，所以，本文就对这几个关键字做一些作用、特点、实现上的讲解。&lt;/p&gt;
    
    </summary>
    
      <category term="Java 源码解读" scheme="http://swenfang.github.io/categories/Java-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
    
      <category term="Java 源码解读" scheme="http://swenfang.github.io/tags/Java-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>第16章任务调度和异步执行器</title>
    <link href="http://swenfang.github.io/2019/04/04/Spring/%E7%AC%AC16%E7%AB%A0%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%92%8C%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E5%99%A8/"/>
    <id>http://swenfang.github.io/2019/04/04/Spring/第16章任务调度和异步执行器/</id>
    <published>2019-04-04T13:41:51.683Z</published>
    <updated>2019-04-20T12:49:00.072Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第16章任务调度和异步执行器"><a href="#第16章任务调度和异步执行器" class="headerlink" title="第16章任务调度和异步执行器"></a>第16章任务调度和异步执行器</h1><a id="more"></a><h2 id="任务调度概述"><a href="#任务调度概述" class="headerlink" title="任务调度概述"></a>任务调度概述</h2><h2 id="Quartz快速进阶"><a href="#Quartz快速进阶" class="headerlink" title="Quartz快速进阶"></a>Quartz快速进阶</h2><h3 id="Quartz-基础结构"><a href="#Quartz-基础结构" class="headerlink" title="Quartz 基础结构"></a>Quartz 基础结构</h3><ul><li>[ ] Job：开发者通过实现该接口来定义需要执行的的任务。Job 运行时的信息都保存在 JobDataMap 实例中。</li><li>[ ] JobDetail：描述 Job 的实现类及其他相关的静态信息，如 Job 名称、描述、关联监听器等信息。</li><li>[ ] Trigger：是一个类，描述触发 Job 执行的时间触发规则。 主要有 SimpleTrigger 和 CronTrigger 这两个子类。当仅需要触发一次或者以固定间隔周期性执行时，SimpleTrigger 是最合适的选择；而 CronTrigger 则可以通过表达式定义出各种复杂的调度方案，如每天早晨 9:00 执行，每周一，周三，周五下午 5:00 执行等。 </li><li>[ ] Calendar：是一些日历特定时间点的集合</li><li>[ ] Scheduler：代表一个 Quartz 的独立运行容器。</li><li>[ ] ThreadPool：Scheduler 使用一个线程池作为任务运行的基础设施，任务通过共享线程池的线程来提高运行效率。</li></ul><p>如下图，描述了 Scheduler 的内部组件结构。SchedulerContext 提供了 Scheduler 全局可见的上下文信息，每个任务都对应一个 JobDataMap ，虚线框中的 JobDataMap 表示有状态的任务。</p><p>一个 Scheduler 可以拥有多个 Trigger 和多个 JobDetail ，它们可以分到不同的组中。在注册 Trigger 和 JobDetail 时，如果不显示指定所属的组，那么 Scheduler 将放到默认的组中，默认的组名为 Scheduler.DEFAULT_GROUP。组名和名称组成了对象的全名，同一类型对象（Job 或 Trigger）的全名不能相同。</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190405022855-962145.jpg" alt=""></p><p>Scheduler 本身就是一个容器，它维护者 Quartz 的各种组件并实施调度的规则。Scheduler 还拥有一个线程池，线程池为任务提供执行线程。这比执行任务时简单的创建一个新的线程要拥有更高的效率，同时通过共享机制可以较少资源的占用。基于线程池组件的支持，对于繁忙度高、压力大的任务调度，Quartz 可以提供良好的伸缩性。</p><h3 id="使用Simple-Trigger"><a href="#使用Simple-Trigger" class="headerlink" title="使用Simple Trigger"></a>使用Simple Trigger</h3><p>SImpleTrigger 拥有多个重载的构造函数，用于在不同场合下构造对应的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleTrigger</span> <span class="keyword">extends</span> <span class="title">Trigger</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">/*指定 Trigger 所属组和名称*/</span>    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleTrigger</span><span class="params">(String name, String group)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(name, group, <span class="keyword">new</span> Date(), (Date)<span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0L</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*指定 Trigger 所属组、名称和触发时间*/</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleTrigger</span><span class="params">(String name, Date startTime)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(name, (String)<span class="keyword">null</span>, startTime);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/*指定 Trigger 所属组、名称、开始时间、结束时间、重复次数、时间间隔*/</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleTrigger</span><span class="params">(String name, String group, Date startTime, Date endTime, <span class="keyword">int</span> repeatCount, <span class="keyword">long</span> repeatInterval)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(name, group);</div><div class="line">        <span class="keyword">this</span>.startTime = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">this</span>.endTime = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">this</span>.nextFireTime = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">this</span>.previousFireTime = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">this</span>.repeatCount = <span class="number">0</span>;</div><div class="line">        <span class="keyword">this</span>.repeatInterval = <span class="number">0L</span>;</div><div class="line">        <span class="keyword">this</span>.timesTriggered = <span class="number">0</span>;</div><div class="line">        <span class="keyword">this</span>.complete = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">this</span>.setStartTime(startTime);</div><div class="line">        <span class="keyword">this</span>.setEndTime(endTime);</div><div class="line">        <span class="keyword">this</span>.setRepeatCount(repeatCount);</div><div class="line">        <span class="keyword">this</span>.setRepeatInterval(repeatInterval);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">   <span class="comment">/*这是最复杂的一个构造函数，在指定触发参数的同时，通过 jobGroup 和 jobName ,使该 Trigger 和 Scheduler 中的某个任务关联起来*/</span> </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">SimpleTrigger</span><span class="params">(String name, String group, String jobName, String jobGroup, Date startTime, Date endTime, <span class="keyword">int</span> repeatCount, <span class="keyword">long</span> repeatInterval)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(name, group, jobName, jobGroup);</div><div class="line">        <span class="keyword">this</span>.startTime = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">this</span>.endTime = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">this</span>.nextFireTime = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">this</span>.previousFireTime = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">this</span>.repeatCount = <span class="number">0</span>;</div><div class="line">        <span class="keyword">this</span>.repeatInterval = <span class="number">0L</span>;</div><div class="line">        <span class="keyword">this</span>.timesTriggered = <span class="number">0</span>;</div><div class="line">        <span class="keyword">this</span>.complete = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">this</span>.setStartTime(startTime);</div><div class="line">        <span class="keyword">this</span>.setEndTime(endTime);</div><div class="line">        <span class="keyword">this</span>.setRepeatCount(repeatCount);</div><div class="line">        <span class="keyword">this</span>.setRepeatInterval(repeatInterval);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过实现 org.quartz.Job 接口，可以是 Java 类变成可调度的任务，如下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext jobCtx)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</div><div class="line">        System.out.println(jobCtx.getTrigger().getName()+<span class="string">"triggered. time is:"</span>+<span class="keyword">new</span> Date());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过 SimpleTrigger 对 SimpleJob 进行调度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleTriggerRunner</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">/*创建一个 JobDetail 实例，指定 SimpleJob*/</span></div><div class="line">            JobDetail jobDetail = <span class="keyword">new</span> JobDetail(<span class="string">"job1_1"</span>,<span class="string">"jdroup1"</span>, SimpleJob.class);</div><div class="line"></div><div class="line">            <span class="comment">/*通过 SimpleTrigger 定义调度规则：马上启动，每2秒运行一次，共运行100次*/</span></div><div class="line">            SimpleTrigger simpleTrigger = <span class="keyword">new</span> SimpleTrigger(<span class="string">"Trigger1_1"</span>,<span class="string">"tgroup1"</span>);</div><div class="line">            simpleTrigger.setStartTime(<span class="keyword">new</span> Date());</div><div class="line">            simpleTrigger.setRepeatInterval(<span class="number">2000</span>);</div><div class="line">            simpleTrigger.setRepeatCount(<span class="number">100</span>);</div><div class="line"></div><div class="line">            <span class="comment">/*通过 SchedulerFactory 获取一个调度器实例*/</span></div><div class="line">            SchedulerFactory schedulerFactory = <span class="keyword">new</span> StdSchedulerFactory();</div><div class="line">            Scheduler scheduler = schedulerFactory.getScheduler();</div><div class="line"></div><div class="line">            <span class="comment">/*注册并进行调度*/</span></div><div class="line">            scheduler.scheduleJob(jobDetail,simpleTrigger);</div><div class="line">            scheduler.start(); <span class="comment">/*调度启动*/</span></div><div class="line">        &#125; <span class="keyword">catch</span> (SchedulerException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>还可以通过 SimpleTrigger 的 setStartTime(Date startTime) 和 setEndTime(Date endTime) 的方法指定运行的时间范围。当运行次数和时间范围产生冲突时，超过时间范围的任务不被执行。如可以通过 simpleTrigger.setStartTime(new Date(System.CurrentTimeMillis()+60000L))方法指定 60 秒后开始运行。</p><p>执行结果：</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190405033803-608110.jpg" alt=""></p><h3 id="使用-CronTrigger"><a href="#使用-CronTrigger" class="headerlink" title="使用 CronTrigger"></a>使用 CronTrigger</h3><p>CronTrigger 能够提供比 SimpleTrigger 更有具体实际意义的调度方案，调度规则基于 Cron 表达式。CronTrigger 支持日历相关的周期时间间隔（比如每月第一个周一执行），而不是简单的周期时间间隔。</p><h4 id="Cron-表达式"><a href="#Cron-表达式" class="headerlink" title="Cron 表达式"></a>Cron 表达式</h4><p>Quartz 使用类似于 Linux 下的 Cron 表达式定义时间规则。Cron 表达式由 6 或 7 个空格的时间字段组成，如下表：</p><p>Cron 表达式时间字段：</p><table><thead><tr><th>位置</th><th>时间域名</th><th>允许值</th><th>允许的特殊字符</th></tr></thead><tbody><tr><td>1</td><td>秒</td><td>0-59</td><td>,-*/</td></tr><tr><td>2</td><td>分钟</td><td>0-59</td><td>,-*/</td></tr><tr><td>3</td><td>小时</td><td>0-23</td><td>,-*/</td></tr><tr><td>4</td><td>日期</td><td>1-31</td><td>,-*?/L W C</td></tr><tr><td>5</td><td>月份</td><td>1-12</td><td>,-*/</td></tr><tr><td>6</td><td>星期</td><td>1-7</td><td>,-*?/L C #</td></tr><tr><td>7</td><td>年（可选）</td><td>空值1970-2099</td><td>,-*/</td></tr></tbody></table><p>Cron 表达式的时间字段除允许设置数值外，该可以使用一些特殊的字符，提供列表、范围、通配符等功能，如下：</p><ul><li>星号（*）：可用在所有字段中，表示对应时间域的某一时刻。</li><li>【例如：*在分钟字段时，表示“每分钟”。】</li><li>问好（?）：该字符只在日期和星期字段中使用，它通常指定为“毫无意义的值”，相当于占位符</li><li>减号（-）：表示一个范围。【例如：在小时字段中使用”10-12”，则表示从10点到12点，即10，11，12】</li><li>逗号（,）：表示一个列表值。【例如：在星期字段中使用”MON,WED,FRI”，则表示星期一、星期三和星期】</li><li>斜杠（/）：x/y 表达一个等长序列，x 为起始值，y为增量步长值。如在分钟字段中使用 0/15 ,则表示为 0,15,30 和 45 秒；而 5/15 在分钟字段中表示 5,20,35,50 。用户可以使用 */y，它等同于 0/y。</li><li>L：在日期和星期字段中使用，在日期中表示这个月的最后一天，在星期中使用表示这星期的周六。但是，如果L出现在星期字段里，而且前面有一个数字N，则表示“这个月的最后N天”。【例如：6L 表示该约的最后一个星期五】</li><li>W：该字符只出现在日期字段里，是对前导日期的修饰，表示该日期最近的工作日。W字符串只能指定单一日期，而不能指定日期范围。</li><li>LW组合：在日期字段中使用，当月的最后一个工作日。</li><li>井号（#）：该字符只能在星期字段中使用，表示当月的某个工作日。【例如：6#3表示当月的第3个星期五（6表示星期五，#3 表示当前的第三个），而  4#5 表示当月的第五个星期三。假如当月没有第五个星期三，则忽略不触发。】</li><li>C：只在日期和星期字段中使用，代表”Calendar”的意思。它是指计划所关联的日期，如果日期没有被关联到，则相当于日历中的所有日期。【例如：5C 在日期字段中相当于5日以后的那一天，1C在星期字段中相当于星期日后的第一天】</li></ul><p>Cron 表达式对特殊字符的大小写不敏感，对代表星期的缩写也不敏感。</p><p>Cron 表示式示例：</p><table><thead><tr><th>表示式</th><th>说明</th></tr></thead><tbody><tr><td>“0 0 12 <em> </em> ? “</td><td>每天 12:00 运行</td></tr><tr><td>“0 15 10 ? <em> </em>“</td><td>每天 10:15 运行</td></tr><tr><td>“0 15 10 <em> </em> ?”</td><td>每天 10:15 运行</td></tr><tr><td>“0 15 10 <em> </em> ? *”</td><td>每天 10:15 运行</td></tr><tr><td>“0 15 10 <em> </em> ? 2008”</td><td>2008 年的每天 10:15 运行</td></tr><tr><td>“0 <em> 14 </em> * ?”</td><td>每天14点到15点每分钟运行一次。开始于14:00 ，结束于14:59</td></tr><tr><td>“0 0/15 14 <em> </em> ?”</td><td>每天14点到15点每5分钟运行一次，开始于 14:00 ，结束于14:59</td></tr><tr><td>“0 0/5 14,18 <em> </em> ?”</td><td>每天14点到15点每5分钟运行一次，此外每天 18点到19点每5分钟也运行一次</td></tr><tr><td>“0 0-15 14 <em> </em> ?”</td><td>每天14:00 到 14:05，每分钟运行一次</td></tr><tr><td>“0 10,44 14 ? 3 WED”</td><td>3月每周三的 14:10 到 14:44 ,每分钟运行一次</td></tr><tr><td>“0 15 10 ? * MON-FRI”</td><td>每周一、二、三、四、五的 10:15 运行</td></tr><tr><td>“0 15 10 15 * ?”</td><td>每月15 日的 10:15 运行</td></tr><tr><td>“0 15 10 L * ?”</td><td>每月最后一天星期五的 10:15 运行</td></tr><tr><td>“0 15 10 ? * 6L”</td><td>每月最后一个星期五的 10:15 运行</td></tr><tr><td>“0 15 10 ? 6L 2014-2016”</td><td>2014年、2015年、2016年每月最后一个星期五的 10:15 运行</td></tr><tr><td>“0 15 10 ? * 6#3”</td><td>每月第三个星期五的 10:15 运行</td></tr></tbody></table><h4 id="CronTrigger-实例"><a href="#CronTrigger-实例" class="headerlink" title="CronTrigger  实例"></a>CronTrigger  实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CronTriggerRunner</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            JobDetail jobDetail = <span class="keyword">new</span> JobDetail(<span class="string">"job_2"</span>,<span class="string">"jGroup1"</span>, SimpleJob.class);</div><div class="line"></div><div class="line">            <span class="comment">/*创建 CronTrigger,指定组及名称*/</span></div><div class="line">            CronTrigger cronTrigger = <span class="keyword">new</span> CronTrigger(<span class="string">"trigger1_2"</span>,<span class="string">"tgroup1"</span>);</div><div class="line">            <span class="comment">/*定义 Cron 表达式*/</span></div><div class="line">            CronExpression cexp = <span class="keyword">new</span> CronExpression(<span class="string">"0/5 * * * * ?"</span>);</div><div class="line">            <span class="comment">/*设置 Cron 表达式*/</span></div><div class="line">            cronTrigger.setCronExpression(cexp);</div><div class="line"></div><div class="line"><span class="comment">/*②*/</span></div><div class="line">            SchedulerFactory schedulerFactory = <span class="keyword">new</span> StdSchedulerFactory();</div><div class="line">            Scheduler scheduler = schedulerFactory.getScheduler();</div><div class="line">            scheduler.scheduleJob(jobDetail,cronTrigger);</div><div class="line">            scheduler.start();</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行 CronTriggerRunner，每5秒将触发 SimpleJob 运行一次。在默认情况下，Cron 表达式对应当前的时区，可以通过 CronTriggerRunner  的 setTimeZone(TimeZone timeZone) 方法显示指定时区。也可以指定开始时间和结束时间。</p><p><code>注意</code>：在代码 ② 处需要通过 Thread.currentThread.sleep() 方法让主线程睡眠一段时间，使调度器可以继续执行任务调度的工作；否则在调度器启动后，因为主线程立即退出，寄生于主线程的调度器也将关闭，调度器的任务都将相应的销毁，这将导致看不到实际的运行效果。在单元测试的时候，使主线程休眠一段时间以便让任务线程不被提前终止是经常使用的测试方法。对于测试某些长周期执行的调度任务，开发者可以简单地调整操作系统时间进行模拟。</p><p>运行结果：</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190406025400-7454.jpg" alt=""></p><h3 id="使用-Calender"><a href="#使用-Calender" class="headerlink" title="使用 Calender"></a>使用 Calender</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> com.mrsw.adx.admin.service.impl.SimpleJob;</div><div class="line"><span class="keyword">import</span> org.quartz.*;</div><div class="line"><span class="keyword">import</span> org.quartz.impl.StdSchedulerFactory;</div><div class="line"><span class="keyword">import</span> org.quartz.impl.calendar.AnnualCalendar;</div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Calendar;</div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"><span class="keyword">import</span> java.util.GregorianCalendar;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalendarExample</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            SchedulerFactory sf = <span class="keyword">new</span> StdSchedulerFactory();</div><div class="line">            Scheduler scheduler = sf.getScheduler();</div><div class="line"></div><div class="line">            <span class="comment">/*法定节日是以每年为周期的，所以使用 AnnualCalendar*/</span></div><div class="line">            AnnualCalendar holidays = <span class="keyword">new</span> AnnualCalendar();</div><div class="line"></div><div class="line">            <span class="comment">/*五一劳动节*/</span></div><div class="line">            Calendar laborDay = <span class="keyword">new</span> GregorianCalendar();</div><div class="line">            laborDay.add(Calendar.MONTH,<span class="number">5</span>);</div><div class="line">            laborDay.add(Calendar.DATE,<span class="number">1</span>);</div><div class="line"></div><div class="line">            <span class="comment">/*国庆节*/</span></div><div class="line">            Calendar nationalDay = <span class="keyword">new</span> GregorianCalendar();</div><div class="line">            nationalDay.add(Calendar.MONTH,<span class="number">10</span>);</div><div class="line">            nationalDay.add(Calendar.DATE,<span class="number">1</span>);</div><div class="line"></div><div class="line">            <span class="comment">/*排除这两个特殊日期*/</span></div><div class="line">            ArrayList&lt;Calendar&gt; calendars = <span class="keyword">new</span> ArrayList&lt;Calendar&gt;();</div><div class="line">            calendars.add(laborDay);</div><div class="line">            calendars.add(nationalDay);</div><div class="line">            holidays.setDaysExcluded(calendars);<span class="comment">/*①*/</span></div><div class="line"></div><div class="line">            <span class="comment">/*向 Scheduler 注册日历*/</span></div><div class="line">            scheduler.addCalendar(<span class="string">"holidays"</span>,holidays,<span class="keyword">false</span>,<span class="keyword">false</span>);</div><div class="line"></div><div class="line">            <span class="comment">/*4月1日上午10点*/</span></div><div class="line">            Date runDate = TriggerUtils.getDateOf(<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">4</span>);</div><div class="line">            JobDetail job = <span class="keyword">new</span> JobDetail(<span class="string">"job1"</span>,<span class="string">"group1"</span>, SimpleJob.class);</div><div class="line">            SimpleTrigger trigger = <span class="keyword">new</span> SimpleTrigger(<span class="string">"trigger1"</span>,<span class="string">"group1"</span>,runDate,</div><div class="line">                    <span class="keyword">null</span>,SimpleTrigger.REPEAT_INDEFINITELY,</div><div class="line">                    <span class="number">60L</span> * <span class="number">60L</span> * <span class="number">1000L</span>);</div><div class="line">            trigger.setCalendarName(<span class="string">"holidays"</span>);</div><div class="line">            <span class="comment">/*让 Trigger 应用指定的日历规则*/</span></div><div class="line"></div><div class="line">            scheduler.scheduleJob(job,trigger);</div><div class="line">            scheduler.start();</div><div class="line">            <span class="comment">// 在实际应用中主线程不能停止，否则 Scheduler 得不到执行，此处省略</span></div><div class="line">        &#125; <span class="keyword">catch</span> (SchedulerException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>注意</code>：在向 Scheduler 注册日历的时候，addCalendar(String calName,Calendar calendar,boolean replace,boolean updateTrigger)。如果 updateTrigger 为 true,则 Scheduler 中引用 Calendar 的 Trigger 将得到更新，如①所示。</p><h3 id="任务调度信息存储"><a href="#任务调度信息存储" class="headerlink" title="任务调度信息存储"></a>任务调度信息存储</h3><p>默认情况下，Quartz 将任务调度的运行信息（调度现场信息包括运行次数、调度规则和JobDataMap 中的数据等。）保存在内存中。这种方法提供了最佳的性能，因为在内存中数据访问速度最快；不足之处在于缺乏数据的持久性，当程序中途停止或系统崩溃时，所有运行的信息都会丢失。</p><p>持久化任务调度信息，可以通过调整 Quartz 的属性文件，将这些数据保存到数据库。</p><h4 id="通过配置文件调整任务调度信息的保存策略"><a href="#通过配置文件调整任务调度信息的保存策略" class="headerlink" title="通过配置文件调整任务调度信息的保存策略"></a>通过配置文件调整任务调度信息的保存策略</h4><p>在 Quartz  JAR 文件的 org.quartz 包下就包含了一个 quartz.properties 属性配置文件，并提供了默认配置。如果需要调整默认配置，则可以直接在类路径下建立一个新的 quartz.properties 属性文件，它将被 Quartz加载并覆盖默认的配置。</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190406051505-539589.jpg" alt=""></p><p>Quartz 的属性文件配置主要包括以下三方面的信息：</p><ol><li>集群信息</li><li>调度器线程池</li><li>任务调度现场数据的保存</li></ol><p><code>注意</code>：如果任务数目很大，则可以通过增大线程池获得更好的性能。</p><p>可以通过 以下设置将任务调度现场数据保存到数据库。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># 要将任务调度保存到数据库，必须使用 JobStoreTX 代替原来的 RAMJobStore</div><div class="line">org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX</div><div class="line"># 数据库表前缀</div><div class="line">org.quartz.jobStore.tablePrefix = QRTZ_</div><div class="line"># 数据源名称</div><div class="line">org.quartz.jobStore.dataSource = qzDS</div><div class="line"></div><div class="line"># 定义数据源的具体属性</div><div class="line">org.quartz.dataSource.qzDS.driver = com.mysql.jdbc.Driver</div><div class="line">org.quartz.dataSource.qzDS.URL = jdbc:mysql://localhost:3306/sampledb</div><div class="line">org.quartz.dataSource.qzDS.user = stamen</div><div class="line">org.quartz.dataSource.qzDS.password = abd</div><div class="line">org.quartz.dataSource.qzDS.maxConnections = 10</div></pre></td></tr></table></figure><p><code>注意</code>：必须事先在相应的数据库中创建 Quartz 的数据表（8张），在 Quartz 的完整发布的 dosc/dbTables 目录下拥有对应的不同的数据库脚本。</p><h4 id="查询数据库的运行信息"><a href="#查询数据库的运行信息" class="headerlink" title="查询数据库的运行信息"></a>查询数据库的运行信息</h4><h2 id="在Spring中使用Quartz"><a href="#在Spring中使用Quartz" class="headerlink" title="在Spring中使用Quartz"></a>在Spring中使用Quartz</h2><p>Spring 为创建 Quartz 的 Scheduler 、Trigger 和 JobDetail 提供了便利的 FactoryBean 类，以便能够在 Spring 容器中享受注入的好处。</p><p>Spring 为 Quartz 提供了两个方面的支持：</p><p>（1）为 Quartz 的重要组件提供更具 Bean 风格的扩展类</p><p>（2）提供创建 Scheduler 的 BeanFactory 类，方便在 Spring 环境下创建对应的组件对象，并结合 Spring 容器生命周期执行启动和停止的动作。</p><h3 id="创建-JobDetail"><a href="#创建-JobDetail" class="headerlink" title="创建 JobDetail"></a>创建 JobDetail</h3><p>Spring 通过扩展 JobDetail 提供了一个更具 Bean 风格的 JobDetailFactoryBean。还提供了一个 MethodInvokingJobDetailBean，通过这个 FactoryBean 可以将 Spring 容器中 Bean 的方法包装成 Quartz 任务，这样开发者就不必为 Job 创建对应的类。</p><h4 id="JobDetailFactoryBean"><a href="#JobDetailFactoryBean" class="headerlink" title="JobDetailFactoryBean"></a>JobDetailFactoryBean</h4><p>扩展于 Quartz 的 JobDetail 。使用该 Bean 声明 JobDetail 时，bean 的名字即任务的名字，如果没有指定所属组，就使用默认组。除了 JobDetail 的属性外，还定义了以下属性：</p><ul><li>jobCalss：类型为 Class，实现 Job 接口的任务类</li><li>beanName：默认为 Bean 的 id 名，通过该属性显示指定 Bean 名称，它对应任务的名称。</li><li>jobDataAsMap：类型为 Map ，为任务所对应的 JobDataMap 提供值。</li><li>applicationContextJobDataKey：可以将 Spring ApplicationContext 的引用保存到 JobDataMap 中，以便在 Job 的代码中访问 ApplicationContext。需要指定一个健用于在 jobDataAsMap 中保存 ApplicationContext。</li><li>jobListenerName：类型为 String[] ，指定注册在 Scheduler 中的 JobDataMap 名称，以便让这些监听器对本任务的事件进行监听。</li></ul><p>在下面的配置片段中使用 JobDetailBean 在 Spring 中配置一个 JobDetail</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;bean name="jobDetail" class="org.springframework.scheduling.quartz.JobDetailBean"</div><div class="line">    p:jobClass="com.smart.quartz.MyJob"</div><div class="line">    p:applicationContextJobDataKey="applicationContext"&gt;</div><div class="line">    &lt;property&gt;</div><div class="line">    &lt;map&gt;</div><div class="line">    &lt;entry key=“size” value="10"/&gt;</div><div class="line">        &lt;/map&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure><p>说明：JobDetailFactoryBean 封装了 MyJob 任务，并为 Job 对应的 JobDataMap 设置了一个健为 size 的数据。此外，通过指定 applicationContextJobDataKey ，让 Job 的 JobDataMap 持有 Spring ApplicationContext 的引用。</p><p>这样，MyJob 在运行时就可以通过 JobDataMap 访问到 size 和 ApplicationContext。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext jctx)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">/*获取 JobDetail 关联的 JobDataMap*/</span></div><div class="line">        Map dataMap = jctx.getJobDetail().getJobDataMap();</div><div class="line">        String size = (String) dataMap.get(<span class="string">"size"</span>);</div><div class="line"></div><div class="line">        ApplicationContext ctx = (ApplicationContext)dataMap.get(<span class="string">"applicationContext"</span>);</div><div class="line">        System.out.println(<span class="string">"size："</span>+size);</div><div class="line">        <span class="comment">/*① 对 JobDataMap 所做的更改是否被持久化取决于任务的类型*/</span></div><div class="line">        dataMap.put(<span class="string">"size"</span>,size+<span class="string">"0"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在代码 ① 处对 JobDataMap 进行修改。如果 MyJob 实现了 Job 接口，则这种更改对于下一次执行是不可见的；如果 MyJob 实现了 StatefulJob 接口，则这种更改对于下一次执行是可见的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJob</span> <span class="keyword">implements</span> <span class="title">StatefulJob</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext jctx)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</div><div class="line"><span class="comment">//    Map dataMap = jctx.getJobDetail().getJobDataMap();</span></div><div class="line">        Map dataMap = jctx.getTrigger().getJobDataMap();</div><div class="line">        String size =(String)dataMap.get(<span class="string">"size"</span>);</div><div class="line">        ApplicationContext ctx = (ApplicationContext)dataMap.get(<span class="string">"applicationContext"</span>);</div><div class="line">        System.out.println(<span class="string">"size:"</span>+size);</div><div class="line">        dataMap.put(<span class="string">"size"</span>,size+<span class="string">"0"</span>);</div><div class="line"></div><div class="line">        String count =(String)dataMap.get(<span class="string">"count"</span>);</div><div class="line">        System.out.println(<span class="string">"count:"</span>+count);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="MethodInvokingJobDetailFactryBean"><a href="#MethodInvokingJobDetailFactryBean" class="headerlink" title="MethodInvokingJobDetailFactryBean"></a>MethodInvokingJobDetailFactryBean</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 通过封装服务类方法实现 --&gt;</div><div class="line">&lt;bean id=<span class="string">"jobDetail_1"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"</span></div><div class="line">p:targetObject-ref=<span class="string">"myService"</span> p:targetMethod=<span class="string">"doJob"</span></div><div class="line">p:concurrent=<span class="string">"false"</span>/&gt;</div><div class="line">&lt;bean id=<span class="string">"myService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.smart.service.MyService"</span> /&gt;</div></pre></td></tr></table></figure><p>jobDetail_1 将 MyService#doJob() 封装成一个任务，同时通过 concurrent 属性指定任务的类型。默认情况下为无状态的任务。如果希望封装为有状态的任务，仅需将 concurrent 属性设置为 false 就可以了。Sping 通过名为 concurrent 的属性指定任务类型，能够更直接的描述任务执行的方式（有状态的任务不能并发执行，无状态的任务可以并发执行），对于不熟悉 Quartz 内部机制的用户来说，比起 stateful ，concurrent 更简明达意。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</div><div class="line">   <span class="comment">/*被封装成任务的目标方法*/</span> </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doJob</span><span class="params">()</span></span>&#123;</div><div class="line">   System.out.println(<span class="string">"in MyService.dojob()."</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>注意</code>：通过 MethodInvokingJobDetailFactoryBean 产生的 JobDetail 不能被序列化，所以不能持久化到数据库。若希望使用持久化任务，则只能创建正规的 Quartz 的 Job 实现类 。</p><h3 id="创建-Trigger"><a href="#创建-Trigger" class="headerlink" title="创建 Trigger"></a>创建 Trigger</h3><h4 id="SimpleTriggerFactoryBean"><a href="#SimpleTriggerFactoryBean" class="headerlink" title="SimpleTriggerFactoryBean"></a>SimpleTriggerFactoryBean</h4><p>在默认情况下，通过 SimpleTriggerFactoryBean 配置的 Trigger 名称即为 Bean 的名称，属于默认组。SimpleTriggerFactoryBean 在 SimpleTrigger 的基础上新增了以下属性。</p><p>jobDetail：对应的 JobDetail。</p><p>beanName：默认为 Bean 的 id 名，通过该属性显示指定 Bean 名称，它对应 Trigger 的名称。</p><p>jobDataAsMap：以 Map 类型为 Trigger 关联的  JobDataMap 提供值。</p><p>startDelay：延迟多少时间开始触发，单位为毫秒，默认值为0</p><p>triggerListenerNames：类型为 String[]，指定注册在 Scheduler 中的 TriggerListener 名称，以便让这些监听器对本触发器的时间进行监听。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;bean id="simpleTrigger" class="org.springframework.scheduling.quartz.SimpleTriggerBean"</div><div class="line">p:jobDetail-ref="jobDetail" p:startDelay="1000" p:repeatInterval="2000"</div><div class="line">p:repeatCount="100"&gt;</div><div class="line">&lt;property name="jobDataAsMap"&gt;&lt;!--①--&gt;</div><div class="line">&lt;map&gt;</div><div class="line">&lt;entry key="count" value="10" /&gt;</div><div class="line">&lt;/map&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure><p>代码①处配置的 Map 数据将填充到 Trigger 的 JobDataMap 中，执行任务时必须通过以下方式获取配置的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJob</span> <span class="keyword">implements</span> <span class="title">StatefulJob</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext jctx)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</div><div class="line">        Map dataMap = jctx.getTrigger().getJobDataMap();</div><div class="line">        <span class="comment">/*对 JobDataMap 的更改不会被持久化，不影响下次的执行*/</span></div><div class="line">        String count =(String)dataMap.get(<span class="string">"count"</span>);</div><div class="line">        System.out.println(<span class="string">"count:"</span>+count);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="CronTriggerFactoryBean"><a href="#CronTriggerFactoryBean" class="headerlink" title="CronTriggerFactoryBean"></a>CronTriggerFactoryBean</h4><p>扩展于 CronTrigger ,触发器的名称即为 Bean 的名称，保存在默认组中。在 CronTrigger 的基础上，新增的属性和 SimpleTriggerFactoryBean 大致相同，配置的方法也和 SimpleTriggerFactoryBean 相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"checkImagesTrigger"</span> </div><div class="line">      <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.scheduling.quartz.CronTriggerBean"</span></div><div class="line">      p:jobDetail-ref=<span class="string">"jobDetail"</span></div><div class="line">      p:cronExpression=<span class="string">"0/5 * * * * ?"</span>/&gt;</div></pre></td></tr></table></figure><h3 id="创建Scheduler"><a href="#创建Scheduler" class="headerlink" title="创建Scheduler"></a>创建Scheduler</h3><p>Quartz 的 SchedulerFactory 是标准的工厂类，不太合适在 Spring 环境下使用。此外，为了保证 Scheduler 能够感知 Spring 容器的生命周期，在 Spring 容器启动后，Scheduler 自动开始工作，而在 Spring 容器关闭之前，自动关闭 Scheduler 。Spring 提供了 SchedulerFactoryBean，这个 FactoryBean 大致拥有以下功能。</p><ul><li>以更具 Bean 风格的方式为 FactoryBean 提供配置信息。</li><li>让 Scheduler 和 Spring 容器的生命周期建立关联，相生相息</li><li>通过属性配置的方式代替 Quartz 自身的配置文件 </li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;bean id="scheduler" class="org.springframework.scheduling.quartz.SchedulerFactory"&gt;</div><div class="line">&lt;!--注册多个 trigger--&gt;</div><div class="line">&lt;property name="triggers"&gt;</div><div class="line">&lt;list&gt;</div><div class="line">&lt;ref bean="simpleTrigger"/&gt;</div><div class="line">    &lt;/list&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">    &lt;!--以Map类型设置 SchedulerContext 数据--&gt;</div><div class="line">    &lt;property name="schedulerContextAsMap"&gt;</div><div class="line">    &lt;map&gt;</div><div class="line">    &lt;entry key="timeout" value="30"/&gt;</div><div class="line">    &lt;/map&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">    &lt;!--显示指定 quartz 的配置文件地址--&gt;</div><div class="line">    &lt;properties name="configLocation" value="classpath:com/smart/quartz/quartz.properties"/&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure><p>SchedulerFactoryBean 还有以下常见的属性：</p><ul><li>calendars：类型为 Map，通过该属性向 Scheduler 注册 Calendar</li><li>jobDetails：类型为 JobDetail[]，通过该属性向 Scheduler 注册 JobDetail</li><li>autoStartup：SchedulerFactoryBean 在初始化后是否马上启动 Scheduler，默认为 true。若设置为 false，则需要手动启动 Scheduler</li><li>startupDelay：在 SchedulerFactoryBean 在初始化完成后，延迟多少秒后启动 Scheduler，默认为0。除非拥有需要立即执行的任务，一般情况下，可以通过 startupDelay 属性让 Scheduler 延迟一小段时间后启动，以便让 Spring 能够更快初始化容器中剩余的 Bean</li></ul><p>SchedulerFactoryBean 的一个重要功能是允许用户将 Quartz 配置文件的信息转移到 Spring 配置文件中。SchedulerFactoryBean 通过以下属性代替框架的自身配置文件：</p><ul><li>dataSource：当需要持久化任务调度数据时，在 Quartz 中配置数据源，也可以直接在 Spring 中通过 dataSource 指定一个 Spring 管理的数据源。如果指定了该属性，即使 quartz.properties 中已经定义了数据源，也会被 dataSource 覆盖</li><li>transactionManager：可以通过该属性设置一个 Spring 事务管理器</li><li>nonTransactionalDataSource：在全局事务的情况下，如果不希望 Scheduler 执行的相关数据操作参与到全局事务中，则可以通过该属性指定数据源。在 Spring 本地事务的情况下，使用 dataSource 属性就足够了</li><li>quartzProperties：类型为 properties ，允许用户在 Spring 中定义 Quartz 的属性，其值将覆盖 quartz.properties 配置文件中的设置。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;bean id="scheduler"</div><div class="line">class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt;</div><div class="line">&lt;property name="quartzProperties"&gt;</div><div class="line">&lt;props&gt;</div><div class="line">&lt;!--属性值1--&gt;</div><div class="line">&lt;prop key="org.quartz.threadPool.class"&gt;</div><div class="line">org.quartz.simpl.SimpleThreadPool</div><div class="line">&lt;/prop&gt;</div><div class="line">&lt;!--属性值2--&gt;</div><div class="line">&lt;prop key="org.quartz.threadPool.threadCount"&gt;10&lt;/prop&gt;</div><div class="line">&lt;/props&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure><h2 id="在Spring中使用JDK-Timer"><a href="#在Spring中使用JDK-Timer" class="headerlink" title="在Spring中使用JDK Timer"></a>在Spring中使用JDK Timer</h2><h3 id="Timer-和-TimerTask"><a href="#Timer-和-TimerTask" class="headerlink" title="Timer 和 TimerTask"></a>Timer 和 TimerTask</h3><p>TimerTask 代表一个需要多次执行的任务，它实现了 Runnable 接口，可以在 run() 方法定义任务逻辑。而 Timer 负责制定调度规则并调度 TimerTask。</p><h4 id="TimerTask"><a href="#TimerTask" class="headerlink" title="TimerTask"></a>TimerTask</h4><p>相当于 Quartz 的  Job ，代表一个被调度的任务。二者区别在于，每次执行任务时，Quartz 都创建一个 Job 实例，而 JDK Timer 则使用相同的 TimerTask 实例。</p><p>实现了 Runnable 接口，是一个抽象类，只有以下3个方法：</p><ol><li>abstract void run()：子类覆盖这个方法并定义任务执行逻辑，每次执行任务时，run() 方法就被调用一次。</li><li>boolean cancel()：取消任务。</li><li>long scheduledExecutionTime()：返回词此任务的计划执行时间。该方法一般在固定频率执行时使用才会有意义。</li></ol><h4 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h4><p>Timer 的构造函数在创建 Timer 对象的同时将启动一个 Time 背景线程。构造函数如下：</p><ul><li>Timer()：创建一个Timer，背景线程是一个非守护线程</li><li>Timer(boolean isDaemon)：当 isDaemon 为 true，背景线程为守护线程，守护线程将在应用程序主线程停止后自动退出。</li><li>Timer(String name)：与 Timer() 类似，只是通过 name 指定守护线程名称。</li></ul><p>通过以下方法执行任务：</p><ul><li>schedule(TimerTask task,Date time)：在特定的时间点执行一次任务。</li><li>schedule(TimerTask task,long delay)：延迟指定时间后执行一次任务，delay的单位为毫秒</li></ul><p>通过以下方按固定时间间隔执行任务：</p><ul><li>schedule(TimerTask task,Date firstTime,long period)：从指定时间开始周期性地执行任务，period 为毫秒，后一次执行将在前一次执行完成后才开始计时。如任务被安排每 2 秒执行一次，假设第一次任务在 0 秒时间点开始执行并花费了 1.5  秒，则第二次将在第 3.5 秒时执行。</li><li>schedule(TimerTask task,long delay,long period)：在延迟指定时间后，周期性地执行任务</li></ul><p>通过以下方法按照固定频率执行任务：</p><ul><li>scheduleAtFixedRate(TimerTask task,Date firstTime,long period)：在指定时间点后，以指定频率执行任务。</li></ul><h4 id="Java-Timer-实例"><a href="#Java-Timer-实例" class="headerlink" title="Java Timer 实例"></a>Java Timer 实例</h4><h3 id="Spring-对-Java-Timer-的支持"><a href="#Spring-对-Java-Timer-的支持" class="headerlink" title="Spring 对 Java Timer 的支持"></a>Spring 对 Java Timer 的支持</h3><h2 id="Spring-对-Java-5-0-Executor-的支持"><a href="#Spring-对-Java-5-0-Executor-的支持" class="headerlink" title="Spring 对 Java 5.0 Executor 的支持"></a>Spring 对 Java 5.0 Executor 的支持</h2><h3 id="了解-Java-5-0-的-Executor"><a href="#了解-Java-5-0-的-Executor" class="headerlink" title="了解 Java 5.0 的 Executor"></a>了解 Java 5.0 的 Executor</h3><h3 id="Spring-对-Executor-所提供的抽象"><a href="#Spring-对-Executor-所提供的抽象" class="headerlink" title="Spring 对 Executor 所提供的抽象"></a>Spring 对 Executor 所提供的抽象</h3><h2 id="实际应用中的调度"><a href="#实际应用中的调度" class="headerlink" title="实际应用中的调度"></a>实际应用中的调度</h2><p>对于那些运行规则固定的静态任务（如每隔30分钟更新缓存），可通过 Spring 配置文件定义调度规则并在 Spring 容器中启动运行调度。若任务的执行时间非常重要，不允许发生时间漂移，那么 Quartz 是最好的选择。</p><h3 id="如何产生任务"><a href="#如何产生任务" class="headerlink" title="如何产生任务"></a>如何产生任务</h3><h4 id="在业务流程中产生"><a href="#在业务流程中产生" class="headerlink" title="在业务流程中产生"></a>在业务流程中产生</h4><p>如果任务的执行时间点离业务的操作时间点不是很长，则可以使用。例如：电力传输管理系统的功能，将一条传输线路在某段时间内停止供电。用户在执行线路停电安排的业务时，立即向 Scheduler 中注册两个任务：某段时间执行断电和执行恢复供电的两个任务。</p><h4 id="扫描线程产生"><a href="#扫描线程产生" class="headerlink" title="扫描线程产生"></a>扫描线程产生</h4><p>有严格的执行时间点并减小数据库的影响，需要一个用于产生最近执行任务的扫描任务定期查询数据库，并为那些在一小段时间后就要执行的潜在任务进行动态安排。    </p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190420035729-649512.jpg" alt=""></p><p>说明：T0 对应一个定时的任务，它负责周期性地扫描业务表，查找在后续的扫描周期时间范围内要执行的任务，并创建这些任务。这中方式带来的好处如下：</p><ol><li>降低对数据库的影响</li><li>缩短调度器中任务列队的长度（由于不是将所有潜在任务提前一段很长时间就进行安排，而仅是对一个扫描周期内的任务进行安排，所以调度器中任务列表的长度可以得到有效的控制）</li><li>保证任务在精确的时间点执行</li></ol><h3 id="任务调度对应程序集群的影响"><a href="#任务调度对应程序集群的影响" class="headerlink" title="任务调度对应程序集群的影响"></a>任务调度对应程序集群的影响</h3><p>对于有集群要求的 Web 应用来说，如果应用系统本身有任务调度的功能，就必须在系统设计初期仔细分析任务调度功能是否适合集群。按任务执行结果影响的范围，可以将任务分为如下两类：</p><ul><li><p>全局任务：指定那些执行结果会影响到应用系统全局的任务。例如：每天凌晨生成业务报表、定期调用短信接口发送短信、定期清理系统过期数据，它们的执行结果都会给系统带来“全局可见”的结果。所以，在传统的集群系统中，全局任务最好在一个独立部署的服务节点执行，否则可能会因重复多次执行而引发系统逻辑的错误。</p></li><li><p>本地任务：指执行结果的影响范围仅限于本地，不会造成全局影响的任务。例如：定期刷新本地缓存、定期清除本地节点临时文件，它们的执行结果只对本地服务节点有影响，需要在每个本地服务节点部署任务。</p><p>Quartz 可支持集群部署，其原理很简单，即让多个调度节点虎威热备，在同一时刻只有一个节点是激活的，任务只有在激活的节点中执行，其他节点都是“休眠”状态；当激活的调度节点崩溃时，则唤醒某一个“休眠”的调度节点，以接管任务调度的工作。</p><p>Quartz 可通过两种方式实现集群：1.通过一个中间数据库，使集群节点相互感知，以实现故障切换；2.通过 Terracotta。</p></li></ul><h3 id="任务调度云"><a href="#任务调度云" class="headerlink" title="任务调度云"></a>任务调度云</h3><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190420050326-614457.jpg" alt=""></p><h3 id="Web应用程序中调度器的启动和关闭问题"><a href="#Web应用程序中调度器的启动和关闭问题" class="headerlink" title="Web应用程序中调度器的启动和关闭问题"></a>Web应用程序中调度器的启动和关闭问题</h3><p>我们知道，静态变量是 ClassLoad 级别的，如果 Web 应用程序停止，那么这些静态变量也会从 JVM 中清除。但线程是 JVM 级别的，如果用户在 Web 应用中启动了一个线程，那么线程的生命周期并不会和 Web 应用程序保持同步。也就是说，即使停止了 Web 应用，这个线程依旧是活动的。</p><p>问题：</p><p>如果手工使用 JDK Timer （Quartz 的 Scheduler），在 Web 容器启动非守护线程的 Timer ，当 Web 容器关闭时，除非用户手动关闭这个 Timer ,否则 Timer 中的任务还会继续。</p><p>解决方法：</p><p>Spring 为 JDK Timer  和 Quartz Scheduler 所提供的 TimerFactoryBean 和 SchedulerFactoryBean 能够与 Spring 容器的生命周期关联，在 Spring 容器启动时启动调度器，而在 Spring 容器关闭时停止调度器。所以在 Spring 中通过配置两个 FactoryBean 配置调度器，再从 Spring IOC 中获取调度器的引用进行任务调度，这样就不会出现这种 Web 容器关闭而任务依然执行的问题。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Quartz  提供了极为丰富的任务调度功能，不但可以制定周期性执行的任务调度方案，还可以让用户按照日历相关的方式进行任务调度。</p><p>Quartz 框架的重要组件包括 Job、JobDetail、Trigger、Scheduler 及辅助性的 JobDataMap 和 SchedulerContext。</p><p>Quartz 拥有一个线程池，通过线程池为任务提供执行线程，可以通过配置配置文件对线程池进行参数定制。</p><p>Quartz 还有一个重要功能，将任务调度信息持久化到数据库中，以便系统重启时能够恢复已经安排的任务。</p><p>Quartz 还拥有完善的事件体系，允许用户注册各种事件的监听器。</p><hr><p>Spring 为 Quartz 的 JobDetail 和 Trigger 提供了更具 Bean 风格的支持类，使得用户能够方便地在 Spring  中通过配置定制这些组件的实例。</p><p>Spring 的 SchedulerFactoryBean 让用户可以脱离 Quartz 自身的体系，而以更具 Spring 风格的方式定义 Scheduler。Scheduler 生命周期和 Spring 容器生命周期绑定。</p><hr><p>JDK Timer 可以满足一些简单的任务调度需求，好处就是用户不必引用 JDK 之外的第三方类库；只能支持小型的任务且任务很快就能完成。</p><p>JDK Timer 只能做到近似时间安排。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第16章任务调度和异步执行器&quot;&gt;&lt;a href=&quot;#第16章任务调度和异步执行器&quot; class=&quot;headerlink&quot; title=&quot;第16章任务调度和异步执行器&quot;&gt;&lt;/a&gt;第16章任务调度和异步执行器&lt;/h1&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://swenfang.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://swenfang.github.io/tags/Spring/"/>
    
  </entry>
  
</feed>
