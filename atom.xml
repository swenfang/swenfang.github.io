<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ShenWenFang</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://swenfang.github.io/"/>
  <updated>2019-04-19T14:29:23.948Z</updated>
  <id>http://swenfang.github.io/</id>
  
  <author>
    <name>ShenWenFang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://swenfang.github.io/2019/04/19/Solr/"/>
    <id>http://swenfang.github.io/2019/04/19/Solr/</id>
    <published>2019-04-19T14:29:23.948Z</published>
    <updated>2019-04-19T14:29:23.948Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CentOS安装JAVA环境（JDK 1.8）</title>
    <link href="http://swenfang.github.io/2019/04/19/CentOS/CentOS%E5%AE%89%E8%A3%85JAVA%E7%8E%AF%E5%A2%83/"/>
    <id>http://swenfang.github.io/2019/04/19/CentOS/CentOS安装JAVA环境/</id>
    <published>2019-04-19T14:25:20.366Z</published>
    <updated>2019-04-19T14:43:07.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CentOS安装JAVA环境（JDK-1-8）"><a href="#CentOS安装JAVA环境（JDK-1-8）" class="headerlink" title="CentOS安装JAVA环境（JDK 1.8）"></a>CentOS安装JAVA环境（JDK 1.8）</h1><h2 id="打开url选择jdk1-8下载"><a href="#打开url选择jdk1-8下载" class="headerlink" title="打开url选择jdk1.8下载"></a>打开url选择jdk1.8下载</h2><p><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="external">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p><p>我选择linux x64版本：</p><a id="more"></a><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419101241-441593.jpg" alt=""></p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419101543-831303.jpg" alt=""></p><p>下载以后通过命令检查安装包大小是否符合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -lht</div></pre></td></tr></table></figure><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419101640-785218.jpg" alt=""></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>（1）创建安装目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir /usr/local/java/</div></pre></td></tr></table></figure><p>（2）解压至安装目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -zxvf jdk-8u171-linux-x64.tar.gz -C /usr/local/java/</div></pre></td></tr></table></figure><h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><p>打开文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/profile</div></pre></td></tr></table></figure><p>在末尾添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">export JAVA_HOME=/usr/local/java/jdk1.8.0_171</div><div class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</div><div class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</div><div class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</div></pre></td></tr></table></figure><p>使环境变量生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source /etc/profile</div></pre></td></tr></table></figure><p>添加软链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ln -s /usr/local/java/jdk1.8.0_171/bin/java /usr/bin/java</div></pre></td></tr></table></figure><p>检查</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -version</div></pre></td></tr></table></figure><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419102013-808980.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CentOS安装JAVA环境（JDK-1-8）&quot;&gt;&lt;a href=&quot;#CentOS安装JAVA环境（JDK-1-8）&quot; class=&quot;headerlink&quot; title=&quot;CentOS安装JAVA环境（JDK 1.8）&quot;&gt;&lt;/a&gt;CentOS安装JAVA环境（JDK 1.8）&lt;/h1&gt;&lt;h2 id=&quot;打开url选择jdk1-8下载&quot;&gt;&lt;a href=&quot;#打开url选择jdk1-8下载&quot; class=&quot;headerlink&quot; title=&quot;打开url选择jdk1.8下载&quot;&gt;&lt;/a&gt;打开url选择jdk1.8下载&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我选择linux x64版本：&lt;/p&gt;
    
    </summary>
    
      <category term="CentOS" scheme="http://swenfang.github.io/categories/CentOS/"/>
    
    
      <category term="CentOS" scheme="http://swenfang.github.io/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>CentOS安装Tomcat</title>
    <link href="http://swenfang.github.io/2019/04/19/CentOS/CentOS%E5%AE%89%E8%A3%85Tomcat/"/>
    <id>http://swenfang.github.io/2019/04/19/CentOS/CentOS安装Tomcat/</id>
    <published>2019-04-19T14:25:20.366Z</published>
    <updated>2019-04-19T14:42:51.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CentOS安装Tomcat"><a href="#CentOS安装Tomcat" class="headerlink" title="CentOS安装Tomcat"></a>CentOS安装Tomcat</h1><h2 id="一-tomcat的简介"><a href="#一-tomcat的简介" class="headerlink" title="一.tomcat的简介"></a>一.tomcat的简介</h2><p>这是<strong>Apache Tomcat</strong> Servlet / JSP容器的文档包的顶级入口点 。的Apache Tomcat 8.0版实现了Servlet 3.1和JavaServer Pages 2.3 <a href="https://wiki.apache.org/tomcat/Specifications" target="_blank" rel="external">规范</a>从 <a href="https://www.jcp.org/" target="_blank" rel="external">Java社区进程</a>，并包含许多额外的功能，使开发和部署Web应用程序和Web服务的有用平台<br><a id="more"></a></p><h2 id="二-tomcat的安装"><a href="#二-tomcat的安装" class="headerlink" title="二.tomcat的安装"></a>二.tomcat的安装</h2><h3 id="1-tomcat下载"><a href="#1-tomcat下载" class="headerlink" title="1.tomcat下载"></a>1.tomcat下载</h3><p>官网地址：<a href="https://www.cnblogs.com/frankdeng/p/%E5%AE%98%E7%BD%91%E5%9C%B0%E5%9D%80%EF%BC%9Ahttp://tomcat.apache.org/" target="_blank" rel="external">http://tomcat.apache.org/</a></p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419094746-454034.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[admin@node21 software]$ wget http://mirrors.shu.edu.cn/apache/tomcat/tomcat-8/v8.0.53/bin/apache-tomcat-8.0.53.tar.gz</div><div class="line">[admin@node21 software]$ ll</div><div class="line">-rw-rw-r-- 1 admin admin   9455895 Jun 30 00:39 apache-tomcat-8.0.53.tar.gz</div></pre></td></tr></table></figure><h3 id="2-tomcat安装"><a href="#2-tomcat安装" class="headerlink" title="2.tomcat安装"></a>2.tomcat安装</h3><p>查看是否安装 JDK</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419094915-822740.jpg" alt=""></p><p>1）解压缩安装包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[admin@node21 software]$ tar zxvf apache-tomcat-8.0.53.tar.gz</div></pre></td></tr></table></figure><p>2）移动安装包到/usr/local/tomcat目录下，也可以不移动设置tomcat环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[admin@node21 software]$ sudo mv apache-tomcat-8.0.53 /usr/local/tomcat8</div></pre></td></tr></table></figure><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419094956-281396.jpg" alt=""></p><h3 id="3-启动tomcat"><a href="#3-启动tomcat" class="headerlink" title="3.启动tomcat"></a>3.启动tomcat</h3><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419095022-266452.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[admin@node21 bin]$ pwd</div><div class="line">/usr/local/tomcat8/bin</div><div class="line">[admin@node21 bin]$ ./startup.sh</div></pre></td></tr></table></figure><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419095051-652902.jpg" alt=""></p><h3 id="4-测试内部是否启动成功"><a href="#4-测试内部是否启动成功" class="headerlink" title="4.测试内部是否启动成功"></a>4.测试内部是否启动成功</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl &quot;http://47.106.180.186:8089/&quot;</div></pre></td></tr></table></figure><p><img src="C:\Users\shenwenfang\AppData\Roaming\Typora\typora-user-images\1555682470740.png" alt="1555682470740"></p><h3 id="5-WebUI访问"><a href="#5-WebUI访问" class="headerlink" title="5.WebUI访问"></a>5.WebUI访问</h3><p>tomcat默认端口8080，访问地址：<a href="http://47.106.180.186:8089/" target="_blank" rel="external">http://47.106.180.186:8089/</a>，默认页面如下</p><p><img src="C:\Users\shenwenfang\AppData\Roaming\Typora\typora-user-images\1555682033090.png" alt="1555682033090"></p><h3 id="6-停止tomcat"><a href="#6-停止tomcat" class="headerlink" title="6.停止tomcat"></a>6.停止tomcat</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[admin@node21 webapps]$ /usr/local/tomcat8/bin/shutdown.sh</div></pre></td></tr></table></figure><h2 id="三-Tomcat服务部署web应用"><a href="#三-Tomcat服务部署web应用" class="headerlink" title="三.Tomcat服务部署web应用"></a>三.Tomcat服务部署web应用</h2><p><strong>第一种方式：利用Tomcat自动部署</strong></p><p>​        利用Tomcat自动部署方式是最简单的、最常用的方式。若一个web应用结构为<strong>D:\workspace\WebApp\AppName\WEB-INF*，只要将一个Web应用的WebContent级的AppName</strong>直接扔进%Tomcat_Home%\webapps文件夹下，系统会把该web应用直接部署到Tomcat中。<strong>所以这里不再赘述</strong></p><p><strong>第二种方式：手动部署修改%Tomcat_Home%\conf\server.xml文件来部署web应用</strong></p><p>打开<strong>%Tomcat_Home%\conf\server.xml</strong>文件并在其中<host>标签里增加以下元素：</host></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Context docBase=&quot;D:\workspace\WebApp\AppName&quot; path=&quot;/XXX&quot; debug=&quot;0&quot; reloadable=&quot;false&quot; /&gt;</div></pre></td></tr></table></figure><p>然后启动Tomcat即可。</p><p><code>注意：</code></p><p>​      （1）以上代码中的<strong>workDir</strong>表示将该Web应用部署后置于的工作目录（Web应用中JSP编译成的Servlet都可在其中找到）。如果自定义web部署文件XXX.xml中未指明workdir，则web应用将默认部署在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%Tomcat_Home%\work\Catalina\localhost</div></pre></td></tr></table></figure><p>路径下新建的以XXX命名的文件夹下。（Web应用中JSP编译成的Servlet都可在其中找到）</p><p>​      （2）<strong>Context path</strong>即指定web应用的虚拟路径名。<strong>docBase</strong>指定要部署的Web应用的源路径。</p><h2 id="四-解决中文乱码及测试访问页"><a href="#四-解决中文乱码及测试访问页" class="headerlink" title="四.解决中文乱码及测试访问页"></a>四.解决中文乱码及测试访问页</h2><h3 id="1-测试修改访问页面"><a href="#1-测试修改访问页面" class="headerlink" title="1.测试修改访问页面"></a>1.测试修改访问页面</h3><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419100432-389841.jpg" alt=""></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello,世界!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><p>再次启动tomcat，输入：<a href="http://47.106.180.186:8089/hello/index.html，出现下图，发现有中文乱码现象。" target="_blank" rel="external">http://47.106.180.186:8089/hello/index.html，出现下图，发现有中文乱码现象。</a></p><h3 id="2-解决中文乱码"><a href="#2-解决中文乱码" class="headerlink" title="2.解决中文乱码"></a>2.解决中文乱码</h3><p>乱码原因：tomcat8之前，URL中参数的默认解码是ISO-8859-1，而tomcat8的默认解码为utf-8。ISO-8859-1并未包括中文字符，中文字符不能被正确解析了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CentOS安装Tomcat&quot;&gt;&lt;a href=&quot;#CentOS安装Tomcat&quot; class=&quot;headerlink&quot; title=&quot;CentOS安装Tomcat&quot;&gt;&lt;/a&gt;CentOS安装Tomcat&lt;/h1&gt;&lt;h2 id=&quot;一-tomcat的简介&quot;&gt;&lt;a href=&quot;#一-tomcat的简介&quot; class=&quot;headerlink&quot; title=&quot;一.tomcat的简介&quot;&gt;&lt;/a&gt;一.tomcat的简介&lt;/h2&gt;&lt;p&gt;这是&lt;strong&gt;Apache Tomcat&lt;/strong&gt; Servlet / JSP容器的文档包的顶级入口点 。的Apache Tomcat 8.0版实现了Servlet 3.1和JavaServer Pages 2.3 &lt;a href=&quot;https://wiki.apache.org/tomcat/Specifications&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;规范&lt;/a&gt;从 &lt;a href=&quot;https://www.jcp.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java社区进程&lt;/a&gt;，并包含许多额外的功能，使开发和部署Web应用程序和Web服务的有用平台&lt;br&gt;
    
    </summary>
    
      <category term="CentOS" scheme="http://swenfang.github.io/categories/CentOS/"/>
    
    
      <category term="CentOS" scheme="http://swenfang.github.io/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>CentOS搭建Solr7单机服务</title>
    <link href="http://swenfang.github.io/2019/04/19/CentOS/CentOS%E6%90%AD%E5%BB%BASolr7%20%E5%8D%95%E6%9C%BA%E6%9C%8D%E5%8A%A1/"/>
    <id>http://swenfang.github.io/2019/04/19/CentOS/CentOS搭建Solr7 单机服务/</id>
    <published>2019-04-19T14:25:20.346Z</published>
    <updated>2019-04-20T13:36:23.801Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CentOS搭建Solr7单机服务"><a href="#CentOS搭建Solr7单机服务" class="headerlink" title="CentOS搭建Solr7单机服务"></a>CentOS搭建Solr7单机服务</h1><h2 id="一-Solr安装环境"><a href="#一-Solr安装环境" class="headerlink" title="一.Solr安装环境"></a>一.Solr安装环境</h2><h3 id="1-官方参考文档"><a href="#1-官方参考文档" class="headerlink" title="1.官方参考文档"></a>1.官方参考文档</h3><p>Solr教程参考指南：<a href="http://lucene.apache.org/solr/guide/7_4/solr-tutorial.html" target="_blank" rel="external">http://lucene.apache.org/solr/guide/7_4/solr-tutorial.html</a></p><a id="more"></a><h3 id="2-Solr运行环境"><a href="#2-Solr运行环境" class="headerlink" title="2.Solr运行环境"></a>2.Solr运行环境</h3><p>系统要求：Java 8+      这里我们把solr服务部署到Tomacat服务器中，Tomcat安装过程参考：<a href="https://swenfang.github.io/2019/04/19/CentOS/CentOS安装Tomcat/">https://swenfang.github.io/2019/04/19/CentOS/CentOS安装Tomcat/</a></p><p><strong>在solr5以前solr的启动都有tomcat作为容器，但是从solr5以后solr内部集成jetty服务器，可以通过bin目录中脚本直接启动。就是从solr5以后跟solr4最大的区别是被发布成一个独立的应用。</strong></p><h3 id="3-Solr下载"><a href="#3-Solr下载" class="headerlink" title="3.Solr下载"></a>3.Solr下载</h3><p> 下载地址：<a href="http://archive.apache.org/dist/lucene/solr/" target="_blank" rel="external">http://archive.apache.org/dist/lucene/solr/</a></p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419093633-377825.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[admin@node21 software]$ wget http://archive.apache.org/dist/lucene/solr/7.4.0/solr-7.4.0.tgz</div><div class="line">[admin@node21 software]$ ll</div><div class="line">-rw-rw-r-- 1 admin admin 167346886 Jun 19 02:51 solr-7.4.0.tgz</div></pre></td></tr></table></figure><h2 id="二-Solr单机安装"><a href="#二-Solr单机安装" class="headerlink" title="二.Solr单机安装"></a>二.Solr单机安装</h2><h3 id="1-解压安装包"><a href="#1-解压安装包" class="headerlink" title="1. 解压安装包"></a>1. 解压安装包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[admin@node21 software]$ tar zxvf solr-7.4.0.tgz </div><div class="line">[admin@node21 software]$ ls solr-7.4.0</div><div class="line">bin CHANGES.txt contrib dist docs example licenses LICENSE.txt LUCENE_CHANGES.txt NOTICE.txt README.txt server</div></pre></td></tr></table></figure><h3 id="2-部署solr到tomcat下"><a href="#2-部署solr到tomcat下" class="headerlink" title="2.部署solr到tomcat下"></a>2.部署solr到tomcat下</h3><p>注意，这里因为我用的是solr7.4最新版，所以跟solr4版本要拷贝*.war文件，然后再启动tomcat解压的操作是不一样的 ，</p><p><strong>1）复制并重命名solr目录里的server/solr-webapp/webapp文件夹到/usr/local/tomcat8/webapps/solr</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[admin@node21 software]$ sudo cp -r solr-7.4.0/server/solr-webapp/webapp /usr/local/tomcat8/webapps/solr</div></pre></td></tr></table></figure><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419093852-618647.jpg" alt=""></p><p><strong>2）拷贝solr-7.4.0\server\lib\ext 下的jar包以及lib目录下gmetric4j-1.0.7.jar和metrics开头的jar包拷贝到 tomcat8\webapps\solr 项目的WEB-INF\lib下</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[admin@node21 software]$ sudo cp solr-7.4.0/server/lib/ext/* /usr/local/tomcat8/webapps/solr/WEB-INF/lib/</div><div class="line">[admin@node21 software]$ sudo cp solr-7.4.0/server/lib/gmetric4j-1.0.7.jar /usr/local/tomcat8/webapps/solr/WEB-INF/lib/</div><div class="line">[admin@node21 software]$ sudo cp solr-7.4.0/server/lib/metrics-*  /usr/local/tomcat8/webapps/solr/WEB-INF/lib/</div></pre></td></tr></table></figure><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419093937-207098.jpg" alt=""></p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419093955-399271.jpg" alt=""></p><p>3）<strong>创建一个索引库solrhome</strong></p><p>拷贝solr-7.4.0\server 下的solr文件夹到其它非中文目录下，重命名为solrhome，我是建立到了/usr/local/tomcat8/solrhome下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[admin@node21 software]$ sudo cp -r solr-7.4.0/server/solr /usr/local/tomcat8/solrhome</div></pre></td></tr></table></figure><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419094030-250401.jpg" alt=""></p><p>4）<strong>关联solr及索引库solrhome，</strong>需要修改tomcat里solr工程的web.xml文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[admin@node21 software]$ sudo vi /usr/local/tomcat8/webapps/solr/WEB-INF/web.xml</div></pre></td></tr></table></figure><p>找到如下代码，打开注释，修改自己的solrhome的路径/put/your/solr/home/here，我的是 /usr/local/tomcat8/solrhome 路径。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--</span></div><div class="line">  &lt;env-entry&gt;</div><div class="line">     &lt;env-entry-name&gt;solr/home&lt;/env-entry-name&gt;</div><div class="line">     &lt;env-entry-value&gt;/put/your/solr/home/here&lt;/env-entry-value&gt;</div><div class="line">     &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt;</div><div class="line">  &lt;/env-entry&gt;</div><div class="line"> --&gt;</div></pre></td></tr></table></figure><p>如下图：</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419094153-478365.jpg" alt=""></p><p>然后到最下方，将这一段注释掉，不然会报403错误，完成后保存退出（solr4部署不用注释这个）</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419094222-739442.jpg" alt=""></p><p><strong>5）拷贝solr7.4.0\server\resources下的</strong> log4j2.xml <strong>到tomcat8/webapps/solr/WEB-INF\classes，如果WEB-INF下没有classes文件那么就创建一个classes文件夹</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[admin@node21 tomcat8]$ sudo mkdir -p /usr/local/tomcat8/webapps/solr/WEB-INF/classes/</div><div class="line">[admin@node21 tomcat8]$ sudo cp -r /opt/software/solr-7.4.0/server/resources/log4j2.xml /usr/local/tomcat8/webapps/solr/WEB-INF/classes/</div></pre></td></tr></table></figure><p><strong>6）修改tomcat的bin目录下catalina.bat脚本，增加solr.log.dir系统变量，指定solr日志记录存放地址。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@node21 solr]# vi /usr/local/tomcat8/bin/catalina.sh </div><div class="line">JAVA_OPTS=&quot;$JAVA_OPTS -Dsolr.log.dir=/usr/local/tomcat8/solrhome/logs&quot;</div></pre></td></tr></table></figure><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419094314-214585.jpg" alt=""></p><h3 id="3-启动服务"><a href="#3-启动服务" class="headerlink" title="3.启动服务"></a>3.启动服务</h3><p>启动tomcat，访问需要完整路径，我的是 <a href="http://47.106.180.186:8089/solr/index.html" target="_blank" rel="external">http://47.106.180.186:8089/solr/index.html</a></p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190419094507-951150.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CentOS搭建Solr7单机服务&quot;&gt;&lt;a href=&quot;#CentOS搭建Solr7单机服务&quot; class=&quot;headerlink&quot; title=&quot;CentOS搭建Solr7单机服务&quot;&gt;&lt;/a&gt;CentOS搭建Solr7单机服务&lt;/h1&gt;&lt;h2 id=&quot;一-Solr安装环境&quot;&gt;&lt;a href=&quot;#一-Solr安装环境&quot; class=&quot;headerlink&quot; title=&quot;一.Solr安装环境&quot;&gt;&lt;/a&gt;一.Solr安装环境&lt;/h2&gt;&lt;h3 id=&quot;1-官方参考文档&quot;&gt;&lt;a href=&quot;#1-官方参考文档&quot; class=&quot;headerlink&quot; title=&quot;1.官方参考文档&quot;&gt;&lt;/a&gt;1.官方参考文档&lt;/h3&gt;&lt;p&gt;Solr教程参考指南：&lt;a href=&quot;http://lucene.apache.org/solr/guide/7_4/solr-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://lucene.apache.org/solr/guide/7_4/solr-tutorial.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="CentOS" scheme="http://swenfang.github.io/categories/CentOS/"/>
    
    
      <category term="CentOS" scheme="http://swenfang.github.io/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>Java 内存区域与内存溢出异常</title>
    <link href="http://swenfang.github.io/2019/04/09/Java%20JVM/Java%20%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>http://swenfang.github.io/2019/04/09/Java JVM/Java 程序的运行机制/</id>
    <published>2019-04-09T13:38:01.763Z</published>
    <updated>2019-04-10T05:35:29.590Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-内存区域与内存溢出异常"><a href="#Java-内存区域与内存溢出异常" class="headerlink" title="Java 内存区域与内存溢出异常"></a>Java 内存区域与内存溢出异常</h1><p>对于 Java 程序员来说，把内存控制权力给了 Java 虚拟机，一旦出现了内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会成为一项异常艰难的工作。</p><a id="more"></a><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。java 虚拟机所管理的内存将会包括以下几个运行时数据区域：</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190409105825-592554.jpg" alt=""></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器是一块较小的内存，它可以看成当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-内存区域与内存溢出异常&quot;&gt;&lt;a href=&quot;#Java-内存区域与内存溢出异常&quot; class=&quot;headerlink&quot; title=&quot;Java 内存区域与内存溢出异常&quot;&gt;&lt;/a&gt;Java 内存区域与内存溢出异常&lt;/h1&gt;&lt;p&gt;对于 Java 程序员来说，把内存控制权力给了 Java 虚拟机，一旦出现了内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会成为一项异常艰难的工作。&lt;/p&gt;
    
    </summary>
    
      <category term="Java JVM" scheme="http://swenfang.github.io/categories/Java-JVM/"/>
    
    
      <category term="Java JVM" scheme="http://swenfang.github.io/tags/Java-JVM/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之ThreadLocal、Volatile、synchronized、Atomic关键字</title>
    <link href="http://swenfang.github.io/2019/04/08/java%20%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BThreadLocal%E3%80%81Volatile%E3%80%81synchronized%E3%80%81Atomic%E5%85%B3%E9%94%AE%E5%AD%97%E6%89%AB%E7%9B%B2/"/>
    <id>http://swenfang.github.io/2019/04/08/java 源码解读/并发编程之ThreadLocal、Volatile、synchronized、Atomic关键字扫盲/</id>
    <published>2019-04-08T14:53:15.275Z</published>
    <updated>2019-04-08T14:52:18.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程之ThreadLocal、Volatile、synchronized、Atomic关键字"><a href="#并发编程之ThreadLocal、Volatile、synchronized、Atomic关键字" class="headerlink" title="并发编程之ThreadLocal、Volatile、synchronized、Atomic关键字"></a>并发编程之ThreadLocal、Volatile、synchronized、Atomic关键字</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>对于ThreadLocal、Volatile、synchronized、Atomic这四个关键字，我想一提及到大家肯定都想到的是解决在多线程并发环境下资源的共享问题，但是要细说每一个的特点、区别、应用场景、内部实现等，却可能模糊不清，说不出个所以然来，所以，本文就对这几个关键字做一些作用、特点、实现上的讲解。</p><a id="more"></a><h2 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a><strong>Atomic</strong></h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h3><p>对于原子操作类，Java的concurrent并发包中主要为我们提供了这么几个常用的：AtomicInteger、AtomicLong、AtomicBoolean、AtomicReference&lt;<strong>T</strong>&gt;。<br>对于原子操作类，最大的特点是在多线程并发操作同一个资源的情况下，使用Lock-Free算法来替代锁，这样开销小、速度快，对于原子操作类是采用原子操作指令实现的，从而可以保证操作的原子性。什么是原子性？比如一个操作i++；实际上这是三个原子操作，先把i的值读取、然后修改(+1)、最后写入给i。所以使用Atomic原子类操作数，比如：i++；那么它会在这步操作都完成情况下才允许其它线程再对它进行操作，而这个实现则是通过Lock-Free+原子操作指令来确定的<br>如：<br>AtomicInteger类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">int</span> current = get();</div><div class="line">        <span class="keyword">int</span> next = current + <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (compareAndSet(current, next))</div><div class="line">            <span class="keyword">return</span> next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>而关于Lock-Free算法，则是一种新的策略替代锁来保证资源在并发时的完整性的，Lock-Free的实现有三步：</p><blockquote><p>1、循环（for(;;)、while）<br>2、CAS（CompareAndSet）<br>3、回退（return、break）</p></blockquote><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a><strong>用法</strong></h3><p>比如在多个线程操作一个count变量的情况下，则可以把count定义为AtomicInteger，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> count.get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</div><div class="line">        count.incrementAndGet();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在每个线程中通过increment()来对count进行计数增加的操作，或者其它一些操作。这样每个线程访问到的将是安全、完整的count。</p><h3 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a><strong>内部实现</strong></h3><p>采用Lock-Free算法替代锁+原子操作指令实现并发情况下资源的安全、完整、一致性</p><h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a><strong>Volatile</strong></h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a><strong>作用</strong></h3><p>Volatile可以看做是一个轻量级的synchronized，它可以在多线程并发的情况下保证变量的“可见性”，什么是可见性？就是在一个线程的工作内存中修改了该变量的值，该变量的值立即能回显到主内存中，从而保证所有的线程看到这个变量的值是一致的。所以在处理同步问题上它大显作用，而且它的开销比synchronized小、使用成本更低。 举个栗子：在写单例模式中，除了用静态内部类外，还有一种写法也非常受欢迎，就是Volatile+DCL：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</div><div class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">                    instance = <span class="keyword">new</span> Singleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样单例不管在哪个线程中创建的，所有线程都是共享这个单例的。</p><p>虽说这个Volatile关键字可以解决多线程环境下的同步问题，不过这也是相对的，因为它不具有操作的原子性，也就是它不适合在对该变量的写操作依赖于变量本身自己。举个最简单的栗子：在进行计数操作时count++，实际是count=count+1;，count最终的值依赖于它本身的值。所以使用volatile修饰的变量在进行这么一系列的操作的时候，就有并发的问题 举个栗子：因为它不具有操作的原子性，有可能1号线程在即将进行写操作时count值为4；而2号线程就恰好获取了写操作之前的值4，所以1号线程在完成它的写操作后count值就为5了，而在2号线程中count的值还为4，即使2号线程已经完成了写操作count还是为5，而我们期望的是count最终为6，所以这样就有并发的问题。而如果count换成这样：count=num+1；假设num是同步的，那么这样count就没有并发的问题的，只要最终的值不依赖自己本身。</p><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a><strong>用法</strong></h3><p>因为volatile不具有操作的原子性，所以如果用volatile修饰的变量在进行依赖于它自身的操作时，就有并发问题，如：count，像下面这样写在并发环境中是达不到任何效果的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>而要想count能在并发环境中保持数据的一致性，则可以在increment()中加synchronized同步锁修饰，改进后的为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a><strong>内部实现</strong></h3><p>汇编指令实现<br>可以看这篇详细了解：<a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.infoq.com%2Fcn%2Farticles%2Fftf-java-volatile" target="_blank" rel="external">Volatile实现原理</a></p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a><strong>synchronized</strong></h2><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a><strong>作用</strong></h3><p>synchronized叫做同步锁，是Lock的一个简化版本，由于是简化版本，那么性能肯定是不如Lock的，不过它操作起来方便，只需要在一个方法或把需要同步的代码块包装在它内部，那么这段代码就是同步的了，所有线程对这块区域的代码访问必须先持有锁才能进入，否则则拦截在外面等待正在持有锁的线程处理完毕再获取锁进入，正因为它基于这种阻塞的策略，所以它的性能不太好，但是由于操作上的优势，只需要简单的声明一下即可，而且被它声明的代码块也是具有操作的原子性。</p><h3 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a><strong>用法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</div><div class="line">        count++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (Counte.class)&#123;</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="内部实现-2"><a href="#内部实现-2" class="headerlink" title="内部实现"></a><strong>内部实现</strong></h3><p>重入锁ReentrantLock+一个Condition，所以说是Lock的简化版本，因为一个Lock往往可以对应多个Condition</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a><strong>ThreadLocal</strong></h2><h3 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a><strong>作用</strong></h3><p>关于ThreadLocal，这个类的出现并不是用来解决在多线程并发环境下资源的共享问题的，它和其它三个关键字不一样，其它三个关键字都是从线程外来保证变量的一致性，这样使得多个线程访问的变量具有一致性，可以更好的体现出资源的共享。</p><p>而ThreadLocal的设计，<strong>并不是解决资源共享的问题</strong>，而是用来提供线程内的局部变量，这样每个线程都自己管理自己的局部变量，别的线程操作的数据不会对我产生影响，互不影响，所以不存在解决资源共享这么一说，如果是解决资源共享，那么其它线程操作的结果必然我需要获取到，而ThreadLocal则是自己管理自己的，相当于封装在Thread内部了，供线程自己管理。</p><h3 id="用法-3"><a href="#用法-3" class="headerlink" title="用法"></a><strong>用法</strong></h3><p>一般使用ThreadLocal，官方建议我们定义为private static ，至于为什么要定义成静态的，这和内存泄露有关，后面再讲。 它有三个暴露的方法，set、get、remove。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;String&gt;()&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> String <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"hello"</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.num = num;</div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            threadLocal.set(String.valueOf(num));</div><div class="line">            System.out.println(<span class="string">"threadLocalValue:"</span>+threadLocal.get());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable(<span class="number">1</span>));</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable(<span class="number">2</span>));</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable(<span class="number">3</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果如下，这些ThreadLocal变量属于线程内部管理的，互不影响：</p><blockquote><p>threadLocalValue:2<br>threadLocalValue:3<br>threadLocalValue:4</p></blockquote><p>对于get方法，在ThreadLocal没有set值得情况下，默认返回null，所有如果要有一个初始值我们可以重写initialValue()方法，在没有set值得情况下调用get则返回初始值。</p><p><strong>值得注意的一点</strong>：ThreadLocal在线程使用完毕后，我们应该手动调用remove方法，移除它内部的值，这样可以防止内存泄露，当然还有设为static。</p><h3 id="内部实现-3"><a href="#内部实现-3" class="headerlink" title="内部实现"></a><strong>内部实现</strong></h3><p>ThreadLocal内部有一个静态类ThreadLocalMap，使用到ThreadLocal的线程会与ThreadLocalMap绑定，维护着这个Map对象，而这个ThreadLocalMap的作用是映射当前ThreadLocal对应的值，它key为当前ThreadLocal的弱引用：WeakReference</p><h4 id="内存泄露问题"><a href="#内存泄露问题" class="headerlink" title="内存泄露问题"></a><strong>内存泄露问题</strong></h4><p>对于ThreadLocal，一直涉及到内存的泄露问题，即当该线程不需要再操作某个ThreadLocal内的值时，应该手动的remove掉，为什么呢？我们来看看ThreadLocal与Thread的联系图：<br>此图来自网络：<br><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190407051647-962899.jpg" alt=""></p><p>其中虚线表示弱引用，从该图可以看出，一个Thread维持着一个ThreadLocalMap对象，而该Map对象的key又由提供该value的ThreadLocal对象弱引用提供，所以这就有这种情况： 如果ThreadLocal不设为static的，由于Thread的生命周期不可预知，这就导致了当系统gc时将会回收它，而ThreadLocal对象被回收了，此时它对应key必定为null，这就导致了该key对应得value拿不出来了，而value之前被Thread所引用，所以就存在key为null、value存在强引用导致这个Entry回收不了，从而导致内存泄露。</p><p>所以避免内存泄露的方法，是对于ThreadLocal要设为static静态的，除了这个，还必须在线程不使用它的值是手动remove掉该ThreadLocal的值，这样Entry就能够在系统gc的时候正常回收，而关于ThreadLocalMap的回收，会在当前Thread销毁之后进行回收。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><blockquote><p>关于Volatile关键字具有可见性，但不具有操作的原子性，而synchronized比volatile对资源的消耗稍微大点，但可以保证变量操作的原子性，保证变量的一致性，最佳实践则是二者结合一起使用。</p></blockquote><p>1、对于synchronized的出现，是解决多线程资源共享的问题，同步机制采用了“以时间换空间”的方式：访问串行化，对象共享化。同步机制是提供一份变量，让所有线程都可以访问。</p><p>2、对于Atomic的出现，是通过原子操作指令+Lock-Free完成，从而实现非阻塞式的并发问题。</p><p>3、对于Volatile，为多线程资源共享问题解决了部分需求，在非依赖自身的操作的情况下，对变量的改变将对任何线程可见。</p><p>4、对于ThreadLocal的出现，并不是解决多线程资源共享的问题，而是用来提供线程内的局部变量，省去参数传递这个不必要的麻烦，ThreadLocal采用了“以空间换时间”的方式：访问并行化，对象独享化。ThreadLocal是为每一个线程都提供了一份独有的变量，各个线程互不影响。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;并发编程之ThreadLocal、Volatile、synchronized、Atomic关键字&quot;&gt;&lt;a href=&quot;#并发编程之ThreadLocal、Volatile、synchronized、Atomic关键字&quot; class=&quot;headerlink&quot; title=&quot;并发编程之ThreadLocal、Volatile、synchronized、Atomic关键字&quot;&gt;&lt;/a&gt;并发编程之ThreadLocal、Volatile、synchronized、Atomic关键字&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;对于ThreadLocal、Volatile、synchronized、Atomic这四个关键字，我想一提及到大家肯定都想到的是解决在多线程并发环境下资源的共享问题，但是要细说每一个的特点、区别、应用场景、内部实现等，却可能模糊不清，说不出个所以然来，所以，本文就对这几个关键字做一些作用、特点、实现上的讲解。&lt;/p&gt;
    
    </summary>
    
      <category term="Java 源码解读" scheme="http://swenfang.github.io/categories/Java-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
    
      <category term="Java 源码解读" scheme="http://swenfang.github.io/tags/Java-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>第16章任务调度和异步执行器</title>
    <link href="http://swenfang.github.io/2019/04/04/Spring/%E7%AC%AC16%E7%AB%A0%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%92%8C%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E5%99%A8/"/>
    <id>http://swenfang.github.io/2019/04/04/Spring/第16章任务调度和异步执行器/</id>
    <published>2019-04-04T13:41:51.683Z</published>
    <updated>2019-04-20T12:49:00.072Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第16章任务调度和异步执行器"><a href="#第16章任务调度和异步执行器" class="headerlink" title="第16章任务调度和异步执行器"></a>第16章任务调度和异步执行器</h1><a id="more"></a><h2 id="任务调度概述"><a href="#任务调度概述" class="headerlink" title="任务调度概述"></a>任务调度概述</h2><h2 id="Quartz快速进阶"><a href="#Quartz快速进阶" class="headerlink" title="Quartz快速进阶"></a>Quartz快速进阶</h2><h3 id="Quartz-基础结构"><a href="#Quartz-基础结构" class="headerlink" title="Quartz 基础结构"></a>Quartz 基础结构</h3><ul><li>[ ] Job：开发者通过实现该接口来定义需要执行的的任务。Job 运行时的信息都保存在 JobDataMap 实例中。</li><li>[ ] JobDetail：描述 Job 的实现类及其他相关的静态信息，如 Job 名称、描述、关联监听器等信息。</li><li>[ ] Trigger：是一个类，描述触发 Job 执行的时间触发规则。 主要有 SimpleTrigger 和 CronTrigger 这两个子类。当仅需要触发一次或者以固定间隔周期性执行时，SimpleTrigger 是最合适的选择；而 CronTrigger 则可以通过表达式定义出各种复杂的调度方案，如每天早晨 9:00 执行，每周一，周三，周五下午 5:00 执行等。 </li><li>[ ] Calendar：是一些日历特定时间点的集合</li><li>[ ] Scheduler：代表一个 Quartz 的独立运行容器。</li><li>[ ] ThreadPool：Scheduler 使用一个线程池作为任务运行的基础设施，任务通过共享线程池的线程来提高运行效率。</li></ul><p>如下图，描述了 Scheduler 的内部组件结构。SchedulerContext 提供了 Scheduler 全局可见的上下文信息，每个任务都对应一个 JobDataMap ，虚线框中的 JobDataMap 表示有状态的任务。</p><p>一个 Scheduler 可以拥有多个 Trigger 和多个 JobDetail ，它们可以分到不同的组中。在注册 Trigger 和 JobDetail 时，如果不显示指定所属的组，那么 Scheduler 将放到默认的组中，默认的组名为 Scheduler.DEFAULT_GROUP。组名和名称组成了对象的全名，同一类型对象（Job 或 Trigger）的全名不能相同。</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190405022855-962145.jpg" alt=""></p><p>Scheduler 本身就是一个容器，它维护者 Quartz 的各种组件并实施调度的规则。Scheduler 还拥有一个线程池，线程池为任务提供执行线程。这比执行任务时简单的创建一个新的线程要拥有更高的效率，同时通过共享机制可以较少资源的占用。基于线程池组件的支持，对于繁忙度高、压力大的任务调度，Quartz 可以提供良好的伸缩性。</p><h3 id="使用Simple-Trigger"><a href="#使用Simple-Trigger" class="headerlink" title="使用Simple Trigger"></a>使用Simple Trigger</h3><p>SImpleTrigger 拥有多个重载的构造函数，用于在不同场合下构造对应的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleTrigger</span> <span class="keyword">extends</span> <span class="title">Trigger</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">/*指定 Trigger 所属组和名称*/</span>    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleTrigger</span><span class="params">(String name, String group)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(name, group, <span class="keyword">new</span> Date(), (Date)<span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0L</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*指定 Trigger 所属组、名称和触发时间*/</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleTrigger</span><span class="params">(String name, Date startTime)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(name, (String)<span class="keyword">null</span>, startTime);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/*指定 Trigger 所属组、名称、开始时间、结束时间、重复次数、时间间隔*/</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleTrigger</span><span class="params">(String name, String group, Date startTime, Date endTime, <span class="keyword">int</span> repeatCount, <span class="keyword">long</span> repeatInterval)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(name, group);</div><div class="line">        <span class="keyword">this</span>.startTime = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">this</span>.endTime = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">this</span>.nextFireTime = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">this</span>.previousFireTime = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">this</span>.repeatCount = <span class="number">0</span>;</div><div class="line">        <span class="keyword">this</span>.repeatInterval = <span class="number">0L</span>;</div><div class="line">        <span class="keyword">this</span>.timesTriggered = <span class="number">0</span>;</div><div class="line">        <span class="keyword">this</span>.complete = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">this</span>.setStartTime(startTime);</div><div class="line">        <span class="keyword">this</span>.setEndTime(endTime);</div><div class="line">        <span class="keyword">this</span>.setRepeatCount(repeatCount);</div><div class="line">        <span class="keyword">this</span>.setRepeatInterval(repeatInterval);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">   <span class="comment">/*这是最复杂的一个构造函数，在指定触发参数的同时，通过 jobGroup 和 jobName ,使该 Trigger 和 Scheduler 中的某个任务关联起来*/</span> </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">SimpleTrigger</span><span class="params">(String name, String group, String jobName, String jobGroup, Date startTime, Date endTime, <span class="keyword">int</span> repeatCount, <span class="keyword">long</span> repeatInterval)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(name, group, jobName, jobGroup);</div><div class="line">        <span class="keyword">this</span>.startTime = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">this</span>.endTime = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">this</span>.nextFireTime = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">this</span>.previousFireTime = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">this</span>.repeatCount = <span class="number">0</span>;</div><div class="line">        <span class="keyword">this</span>.repeatInterval = <span class="number">0L</span>;</div><div class="line">        <span class="keyword">this</span>.timesTriggered = <span class="number">0</span>;</div><div class="line">        <span class="keyword">this</span>.complete = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">this</span>.setStartTime(startTime);</div><div class="line">        <span class="keyword">this</span>.setEndTime(endTime);</div><div class="line">        <span class="keyword">this</span>.setRepeatCount(repeatCount);</div><div class="line">        <span class="keyword">this</span>.setRepeatInterval(repeatInterval);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过实现 org.quartz.Job 接口，可以是 Java 类变成可调度的任务，如下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext jobCtx)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</div><div class="line">        System.out.println(jobCtx.getTrigger().getName()+<span class="string">"triggered. time is:"</span>+<span class="keyword">new</span> Date());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过 SimpleTrigger 对 SimpleJob 进行调度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleTriggerRunner</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">/*创建一个 JobDetail 实例，指定 SimpleJob*/</span></div><div class="line">            JobDetail jobDetail = <span class="keyword">new</span> JobDetail(<span class="string">"job1_1"</span>,<span class="string">"jdroup1"</span>, SimpleJob.class);</div><div class="line"></div><div class="line">            <span class="comment">/*通过 SimpleTrigger 定义调度规则：马上启动，每2秒运行一次，共运行100次*/</span></div><div class="line">            SimpleTrigger simpleTrigger = <span class="keyword">new</span> SimpleTrigger(<span class="string">"Trigger1_1"</span>,<span class="string">"tgroup1"</span>);</div><div class="line">            simpleTrigger.setStartTime(<span class="keyword">new</span> Date());</div><div class="line">            simpleTrigger.setRepeatInterval(<span class="number">2000</span>);</div><div class="line">            simpleTrigger.setRepeatCount(<span class="number">100</span>);</div><div class="line"></div><div class="line">            <span class="comment">/*通过 SchedulerFactory 获取一个调度器实例*/</span></div><div class="line">            SchedulerFactory schedulerFactory = <span class="keyword">new</span> StdSchedulerFactory();</div><div class="line">            Scheduler scheduler = schedulerFactory.getScheduler();</div><div class="line"></div><div class="line">            <span class="comment">/*注册并进行调度*/</span></div><div class="line">            scheduler.scheduleJob(jobDetail,simpleTrigger);</div><div class="line">            scheduler.start(); <span class="comment">/*调度启动*/</span></div><div class="line">        &#125; <span class="keyword">catch</span> (SchedulerException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>还可以通过 SimpleTrigger 的 setStartTime(Date startTime) 和 setEndTime(Date endTime) 的方法指定运行的时间范围。当运行次数和时间范围产生冲突时，超过时间范围的任务不被执行。如可以通过 simpleTrigger.setStartTime(new Date(System.CurrentTimeMillis()+60000L))方法指定 60 秒后开始运行。</p><p>执行结果：</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190405033803-608110.jpg" alt=""></p><h3 id="使用-CronTrigger"><a href="#使用-CronTrigger" class="headerlink" title="使用 CronTrigger"></a>使用 CronTrigger</h3><p>CronTrigger 能够提供比 SimpleTrigger 更有具体实际意义的调度方案，调度规则基于 Cron 表达式。CronTrigger 支持日历相关的周期时间间隔（比如每月第一个周一执行），而不是简单的周期时间间隔。</p><h4 id="Cron-表达式"><a href="#Cron-表达式" class="headerlink" title="Cron 表达式"></a>Cron 表达式</h4><p>Quartz 使用类似于 Linux 下的 Cron 表达式定义时间规则。Cron 表达式由 6 或 7 个空格的时间字段组成，如下表：</p><p>Cron 表达式时间字段：</p><table><thead><tr><th>位置</th><th>时间域名</th><th>允许值</th><th>允许的特殊字符</th></tr></thead><tbody><tr><td>1</td><td>秒</td><td>0-59</td><td>,-*/</td></tr><tr><td>2</td><td>分钟</td><td>0-59</td><td>,-*/</td></tr><tr><td>3</td><td>小时</td><td>0-23</td><td>,-*/</td></tr><tr><td>4</td><td>日期</td><td>1-31</td><td>,-*?/L W C</td></tr><tr><td>5</td><td>月份</td><td>1-12</td><td>,-*/</td></tr><tr><td>6</td><td>星期</td><td>1-7</td><td>,-*?/L C #</td></tr><tr><td>7</td><td>年（可选）</td><td>空值1970-2099</td><td>,-*/</td></tr></tbody></table><p>Cron 表达式的时间字段除允许设置数值外，该可以使用一些特殊的字符，提供列表、范围、通配符等功能，如下：</p><ul><li>星号（*）：可用在所有字段中，表示对应时间域的某一时刻。</li><li>【例如：*在分钟字段时，表示“每分钟”。】</li><li>问好（?）：该字符只在日期和星期字段中使用，它通常指定为“毫无意义的值”，相当于占位符</li><li>减号（-）：表示一个范围。【例如：在小时字段中使用”10-12”，则表示从10点到12点，即10，11，12】</li><li>逗号（,）：表示一个列表值。【例如：在星期字段中使用”MON,WED,FRI”，则表示星期一、星期三和星期】</li><li>斜杠（/）：x/y 表达一个等长序列，x 为起始值，y为增量步长值。如在分钟字段中使用 0/15 ,则表示为 0,15,30 和 45 秒；而 5/15 在分钟字段中表示 5,20,35,50 。用户可以使用 */y，它等同于 0/y。</li><li>L：在日期和星期字段中使用，在日期中表示这个月的最后一天，在星期中使用表示这星期的周六。但是，如果L出现在星期字段里，而且前面有一个数字N，则表示“这个月的最后N天”。【例如：6L 表示该约的最后一个星期五】</li><li>W：该字符只出现在日期字段里，是对前导日期的修饰，表示该日期最近的工作日。W字符串只能指定单一日期，而不能指定日期范围。</li><li>LW组合：在日期字段中使用，当月的最后一个工作日。</li><li>井号（#）：该字符只能在星期字段中使用，表示当月的某个工作日。【例如：6#3表示当月的第3个星期五（6表示星期五，#3 表示当前的第三个），而  4#5 表示当月的第五个星期三。假如当月没有第五个星期三，则忽略不触发。】</li><li>C：只在日期和星期字段中使用，代表”Calendar”的意思。它是指计划所关联的日期，如果日期没有被关联到，则相当于日历中的所有日期。【例如：5C 在日期字段中相当于5日以后的那一天，1C在星期字段中相当于星期日后的第一天】</li></ul><p>Cron 表达式对特殊字符的大小写不敏感，对代表星期的缩写也不敏感。</p><p>Cron 表示式示例：</p><table><thead><tr><th>表示式</th><th>说明</th></tr></thead><tbody><tr><td>“0 0 12 <em> </em> ? “</td><td>每天 12:00 运行</td></tr><tr><td>“0 15 10 ? <em> </em>“</td><td>每天 10:15 运行</td></tr><tr><td>“0 15 10 <em> </em> ?”</td><td>每天 10:15 运行</td></tr><tr><td>“0 15 10 <em> </em> ? *”</td><td>每天 10:15 运行</td></tr><tr><td>“0 15 10 <em> </em> ? 2008”</td><td>2008 年的每天 10:15 运行</td></tr><tr><td>“0 <em> 14 </em> * ?”</td><td>每天14点到15点每分钟运行一次。开始于14:00 ，结束于14:59</td></tr><tr><td>“0 0/15 14 <em> </em> ?”</td><td>每天14点到15点每5分钟运行一次，开始于 14:00 ，结束于14:59</td></tr><tr><td>“0 0/5 14,18 <em> </em> ?”</td><td>每天14点到15点每5分钟运行一次，此外每天 18点到19点每5分钟也运行一次</td></tr><tr><td>“0 0-15 14 <em> </em> ?”</td><td>每天14:00 到 14:05，每分钟运行一次</td></tr><tr><td>“0 10,44 14 ? 3 WED”</td><td>3月每周三的 14:10 到 14:44 ,每分钟运行一次</td></tr><tr><td>“0 15 10 ? * MON-FRI”</td><td>每周一、二、三、四、五的 10:15 运行</td></tr><tr><td>“0 15 10 15 * ?”</td><td>每月15 日的 10:15 运行</td></tr><tr><td>“0 15 10 L * ?”</td><td>每月最后一天星期五的 10:15 运行</td></tr><tr><td>“0 15 10 ? * 6L”</td><td>每月最后一个星期五的 10:15 运行</td></tr><tr><td>“0 15 10 ? 6L 2014-2016”</td><td>2014年、2015年、2016年每月最后一个星期五的 10:15 运行</td></tr><tr><td>“0 15 10 ? * 6#3”</td><td>每月第三个星期五的 10:15 运行</td></tr></tbody></table><h4 id="CronTrigger-实例"><a href="#CronTrigger-实例" class="headerlink" title="CronTrigger  实例"></a>CronTrigger  实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CronTriggerRunner</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            JobDetail jobDetail = <span class="keyword">new</span> JobDetail(<span class="string">"job_2"</span>,<span class="string">"jGroup1"</span>, SimpleJob.class);</div><div class="line"></div><div class="line">            <span class="comment">/*创建 CronTrigger,指定组及名称*/</span></div><div class="line">            CronTrigger cronTrigger = <span class="keyword">new</span> CronTrigger(<span class="string">"trigger1_2"</span>,<span class="string">"tgroup1"</span>);</div><div class="line">            <span class="comment">/*定义 Cron 表达式*/</span></div><div class="line">            CronExpression cexp = <span class="keyword">new</span> CronExpression(<span class="string">"0/5 * * * * ?"</span>);</div><div class="line">            <span class="comment">/*设置 Cron 表达式*/</span></div><div class="line">            cronTrigger.setCronExpression(cexp);</div><div class="line"></div><div class="line"><span class="comment">/*②*/</span></div><div class="line">            SchedulerFactory schedulerFactory = <span class="keyword">new</span> StdSchedulerFactory();</div><div class="line">            Scheduler scheduler = schedulerFactory.getScheduler();</div><div class="line">            scheduler.scheduleJob(jobDetail,cronTrigger);</div><div class="line">            scheduler.start();</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行 CronTriggerRunner，每5秒将触发 SimpleJob 运行一次。在默认情况下，Cron 表达式对应当前的时区，可以通过 CronTriggerRunner  的 setTimeZone(TimeZone timeZone) 方法显示指定时区。也可以指定开始时间和结束时间。</p><p><code>注意</code>：在代码 ② 处需要通过 Thread.currentThread.sleep() 方法让主线程睡眠一段时间，使调度器可以继续执行任务调度的工作；否则在调度器启动后，因为主线程立即退出，寄生于主线程的调度器也将关闭，调度器的任务都将相应的销毁，这将导致看不到实际的运行效果。在单元测试的时候，使主线程休眠一段时间以便让任务线程不被提前终止是经常使用的测试方法。对于测试某些长周期执行的调度任务，开发者可以简单地调整操作系统时间进行模拟。</p><p>运行结果：</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190406025400-7454.jpg" alt=""></p><h3 id="使用-Calender"><a href="#使用-Calender" class="headerlink" title="使用 Calender"></a>使用 Calender</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> com.mrsw.adx.admin.service.impl.SimpleJob;</div><div class="line"><span class="keyword">import</span> org.quartz.*;</div><div class="line"><span class="keyword">import</span> org.quartz.impl.StdSchedulerFactory;</div><div class="line"><span class="keyword">import</span> org.quartz.impl.calendar.AnnualCalendar;</div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Calendar;</div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"><span class="keyword">import</span> java.util.GregorianCalendar;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalendarExample</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            SchedulerFactory sf = <span class="keyword">new</span> StdSchedulerFactory();</div><div class="line">            Scheduler scheduler = sf.getScheduler();</div><div class="line"></div><div class="line">            <span class="comment">/*法定节日是以每年为周期的，所以使用 AnnualCalendar*/</span></div><div class="line">            AnnualCalendar holidays = <span class="keyword">new</span> AnnualCalendar();</div><div class="line"></div><div class="line">            <span class="comment">/*五一劳动节*/</span></div><div class="line">            Calendar laborDay = <span class="keyword">new</span> GregorianCalendar();</div><div class="line">            laborDay.add(Calendar.MONTH,<span class="number">5</span>);</div><div class="line">            laborDay.add(Calendar.DATE,<span class="number">1</span>);</div><div class="line"></div><div class="line">            <span class="comment">/*国庆节*/</span></div><div class="line">            Calendar nationalDay = <span class="keyword">new</span> GregorianCalendar();</div><div class="line">            nationalDay.add(Calendar.MONTH,<span class="number">10</span>);</div><div class="line">            nationalDay.add(Calendar.DATE,<span class="number">1</span>);</div><div class="line"></div><div class="line">            <span class="comment">/*排除这两个特殊日期*/</span></div><div class="line">            ArrayList&lt;Calendar&gt; calendars = <span class="keyword">new</span> ArrayList&lt;Calendar&gt;();</div><div class="line">            calendars.add(laborDay);</div><div class="line">            calendars.add(nationalDay);</div><div class="line">            holidays.setDaysExcluded(calendars);<span class="comment">/*①*/</span></div><div class="line"></div><div class="line">            <span class="comment">/*向 Scheduler 注册日历*/</span></div><div class="line">            scheduler.addCalendar(<span class="string">"holidays"</span>,holidays,<span class="keyword">false</span>,<span class="keyword">false</span>);</div><div class="line"></div><div class="line">            <span class="comment">/*4月1日上午10点*/</span></div><div class="line">            Date runDate = TriggerUtils.getDateOf(<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">4</span>);</div><div class="line">            JobDetail job = <span class="keyword">new</span> JobDetail(<span class="string">"job1"</span>,<span class="string">"group1"</span>, SimpleJob.class);</div><div class="line">            SimpleTrigger trigger = <span class="keyword">new</span> SimpleTrigger(<span class="string">"trigger1"</span>,<span class="string">"group1"</span>,runDate,</div><div class="line">                    <span class="keyword">null</span>,SimpleTrigger.REPEAT_INDEFINITELY,</div><div class="line">                    <span class="number">60L</span> * <span class="number">60L</span> * <span class="number">1000L</span>);</div><div class="line">            trigger.setCalendarName(<span class="string">"holidays"</span>);</div><div class="line">            <span class="comment">/*让 Trigger 应用指定的日历规则*/</span></div><div class="line"></div><div class="line">            scheduler.scheduleJob(job,trigger);</div><div class="line">            scheduler.start();</div><div class="line">            <span class="comment">// 在实际应用中主线程不能停止，否则 Scheduler 得不到执行，此处省略</span></div><div class="line">        &#125; <span class="keyword">catch</span> (SchedulerException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>注意</code>：在向 Scheduler 注册日历的时候，addCalendar(String calName,Calendar calendar,boolean replace,boolean updateTrigger)。如果 updateTrigger 为 true,则 Scheduler 中引用 Calendar 的 Trigger 将得到更新，如①所示。</p><h3 id="任务调度信息存储"><a href="#任务调度信息存储" class="headerlink" title="任务调度信息存储"></a>任务调度信息存储</h3><p>默认情况下，Quartz 将任务调度的运行信息（调度现场信息包括运行次数、调度规则和JobDataMap 中的数据等。）保存在内存中。这种方法提供了最佳的性能，因为在内存中数据访问速度最快；不足之处在于缺乏数据的持久性，当程序中途停止或系统崩溃时，所有运行的信息都会丢失。</p><p>持久化任务调度信息，可以通过调整 Quartz 的属性文件，将这些数据保存到数据库。</p><h4 id="通过配置文件调整任务调度信息的保存策略"><a href="#通过配置文件调整任务调度信息的保存策略" class="headerlink" title="通过配置文件调整任务调度信息的保存策略"></a>通过配置文件调整任务调度信息的保存策略</h4><p>在 Quartz  JAR 文件的 org.quartz 包下就包含了一个 quartz.properties 属性配置文件，并提供了默认配置。如果需要调整默认配置，则可以直接在类路径下建立一个新的 quartz.properties 属性文件，它将被 Quartz加载并覆盖默认的配置。</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190406051505-539589.jpg" alt=""></p><p>Quartz 的属性文件配置主要包括以下三方面的信息：</p><ol><li>集群信息</li><li>调度器线程池</li><li>任务调度现场数据的保存</li></ol><p><code>注意</code>：如果任务数目很大，则可以通过增大线程池获得更好的性能。</p><p>可以通过 以下设置将任务调度现场数据保存到数据库。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># 要将任务调度保存到数据库，必须使用 JobStoreTX 代替原来的 RAMJobStore</div><div class="line">org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX</div><div class="line"># 数据库表前缀</div><div class="line">org.quartz.jobStore.tablePrefix = QRTZ_</div><div class="line"># 数据源名称</div><div class="line">org.quartz.jobStore.dataSource = qzDS</div><div class="line"></div><div class="line"># 定义数据源的具体属性</div><div class="line">org.quartz.dataSource.qzDS.driver = com.mysql.jdbc.Driver</div><div class="line">org.quartz.dataSource.qzDS.URL = jdbc:mysql://localhost:3306/sampledb</div><div class="line">org.quartz.dataSource.qzDS.user = stamen</div><div class="line">org.quartz.dataSource.qzDS.password = abd</div><div class="line">org.quartz.dataSource.qzDS.maxConnections = 10</div></pre></td></tr></table></figure><p><code>注意</code>：必须事先在相应的数据库中创建 Quartz 的数据表（8张），在 Quartz 的完整发布的 dosc/dbTables 目录下拥有对应的不同的数据库脚本。</p><h4 id="查询数据库的运行信息"><a href="#查询数据库的运行信息" class="headerlink" title="查询数据库的运行信息"></a>查询数据库的运行信息</h4><h2 id="在Spring中使用Quartz"><a href="#在Spring中使用Quartz" class="headerlink" title="在Spring中使用Quartz"></a>在Spring中使用Quartz</h2><p>Spring 为创建 Quartz 的 Scheduler 、Trigger 和 JobDetail 提供了便利的 FactoryBean 类，以便能够在 Spring 容器中享受注入的好处。</p><p>Spring 为 Quartz 提供了两个方面的支持：</p><p>（1）为 Quartz 的重要组件提供更具 Bean 风格的扩展类</p><p>（2）提供创建 Scheduler 的 BeanFactory 类，方便在 Spring 环境下创建对应的组件对象，并结合 Spring 容器生命周期执行启动和停止的动作。</p><h3 id="创建-JobDetail"><a href="#创建-JobDetail" class="headerlink" title="创建 JobDetail"></a>创建 JobDetail</h3><p>Spring 通过扩展 JobDetail 提供了一个更具 Bean 风格的 JobDetailFactoryBean。还提供了一个 MethodInvokingJobDetailBean，通过这个 FactoryBean 可以将 Spring 容器中 Bean 的方法包装成 Quartz 任务，这样开发者就不必为 Job 创建对应的类。</p><h4 id="JobDetailFactoryBean"><a href="#JobDetailFactoryBean" class="headerlink" title="JobDetailFactoryBean"></a>JobDetailFactoryBean</h4><p>扩展于 Quartz 的 JobDetail 。使用该 Bean 声明 JobDetail 时，bean 的名字即任务的名字，如果没有指定所属组，就使用默认组。除了 JobDetail 的属性外，还定义了以下属性：</p><ul><li>jobCalss：类型为 Class，实现 Job 接口的任务类</li><li>beanName：默认为 Bean 的 id 名，通过该属性显示指定 Bean 名称，它对应任务的名称。</li><li>jobDataAsMap：类型为 Map ，为任务所对应的 JobDataMap 提供值。</li><li>applicationContextJobDataKey：可以将 Spring ApplicationContext 的引用保存到 JobDataMap 中，以便在 Job 的代码中访问 ApplicationContext。需要指定一个健用于在 jobDataAsMap 中保存 ApplicationContext。</li><li>jobListenerName：类型为 String[] ，指定注册在 Scheduler 中的 JobDataMap 名称，以便让这些监听器对本任务的事件进行监听。</li></ul><p>在下面的配置片段中使用 JobDetailBean 在 Spring 中配置一个 JobDetail</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;bean name="jobDetail" class="org.springframework.scheduling.quartz.JobDetailBean"</div><div class="line">    p:jobClass="com.smart.quartz.MyJob"</div><div class="line">    p:applicationContextJobDataKey="applicationContext"&gt;</div><div class="line">    &lt;property&gt;</div><div class="line">    &lt;map&gt;</div><div class="line">    &lt;entry key=“size” value="10"/&gt;</div><div class="line">        &lt;/map&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure><p>说明：JobDetailFactoryBean 封装了 MyJob 任务，并为 Job 对应的 JobDataMap 设置了一个健为 size 的数据。此外，通过指定 applicationContextJobDataKey ，让 Job 的 JobDataMap 持有 Spring ApplicationContext 的引用。</p><p>这样，MyJob 在运行时就可以通过 JobDataMap 访问到 size 和 ApplicationContext。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext jctx)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">/*获取 JobDetail 关联的 JobDataMap*/</span></div><div class="line">        Map dataMap = jctx.getJobDetail().getJobDataMap();</div><div class="line">        String size = (String) dataMap.get(<span class="string">"size"</span>);</div><div class="line"></div><div class="line">        ApplicationContext ctx = (ApplicationContext)dataMap.get(<span class="string">"applicationContext"</span>);</div><div class="line">        System.out.println(<span class="string">"size："</span>+size);</div><div class="line">        <span class="comment">/*① 对 JobDataMap 所做的更改是否被持久化取决于任务的类型*/</span></div><div class="line">        dataMap.put(<span class="string">"size"</span>,size+<span class="string">"0"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在代码 ① 处对 JobDataMap 进行修改。如果 MyJob 实现了 Job 接口，则这种更改对于下一次执行是不可见的；如果 MyJob 实现了 StatefulJob 接口，则这种更改对于下一次执行是可见的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJob</span> <span class="keyword">implements</span> <span class="title">StatefulJob</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext jctx)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</div><div class="line"><span class="comment">//    Map dataMap = jctx.getJobDetail().getJobDataMap();</span></div><div class="line">        Map dataMap = jctx.getTrigger().getJobDataMap();</div><div class="line">        String size =(String)dataMap.get(<span class="string">"size"</span>);</div><div class="line">        ApplicationContext ctx = (ApplicationContext)dataMap.get(<span class="string">"applicationContext"</span>);</div><div class="line">        System.out.println(<span class="string">"size:"</span>+size);</div><div class="line">        dataMap.put(<span class="string">"size"</span>,size+<span class="string">"0"</span>);</div><div class="line"></div><div class="line">        String count =(String)dataMap.get(<span class="string">"count"</span>);</div><div class="line">        System.out.println(<span class="string">"count:"</span>+count);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="MethodInvokingJobDetailFactryBean"><a href="#MethodInvokingJobDetailFactryBean" class="headerlink" title="MethodInvokingJobDetailFactryBean"></a>MethodInvokingJobDetailFactryBean</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 通过封装服务类方法实现 --&gt;</div><div class="line">&lt;bean id=<span class="string">"jobDetail_1"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"</span></div><div class="line">p:targetObject-ref=<span class="string">"myService"</span> p:targetMethod=<span class="string">"doJob"</span></div><div class="line">p:concurrent=<span class="string">"false"</span>/&gt;</div><div class="line">&lt;bean id=<span class="string">"myService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.smart.service.MyService"</span> /&gt;</div></pre></td></tr></table></figure><p>jobDetail_1 将 MyService#doJob() 封装成一个任务，同时通过 concurrent 属性指定任务的类型。默认情况下为无状态的任务。如果希望封装为有状态的任务，仅需将 concurrent 属性设置为 false 就可以了。Sping 通过名为 concurrent 的属性指定任务类型，能够更直接的描述任务执行的方式（有状态的任务不能并发执行，无状态的任务可以并发执行），对于不熟悉 Quartz 内部机制的用户来说，比起 stateful ，concurrent 更简明达意。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</div><div class="line">   <span class="comment">/*被封装成任务的目标方法*/</span> </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doJob</span><span class="params">()</span></span>&#123;</div><div class="line">   System.out.println(<span class="string">"in MyService.dojob()."</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>注意</code>：通过 MethodInvokingJobDetailFactoryBean 产生的 JobDetail 不能被序列化，所以不能持久化到数据库。若希望使用持久化任务，则只能创建正规的 Quartz 的 Job 实现类 。</p><h3 id="创建-Trigger"><a href="#创建-Trigger" class="headerlink" title="创建 Trigger"></a>创建 Trigger</h3><h4 id="SimpleTriggerFactoryBean"><a href="#SimpleTriggerFactoryBean" class="headerlink" title="SimpleTriggerFactoryBean"></a>SimpleTriggerFactoryBean</h4><p>在默认情况下，通过 SimpleTriggerFactoryBean 配置的 Trigger 名称即为 Bean 的名称，属于默认组。SimpleTriggerFactoryBean 在 SimpleTrigger 的基础上新增了以下属性。</p><p>jobDetail：对应的 JobDetail。</p><p>beanName：默认为 Bean 的 id 名，通过该属性显示指定 Bean 名称，它对应 Trigger 的名称。</p><p>jobDataAsMap：以 Map 类型为 Trigger 关联的  JobDataMap 提供值。</p><p>startDelay：延迟多少时间开始触发，单位为毫秒，默认值为0</p><p>triggerListenerNames：类型为 String[]，指定注册在 Scheduler 中的 TriggerListener 名称，以便让这些监听器对本触发器的时间进行监听。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;bean id="simpleTrigger" class="org.springframework.scheduling.quartz.SimpleTriggerBean"</div><div class="line">p:jobDetail-ref="jobDetail" p:startDelay="1000" p:repeatInterval="2000"</div><div class="line">p:repeatCount="100"&gt;</div><div class="line">&lt;property name="jobDataAsMap"&gt;&lt;!--①--&gt;</div><div class="line">&lt;map&gt;</div><div class="line">&lt;entry key="count" value="10" /&gt;</div><div class="line">&lt;/map&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure><p>代码①处配置的 Map 数据将填充到 Trigger 的 JobDataMap 中，执行任务时必须通过以下方式获取配置的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJob</span> <span class="keyword">implements</span> <span class="title">StatefulJob</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext jctx)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</div><div class="line">        Map dataMap = jctx.getTrigger().getJobDataMap();</div><div class="line">        <span class="comment">/*对 JobDataMap 的更改不会被持久化，不影响下次的执行*/</span></div><div class="line">        String count =(String)dataMap.get(<span class="string">"count"</span>);</div><div class="line">        System.out.println(<span class="string">"count:"</span>+count);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="CronTriggerFactoryBean"><a href="#CronTriggerFactoryBean" class="headerlink" title="CronTriggerFactoryBean"></a>CronTriggerFactoryBean</h4><p>扩展于 CronTrigger ,触发器的名称即为 Bean 的名称，保存在默认组中。在 CronTrigger 的基础上，新增的属性和 SimpleTriggerFactoryBean 大致相同，配置的方法也和 SimpleTriggerFactoryBean 相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=<span class="string">"checkImagesTrigger"</span> </div><div class="line">      <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.scheduling.quartz.CronTriggerBean"</span></div><div class="line">      p:jobDetail-ref=<span class="string">"jobDetail"</span></div><div class="line">      p:cronExpression=<span class="string">"0/5 * * * * ?"</span>/&gt;</div></pre></td></tr></table></figure><h3 id="创建Scheduler"><a href="#创建Scheduler" class="headerlink" title="创建Scheduler"></a>创建Scheduler</h3><p>Quartz 的 SchedulerFactory 是标准的工厂类，不太合适在 Spring 环境下使用。此外，为了保证 Scheduler 能够感知 Spring 容器的生命周期，在 Spring 容器启动后，Scheduler 自动开始工作，而在 Spring 容器关闭之前，自动关闭 Scheduler 。Spring 提供了 SchedulerFactoryBean，这个 FactoryBean 大致拥有以下功能。</p><ul><li>以更具 Bean 风格的方式为 FactoryBean 提供配置信息。</li><li>让 Scheduler 和 Spring 容器的生命周期建立关联，相生相息</li><li>通过属性配置的方式代替 Quartz 自身的配置文件 </li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;bean id="scheduler" class="org.springframework.scheduling.quartz.SchedulerFactory"&gt;</div><div class="line">&lt;!--注册多个 trigger--&gt;</div><div class="line">&lt;property name="triggers"&gt;</div><div class="line">&lt;list&gt;</div><div class="line">&lt;ref bean="simpleTrigger"/&gt;</div><div class="line">    &lt;/list&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">    &lt;!--以Map类型设置 SchedulerContext 数据--&gt;</div><div class="line">    &lt;property name="schedulerContextAsMap"&gt;</div><div class="line">    &lt;map&gt;</div><div class="line">    &lt;entry key="timeout" value="30"/&gt;</div><div class="line">    &lt;/map&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">    &lt;!--显示指定 quartz 的配置文件地址--&gt;</div><div class="line">    &lt;properties name="configLocation" value="classpath:com/smart/quartz/quartz.properties"/&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure><p>SchedulerFactoryBean 还有以下常见的属性：</p><ul><li>calendars：类型为 Map，通过该属性向 Scheduler 注册 Calendar</li><li>jobDetails：类型为 JobDetail[]，通过该属性向 Scheduler 注册 JobDetail</li><li>autoStartup：SchedulerFactoryBean 在初始化后是否马上启动 Scheduler，默认为 true。若设置为 false，则需要手动启动 Scheduler</li><li>startupDelay：在 SchedulerFactoryBean 在初始化完成后，延迟多少秒后启动 Scheduler，默认为0。除非拥有需要立即执行的任务，一般情况下，可以通过 startupDelay 属性让 Scheduler 延迟一小段时间后启动，以便让 Spring 能够更快初始化容器中剩余的 Bean</li></ul><p>SchedulerFactoryBean 的一个重要功能是允许用户将 Quartz 配置文件的信息转移到 Spring 配置文件中。SchedulerFactoryBean 通过以下属性代替框架的自身配置文件：</p><ul><li>dataSource：当需要持久化任务调度数据时，在 Quartz 中配置数据源，也可以直接在 Spring 中通过 dataSource 指定一个 Spring 管理的数据源。如果指定了该属性，即使 quartz.properties 中已经定义了数据源，也会被 dataSource 覆盖</li><li>transactionManager：可以通过该属性设置一个 Spring 事务管理器</li><li>nonTransactionalDataSource：在全局事务的情况下，如果不希望 Scheduler 执行的相关数据操作参与到全局事务中，则可以通过该属性指定数据源。在 Spring 本地事务的情况下，使用 dataSource 属性就足够了</li><li>quartzProperties：类型为 properties ，允许用户在 Spring 中定义 Quartz 的属性，其值将覆盖 quartz.properties 配置文件中的设置。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;bean id="scheduler"</div><div class="line">class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt;</div><div class="line">&lt;property name="quartzProperties"&gt;</div><div class="line">&lt;props&gt;</div><div class="line">&lt;!--属性值1--&gt;</div><div class="line">&lt;prop key="org.quartz.threadPool.class"&gt;</div><div class="line">org.quartz.simpl.SimpleThreadPool</div><div class="line">&lt;/prop&gt;</div><div class="line">&lt;!--属性值2--&gt;</div><div class="line">&lt;prop key="org.quartz.threadPool.threadCount"&gt;10&lt;/prop&gt;</div><div class="line">&lt;/props&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure><h2 id="在Spring中使用JDK-Timer"><a href="#在Spring中使用JDK-Timer" class="headerlink" title="在Spring中使用JDK Timer"></a>在Spring中使用JDK Timer</h2><h3 id="Timer-和-TimerTask"><a href="#Timer-和-TimerTask" class="headerlink" title="Timer 和 TimerTask"></a>Timer 和 TimerTask</h3><p>TimerTask 代表一个需要多次执行的任务，它实现了 Runnable 接口，可以在 run() 方法定义任务逻辑。而 Timer 负责制定调度规则并调度 TimerTask。</p><h4 id="TimerTask"><a href="#TimerTask" class="headerlink" title="TimerTask"></a>TimerTask</h4><p>相当于 Quartz 的  Job ，代表一个被调度的任务。二者区别在于，每次执行任务时，Quartz 都创建一个 Job 实例，而 JDK Timer 则使用相同的 TimerTask 实例。</p><p>实现了 Runnable 接口，是一个抽象类，只有以下3个方法：</p><ol><li>abstract void run()：子类覆盖这个方法并定义任务执行逻辑，每次执行任务时，run() 方法就被调用一次。</li><li>boolean cancel()：取消任务。</li><li>long scheduledExecutionTime()：返回词此任务的计划执行时间。该方法一般在固定频率执行时使用才会有意义。</li></ol><h4 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h4><p>Timer 的构造函数在创建 Timer 对象的同时将启动一个 Time 背景线程。构造函数如下：</p><ul><li>Timer()：创建一个Timer，背景线程是一个非守护线程</li><li>Timer(boolean isDaemon)：当 isDaemon 为 true，背景线程为守护线程，守护线程将在应用程序主线程停止后自动退出。</li><li>Timer(String name)：与 Timer() 类似，只是通过 name 指定守护线程名称。</li></ul><p>通过以下方法执行任务：</p><ul><li>schedule(TimerTask task,Date time)：在特定的时间点执行一次任务。</li><li>schedule(TimerTask task,long delay)：延迟指定时间后执行一次任务，delay的单位为毫秒</li></ul><p>通过以下方按固定时间间隔执行任务：</p><ul><li>schedule(TimerTask task,Date firstTime,long period)：从指定时间开始周期性地执行任务，period 为毫秒，后一次执行将在前一次执行完成后才开始计时。如任务被安排每 2 秒执行一次，假设第一次任务在 0 秒时间点开始执行并花费了 1.5  秒，则第二次将在第 3.5 秒时执行。</li><li>schedule(TimerTask task,long delay,long period)：在延迟指定时间后，周期性地执行任务</li></ul><p>通过以下方法按照固定频率执行任务：</p><ul><li>scheduleAtFixedRate(TimerTask task,Date firstTime,long period)：在指定时间点后，以指定频率执行任务。</li></ul><h4 id="Java-Timer-实例"><a href="#Java-Timer-实例" class="headerlink" title="Java Timer 实例"></a>Java Timer 实例</h4><h3 id="Spring-对-Java-Timer-的支持"><a href="#Spring-对-Java-Timer-的支持" class="headerlink" title="Spring 对 Java Timer 的支持"></a>Spring 对 Java Timer 的支持</h3><h2 id="Spring-对-Java-5-0-Executor-的支持"><a href="#Spring-对-Java-5-0-Executor-的支持" class="headerlink" title="Spring 对 Java 5.0 Executor 的支持"></a>Spring 对 Java 5.0 Executor 的支持</h2><h3 id="了解-Java-5-0-的-Executor"><a href="#了解-Java-5-0-的-Executor" class="headerlink" title="了解 Java 5.0 的 Executor"></a>了解 Java 5.0 的 Executor</h3><h3 id="Spring-对-Executor-所提供的抽象"><a href="#Spring-对-Executor-所提供的抽象" class="headerlink" title="Spring 对 Executor 所提供的抽象"></a>Spring 对 Executor 所提供的抽象</h3><h2 id="实际应用中的调度"><a href="#实际应用中的调度" class="headerlink" title="实际应用中的调度"></a>实际应用中的调度</h2><p>对于那些运行规则固定的静态任务（如每隔30分钟更新缓存），可通过 Spring 配置文件定义调度规则并在 Spring 容器中启动运行调度。若任务的执行时间非常重要，不允许发生时间漂移，那么 Quartz 是最好的选择。</p><h3 id="如何产生任务"><a href="#如何产生任务" class="headerlink" title="如何产生任务"></a>如何产生任务</h3><h4 id="在业务流程中产生"><a href="#在业务流程中产生" class="headerlink" title="在业务流程中产生"></a>在业务流程中产生</h4><p>如果任务的执行时间点离业务的操作时间点不是很长，则可以使用。例如：电力传输管理系统的功能，将一条传输线路在某段时间内停止供电。用户在执行线路停电安排的业务时，立即向 Scheduler 中注册两个任务：某段时间执行断电和执行恢复供电的两个任务。</p><h4 id="扫描线程产生"><a href="#扫描线程产生" class="headerlink" title="扫描线程产生"></a>扫描线程产生</h4><p>有严格的执行时间点并减小数据库的影响，需要一个用于产生最近执行任务的扫描任务定期查询数据库，并为那些在一小段时间后就要执行的潜在任务进行动态安排。    </p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190420035729-649512.jpg" alt=""></p><p>说明：T0 对应一个定时的任务，它负责周期性地扫描业务表，查找在后续的扫描周期时间范围内要执行的任务，并创建这些任务。这中方式带来的好处如下：</p><ol><li>降低对数据库的影响</li><li>缩短调度器中任务列队的长度（由于不是将所有潜在任务提前一段很长时间就进行安排，而仅是对一个扫描周期内的任务进行安排，所以调度器中任务列表的长度可以得到有效的控制）</li><li>保证任务在精确的时间点执行</li></ol><h3 id="任务调度对应程序集群的影响"><a href="#任务调度对应程序集群的影响" class="headerlink" title="任务调度对应程序集群的影响"></a>任务调度对应程序集群的影响</h3><p>对于有集群要求的 Web 应用来说，如果应用系统本身有任务调度的功能，就必须在系统设计初期仔细分析任务调度功能是否适合集群。按任务执行结果影响的范围，可以将任务分为如下两类：</p><ul><li><p>全局任务：指定那些执行结果会影响到应用系统全局的任务。例如：每天凌晨生成业务报表、定期调用短信接口发送短信、定期清理系统过期数据，它们的执行结果都会给系统带来“全局可见”的结果。所以，在传统的集群系统中，全局任务最好在一个独立部署的服务节点执行，否则可能会因重复多次执行而引发系统逻辑的错误。</p></li><li><p>本地任务：指执行结果的影响范围仅限于本地，不会造成全局影响的任务。例如：定期刷新本地缓存、定期清除本地节点临时文件，它们的执行结果只对本地服务节点有影响，需要在每个本地服务节点部署任务。</p><p>Quartz 可支持集群部署，其原理很简单，即让多个调度节点虎威热备，在同一时刻只有一个节点是激活的，任务只有在激活的节点中执行，其他节点都是“休眠”状态；当激活的调度节点崩溃时，则唤醒某一个“休眠”的调度节点，以接管任务调度的工作。</p><p>Quartz 可通过两种方式实现集群：1.通过一个中间数据库，使集群节点相互感知，以实现故障切换；2.通过 Terracotta。</p></li></ul><h3 id="任务调度云"><a href="#任务调度云" class="headerlink" title="任务调度云"></a>任务调度云</h3><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190420050326-614457.jpg" alt=""></p><h3 id="Web应用程序中调度器的启动和关闭问题"><a href="#Web应用程序中调度器的启动和关闭问题" class="headerlink" title="Web应用程序中调度器的启动和关闭问题"></a>Web应用程序中调度器的启动和关闭问题</h3><p>我们知道，静态变量是 ClassLoad 级别的，如果 Web 应用程序停止，那么这些静态变量也会从 JVM 中清除。但线程是 JVM 级别的，如果用户在 Web 应用中启动了一个线程，那么线程的生命周期并不会和 Web 应用程序保持同步。也就是说，即使停止了 Web 应用，这个线程依旧是活动的。</p><p>问题：</p><p>如果手工使用 JDK Timer （Quartz 的 Scheduler），在 Web 容器启动非守护线程的 Timer ，当 Web 容器关闭时，除非用户手动关闭这个 Timer ,否则 Timer 中的任务还会继续。</p><p>解决方法：</p><p>Spring 为 JDK Timer  和 Quartz Scheduler 所提供的 TimerFactoryBean 和 SchedulerFactoryBean 能够与 Spring 容器的生命周期关联，在 Spring 容器启动时启动调度器，而在 Spring 容器关闭时停止调度器。所以在 Spring 中通过配置两个 FactoryBean 配置调度器，再从 Spring IOC 中获取调度器的引用进行任务调度，这样就不会出现这种 Web 容器关闭而任务依然执行的问题。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Quartz  提供了极为丰富的任务调度功能，不但可以制定周期性执行的任务调度方案，还可以让用户按照日历相关的方式进行任务调度。</p><p>Quartz 框架的重要组件包括 Job、JobDetail、Trigger、Scheduler 及辅助性的 JobDataMap 和 SchedulerContext。</p><p>Quartz 拥有一个线程池，通过线程池为任务提供执行线程，可以通过配置配置文件对线程池进行参数定制。</p><p>Quartz 还有一个重要功能，将任务调度信息持久化到数据库中，以便系统重启时能够恢复已经安排的任务。</p><p>Quartz 还拥有完善的事件体系，允许用户注册各种事件的监听器。</p><hr><p>Spring 为 Quartz 的 JobDetail 和 Trigger 提供了更具 Bean 风格的支持类，使得用户能够方便地在 Spring  中通过配置定制这些组件的实例。</p><p>Spring 的 SchedulerFactoryBean 让用户可以脱离 Quartz 自身的体系，而以更具 Spring 风格的方式定义 Scheduler。Scheduler 生命周期和 Spring 容器生命周期绑定。</p><hr><p>JDK Timer 可以满足一些简单的任务调度需求，好处就是用户不必引用 JDK 之外的第三方类库；只能支持小型的任务且任务很快就能完成。</p><p>JDK Timer 只能做到近似时间安排。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第16章任务调度和异步执行器&quot;&gt;&lt;a href=&quot;#第16章任务调度和异步执行器&quot; class=&quot;headerlink&quot; title=&quot;第16章任务调度和异步执行器&quot;&gt;&lt;/a&gt;第16章任务调度和异步执行器&lt;/h1&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://swenfang.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://swenfang.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>第3章数据结构</title>
    <link href="http://swenfang.github.io/2019/03/30/SoftTestTechnique/%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://swenfang.github.io/2019/03/30/SoftTestTechnique/第3章数据结构/</id>
    <published>2019-03-30T02:35:49.025Z</published>
    <updated>2019-04-04T13:45:31.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第3章数据结构"><a href="#第3章数据结构" class="headerlink" title="第3章数据结构"></a>第3章数据结构</h1><a id="more"></a><h2 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h2><h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><h2 id="数组、矩阵和广义表"><a href="#数组、矩阵和广义表" class="headerlink" title="数组、矩阵和广义表"></a>数组、矩阵和广义表</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><h3 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h3><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="树与二叉树的定义"><a href="#树与二叉树的定义" class="headerlink" title="树与二叉树的定义"></a>树与二叉树的定义</h3><h3 id="二叉树的性质与存储结构"><a href="#二叉树的性质与存储结构" class="headerlink" title="二叉树的性质与存储结构"></a>二叉树的性质与存储结构</h3><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><h3 id="最优二叉树"><a href="#最优二叉树" class="headerlink" title="最优二叉树"></a>最优二叉树</h3><h3 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h3><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="图的定义与储存"><a href="#图的定义与储存" class="headerlink" title="图的定义与储存"></a>图的定义与储存</h3><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><h3 id="生成树与最小生成树"><a href="#生成树与最小生成树" class="headerlink" title="生成树与最小生成树"></a>生成树与最小生成树</h3><h3 id="拓扑排序和关键路径"><a href="#拓扑排序和关键路径" class="headerlink" title="拓扑排序和关键路径"></a>拓扑排序和关键路径</h3><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="查找的基本概念"><a href="#查找的基本概念" class="headerlink" title="查找的基本概念"></a>查找的基本概念</h3><h3 id="静态查找表的查找方法"><a href="#静态查找表的查找方法" class="headerlink" title="静态查找表的查找方法"></a>静态查找表的查找方法</h3><h3 id="动态查找表"><a href="#动态查找表" class="headerlink" title="动态查找表"></a>动态查找表</h3><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190316115757-374692.jpg" alt=""></p><p>十种常见排序算法可以分为两大类：</p><p><code>比较类排序</code>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</p><p><code>非比较类排序</code>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</p><h3 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h3><p>假设含 n 个记录文件内容为{$R_{1}, R_{2},\ldots ,R_{n}​$}，相应的关键字{$k_{1}, k_{2},\ldots ,k_{n}​$}。经过排序确定一种排列{$R_{j_{1}},R_{j_{2}},\ldots ,R_{n}​$}，使得它们的关键字满足以下递增（或递减）关系：$k_{j_1}\leq k_{j_{2}}\leq \ldots \leq k_{j_{n}}​$（或$k_{j_{1}}\geq k_{j_{2}}\geq \ldots k_{jn}​$）。</p><p>若在待排序中的一个序列中，$R_{i}​$和$R_{j}​$的关键字相同，即 $k_{i}​$=$k_{j}​$，且在排序前 $R_{i}​$先于$R_{j}​$，那么在排序后，如果$R_{i}​$和$R_{j}​$的相对次序保持不变，$R_{i}​$仍领先于$R_{j}​$，则此类排序算法为稳定的。若在排序后的序列中有可能出现$R_{j}​$领先于$R_{i}​$的情形，则此类排序为不稳定的。</p><p><code>内部排序</code>：指待排序记录全部存放在内存中进行排序的过程。</p><p><code>外部排序</code>：指待排序记录的数量很大，以至于内存不能容纳全部记录，在排序过程中尚需对外存进行访问的排序过程。</p><h3 id="简单排序"><a href="#简单排序" class="headerlink" title="简单排序"></a>简单排序</h3><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p>又称简单插入排序，是一种简单的排序算法。</p><p>具体做法：在插入第 i 个记录时，$R_{1}$、$R_{2}$、….、$R_{i-1}$ 已经安排好序，这时将 $R_{i}$的关键字 $k_{i}$一次与 $K_{i-1}$、$K_{i-2}$等进行比较，从而找到应该插入的位置并将$R_{i}$插入，插入位置及其后的记录向后移动。</p><p><img src="https://blogimg.nos-eastchina1.126.net/190318/jiandacharu.gif" alt=""></p><p>实现程序  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] insertionSort(<span class="keyword">int</span>[] arr)&#123;</div><div class="line">    <span class="keyword">int</span> len = arr.length;</div><div class="line">    <span class="keyword">int</span> preIndex,current;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;len;i++)&#123;</div><div class="line">        preIndex = i - <span class="number">1</span>;</div><div class="line">        current = arr[i];</div><div class="line">        <span class="keyword">while</span>(preIndex&gt;=<span class="number">0</span> &amp;&amp; current&lt;arr[preIndex])&#123;</div><div class="line">            arr[preIndex+<span class="number">1</span>] = arr[preIndex];</div><div class="line">            preIndex--;</div><div class="line">        &#125;</div><div class="line">        arr[preIndex+<span class="number">1</span>] = current;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>直接排序算法在最好的情况下（待排序列已按关键码有序），每趟只需操作 1 次比较且不需要移动元素，因此n个元素排序时的总比较次数为 n-1 次，总移动次数为0。在最坏情况下（元素已经逆序排序），进行第 i 趟排序时，待插入的记录需要同前面的 i 个记录进行比较，因此，总比较次数为 $\dfrac {n\left( n-1\right) }{2}$在排序过程中，第 i 趟排序时移动记录的次数为 i+1 （包括移进、移除tmp）,总移动次数为 $\dfrac {\left( n+3\right) \left( n+2\right) }{2}$</p><p><code>注意</code>：是一种稳定的排序算法;时间复杂度$O\left( n^{2}\right)$;在排序过程中仅需要一个元素的辅助空间用于交换，空间复杂度为$O\left( 1\right)$</p><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><p>具体的做法：</p><p><img src="https://blogimg.nos-eastchina1.126.net/190318/maopao.gif" alt=""></p><p>实现程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] bubbleSort(<span class="keyword">int</span>[] arr)&#123;</div><div class="line">    <span class="keyword">int</span> n = arr.length;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;i++)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n - <span class="number">1</span> - i;j++)&#123;</div><div class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</div><div class="line">                <span class="keyword">int</span> temp = arr[j+<span class="number">1</span>];</div><div class="line">                arr[j+<span class="number">1</span>] = arr[j];</div><div class="line">                arr[j] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>冒泡排序在最好情况下（待排序列已按关键码有序），只需要做一趟，元素的比较次数为 n-1 且不需要交换元素。在最坏情况下（元素已经逆序排序），在进行第 j 趟排序时，最大的 j-1 个元素已经排好序，其余的 n-(j-1) 个元素需要进行 n-j 次比较和 n-j 次交换。因此总比较次数为：$\dfrac {n\left( n-1\right) }{2}$ ，总的交换次数为：$\dfrac {n\left( n-1\right) }{2}​$</p><p><code>注意</code>：稳定的排序方法；时间复杂度$O\left( n^{2}\right)$;在排序过程中仅需要一个元素的辅助空间用于交换，空间复杂度为$O\left( 1\right)​$</p><h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><p>是一种简单直观的排序算法。工作原理：首先在末尾排序序列中找到最小（大）元素，存放到排序序列的其实位置，然后，再从剩下元素中继续寻找最小（最大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><p>具体做法：</p><p><img src="https://blogimg.nos-eastchina1.126.net/190318/jiandanxuanze.gif" alt=""></p><p>程序实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] selectionSort(<span class="keyword">int</span>[] arr)&#123;</div><div class="line">    <span class="keyword">int</span> n = arr.length;</div><div class="line">    <span class="keyword">int</span> minIndex,temp;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</div><div class="line">        minIndex = i;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j&lt;n;j++)&#123;</div><div class="line">            <span class="keyword">if</span>(arr[j]&lt;arr[minIndex])&#123;</div><div class="line">                minIndex = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        temp = arr[i];</div><div class="line">        arr[i] = arr[minIndex];</div><div class="line">        arr[minIndex] = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>简单选择排序算法在最好情况下（待排序列按关键码有序），不需要移动元素，因此 n 个元素排序时的总移动次数为 0 次。在坏情况下（元素已经逆序排序），前$\dfrac {n}{2}$趟中，每趟排序移动记录的次数都为3次（两个数组元素加交换值），其后不再移动元素，共进行 n-1 趟排序，总移动次数为$3\left( n-1\right) /2$。无论哪种情况，元素总比较次数为$\dfrac {n\left( n-1\right) }{2}$。</p><p><code>注意</code>：不稳定的排序方法；时间复杂度为：$O\left( n^{2}\right)$；在排序过程中仅需要一个元素的辅助空间用于数组元素的交换，空间复杂度为$O\left( 1\right)$</p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>是第一个突破$O\left( n^{2}\right)​$的排序算法，是简单插入排序的改进版。与插入排序的不同之处在于，它会优先比较距离较远的元素，通过逐步减少间距，最终以1为间距或者进行一次常规的插入排序。希尔排序又叫缩小增量排序。    </p><p>具体做法：先取一个小于 n 的整数 d1 作为第一个增量，把文件的全部记录分成 d1 个组，即将所有距离为 d1 倍数序号的记录放在同一个组中，在和组内进行直接插入排序；然后取第二个增量 d2（d2&lt;d1），重复上述分组和排序工作，依次类推，直到所有的增量 d = 1，即所有的记录放在同一组进行直接插入排序为止。</p><p><img src="https://blogimg.nos-eastchina1.126.net/xierpaixu.gif" alt=""></p><p>程序实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] shellSort(<span class="keyword">int</span>[] arr)&#123;</div><div class="line">    <span class="keyword">int</span> n = arr.length;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> gap = (<span class="keyword">int</span>)Math.floor(n/<span class="number">2</span>);gap &gt; <span class="number">0</span>;gap = (<span class="keyword">int</span>)Math.floor(gap/<span class="number">2</span>))&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = gap;i &lt; n;i++)&#123;</div><div class="line">            <span class="keyword">int</span> j = i;</div><div class="line">            <span class="keyword">int</span> current = arr[i];</div><div class="line">            <span class="keyword">while</span>(j - gap &gt;= <span class="number">0</span> &amp;&amp; current &lt; arr[j - gap])&#123;</div><div class="line">                arr[j] = arr[j - gap];</div><div class="line">                j = j - gap;</div><div class="line">            &#125;</div><div class="line">            arr[j] = current;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>注意</code>：是一种不稳定的排序方法；时间复杂度为：$O\left( n^{1.3}\right)$；空间复杂度数为：$O\left( 1\right)​$</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>基本思想：通过一趟排序将待排序的记录划分为独立的两部分，称为前半区和后半区，其中，前半区中记录的关键字均不大于后半区记录的关键字，然后再分别对这两部分记录继续进行快速排序，从而使整个序列有序。</p><p>一趟快速排的过程称为一次划分，具体的做法是：设两个位置指示变量 i 和 j，它们的初始值分别指向序列的第一个记录和最后一个记录。设枢轴记录（通常是第一个记录）的关键字为 pivot,则首先从 j 所指定的位置向前搜索，找到第一个关键字小于 pivot 的记录时向前移到 i 的位置，然后从 i 所指位置向后搜索，找到第一个关键字大于 pivot 的记录时将改记录向后移到 j 所指位置，重复该过程直至 i 与 j 相等位置。</p><p>具体做法：</p><p>请看  <a href="https://swenfang.github.io/2019/03/30/SoftTestTechnique/快速排序原理和实现/#more">https://swenfang.github.io/2019/03/30/SoftTestTechnique/快速排序原理和实现/#more</a> 这篇文章。</p><p>程序实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span></span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">8</span>&#125;;</div><div class="line">        quickSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</div><div class="line">        System.out.println(Arrays.toString(arr));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 划分</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">        <span class="comment">// 用 arr[low] 作为枢纽轴元素 pivot 进行划分</span></div><div class="line">        <span class="comment">// 使得 arr[low,...,i-1] 均不大于 pivot，data[i+1,...,high]均小于 pivot</span></div><div class="line">        <span class="keyword">int</span> i,j; <span class="keyword">int</span> pivot;</div><div class="line">        pivot = arr[low]; i = low;j = high;</div><div class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</div><div class="line">            <span class="comment">/*从数组的两端交替地向中间扫描*/</span></div><div class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; arr[j] &gt;= pivot)j--;</div><div class="line">            arr[i] = arr[j];<span class="comment">/*比枢轴元素小者往前移动*/</span></div><div class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; arr[i] &lt;= pivot)i++;</div><div class="line">            arr[j] = arr[i];<span class="comment">/*比枢轴元素大者往后移动*/</span></div><div class="line">        &#125;</div><div class="line">        arr[i] = pivot;</div><div class="line">        <span class="keyword">return</span> i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 对整型数组进行非递减排序</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span> arr[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)&#123;</div><div class="line">        <span class="keyword">if</span>(low&lt;high)&#123;</div><div class="line">            <span class="keyword">int</span> loc = partition(arr,low,high);<span class="comment">/*进行划分*/</span></div><div class="line">            quickSort(arr,low,loc-<span class="number">1</span>);<span class="comment">/*对前半区进行快速排序*/</span></div><div class="line">            quickSort(arr,loc+<span class="number">1</span>,high);<span class="comment">/*对后半区进行快速排序*/</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> arr;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>注意</code>：快速排序算法的时间复杂度为 $O\left( n\log _{2}n\right)$，在所有算法复杂度为此数量级的排序方法中，快速排序被认为是平均性能最好的一种。但是，若初始记录序列按关键字有序或基本有序时，即每次划分都是将序列分为某一半序列的长度为0的情况，此时快速排序的性能退化为时间复杂度是$O\left( n^{2}\right)$。快速排序是一种<code>不稳定</code>的排序算法。</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用<code>分治法</code>（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p><p>具体做法：</p><p><img src="https://blogimg.nos-eastchina1.126.net/190318/bingguipaixu.gif" alt=""></p><p>程序实现：</p><p>递归法（Top-down）</p><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li><li>重复步骤3直到某一指针到达序列尾</li><li>将另一个序列剩下的所有元素直接复制到合并序列尾</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">8</span>&#125;;</div><div class="line">        sort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</div><div class="line">        System.out.println(Arrays.toString(arr));</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 使用递归</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Sort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> leftStart,<span class="keyword">int</span> rightEnd)</span></span>&#123;</div><div class="line">        <span class="comment">// 满足基本条件</span></div><div class="line">        <span class="keyword">if</span>(leftStart&gt;=rightEnd)&#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 算出左边数组结束位置</span></div><div class="line">        <span class="keyword">int</span> leftEnd = (leftStart+rightEnd) &gt;&gt; <span class="number">1</span>;</div><div class="line">        <span class="comment">// 算出右边数组开始位置</span></div><div class="line">        <span class="keyword">int</span> rightStart = leftEnd+<span class="number">1</span>;</div><div class="line">        <span class="comment">/*递归地对arr[leftStart...leftEnd]进行归并排序*/</span></div><div class="line">        Sort(arr,leftStart,leftEnd);</div><div class="line">       <span class="comment">/*递归地对arr[rightStart...rightEnd]进行归并排序*/</span></div><div class="line">        Sort(arr,rightStart,rightEnd);</div><div class="line">        <span class="comment">/*对一维数组arr[leftStart...rightEnd]中的元素进行两路归并牌排序*/</span></div><div class="line">        Merge(arr,leftStart,leftEnd,rightStart,rightEnd);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 两两归并</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> leftStart,<span class="keyword">int</span> leftEnd,<span class="keyword">int</span> rightStart,<span class="keyword">int</span> rightEnd)</span></span>&#123;</div><div class="line">        <span class="comment">// 定义一个临时数组</span></div><div class="line">        <span class="keyword">int</span>[] tempArr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</div><div class="line">        <span class="keyword">int</span> tempIndex = leftStart;</div><div class="line">        <span class="keyword">int</span> resultIndex = leftStart;</div><div class="line">        <span class="comment">// 进行比较</span></div><div class="line">        <span class="keyword">while</span>(leftStart &lt;= leftEnd &amp;&amp; rightStart &lt;= rightEnd)&#123;</div><div class="line">            tempArr[tempIndex++] = arr[leftStart] &lt;= arr[rightStart] ?                                        arr[leftStart++]:arr[rightStart++];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 把最后一个比较的元素存放到临时素组中</span></div><div class="line">        <span class="keyword">while</span>(leftStart&lt;=leftEnd)&#123;</div><div class="line">            tempArr[tempIndex++] = arr[leftStart++];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(rightStart &lt;= rightEnd)&#123;</div><div class="line">             tempArr[tempIndex++] = arr[rightStart++];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 把临时数组元素顺序复制到原数组</span></div><div class="line">        <span class="keyword">while</span>(resultIndex &lt;= rightEnd)&#123;</div><div class="line">            arr[resultIndex] = tempArr[resultIndex++]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>迭代法（Bottom-up）</p><p>假设序列共有 n 个元素</p><ol><li>将序列每相邻两个数字进行归并操作，形成 floor(n/2)个序列，排序后每个序列包含两/一个元素</li><li>若此时序列数不是1个则将上述序列再次归并，形成 floor(n/4)，每个序列包含四/三个元素</li><li>重复步骤2，直到所有元素排序完毕，即序列数为1</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure><p><code>适用</code>：多链表排序。</p><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><h3 id="内部排序方法小结"><a href="#内部排序方法小结" class="headerlink" title="内部排序方法小结"></a>内部排序方法小结</h3><h3 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第3章数据结构&quot;&gt;&lt;a href=&quot;#第3章数据结构&quot; class=&quot;headerlink&quot; title=&quot;第3章数据结构&quot;&gt;&lt;/a&gt;第3章数据结构&lt;/h1&gt;
    
    </summary>
    
      <category term="软件技术" scheme="http://swenfang.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="软件技术" scheme="http://swenfang.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>第2章程序设计语言基础知识</title>
    <link href="http://swenfang.github.io/2019/03/30/SoftTestTechnique/%E7%AC%AC2%E7%AB%A0%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://swenfang.github.io/2019/03/30/SoftTestTechnique/第2章程序设计语言基础知识/</id>
    <published>2019-03-30T02:35:49.024Z</published>
    <updated>2019-04-04T05:31:44.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第2章程序设计语言基础知识"><a href="#第2章程序设计语言基础知识" class="headerlink" title="第2章程序设计语言基础知识"></a>第2章程序设计语言基础知识</h1><h2 id="程序设计语言概述"><a href="#程序设计语言概述" class="headerlink" title="程序设计语言概述"></a>程序设计语言概述</h2><h3 id="程序设计语言的基本概念"><a href="#程序设计语言的基本概念" class="headerlink" title="程序设计语言的基本概念"></a>程序设计语言的基本概念</h3><h4 id="低级语言和高级语言"><a href="#低级语言和高级语言" class="headerlink" title="低级语言和高级语言"></a>低级语言和高级语言</h4><p>机器语言和汇编语言为高级语言。在此基础上，人们开发了功能更强、抽象级别更高的语言以支持程序设计，于是产生了面向各类应用程序的程序设计语言，称为高级语言。ge:Java、C、C++、PHP、Python等。</p><a id="more"></a><h4 id="编译程序和解释程序"><a href="#编译程序和解释程序" class="headerlink" title="编译程序和解释程序"></a>编译程序和解释程序</h4><p>语言之间的翻译方式有：汇编、解释和编译。</p><p>解释程序也称为解释器，它或者直接解释执行源程序，或者将源程序翻译成某种中间代码后再加以执行。</p><p>编译程序（编译器）则是将源程序翻译成目标语言程序，然后再计算机上运行目标程序。</p><p><code>根本区别</code>:编译方式下，编译器则将源程序翻译成独立保存的目标程序。在解释程序下，翻译源程序时不生成独立的目标程序。</p><h4 id="程序设计语言的定义"><a href="#程序设计语言的定义" class="headerlink" title="程序设计语言的定义"></a>程序设计语言的定义</h4><p>程序设计语言的定义都涉及语法、语义和语用。</p><p><code>语法</code>是指由程序设计语言的基本符号组成程序中的各个语法成分（包含程序）的一组规则，其中由基本字符构成的符号（单词）书写规则称为词法规则，由符号构成语法成分的规则称为语法规则。程序设计语言的语法可用形式语言进行描述。</p><p><code>语义</code>是程序设计语言中按语法规则构成的各个语法成分的含义，可分为<code>静态语义</code>和<code>动态语义</code>。静态语义指<code>编译时可以确定的</code>语法成分的含义，而<code>运行时才能确定的</code>含义是动态语义。一个程序的执行效果说明了该程序的语义，它取决于构成程序的各个组成部分和语义。</p><p><code>语用</code>表示了构成语言的各个记号和使用者的关系，涉及符号的来源、使用和影响。</p><p><code>语言</code>的实现则有语境问题。语境是指理解和实现程序设计语言的环境，包括编译环境和运行环境。</p><h4 id="程序设计语言分类"><a href="#程序设计语言分类" class="headerlink" title="程序设计语言分类"></a>程序设计语言分类</h4><h5 id="程序设计语言发展概述"><a href="#程序设计语言发展概述" class="headerlink" title="程序设计语言发展概述"></a>程序设计语言发展概述</h5><table><thead><tr><th>语言名称</th><th>概述</th></tr></thead><tbody><tr><td>Fortran</td><td>第一个被广泛用来进行科学和工程计算的高级语言。</td></tr><tr><td>ALGOL</td><td>为软件自动及软件可靠性的发展墓定了基础</td></tr><tr><td>PASCAL</td><td>是一种过程式、结构化程序设计语言</td></tr><tr><td>C 语言</td><td>20世纪70年代初发展起来的一种通用程序设计语言</td></tr><tr><td>C++</td><td>基于C语言发展起来的，比C多了封装和抽象，增加了类机制是C++成为面向对象程序设计语言</td></tr><tr><td>C#</td><td>由 Microsoft 公司开发的一种面向对象语言，较于C++它在许多方面进行了限制和增强</td></tr><tr><td>Objective-C</td><td>根据C衍生出来的语言，与 C# 类似，它仅支持单一父类继承，不支持多重继承</td></tr><tr><td>Java</td><td>产生于20世纪70年代，保留了 C++ 的基本语法、类和继承等概念，与 C++ 相比，其语法和语义更合理</td></tr><tr><td>Ruby</td><td>约1993年设计的一种解释性、面向对象、动态类型的脚本语言。</td></tr><tr><td>PHP</td><td>是一种在服务器端执行的、嵌入 HTML 文档的脚本语言，语言风格类似于 C 语言，由网站编程人员广泛运用。它可以快速的执行动态网页，其语法混了C、Java、Perl以及 PHP 自创的语法。由于在服务器端执行，PHP 能充分利用服务器的性能。PHP 支持几乎所有流行的数据库以及操作系统。</td></tr><tr><td>Python</td><td>是一种面向对象的解释型程序设计语言，可用于编写独立程序、快速脚本和复杂应用的原型。Python 也是一种脚本语言，它支持多操作系统的底层访问，也可以将 Python 源程序翻译成字节码在 Python 虚拟机上运行。虽然 Python 的内核很小，但它提供了丰富的基本构建块，还可以用 C、C++ 和 Java 等进行扩展，因此可以用它开发任何类型的程序。</td></tr><tr><td>Java Script</td><td>是一种脚本语言，被广泛用于 Web 应用开发。通常，将 Java Script 脚本嵌入到 HTML 中来实现自身的功能</td></tr><tr><td>Delphi</td><td>是一种可视化开发工具，主要特性是基于窗体和面向对象的方法、高速的编译器、强大的数据库支持、与 Windows 编程紧密结合以及成熟的组件技术。</td></tr><tr><td>Visual Basse.NET</td><td>y用 .NET 语言开发的程序源代码被编译为中间代码 MSIL 然后通过 .NET Framework 的通用语言运行时（CLR）来执行。</td></tr></tbody></table><h5 id="程序设计语言分类-1"><a href="#程序设计语言分类-1" class="headerlink" title="程序设计语言分类"></a>程序设计语言分类</h5><p>根据设计程序的方法将程序语言大致分为<code>命令式和结构化</code>程序设计语言、<code>面向对象</code>的程序设计语言、<code>函数式</code>程序设计语言和<code>逻辑型</code>程序程序设计语言等。</p><p>1、命令式和结构化程序设计语言</p><p>通常所以称的结构化程序语言属于命令式语言类，其结构特性主要反映在以下几个方面：</p><ul><li>用自顶向下逐步精化的方法编程</li><li>按模块组织的方法编程</li><li>程序只包含顺序、判定（分支）及循环构造</li></ul><p>C、PASCAL 等都是典型的结构化程序设计语言。</p><p>2、面向对象的程序设计语言</p><p>C++、Java 和 Smalltalk 是面向对象程序设计语言的代表，它们都必须支持新的程序设计技术，如数据隐式、数据抽象、用户定义类型、继承和多态</p><p>3、函数式程序设计语言</p><p>优点是对表达式中出现的任何函数都可以用其他函数来代替，只要这些函数调用产生相同的值。</p><p>函数式语言的代表 LISP 在许多方面与其他语言不同，最为显著的是，其程序和数据的形式是等价的，这样的数据结构就可以作为程序执行，程序也可以作为数据修改。常见的函数式语言有 Hashell、Scala、Scheme、APL 等。</p><p>4、逻辑型程序设计语言</p><p>是一类以形式逻辑为基础的语言。</p><h3 id="程序设计语言的基本成分"><a href="#程序设计语言的基本成分" class="headerlink" title="程序设计语言的基本成分"></a>程序设计语言的基本成分</h3><h4 id="程序设计语言的数据成分"><a href="#程序设计语言的数据成分" class="headerlink" title="程序设计语言的数据成分"></a>程序设计语言的数据成分</h4><p>1）常量和变量</p><p>按照程序运行时数据的值能否改变，将数据分为常量和变量。程序中的数据对象可以具有左值和（或）右值，左值指存储单元（或地址、容量）。变量具有左值和右值，在程序运行过程中其右值可以改变；常量只有右值，在程序运行过程中其右值不能改变。</p><p>2）全局量和局部量</p><p>数据按在程序代码中的作用范围（作用域）可以分为全局量和局部量。一般情况下，全局变量的作用域为整个文件或程序，系统为全局变量分配的存储空间在程序运行的过程中是不改变的，局部变量的作用域为定义它的函数或语句块，为局部变量分配的存储单元是动态改变的。</p><p>3）数据类型</p><p>按照数据组织形式的不同可将数据分为基本类型、用户定义类型、构造类型及其他类型。C（C++）的数据类型如下：</p><ul><li>基本数据类型：整型（int）、字符型（char）、实型（float、double）和布尔类型（bool）</li><li>特殊类型：空类型（void）</li><li>用户定义类型：枚举类型（enum）</li><li>构造类型：数组、结构、联合</li><li>指针类型：type*</li><li>抽象数据类型：类类型</li></ul><h4 id="程序设计语言的运算成分"><a href="#程序设计语言的运算成分" class="headerlink" title="程序设计语言的运算成分"></a>程序设计语言的运算成分</h4><h4 id="程序设计语言的控制部分"><a href="#程序设计语言的控制部分" class="headerlink" title="程序设计语言的控制部分"></a>程序设计语言的控制部分</h4><h5 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h5><p><img src="C:\Users\shenwenfang\AppData\Roaming\Typora\typora-user-images\1554022404155.png" alt="1554022404155"></p><h5 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h5><p>选择结构提供了在两种或多种分支中选择其中一个的逻辑。基本的选择结构是指定一个条件P，然后根据条件的成立与否决定控制流计算A和B，从两个分支中选择一个执行（如图a）。选择结构中的计算A或B还包含顺序、选择和重复结构。程序设计语言中还通常提供简化了的选择结构，也就没有计算 B 的分支结构，（如图b）。</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190331050128-715641.jpg" alt=""></p><h5 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h5><p>主要有两种形式：while 型 和 do-while 型循环结构。</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190331050219-570285.jpg" alt=""></p><h5 id="C（C-）语言提供的控制语句"><a href="#C（C-）语言提供的控制语句" class="headerlink" title="C（C++）语言提供的控制语句"></a>C（C++）语言提供的控制语句</h5><ul><li>复合语句。是一系列用”{“和”}”括起来的声明和语句，主要作用是将多条语句组成一个可执行单元。复合语句是一个整体，要么全部执行，要么一句也不执行。</li><li>if 语句和swith语句</li><li>循环语句</li></ul><h3 id="程序设计语言的传输成分"><a href="#程序设计语言的传输成分" class="headerlink" title="程序设计语言的传输成分"></a>程序设计语言的传输成分</h3><p>指明语言允许的数据传输方式，如赋值处理、数据的输入和输出等。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数是程序块的主要成分，它是一段具有独立功能的程序。</p><h2 id="语言处理程序基础"><a href="#语言处理程序基础" class="headerlink" title="语言处理程序基础"></a>语言处理程序基础</h2><p>语言处理程序是一类系统软件的总称，主要作用是将高级语言或汇编语言编写的程序翻译成某种机器语言程序，使程序可在计算机上运行。语言处理程序主要分为<code>汇编程序</code>、<code>编译程序</code>和<code>解释程序</code>3中基本类型。</p><h3 id="汇编程序基本原理"><a href="#汇编程序基本原理" class="headerlink" title="汇编程序基本原理"></a>汇编程序基本原理</h3><h4 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h4><p>是为特定的计算机设计的面向机器的符号化的程序设计语言。</p><p>汇编语言源程序由若干语句组成，其中可以有三类语句：<code>指令语句</code>、<code>伪指令语句</code>和<code>宏指令语句</code>。</p><h5 id="指令语句"><a href="#指令语句" class="headerlink" title="指令语句"></a>指令语句</h5><p>又称机器指令语句，其汇编后能产生相应的机器代码，这些代码能被 CPU 直接识别并执行相应的操作。基本的指令有 ADD、SUB 和 AND 等，书写指令语句时必须遵循指令的格式要求。</p><p>指令语句可分为<code>传送指令</code>、<code>算术运算指令</code>、<code>逻辑运算指令</code>、<code>移位指令</code>、<code>转移指令</code>和<code>处理机控制指令</code>等类型。</p><h5 id="伪指令语句"><a href="#伪指令语句" class="headerlink" title="伪指令语句"></a>伪指令语句</h5><p>指汇编程序在汇编源代码时完成某些工作，例如为变量分配存储单元地址，给某个符号赋一个值等。</p><p>伪指令语句和指令语句的区别是：伪指令语句经汇编后不产生机器代码，而指令语句经汇编后要产生相应的机器代码。伪指令语句所指示的操作是在源程序被编译时完成的，而指令语句的操作必须在程序运行时完成。</p><h5 id="宏指令语句"><a href="#宏指令语句" class="headerlink" title="宏指令语句"></a>宏指令语句</h5><p>在汇编语言中，还允许用户将多次重复使用的程序段定义为宏。每个宏都有相应的宏名。在程序的任意位置，若需要使用这段程序，只要使用该宏名就使用了这段程序。因此，宏指令语句就是宏的引用。</p><h4 id="汇编程序"><a href="#汇编程序" class="headerlink" title="汇编程序"></a>汇编程序</h4><p>功能是将用汇编语言编写的源程序翻译成机器指令程序。</p><p>汇编程序一般需要两次扫描源程序才能完成翻译过程。</p><p>第一次扫描的主要工作是：定义符号的值并创建一个符号表ST，记录汇编时所遇到的符号的值。还有一个固定的表MOT1，记录每条机器指令的记忆码和指令的长度。为了计算各汇编语句标号的地址，需要设立一个位置计数器或单元地址计数器LC，初始值一般为0。</p><p>汇编程序第一次扫描的过程：</p><ol><li><p>单元计数器初始值为0</p></li><li><p>打开源程序文件</p></li><li><p>从源程序中读入第一条语句</p></li><li><p>while（若当前语句不是END语句）{</p><p>if（语句有标号）将标号和单元计数器LC的当前值填入符号表ST；</p><p>if（语句有可执行的汇编指令语句）查找 MOT1 表获取当前指令的长度K，并令 LC=LC+K；</p><p>if（指令是伪指令）查找 POT1 表并调用相应的子程序；</p><p>if（指令的操作码是非法记忆码）调用出错处理子程序。</p><p>从源程序中读取下一条语句；</p><p>}</p></li><li><p>关闭源程序文件</p></li></ol><p>汇编程序第二次扫描的任务是产生目标程序。</p><h3 id="编译程序基本原理"><a href="#编译程序基本原理" class="headerlink" title="编译程序基本原理"></a>编译程序基本原理</h3><h4 id="编译过程概述"><a href="#编译过程概述" class="headerlink" title="编译过程概述"></a>编译过程概述</h4><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190331064847-170859.jpg" width="400px" height="400px"></p><h5 id="1）词法分析"><a href="#1）词法分析" class="headerlink" title="1）词法分析"></a>1）词法分析</h5><p>对源程序从前到后（从左到右）逐字符的扫描，从中识别出一个个”单词”符号。（单词：关键字、标识符、常数、运算符和分割符）</p><h5 id="2）语法分析"><a href="#2）语法分析" class="headerlink" title="2）语法分析"></a>2）语法分析</h5><p>确定整个输入串是否构成一个语法上的正确程序</p><h5 id="3）语义分析"><a href="#3）语义分析" class="headerlink" title="3）语义分析"></a>3）语义分析</h5><p>分析各词法结构的含义。</p><h5 id="4）中间代码生成"><a href="#4）中间代码生成" class="headerlink" title="4）中间代码生成"></a>4）中间代码生成</h5><p>根据语义分析的输出生成中间代码。</p><h5 id="5）代码优化"><a href="#5）代码优化" class="headerlink" title="5）代码优化"></a>5）代码优化</h5><p>因为中间代码的生成是机械的、按固定模式进行的，所以在时间和空间上有较大的浪费。要生成高效的代码就得进行优化。优化一般建立在对程序的控制流和数据流分析的基础之上，与具体的机器无关。可在中间代码生成或目标代码生成阶段进行。</p><h5 id="6）目标代码生成"><a href="#6）目标代码生成" class="headerlink" title="6）目标代码生成"></a>6）目标代码生成</h5><p>把中间代码变换成特定机器上的绝对指令代码、可重定位的指令代码或汇编指令代码。此阶段与机器密切相关。</p><h5 id="7）符号表管理"><a href="#7）符号表管理" class="headerlink" title="7）符号表管理"></a>7）符号表管理</h5><p>符号表的作用是记录源程序中各个符号的必要信息。符号表的建立可以在词法分析、语法分析、语义分析阶段</p><h5 id="8）出错处理"><a href="#8）出错处理" class="headerlink" title="8）出错处理"></a>8）出错处理</h5><p>在逻辑上分为前端和后端。前端（包括从词法分析到中间代码生成），后端（中间代码优化和目标代码优化）</p><p>以中间代码为分水岭，把编译器分为与机器有关的部分和与机器无关的部分。</p><h4 id="文法和语言的形式描述"><a href="#文法和语言的形式描述" class="headerlink" title="文法和语言的形式描述"></a>文法和语言的形式描述</h4><p>1）字母表、字符串、字符串集合与运算</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190402101622-809013.jpg" alt=""></p><p>2）文法和语言的形式描述</p><p>定义：描述语言语法结构的规则</p><p>分类：0型、1型、2型、3型（差别在于对产生式要施加不同的限制）；0型又称短语文法，递归可枚举的、1型又称上下文有关文法、2型又称上下文无关文法、3型文法等价正规式</p><p>3）句子和语言</p><ul><li>推导与直接推导</li><li>直接规约和规约</li><li>句型和句子</li><li>语言</li></ul><p>4）文法的等价</p><p>文法 G1 和 G2 产生的语言相同</p><h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h4><p>词法规则可用3型文法（正规文法）或正规表达式描述，它产生的集合是语言基本字符集 $\Sigma​$ （字符表）上的字符串的一个子集，称为正规集。</p><p>1）正规表达式和正规集</p><ul><li>$\varepsilon​$是一个正规式，它表示集合 $L\left( \varepsilon \right) =​${$\varepsilon​$}</li><li>若 $a​$ 是 $\Sigma​$ 上的字符，则 $a​$ 是一个正规式，它所表示的正规集合为 {$a​$ }</li><li>若正规表达式 r 和 s 分别表示 $L\left( r\right)​$ 和 $L\left( s\right)​$，则<ul><li>r|s 式正规式，表示集合 $L\left( r\right)​$ U $L\left( s\right)​$</li><li>r*s 是正规式，表示集合$L\left( r\right)​$ $L\left( s\right)​$</li><li>$r^{\ast }​$是正规式，表示集合$\left( L\left( r\right) \right) ^{\ast }​$</li><li>$\left( r\right)$是正规式，表示集合$L\left( r\right)$</li></ul></li></ul><p>仅通过有限地使用上述3个步骤定义的表达式才是$\Sigma$ 上的正规式，其中，运算符“|” “.” 和 “<em>” 分别称为 “或”“连接”和“闭包”。在正规式的书写中，连接运算符 “.” 可以省略。运算优先级（高到低）为 </em> . |</p><p>设 $\Sigma$ ={a,b} ，列出 $\Sigma$ 上的一些正规式和相应的正规集：</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190402100532-856441.jpg" alt=""></p><p>2）有限自动机</p><p>是一种识别装置的抽象概念，它能准确的识别正规集。分为<code>确定的有限自动机</code>（DFA）和<code>不确定的有限自动机</code>（NFA）。</p><p>确定的有限自动机（DFA）。由五个元组（S， $\Sigma$，$f$，$S_{0}$，Z）其中：</p><ul><li>S 是一个有限集，其每个元素称为一个状态</li><li>$\Sigma​$是一个有穷字母表，其每个元素称为一个输入符</li><li>$f​$ 是 $S\times \Sigma \rightarrow 2^{s}​$ 上的单值部分映像。$f\left( A,a\right) =Q​$表示当前状态为A、输入为 $a​$ 时，将转换到下一个状态 Q,称Q为A的一个后继状态</li><li>$S_{0}\in S​$，是唯一的一个开始状态</li><li>Z 是非空的终止状态集合，$Z\subseteq S​$</li></ul><p><code>注意</code>：DFA 中的每个状态对应转换图中的一个结点，每个转换函数对应一条有向弧，若转换函数为$f\left( A,a\right) =Q​$，则该有向弧从结点A出发，进入到Q，字符 $a​$ 是弧上的标记</p><p><img src="C:\Users\shenwenfang\AppData\Roaming\Typora\typora-user-images\1554215667943.png" alt="1554215667943"></p><p>不确定的有限自动机（NFA）。也是由五个元组，它与确定有限自动机的区别如下：</p><ul><li>$f​$ 是 $S\times \Sigma \rightarrow 2^{s}​$ 上的映像。对于 S 中的一个给定状态及输入符合，返回一个状态的集合。即当前状态的后继状态不一定是唯一的。</li><li>有向弧上的标记可以是 $\varepsilon$</li></ul><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190403125321-684629.jpg" alt=""></p><p>3）NFA 到 DFA 的转换</p><p>定义转换过程中需要的计算：</p><p>1、若 $I​$ 是 NFA M 的状态集合的一个子集。定义$\varepsilon​$_CLOSURE($I​$) 如下：</p><ul><li>状态集$I$ 的 $\varepsilon$_CLOSURE($I$)  是一个状态集</li><li>状态集 $I$的所有状态属于 $\varepsilon$_CLOSURE($I$) </li><li>若 $S\in I​$，那么从 S 出发经过任意条  $\varepsilon​$ 弧达到的状态 S’ 都属于 $\varepsilon​$_CLOSURE($I​$) </li></ul><p>状态集合 $\varepsilon​$<em>CLOSURE($I​$)  称为  $I​$的 $\varepsilon​$</em>闭包。</p><p>由上可知，$I​$ 的 $\varepsilon​$_闭包 就是从状态集$I​$ 的状态出发，经  $\varepsilon​$ 所能到达的全体。假定 $I​$ 是 NFA M 的状态集的一个子集，$a​$ 是 $\Sigma ​$ 中的一个字符，定义：</p><p>$I_{a}$ =  $\varepsilon$_CLOSURE(J) </p><p>J 是那些可以从 $I$中的某一状态结点出发经过一条 $a$弧而到达的状态结点的全体。</p><p>2、NFA 转换为 DNF 。</p><p>4）DFA 的最小化</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190403101129-17260.jpg" alt=""></p><h4 id="正规式与有限自动机的转换"><a href="#正规式与有限自动机的转换" class="headerlink" title="正规式与有限自动机的转换"></a>正规式与有限自动机的转换</h4><p>1）有限自动机转换为正规式</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190403101916-708797.jpg" alt=""></p><p>2）正规式转换为有限自动机</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190403102347-362614.jpg" alt=""></p><h4 id="词法分析器的构造"><a href="#词法分析器的构造" class="headerlink" title="词法分析器的构造"></a>词法分析器的构造</h4><p>步骤：</p><p>（1）用正规式描述语言中的单词构成规则</p><p>（2）为每个正规式构造一个 NFA ，它识别正规式所表示的正规集</p><p>（3）将构造出的 NFA 转换称等价的 DFA</p><p>（4）对 DFA 进行最小化处理，使其最简</p><p>（5）从 DFA 构造词法分析器</p><h4 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h4><p>任务是分析单词串是否构成表达式、语句和程序等基本语言结构，同时检查和处理程序中的语法错误。</p><p>程序语言的绝大多数语法规则采用<code>上下无关文法</code>进行扫描。</p><p>根据产生的语法树的方向，可分为<code>自底向上</code>和<code>自顶向下</code>两类。</p><p>1）上下文无关文法</p><p>规范推导；短语、直接短语和句柄；</p><p>2）自顶向下语法分析方法</p><p>基本思想：对于给定的输入串 $\omega​$ ，从文法的开始符号 S 出发进行最左推导，直到得到一个合法的句子或者发现一个非法结构。在推导的过程中试图用一切可能的方法，自上而下、从左到右地输入串 $\omega​$  建立语法树。整个过程是一个反复试探的过程。</p><ul><li>消除文法的左递归</li><li>提起公共左因子</li><li>LL(1) 文法</li><li>递归下降分析法</li><li>预测分析法</li></ul><p>3）自底向上语法分析方法</p><p>又称移进-归约分析法。基本思想是：对输入序号  $\omega​$ 自左向右进行扫描，并输入符号逐个移进栈中，边移进边分析，一旦栈顶符号串形成某个句型的归约串，就用某个产生式的左部非终结符来替代，这一步称为归约。重复这一过程，直到栈中只剩下文法的开始符号且输入串也被扫描完为止。</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190404012854-166000.jpg" alt=""></p><h4 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h4><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><h4 id="目标代码生成"><a href="#目标代码生成" class="headerlink" title="目标代码生成"></a>目标代码生成</h4><h4 id="符号表管理"><a href="#符号表管理" class="headerlink" title="符号表管理"></a>符号表管理</h4><h4 id="出错处理"><a href="#出错处理" class="headerlink" title="出错处理"></a>出错处理</h4><h3 id="解释程序基本原理"><a href="#解释程序基本原理" class="headerlink" title="解释程序基本原理"></a>解释程序基本原理</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第2章程序设计语言基础知识&quot;&gt;&lt;a href=&quot;#第2章程序设计语言基础知识&quot; class=&quot;headerlink&quot; title=&quot;第2章程序设计语言基础知识&quot;&gt;&lt;/a&gt;第2章程序设计语言基础知识&lt;/h1&gt;&lt;h2 id=&quot;程序设计语言概述&quot;&gt;&lt;a href=&quot;#程序设计语言概述&quot; class=&quot;headerlink&quot; title=&quot;程序设计语言概述&quot;&gt;&lt;/a&gt;程序设计语言概述&lt;/h2&gt;&lt;h3 id=&quot;程序设计语言的基本概念&quot;&gt;&lt;a href=&quot;#程序设计语言的基本概念&quot; class=&quot;headerlink&quot; title=&quot;程序设计语言的基本概念&quot;&gt;&lt;/a&gt;程序设计语言的基本概念&lt;/h3&gt;&lt;h4 id=&quot;低级语言和高级语言&quot;&gt;&lt;a href=&quot;#低级语言和高级语言&quot; class=&quot;headerlink&quot; title=&quot;低级语言和高级语言&quot;&gt;&lt;/a&gt;低级语言和高级语言&lt;/h4&gt;&lt;p&gt;机器语言和汇编语言为高级语言。在此基础上，人们开发了功能更强、抽象级别更高的语言以支持程序设计，于是产生了面向各类应用程序的程序设计语言，称为高级语言。ge:Java、C、C++、PHP、Python等。&lt;/p&gt;
    
    </summary>
    
      <category term="软件技术" scheme="http://swenfang.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="软件技术" scheme="http://swenfang.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>快速排序原理和实现</title>
    <link href="http://swenfang.github.io/2019/03/30/SoftTestTechnique/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
    <id>http://swenfang.github.io/2019/03/30/SoftTestTechnique/快速排序原理和实现/</id>
    <published>2019-03-30T02:35:49.019Z</published>
    <updated>2019-03-30T02:35:49.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序原理和实现"><a href="#快速排序原理和实现" class="headerlink" title="快速排序原理和实现"></a>快速排序原理和实现</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>高快省的排序算法，既不浪费空间也可以快一点的排序算法。</p><a id="more"></a><p>假设我们现在对“6  1  2 7  9  3  4  5 10  8”这个10个数进行排序。首先在这个序列中随便找一个数作为基准数。为了方便，就让第一个数6作为基准数吧。接下来，需要将这个序列中所有比基准数大的数放在6的右边，比基准数小的数放在6的左边，类似下面这种排列：3  1  2 5  4  6  9 7  10  8</p><p>在初始状态下，数字6在序列的第1位。我们的目标是将6挪到序列中间的某个位置，假设这个位置是k。现在就需要寻找这个k，并且以第k位为分界点，左边的数都小于等于6，右边的数都大于等于6。</p><p>方法其实很简单：分别从初始序列“6  1  2 7  9  3  4  5 10  8”两端开始“探测”。先从右往左找一个小于6的数，再从左往右找一个大于6的数，然后交换他们。这里可以用两个变量i和j，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵i”和“哨兵j”。刚开始的时候让哨兵i指向序列的最左边（即i=1），指向数字6。让哨兵j指向序列的最右边（即=10），指向数字。</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190322104101-714647.jpg" alt=""></p><p>首先哨兵j开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵j先出动，这一点非常重要（请自己想一想为什么）。哨兵j一步一步地向左挪动（即j–），直到找到一个小于6的数停下来。接下来哨兵i再一步一步向右挪动（即i++），直到找到一个数大于6的数停下来。最后哨兵j停在了数字5面前，哨兵i停在了数字7面前。</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190322104119-335436.jpg" alt=""></p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190322104136-475270.jpg" alt=""></p><p>现在交换哨兵i和哨兵j所指向的元素的值。交换之后的序列如下：<br>6  1  2  5  9 3  4  7  10  8</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190322104036-743762.jpg" alt=""></p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190322104209-151834.jpg" alt=""></p><p>到此，第一次交换结束。接下来开始哨兵j继续向左挪动（再友情提醒，每次必须是哨兵j先出发）。他发现了4（比基准数6要小，满足要求）之后停了下来。哨兵i也继续向右挪动的，他发现了9（比基准数6要大，满足要求）之后停了下来。此时再次进行交换，交换之后的序列如下：<br>6  1  2 5  4  3  9  7 10  8</p><p>第二次交换结束，“探测”继续。哨兵j继续向左挪动，他发现了3（比基准数6要小，满足要求）之后又停了下来。哨兵i继续向右移动，糟啦！此时哨兵i和哨兵j相遇了，哨兵i和哨兵j都走到3面前。说明此时“探测”结束。我们将基准数6和3进行交换。交换之后的序列如下：<br>3  1 2  5  4  6  9 7  10  8</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190322104242-347520.jpg" alt=""></p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190322104303-766599.jpg" alt=""></p><p>到此第一轮“探测”真正结束。此时以基准数6为分界点，6左边的数都小于等于6，6右边的数都大于等于6。回顾一下刚才的过程，其实哨兵j的使命就是要找小于基准数的数，而哨兵i的使命就是要找大于基准数的数，直到i和j碰头为止。<br>OK，解释完毕。现在基准数6已经归位，它正好处在序列的第6位。此时我们已经将原来的序列，以6为分界点拆分成了两个序列，左边的序列是“3  1 2  5  4”，右边的序列是“9  7  10  8”。接下来还需要分别处理这两个序列。因为6左边和右边的序列目前都还是很混乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理6左边和右边的序列即可。现在先来处理6左边的序列现吧。</p><p> 左边的序列是“3  1  2 5  4”。请将这个序列以3为基准数进行调整，使得3左边的数都小于等于3，3右边的数都大于等于3。好了开始动笔吧  如果你模拟的没有错，调整完毕之后的序列的顺序应该是：</p><p>2  1  3  5  4  OK，现在3已经归位。接下来需要处理3左边的序列“2 1”和右边的序列“5 4”。对序列“2 1”以2为基准数进行调整，处理完毕之后的序列为“1 2”，到此2已经归位。序列“1”只有一个数，也不需要进行任何处理。至此我们对序列“2 1”已全部处理完毕，得到序列是“1 2”。序列“5 4”的处理也仿照此方法，最后得到的序列如下：  1  2  3 4  5  6 9  7  10  8  对于序列“9  7  10  8”也模拟刚才的过程，直到不可拆分出新的子序列为止。最终将会得到这样的序列，如下  1  2  3 4  5  6  7  8 9  10  到此，排序完全结束。细心的同学可能已经发现，快速排序的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了。下面上个霸气的图来描述下整个算法的处理过程。</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190322104349-934078.jpg" alt=""></p><p>这是为什么呢？快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是O(N2)，它的平均时间复杂度为O(NlogN)。其实快速排序是基于一种叫做“二分”的思想。我们后面还会遇到“二分”思想，到时候再聊。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">8</span>&#125;;</div><div class="line">        quickSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</div><div class="line">        System.out.println(Arrays.toString(arr));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 划分</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">        <span class="comment">// 用 arr[low] 作为枢纽轴元素 pivot 进行划分</span></div><div class="line">        <span class="comment">// 使得 arr[low,...,i-1] 均不大于 pivot，data[i+1,...,high]均小于 pivot</span></div><div class="line">        <span class="keyword">int</span> i,j; <span class="keyword">int</span> pivot;</div><div class="line">        pivot = arr[low]; i = low;j = high;</div><div class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</div><div class="line">            <span class="comment">/*从数组的两端交替地向中间扫描*/</span></div><div class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; arr[j] &gt;= pivot)j--;</div><div class="line">            arr[i] = arr[j];<span class="comment">/*比枢轴元素小者往前移动*/</span></div><div class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; arr[i] &lt;= pivot)i++;</div><div class="line">            arr[j] = arr[i];<span class="comment">/*比枢轴元素大者往后移动*/</span></div><div class="line">        &#125;</div><div class="line">        arr[i] = pivot;</div><div class="line">        <span class="keyword">return</span> i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 对整型数组进行非递减排序</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span> arr[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)&#123;</div><div class="line">        <span class="keyword">if</span>(low&lt;high)&#123;</div><div class="line">            <span class="keyword">int</span> loc = partition(arr,low,high);<span class="comment">/*进行划分*/</span></div><div class="line">            quickSort(arr,low,loc-<span class="number">1</span>);<span class="comment">/*对前半区进行快速排序*/</span></div><div class="line">            quickSort(arr,loc+<span class="number">1</span>,high);<span class="comment">/*对后半区进行快速排序*/</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> arr;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;快速排序原理和实现&quot;&gt;&lt;a href=&quot;#快速排序原理和实现&quot; class=&quot;headerlink&quot; title=&quot;快速排序原理和实现&quot;&gt;&lt;/a&gt;快速排序原理和实现&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p&gt;高快省的排序算法，既不浪费空间也可以快一点的排序算法。&lt;/p&gt;
    
    </summary>
    
      <category term="软件技术" scheme="http://swenfang.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="软件技术" scheme="http://swenfang.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>第1章计算机网络概述</title>
    <link href="http://swenfang.github.io/2019/03/30/SoftTestTechnique/%E7%AC%AC1%E7%AB%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
    <id>http://swenfang.github.io/2019/03/30/SoftTestTechnique/第1章计算机网络概述/</id>
    <published>2019-03-30T02:35:49.019Z</published>
    <updated>2019-04-06T09:32:37.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第1章计算机网络概述"><a href="#第1章计算机网络概述" class="headerlink" title="第1章计算机网络概述"></a>第1章计算机网络概述</h1><h2 id="计算机系统基础知识"><a href="#计算机系统基础知识" class="headerlink" title="计算机系统基础知识"></a>计算机系统基础知识</h2><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190315110740-590645.jpg" alt=""></p><h3 id="计算机系统硬件基本组成"><a href="#计算机系统硬件基本组成" class="headerlink" title="计算机系统硬件基本组成"></a>计算机系统硬件基本组成</h3><p>计算机系统是由硬件和软件组成的。基本硬件系统由 <code>运算器</code> <code>控制器</code>  <code>存储器</code> <code>输入设备</code> <code>输出设备</code>。<br><a id="more"></a></p><p>1、中央处理单元</p><p>运算器、控制器 等部件被集成在一起统称为<code>中央处理单元（CPU）</code>（硬件系统的核心）。CPU 用于数据加工处理，完成各种算术、逻辑运算及控制能力。</p><p>2、存储器</p><p><code>存储器</code> 是计算机系统中的记忆设备，分为<code>内部存储器</code>和<code>外部存储器</code> 。内部存储器速度高、容量小。一般用于临时存放程序，数据及中间结果。；外部存储器容量大、速度慢。可以长期保存程序和数据。</p><p>3、外部设备</p><p>输入和输出设备合称为 <code>外部设备</code></p><h3 id="中央处理单元"><a href="#中央处理单元" class="headerlink" title="中央处理单元"></a>中央处理单元</h3><p>CPU 是计算机系统的核心，负责获<code>取程序指令</code>、对指令进行<code>译码</code>并加以<code>执行</code>。</p><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul><li>程序控制（重要功能）：通过执行指令来控制程序的顺序。</li><li>操作控制：生产指令操作信号–&gt;把操作信号送往对应的部件–&gt;控制相应的部件按指令的功能要求进行操作。</li><li>时间控制：指令执行过程中操作信号的出现时间、持续时间以及出现的时间顺序都需要进行严格控制。</li><li>数据处理（根本任务）：对数据进行算术运算及逻辑运算等方式对数据进行加工处理。</li></ul><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p>运算器、控制器、寄存器和内部总线等部件组成。</p><h5 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h5><p>由<code>算术逻辑单元</code>、<code>累加寄存器</code>、<code>数据缓冲寄存器</code>、<code>状态条件寄存器</code>组成。是数据加工处理部件。</p><p>注意：运算器所进行的全部操作都是由控制器发出的控制信号来指挥的，so 它是执行部件。</p><p>1、算术逻辑单元（ALU）：负责数据处理，实现对数据的算术运算和逻辑运算。</p><p>2、累加寄存器（AC）:  为 ALU 提供一个工作区。例如：在执行一个减法运算前，先将被减数取出暂存在 AC 中，再从内存存储器中取出减数，然后同 AC 的内容相减，<code>将所得的结果送回 AC 中</code>。</p><p>注意：运算器中至少要有一个累加器寄存器。</p><p>3、数据缓冲寄存器（DR）：作为 CPU 和内存、外部设备之间数据传送的中转站。作为 CPU 和内存、外围设备之间在操作速度上的缓冲。</p><p>注意：在单累加器结构的运算器中，数据缓冲寄存器还可兼作为操作数寄存器。</p><p>4、状态条件寄存器（PSW）：状态条件寄存器保存由算术指令和逻辑指令运行或测试或测试的结果建立的各种条件码内容，主要分为状态标志和控制标志。</p><h6 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h6><p>1、执行所有的算术运算</p><p>2、执行所有的逻辑运算并进行逻辑测试</p><h5 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h5><p>用于控制整个 CPU 的工作，它决定了计算机运行过程的自动化。控制器一般包括<code>指令控制逻辑</code>、<code>时序控制逻辑</code>、<code>总线控制逻辑</code>和<code>中断控制逻辑</code>等几个部分。</p><p>指令控制逻辑过程：取指令–&gt;指令译码–&gt;按指令操作执行–&gt;形成下一条指令地址。</p><p>1、指令寄存器（IR）：当 CPU 执行一条指令时，先把它从内存储器取到缓冲寄存器中，再送入 IR 暂存，指令译码器根据 IR 的内容产生各种微操作指令，控制其他的组成部件工作，完成所有的功能。</p><p>2、程序计数器（PC）：具有<code>寄存信息</code>和<code>计数</code>功能，即又称<code>指令计数器</code>。程序的执行一般分为两种，一种是顺序执行，一种是转移执行。由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单地对 PC 加 1。当遇到转移指令时，后继指令的地址根据当前指令的地址加上一个向前或向后的位移的位移得到，或者根据转移指令给出直接转移的地址得到。</p><p>3、地址寄存器（AR）： 保存当前 CPU 所访问的内存单元的地址。</p><p>4、指令译码器（ID）：指令包含操作码和地址码。指令译码器是对指令中的操作码字段进行分析解析，识别该指令规定的操作，向操作控制器发出具体的控制信号，控制各部件工作，完成所需的功能。</p><p>时序控制逻辑–&gt;为每条指令按时间顺序提供有应有的控制信号。</p><p>总线逻辑–&gt;为多个功能部件服务的信息通路的控制电路。</p><p>中断控制逻辑–&gt;用于控制各种中断请求，并根据优先级的高低对中断请求进行排队，逐个交给 CPU 处理。</p><h5 id="寄存器组"><a href="#寄存器组" class="headerlink" title="寄存器组"></a>寄存器组</h5><p>分为<code>专用寄存器</code>和<code>通用寄存器</code>。运算器和控制器中的寄存器是专用寄存器，其作用是固定的。</p><h4 id="多核-CPU"><a href="#多核-CPU" class="headerlink" title="多核 CPU"></a>多核 CPU</h4><p>核心又称为内核，是 CPU 最重要的组成部分。CPU 所有的计算、接受/存储命令、处理数据都由核心执行。各种 CPU 核心都是具有固定的逻辑结构，一级缓存、二级缓存、执行单元、指令级单元和总线接口等逻辑单元都会有合理的布局。</p><p>多核即在一个单芯片上面集成两个甚至更多个处理器内核，其中每一个内核都有自己的逻辑单元、控制单元、中断处理器、运算单元，一级缓存、二级 Cache 共享独有，其中部件的完整性和单核处理器内核相比完全一样。</p><p>多核 CPU 最大的优点是可以满足用户同时进行多任务处理的要求。</p><p>要发挥 CPU 的多核性能，就需要操作系统能够及时、合理得给各个核分配任务和资源（如：缓存、总线、内存等），也需要应用软件在运行时可以把并行的线程同时交付给多个核心分别处理。</p><h3 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h3><p>各种数值在计算机中表示的形式称为<code>机器数</code>。</p><p>机器数分为：<code>无符号数</code>和 <code>带符号数</code>    </p><h4 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h4><p>表示正数，在机器数中没有符号位。</p><h4 id="带符号数"><a href="#带符号数" class="headerlink" title="带符号数"></a>带符号数</h4><p>机器数的最高位是表示正、负的符号位，其余位则表示数值。为了便于运算，带符号的机器数采用原码、反码、补码等不同的编码方法，机器数的这些编码方法称为<code>码制</code>。</p><h5 id="原码、反码、补码和移码"><a href="#原码、反码、补码和移码" class="headerlink" title="原码、反码、补码和移码"></a>原码、反码、补码和移码</h5><h6 id="原码表示法"><a href="#原码表示法" class="headerlink" title="原码表示法"></a>原码表示法</h6><p>n为机器字长</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190310091545-303485.jpg" alt=""></p><p>最高位是符号位，<code>0表示正数，1表示负数</code>，<code>其余的 n-1 位表示数值的绝对值</code>。</p><p>例子：若机器字长为8位</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190310091506-127376.jpg" alt=""></p><h6 id="反码表示法"><a href="#反码表示法" class="headerlink" title="反码表示法"></a>反码表示法</h6><p>n为机器字长</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190310091616-543866.jpg" alt=""></p><p>正数的反码和<code>原码相同</code>，负数的反码则是其<code>绝对值按位求反</code>。</p><p>例子：若机器字长为8位</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190310091649-920567.jpg" alt=""></p><h6 id="补码表示法"><a href="#补码表示法" class="headerlink" title="补码表示法"></a>补码表示法</h6><p>n为机器字长</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190310092006-651821.jpg" alt=""></p><p>正数的补码与其原码和反码相同，负数的补码等于其反码的末尾加1。</p><p>例子：若机器字长为8位</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190310092203-375413.jpg" alt=""></p><h6 id="移码表示法"><a href="#移码表示法" class="headerlink" title="移码表示法"></a>移码表示法</h6><p>只有将补码的符号位取反。</p><h5 id="定点数和浮点数"><a href="#定点数和浮点数" class="headerlink" title="定点数和浮点数"></a>定点数和浮点数</h5><h6 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h6><p>小数点的位置固定不变的数。小数点的位置通常有两种约定方式：<code>定点正数</code>、<code>定点小数</code></p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190310093206-38356.jpg" alt=""></p><h6 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h6><p>小数点的位置不确定</p><p>一个二进制  N 可以表示为更一般的形式 $N=2^{E}\times F$ ，其中 E 称为阶码，F称为尾数。用阶码和尾数表示的数称为浮点数，表示方法称为<code>浮点表示法</code>。</p><p>在浮点表示法中，阶码为带符号的纯正数，尾码为带符号的纯小数。</p><p>浮点数的表示格式：</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190310093240-213346.jpg" alt=""></p><p>浮点数所能表示的<code>数值范围</code>有由<code>阶码</code>决定，<code>精度</code>由于<code>尾数</code>决定</p><p>规范化就是将位数的绝对值限定在区间[0.5,1]。</p><p>当尾数用补码表示时，要注意：</p><p>若为数 $$M\geq 0​$$ ，规格化的尾数形式为 M=0.1XXX…X ,X 可为0，也可为1，即将尾数限定在区间[0.5,1]。</p><p>若为数 $$M &lt;0$$，………..即将尾数限定在区间[-1,-0.5]。</p><p>当浮点数的阶码用 R 位的移码表示，尾数用 M 位的补码表示，浮点数表示的数值范围：</p><p>最大：$+\left( 1-2^{-m+1}\right) \times 2^\left( 2^{r-1}-1\right)$</p><p>最小：$ -1 \times 2^\left( 2^{r-1}-1\right)$</p><h6 id="工业标准-IEEE754"><a href="#工业标准-IEEE754" class="headerlink" title="工业标准 IEEE754"></a>工业标准 IEEE754</h6><p>标准的表示形式为： $\left( -1\right) ^{S}2^{E}\left( b_{0}b_{1}b_{3}\ldots b_{p-1}\right)$</p><p>其中，$\left( -1\right) ^{S}​$ 浮点数的数符，当 S 为 0 时表示正数，S 为 1 时表示负数；E 为指数（阶码），用移码表示；</p><p>$\left( b_{0}b_{1}b_{3}\ldots b_{p-1}\right)$为尾数，长度为 p 位，用原码表示。</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190310093302-106776.jpg" alt=""></p><p>根据 IEEE754 标准，被编码的值分为 3 种不同的情况：<code>规范化的值</code>、<code>非规范化的值</code>和<code>特殊值</code>。</p><p>【1】、规范化的值：当阶码部分的二进制值不全为0，也不全为1时。</p><p>例子：利用 IEEE754 标准将数 176.0625 表示为单精度浮点数。</p><p>1、十进制数–&gt;转成二进制 （转换过程访问：<a href="https://www.cnblogs.com/xkfz007/articles/2590472.html）" target="_blank" rel="external">https://www.cnblogs.com/xkfz007/articles/2590472.html）</a></p><p>$\left( 176.065\right) _{10}=\left( 10110000.001\right) _{2}$</p><p>2、规格化处理</p><p>$10110000.001$ = $1\langle \rangle 01100000001\times 2^{7}$</p><p>将 $$b_{0}​$$ 去掉并扩展为单浮点数所规定的 23 位尾数。</p><p>01100000010000000000000</p><p>3、求阶码</p><p>$1\langle \rangle 01100000001\times 2^{7}$$的指数为 7 ，<code>单精度浮点数规定指数的偏移量为 127</code>。</p><p>所有 E = 7 + 127 = 134 ,求得移码为 10000110。 </p><p>0 10000110 01100000010000000000000</p><p>【2】、非规范化的值</p><p>阶码的二进制全为 0 。指数的真值为1–偏移量（对于单精度浮点数为-126，双精度浮点数为-1022），尾数的值就是二进制形式对应的小数，不包含隐含的1。</p><p>用途：①表示数值0；②表示哪些非常接近于0的数。</p><p>【3】、特殊值</p><p>阶码的二进制全为1。</p><p>尾数部分全为0：无穷大；符号为为0：$+\infty​$，1：$-\infty​$;</p><p>尾数部分不全为0：NaN;</p><h6 id="浮点数的运算"><a href="#浮点数的运算" class="headerlink" title="浮点数的运算"></a>浮点数的运算</h6><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190310093323-644702.jpg" alt=""></p><p><img src="C:\Users\shenwenfang\AppData\Roaming\Typora\typora-user-images\1550984468615.png" alt="1550984468615"></p><h3 id="校验码"><a href="#校验码" class="headerlink" title="校验码"></a>校验码</h3><p>使用校验码的方法来检测传送的数据是否出错。</p><p><code>码距</code>指一个编码系统中任意两个合法编码之间至少有多少个二进制位不同。例如：4 位 8421 码的码距为1 ，在传输过程中，该代码的一位或多位发生错误，都将变成另一个合法的编码，因此这样编码无检错能力。</p><h4 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h4><p>在编码中增加一位校验位来使编码中 1 的个数为奇数（奇校验）或者为偶数（偶校验），从而时码距变为2。奇校验，可以检测代码中奇数位出错的编码，但不能发现偶数位出错的情况，即当合法编码中的奇数位发生了变化，即当编码中的0变成了1或1变成了0，则该编码中1 的个数的奇偶性就发生了变化。</p><p>常用的奇偶检验码有：<code>水平奇偶检验码</code>、<code>垂直奇偶校验码</code>、<code>水平垂直奇偶校验</code></p><h4 id="海明码"><a href="#海明码" class="headerlink" title="海明码"></a>海明码</h4><p>构成方法是在数据位之间的特定位置上插入 k 个校验位，通过扩大码距来实现检错和纠错。</p><p>设数据位是 n 位， 校验位是 k 位，则 n 与 k 必须满足以下关系： $2^{k}-1\geq n+k$</p><h2 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h2><h3 id="计算机体系结构的发展"><a href="#计算机体系结构的发展" class="headerlink" title="计算机体系结构的发展"></a>计算机体系结构的发展</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><code>计算机体系结构</code>、<code>计算机组织</code>和<code>计算机实现</code>的关系：</p><p>体系结构：计算机的概念性结构和功能属性。</p><p>组织：计算机组成原理（计算机体系结构的逻辑实现，包括计算机内的数据流和控制流的组成以及逻辑设计等）。</p><p>实现：计算机组织的物理实现。</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>1、（宏观）按处理机的数量分：<code>单处理系统</code>、<code>并行处理与多处理系统</code>、<code>分布式处理系统</code></p><p>2、（微观）按并行程度分：<code>Flynn 分类法</code>、<code>冯泽云分类法</code>、<code>Handler 分类法</code>、<code>Kuck分类法</code></p><p>指令流：机器执行的指令序列；</p><p>数据流：指令调用的数据序列；</p><p>并行度：计算机系统在单位时间内能够处理的最大二进制位数。</p><p>Flynn ：按指令流和数据流的多少分类（单/多指令：单/多数据流，4种）</p><p>冯泽云：按并行度分类（字串/并行：位串/并行，4种）</p><p>Handler：提出一个基于硬件并行程度计算并行度的方法。</p><p>Kuck：按指令流和执行流及其多重性分（单/多指令：单/多执行流，4钟）</p><h4 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h4><p>指令集体系结构：一个处理器的指令和指令的字节级编码；不同的处理器族支持不同的指令集体系结构。</p><h5 id="指令集体系结构的分类"><a href="#指令集体系结构的分类" class="headerlink" title="指令集体系结构的分类"></a>指令集体系结构的分类</h5><h6 id="从体系结构的观点分"><a href="#从体系结构的观点分" class="headerlink" title="从体系结构的观点分"></a>从体系结构的观点分</h6><p>1、操作数在 CPU 中的存储方式</p><p>2、显式操作数的数量</p><p>3、操作数的位置</p><p>4、指令的操作</p><p>5、操作数的类型与大小</p><h6 id="按暂存机制分"><a href="#按暂存机制分" class="headerlink" title="按暂存机制分"></a>按暂存机制分</h6><p>堆栈（Stack）、累加器（Accumulator）、寄存器组</p><h5 id="CISC-和-RISC"><a href="#CISC-和-RISC" class="headerlink" title="CISC 和 RISC"></a>CISC 和 RISC</h5><p>CISC（复杂 指令集）和 RISC（精简指令集）是指令集发展的两种途径。</p><p>CISC：用更为复杂的新指令取代原先由软件子程序完成的功能，实现软件的硬件化，导致机器的指令系统越来月庞大、复杂。</p><p>RISC：通过减少指令总数和简化指令功能降低硬件设计的复杂度，使用指令能够单周期执行，并通过优化编译提高指令的执行速度。采用硬布线控制逻辑优化编译程序。</p><p>优化：</p><p>提高目标程序的实现效率：对动态和静态使用频率进行优化，既可以减少程序所需的存储空间，又可以提高程序的执行速度。</p><p>面向高级程序语言：缩小高级语言与机器语言之间的语义差距。</p><p>面向操作系统：缩小操作系统与体系结构之间的语义差异。</p><h5 id="指令的流水处理"><a href="#指令的流水处理" class="headerlink" title="指令的流水处理"></a>指令的流水处理</h5><h6 id="指令控制方式"><a href="#指令控制方式" class="headerlink" title="指令控制方式"></a>指令控制方式</h6><p>①<code>顺序执行</code>：指各条机器指令之间顺序的执行。优点是控制简单；缺点是速度慢，各部件的利用率低。</p><p>②<code>重叠方式</code>：指在解释第K条指令的操作完成之间就可以开始第K+1条指令。优点是速度提高，控制简单；缺点是出现冲突、转移和相关等问题。</p><p>③<code>流水方式</code>：把并行性和并发性嵌入到计算机系统的一种形式，把重复的顺序处理过程分解为若干个子过程，每个子过程能在独立的模块上有效地并发工作。</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190310093353-850138.jpg" alt=""></p><h6 id="流水线的种类"><a href="#流水线的种类" class="headerlink" title="流水线的种类"></a>流水线的种类</h6><p>①级别：部件级、处理级、系统级</p><p>②功能：单功能、多功能</p><p>③连接：静态、动态</p><p>④是否有反馈回路：线性流水、非线性流水</p><p>⑤流动顺序：同步流水、异步流水</p><p>⑥数据表示：标准、向量</p><h6 id="流水的相关处理"><a href="#流水的相关处理" class="headerlink" title="流水的相关处理"></a>流水的相关处理</h6><p>1、流水线时同时处理多条指令，会出现相关。相关带来的影响是局部性的，所以称为局部性相关。解决方式：<code>推后法</code>和<code>通路法</code>。推后法：推后相关单元的读，直到写入完成。通路法：设置相关专用通路直接使用运算结果，以加快速度。</p><p>2、转移指令与后面的指令之间存在关联，使之不能同时解释。执行转移指令时，可能会改动指令缓冲器中预取到的指令内容，造成流水线吞吐率和效率下降，称全局性相关。解决：<code>猜测转移分支</code>、<code>加快和提前形成条形码</code>、<code>加快断循环程序的处理</code>。</p><p>3、RISC 采用的流水技术：</p><p>①<code>超流水线</code>：在所有的功能单元都采用流水，并有更高的时钟频率和更深的流水深度。</p><p>②<code>超标量</code>：</p><p>③<code>超长指令字</code>：</p><h6 id="吞吐率和流水建立的时间"><a href="#吞吐率和流水建立的时间" class="headerlink" title="吞吐率和流水建立的时间"></a>吞吐率和流水建立的时间</h6><p>单位时间内流水线处理机流出的结果数（对指令，单位时间内执行的指令数）。</p><p>当流水线的子过程所用的时间不一样，吞吐率 $p=1/\max \left{ \Delta t_{1},\Delta t_{2},\ldots ,\Delta t_{m}\right}$</p><p>若m个子过程所用的时间一样，均为 $\Delta t_{0}$ ,则建立时间  $T_{0}=m\Delta t_{0}$</p><h4 id="阵列、并行、多处理机"><a href="#阵列、并行、多处理机" class="headerlink" title="阵列、并行、多处理机"></a>阵列、并行、多处理机</h4><p><code>并行性</code>：同一时刻发生；<code>并发性</code>：同一时间间隔内连续发生。</p><p>1、阵列处理机：将重复处理的多个单元（PU）按一定方式连成阵列。是一中单指令多数据流计算机，通过资源重复实现并行。</p><p>2、并行处理机：SIMD（共享存储器和分布式存取器形式） 和 MIMD 是典型的并行计算机。</p><p>3、多处理机：由多台处理及组成的。各自独立，共享一个主存器和所有的外部设备。多指令多数据流计算机。</p><p>4、其他计算机：集群计算机是一种并行或分布式处理系统。主要用来解决大型计算问题。这种系统可以提供一种价格合理的且可获得所需性能和快速而可靠的服务的解决方案。</p><h3 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h3><h4 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h4><p>例子：CPU 内部的通用寄存器组、CPU 内的 Cache(高速缓存)、CPU 外的 Cache、主板上的主存储器等。</p><p>注意：Cache 和主存之间的交互功能全部由硬件实现，主存和辅存由硬件和软件结合起来实现。</p><h4 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h4><p>1、按位置：</p><table><thead><tr><th>内存（主存）</th><th>外存（辅存）</th></tr></thead><tbody><tr><td>主机内和主机板上</td><td>磁盘、磁带和光盘</td></tr><tr><td>容量小速度快（相对于外存）</td><td></td></tr><tr><td>存放当前运行的程序和数据，向CPU提供信息</td><td>存放不参与运行的信息，需要是才调入</td></tr></tbody></table><p>2、按构成材料：</p><p>磁存储器、半导体存储器、光存储器</p><p>3、按工作方式：</p><p>读/写存储器、只读存储器</p><p>4、按访问方式：</p><p>按地址访问存储器、按内容访问存储器</p><p>5、按寻址方式：</p><p>随机存储器、顺序存储器、直接存储器</p><h4 id="相连存储器"><a href="#相连存储器" class="headerlink" title="相连存储器"></a>相连存储器</h4><p>是一种按内容访问的存储器。按关键字顺序存储和读取。适合于信息的检索和更新。相连存储器可用在高速缓存存储器中，在虚拟存储器中用来作为段表、页表和快表存储器，用在数据库和知识库中。</p><h4 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h4><p>用来存放当前最活跃和程序和数据。<code>特点</code>：位于 CPU 与主存之间；容量 几千~~几兆字节；速度比主存快 5~10 倍，由快速半导体存储器构成；其内容是主存局部域和副本，对程序员来说是透明的。</p><h5 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h5><p>高速缓存（Cache）、主存（Main Memory）与 CPU。关系如下：</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190310093436-392776.jpg" alt=""></p><p>现代 CPU 的缓存分为多层，关系如下：</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190310093508-644025.jpg" alt=""></p><h5 id="地址映像方法"><a href="#地址映像方法" class="headerlink" title="地址映像方法"></a>地址映像方法</h5><p>CPU 工作时，送出去的是主存单元地址，而应从 Cache 存储器中读/写信息。需要将主存地址转化成 Cache 存储器地址，这种地址转换称为<code>地址映像</code>。</p><p>①<code>直接映像</code>：主存块与Cache 的对应关系是固定。</p><p>②<code>全相联映像</code>：主存的任一块可以调入Cache 存储器的任何一个块的空间。</p><p>③<code>组相联映像</code>：将 Cache 中的块再分成组。</p><table><thead><tr><th>映射名称</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>直接映像</td><td>地址变换很简单</td><td>灵活性差</td></tr><tr><td>全相联映像</td><td>主存的块调入Cache 的位置不限制，灵活</td><td>无法从主存块号中直接获得 Cache 的块号，变换复杂，速度比较慢</td></tr><tr><td>组相联映像</td><td>前两种方式的折中</td></tr></tbody></table><h5 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h5><p>目的：使 Cache 获得尽可能高的命中率。</p><p>①随机替换：随机产生一个要替换的块号，将该块替换出去。</p><p>②先进先出：将最先进入Cache的块替换出去。</p><p>③近期最少使用：</p><p>④优化替换：必须先执行一次程序，统计 Cache 的替换情况。在第二次执行该程序便可以使用做有效的方式来替换。</p><h5 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h5><p>设 $H_{c}$ 是Cache 的命中率， $t_{c}$ 是Cache 的存取时间， $t_{m}$ 是主存的访问时间，则 Cache 存储器的等效加权平均访问时间 $t_{a}$ 为：$t_{a}=H_{c}t_{c}+\left( 1-H_{c}\right) t_{m}=t_{c}+\left( 1-H_{c}\right) \left( t_{m}-t_{c}\right)$</p><p>假设 Cache 访问和主存的访问是同时启动的， $t_{c}$ 是Cache 的存取时间，$\left( t_{m}-t_{c}\right)$ 为失效访问时间。如果在 Cache 不命中时才启动主内存，则 ：$t_{a}=t_{c}+\left( 1-H_{c}\right) t_{m}$</p><p>总结：降低 Cache 的失效率是提高 Cache 性能的一项重要措施。主要方法是：<code>选择恰当的块容量、提高 Cache 的容量和提高 Cache 的相联度</code>。</p><p>Cache 容量越大（增加 Cache 的成本和Cache 的命中时间），命中率越高，随着 Cache 容量的增加，失效率接近0%。</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190310093550-361073.jpg" alt=""></p><h5 id="多级-Cache"><a href="#多级-Cache" class="headerlink" title="多级 Cache"></a>多级 Cache</h5><p>多级，一般分为：一级（L1 Cache），二级（L2 Cache），三级（L3 Cache）等。CPU 访问首先查找 一级，若命不中就访问 二级，直到所有级别的 Cache 都命不中才访问主存。</p><h4 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h4><p>是一种对主存的抽象。使用虚拟地址（Virtual Address ，由 CPU 生成）的概念来访问主存，使用专门的 MMU 将虚拟地址转为物理地址后访问主存。<code>它实际上是一种逻辑存储器，实质是对物理存储设备进行逻辑化的处理</code>。</p><p>访问主存中的数据：CPU 给出<code>存储单元地址</code>–&gt;主存的读写控制部件定位对应的存储单元–&gt;进行读（写）操作完成访问。</p><h4 id="外存储器"><a href="#外存储器" class="headerlink" title="外存储器"></a>外存储器</h4><p>存放暂时不用的程序和数据，以文件的形式存储。<code>CPU 不能直接访问外存中的程序和数据，只有将其以文件为单位调入主存才可访问</code>。</p><h5 id="磁表面存储器"><a href="#磁表面存储器" class="headerlink" title="磁表面存储器"></a>磁表面存储器</h5><p>由<code>盘片</code>（控制数据写入和读出）、<code>驱动器</code>（寻找目标磁道位置）、<code>控制器</code>（控制驱动器的读/写操作）和<code>接口</code>（主机和磁盘存储器之间的连接逻辑）组成。</p><p>注意：控制器接收主机发来的命令，转化成控制命令，实现主机和驱动器之间数据格式的转换及数据传送，以控制驱动器的读/写操作。</p><p><code>硬盘</code>是常见的外部存储器。</p><p>硬盘的寻址信息由<code>硬盘驱动号</code>、<code>圆柱面号</code>、<code>磁头号</code>（记录面）、<code>数据块号</code>（或扇区号）、<code>交换量</code>组成。 </p><p>磁盘容量的两中指标：</p><p>①非格式化容量（总位数）：面数 X（磁道数/面）X 内圆周长 X 最大位密度</p><p>②格式化容量（各扇区中数据区容量的总和）：面数 X（磁道数/面）X（扇区数/道）X（字节数/扇区）</p><h5 id="光盘存储器"><a href="#光盘存储器" class="headerlink" title="光盘存储器"></a>光盘存储器</h5><p>采用聚焦激光束在盘式介质上非接触地记录高密度信息的新型存储装置。由光学、电学和机器部件组成。</p><p>特点是：记录密度高、存储容量大、采用非接触式读/写信息，信息可长期保存、数据传送率可超过200Mb/s、制造成本低、对机械结构的精度要求不高、存取时间较长。</p><p>分为：只读型光盘、只写型光盘、可擦除型光盘</p><h5 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h5><p>具有传统机械硬盘不具备的读写快速、质量轻、能耗低以及体积小等特定。但其价格昂贵、容量较低、一旦硬件损坏，数据较难恢复。</p><p>存储介质分为两种：采用<code>闪存（FLASH 芯片）</code>、采用<code>DRAM</code> 作为介质。</p><h4 id="磁盘阵列"><a href="#磁盘阵列" class="headerlink" title="磁盘阵列"></a>磁盘阵列</h4><p>由多台磁盘存储器组成的一个快速、大容量、高可靠的外存子系统。常见的<code>磁盘阵列称为廉价冗余磁盘阵列（RAID）</code>。</p><p>级别：从 RAID-0 到 RAID-6，各种类型的 RAID 可以组合起来，构成复合型的 RAID。    </p><h4 id="存储域网络（SAN）"><a href="#存储域网络（SAN）" class="headerlink" title="存储域网络（SAN）"></a>存储域网络（SAN）</h4><p>把一个或多个服务器与多个存储设备连接起来，每个存储设备可以是 RAID 、磁带备份系统、磁带库和 CD-ROM 库等。</p><p>解决了①服务器对存储容量的要求；②多个服务器之间共享文件系统和辅助存储空间；③实现分布式存储系统的集中管理，降低管理成本，提高管理效率；</p><p>SAN 的结构：存储域网络是连接服务器与存储设备的网络，它将多个分布在不同地点的 RAID 组织成一个逻辑存储设备，供多个服务器共同访问。</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190310093630-732446.jpg" alt=""></p><h3 id="输入-输出技术"><a href="#输入-输出技术" class="headerlink" title="输入/输出技术"></a>输入/输出技术</h3><h4 id="微型计算机中最常用的内存与接口的编址方法"><a href="#微型计算机中最常用的内存与接口的编址方法" class="headerlink" title="微型计算机中最常用的内存与接口的编址方法"></a>微型计算机中最常用的内存与接口的编址方法</h4><p>常见的两种：<code>内存与接口独立编制</code>和<code>内存与接口地址统一编址</code></p><table><thead><tr><th>说明</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>内存地址和接口地址是完全独立的两个地址空间</td><td>在编程序或读程序很易使用和辨认</td><td>接口的指令太少，功能太弱。</td></tr><tr><td>内存单元和接口共用地址空间</td><td>指令上不再区分内存指令和接口指令，增强了对接口的操作功能</td><td>内存地址不连续，需要参数定义表辨别</td></tr></tbody></table><h4 id="直接程序控制"><a href="#直接程序控制" class="headerlink" title="直接程序控制"></a>直接程序控制</h4><p>指外设数据的输入/输出过程是在 CPU 执行程序的控制下完成的。</p><p>分为：<code>无条件传送</code>(可随时向 CPU 接收或发送数据)、<code>有条件传送</code>（需要CPU查询外设状态；降低 CPU 的效率、无法实时的响应外部事件）</p><h4 id="中断方式"><a href="#中断方式" class="headerlink" title="中断方式"></a>中断方式</h4><p>程序控制 I/O 的方法。</p><p>缺点：CPU 需要定期查询 I/O 的状态，来确认传输是否完成，降低了系统的性能。</p><p>与程序控制方式相比，中断方式因为CPU无需等待而提高了效率。</p><h5 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h5><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>多中断信号线</td><td>中断请求信号线向 CPU 提出中断请求</td></tr><tr><td>中断软件查询</td><td>轮询每个中断源确定发出请求中断者</td></tr><tr><td>菊花链（硬件查询）</td><td>中断确认信号在 I/O 模块间传递，直达发出请求的模块，该模块把它的ID送往数据线由  CPU 读取</td></tr><tr><td>总线仲裁</td><td>在发中断前需要获取总线控制权，总线可决定谁可以发出中断请求</td></tr><tr><td>中断向量表</td><td>中断向量表保存各个中断源的中断服务程序入口地址。</td></tr></tbody></table><h5 id="优先级控制"><a href="#优先级控制" class="headerlink" title="优先级控制"></a>优先级控制</h5><p>给最紧迫的中断源分配高的优先级，给相对不紧迫的中断源分配低一些的优先级。</p><p>优先级控制可以解决以下情况：</p><p>1、当多个优先级不同的中断请求提出时，CPU 优先响应优先级最高的中断源。</p><p>2、执行中断嵌套。</p><h4 id="直接存储器存取方式"><a href="#直接存储器存取方式" class="headerlink" title="直接存储器存取方式"></a>直接存储器存取方式</h4><p>直接存储器简称 <code>DMA</code>。指在内存与I/O设备传送一个数据块的过程，不需要 CPU 的干涉（只需要在过程开启和结束）。在 DMA 传送过程中，整个系统都交给了 DMA 控制器（DMAC），由它控制系统总线完成数据传送。在 DMA 传送数据期间，CPU 不能使用总线。</p><h4 id="输入输出处理机"><a href="#输入输出处理机" class="headerlink" title="输入输出处理机"></a>输入输出处理机</h4><p>简称 <code>IOP</code>。IOP 也被成为通道，它分担了 CPU 的一部分功能，实现对外围设备的统一管理，完成外围设备与主存之间的数据传送，提高 CPU 的工作效率，但是它需要增加更多的硬件作为代价。</p><p>几步发展产品：外围处理机（PPU）、专用处理机（PPU）</p><h3 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h3><p>总线简称 <code>Bus</code>。指计算机设备和设备之间传输信息的公共数据通道。它的特征是由总线上的所有设备共享，可将计算机系统内的多种设备连接到总线上。</p><h4 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h4><p><code>数据总线</code>、<code>地址总线</code>、<code>控制总线</code>，不同型号的CPU芯片，它们也不同。</p><p>1、数据总线（DB）：双向、CPU通过DB从内存或输入输出设备读入数据也可以传送数据、<code>宽度决定了CPU和计算机其他设备之间每次交换数据的位数</code>。</p><p>2、地址总线（AB）：用于传送 CPU 发出的地址信息、单向、<code>宽度决定了 CPU 的最大寻址能力</code>。</p><p>3、控制总线（CB）：用来传送信号（例如：控制信号、时序信号、状态信号）、作为整体是双向的。</p><p>总结：总线的性能直接影响到整体系统的性能；任何系统研制和外围模块的开发都必须依从所采用的总线规范。</p><h4 id="常见总线"><a href="#常见总线" class="headerlink" title="常见总线"></a>常见总线</h4><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>ISA 总线（AT标准）</td><td>工业标准；支持16位I/O;传速16Mb/s</td></tr><tr><td>EISE总线</td><td>基于ISA起来的；32位；传输 33Mb/s</td></tr><tr><td>PCI总线</td><td>使用较广的内总线，采用并发传输方式；32/64位；PCI上的设备是即插即用；在传输时会进奇偶校验</td></tr><tr><td>PCI Express 总线</td><td>简称 <code>PCI-E</code>;采用点对点串行连接，无需向总线请求宽带，提高传输频率；PCI-E支持热拔插；双向传输，可运行全双工和双单连接工模式，连接的每个装置都可使用到做大宽度。</td></tr><tr><td>前端总线</td><td>简称 <code>FSB</code>;将CPU 连接到北桥芯片。系统需要主板和CPU都支持某个总线，才能工作；数据传输能力决定对计算机整体性能影响大；</td></tr><tr><td>RS-232C</td><td>串行外总线；至少需要三条；传输距离远；具有较好的抗干扰性</td></tr><tr><td>SCSI总线</td><td>并行外总线；广用于连接硬磁盘、光盘、扫描仪；传输距离20m（差分传送）</td></tr><tr><td>SATA</td><td>串行；主要用在主板和大量存储（硬盘、光盘）之间传输；能对传输指令进行校验并自动校正；接口优点：结构简单、支持热拔插</td></tr><tr><td>USB</td><td>串行；由四条信号线组成（两条数据传送，两条传送电源）；优点：支持热插拔、即插即用</td></tr><tr><td>IEEE-1394</td><td>最高速串行外总线；支持热拔插，可提供电源；支持同步和异步数据传输；由6条信号线组成（两条传送数据两条传送控制信号；两条传送电源）；传输可达3.2Gb/s</td></tr><tr><td>IEEE-488 总线</td><td>并行总线接口标准；总线连接方式；仪器设备（微计算机、数字电压表、数码显示器等）不需中介单元直接并行、字节串行双向异步方式传输信号；最多可连接15台设备；</td></tr></tbody></table><h2 id="安全性、可靠性与系统性能评测基础知识"><a href="#安全性、可靠性与系统性能评测基础知识" class="headerlink" title="安全性、可靠性与系统性能评测基础知识"></a>安全性、可靠性与系统性能评测基础知识</h2><h3 id="计算机安全概述"><a href="#计算机安全概述" class="headerlink" title="计算机安全概述"></a>计算机安全概述</h3><p>计算机安全包括：安全管理、通信与网络安全、密码学、安全体系及模型、容错与容灾。</p><h4 id="计算机的安全等级"><a href="#计算机的安全等级" class="headerlink" title="计算机的安全等级"></a>计算机的安全等级</h4><p>4组7个等级</p><table><thead><tr><th>组</th><th>安全级别</th><th>定义</th></tr></thead><tbody><tr><td>1</td><td>A1</td><td>可验证安全设计。提供B3级保护，给出形式化隐秘通道分析，非形式化代码一致性验证</td></tr><tr><td>2</td><td>B3</td><td>安全域。TCB必须满足访问监控的要求，提供系统恢复过程</td></tr><tr><td></td><td>B2</td><td>结构化安全保护。建立安全策略模型，对所有的主体和客体实施自主访问和强制访问</td></tr><tr><td></td><td>B1</td><td>标记安全保护。对数据进行标记，对标记的主体和客体实施强制存取控制</td></tr><tr><td>3</td><td>C2</td><td>受控访问控制。存取控制以用户为单位</td></tr><tr><td></td><td>C1</td><td>c初级的自主安全保护，实现用户和数据的分离，进行自主存取控制，以用户组为单位</td></tr><tr><td>4</td><td>D</td><td>最低级、保护措施很小、没有安全功能</td></tr></tbody></table><h4 id="安全威胁"><a href="#安全威胁" class="headerlink" title="安全威胁"></a>安全威胁</h4><p>分两类：<code>故意</code>（黑客渗透）和 <code>偶然</code>（信息法网错误的地址）</p><p>典型的安全威胁</p><p>授权侵犯、拒绝服务、窃听、信息泄露、截获/修改、假冒、否认、非法使用、人员疏忽、完整性破坏、媒体清理、物理入侵、资源耗尽</p><h4 id="影响数据安全因素"><a href="#影响数据安全因素" class="headerlink" title="影响数据安全因素"></a>影响数据安全因素</h4><p>1、内部因素：数据加密；安全规划 ；安全存储等</p><p>2、外部因素：设置权限；设置身份、密码、口令等多种认证；设置防火墙；</p><h3 id="加密认证技术和认证技术"><a href="#加密认证技术和认证技术" class="headerlink" title="加密认证技术和认证技术"></a>加密认证技术和认证技术</h3><h4 id="加密技术"><a href="#加密技术" class="headerlink" title="加密技术"></a>加密技术</h4><p>密钥加密技术的密码体制分为<code>对称密钥体制</code>和<code>非对称密钥体制</code>。</p><p>数据加密的技术分为两类，即<code>对称加密</code>（私人密钥加密）和<code>非对称加密</code>（公开密钥加密）。</p><h5 id="对称机密技术"><a href="#对称机密技术" class="headerlink" title="对称机密技术"></a>对称机密技术</h5><p>文件加密和解密使用相同的密钥。</p><p>常用的对称加密算法：</p><p>（1）、数据加密标准算法简称<code>DES</code>：运算速度块、密钥产生容易；适合在当前大多数计算机上用软件方法实现；适合于在专用芯片上实现。</p><p>（2）、三重DES（3DES或TDEA）：在 DES 的基础上采用三重DES，密钥长度加倍；发送方式，K1加密–&gt;k2解密–&gt;K1加密；接收方式，K1解密–&gt;k2加密–&gt;K1解密</p><p>（3）、RC-5：是在RCF2040中定义的</p><p>（4）、国际数据加密算法（IDEA）：密钥为 128位置；是一种据库块加密算法</p><p>（5）、高级加密标准（AES）算法：基于排列（对数据进行重新安排）和置换（将一个数据单元替换为另一个）运算。AES 是一个迭代的、对称密钥分组的密码，可使用 128、192和256位密钥。</p><h5 id="非对称加密技术"><a href="#非对称加密技术" class="headerlink" title="非对称加密技术"></a>非对称加密技术</h5><p>因为加密和解密使用的是两个不同的密钥。非对称加密算法需要两个密钥：<code>公开密钥</code>和<code>私有密钥</code>。若使用公开密钥进行加密则私有密钥才能解密；反之；</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190310093703-412311.jpg" alt=""></p><p><code>优缺点</code>：保密性好；加密和解密花费的事件长、速度慢，不适合对文件加密，适合少量数据加密。</p><p><code>RSA算法</code>是一种公钥加密算法；安全性是基于大素数分解的困难性能。</p><h5 id="密钥管理"><a href="#密钥管理" class="headerlink" title="密钥管理"></a>密钥管理</h5><p>包括<code>密钥生产</code>、<code>密钥备份和恢复</code>、<code>密钥更新</code>等</p><p><strong>密钥生产</strong>：密钥对的产生是证书申请中的一步，产生的私密由用户保留，公密由和其他信息交给CA中心进行签证，从而产生证书。普通/测试证书由浏览器或固定的终端应用产生。重要（商家证书、服务器证书）的证书，一般由专用应用或CA中心直接产生。</p><p><strong>密钥备份和恢复</strong>：在 PKI（公开密钥体系） 系统中，即使密钥丢失，使用 PKI 的企业和组织必须仍能得到确认，受密钥保护的重要信息也必须能够恢复。</p><p><strong>密钥更新</strong>：对没和由CA颁发的证书都会有有效期，密钥对生命周期的长短由签发证书的CA中心来确定，各证书的有效期都不同。</p><p><strong>多密钥的管理</strong>：Kerberos 建立了一个安全的、可信任的密钥中心（KDC），每个用户只要知道一个和KDC进行会话的密钥就可以了。</p><h4 id="认证技术"><a href="#认证技术" class="headerlink" title="认证技术"></a>认证技术</h4><p>主要解决网络通信过程中通信双方的身份认可。涉及加密（对称加密、不对称加密、两种混合）和密钥交换。认证一般有<code>账户名/口令认证</code>、<code>使用摘要算法认证</code>和<code>基于PKI认证</code>。</p><p>认证机构：数字证书的申请及签发机关（CA）；</p><p>PKI 的主要目的通过自动管理密钥和证书为用户建立一个安全的网络运行环境，是用户可以在多种环境下方便的使用加密和数字签名技术，保证网上数据的机密性、完整性和有效性。</p><p>KPI标准化主要有两方面：1、RSA 公司的公钥加密标准；2、一组具有互操作性的公钥基础设施协议</p><h5 id="Hash-函数与信息摘要"><a href="#Hash-函数与信息摘要" class="headerlink" title="Hash 函数与信息摘要"></a>Hash 函数与信息摘要</h5><p>信息摘要：简要地描述一份较长的信息或文件。用于创建数字签名（是唯一的）。</p><p>例子：</p><p>MD5（MD表示信息摘要），是被广泛应用的 Hash 函数。特点：压缩性（长度固定）、容易计算、抗修改性、强抗碰撞。</p><h5 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h5><p>数字签名过程：信息发送者对信息生成信息摘要–&gt;信息发送者使用私钥签名信息摘要–&gt;把信息本身和已签名的信息摘要一起发送出去–&gt;（使用同一个散列函数）接收者对信息本身生成新的信息摘要，并使用公钥对信息摘要进行验证</p><p>总结：数字签名是一对多的关系；可以验证数字签名的正确性；</p><p>数字加密过程：</p><p>1、信息发送者需要生成一个对称密钥，用该密钥加密要发送的报文。</p><p>2、信息发送者用接收者的公钥加密对称密钥。</p><p>3、数字信封：步骤1和步骤2结合在一起的结果。</p><p>4、接收者使用私钥解密被解密的对称密钥，再用对称密钥解密被加密的密文，得到原文。</p><p>总结：数字加密是多对一的关系；任何知道公钥的人都可向接收方发送加密信息；采用对称加密算法和非对称加密算法，保证发送信息的保密性。</p><h5 id="SSL-协议"><a href="#SSL-协议" class="headerlink" title="SSL 协议"></a>SSL 协议</h5><p>SSL 是安全套接层，主要用于提高应用程序之间数据的安全系数。是一个保证计算机通信安全的协议。</p><p>提供以下3方面的服务：    </p><p>1、用户和服务器的合法性认证。是它们确信数据被送到正确的客户端和服务器上。验证用户的合法性，安全套层协议要求在握交换数据时，进行数字认证。</p><p>2、加密数据易隐藏被发送的数据。在客户端与服务器进行数据交换之前，交换SSL初始握手信息，在 SSL 握手信息中采用了各种加密技术对其加密，保证其机密性和数据完整性，并用数字证书进行鉴别，防止破译。</p><p>3、保护数据的完整性。安全套接层协议采用 Hash 函数和机密共享的方法来提供信息的完整性服务，建立客户端与服务器之间的安全通道。</p><p>主要经过的阶段：</p><p>接通（服务响应）–&gt;密码交换–&gt;会谈密码–&gt;检验–&gt;结束</p><p>发送时，信息用对称密钥加密，对称密钥用非对称算法加密，再把两个包捆绑在一起送过去。</p><h5 id="数字事件戳技术"><a href="#数字事件戳技术" class="headerlink" title="数字事件戳技术"></a>数字事件戳技术</h5><p>是数字签名技术的一种变种应用。</p><p>数字时间戳服务（DTS）是网上电子商务安全服务项目之一，提供电子文件的日期和时间信息的安全保护。是一个经加密后形成的凭证文档。</p><p>包括如下3步骤：</p><p>文件的摘要–&gt;DTS收到文件的日期和时间–&gt;DTS的数字签名</p><h3 id="计算机可靠性"><a href="#计算机可靠性" class="headerlink" title="计算机可靠性"></a>计算机可靠性</h3><h4 id="计算机可靠性概述"><a href="#计算机可靠性概述" class="headerlink" title="计算机可靠性概述"></a>计算机可靠性概述</h4><p>其中，$R\left( t\right)$ 是正常运行的概率；$$\lambda$$ 指单位时间内失效的元件数与元件总数的比例，当它为常量时，可靠性与失效性的关系为：$R\left( t\right) =e^{-\lambda t}​$</p><p>失效率特征如下图</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190310093721-85438.jpg" alt=""></p><p>平均无故障时间：$MTBF=\dfrac {1}{\lambda }$</p><p>计算机的维修效率（MTRF）。计算机的可用性是指计算机的使用效率。它以系统在执行任务的任意时刻能正常工作的概率A表示，即：$A=\dfrac {ETBF}{MTBF+MTRT}$</p><p>计算机的 RAS 是指用可靠性 R 、可用性 A 和可维修性S这3个指衡量一个计算机系统。</p><h4 id="计算机可靠性模型"><a href="#计算机可靠性模型" class="headerlink" title="计算机可靠性模型"></a>计算机可靠性模型</h4><p>常见的系统可靠性数学模型有一下3种：</p><h5 id="串联系统"><a href="#串联系统" class="headerlink" title="串联系统"></a>串联系统</h5><p>且仅当所欲的子系统都能正常工作时。系统才正常工作。</p><p>可靠性公式：（$R_{1}$ $R_{2}$ 表示子系统）</p><p>$R=R_{1}R_{2}\ldots R_{N}​$</p><p>失效公式：（$$\lambda _{1}​$$ $$\lambda _{2}​$$ 表示子系统的失效率）</p><p>$\lambda =\lambda _{1}+\lambda _{2}+\ldots +\lambda _{N}$</p><h5 id="并联系统"><a href="#并联系统" class="headerlink" title="并联系统"></a>并联系统</h5><p>只要有一个子系统正常工作，系统就能正常运行</p><p>可靠性公式：$R=1-\left( 1-R_{1}\right) \left( 1-R_{2}\right) \ldots \left( 1-R_{N}\right)$</p><p>失效率：$\mu =\dfrac {1}{\dfrac {1}{\lambda }\sum ^{N}_{j=1}\dfrac {1}{j}}$</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190310093745-219866.jpg" alt=""></p><h5 id="N-模冗余系统"><a href="#N-模冗余系统" class="headerlink" title="N 模冗余系统"></a>N 模冗余系统</h5><p>由N个（N=2n+1）相同的子系统和一个表决器组成。只要有 n+1 个或 n+1 个以上的子系统能正常工作，系统就正常工作。</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190311125807-867679.jpg" alt=""></p><p>公式：</p><p>$R=\sum ^{N}<em>{i=n+1}\begin{pmatrix} j \ N \end{pmatrix}\times R^{i}</em>{0}\left( 1-R_{0}\right) ^{N-i}$</p><p>$\begin{pmatrix} j \ N \end{pmatrix}$ 表示从 N 个元素中取 i 个元素的组合数。</p><p>提高可靠性：提高元器件数量；发展容错技术。</p><h3 id="计算机系统的性能评价"><a href="#计算机系统的性能评价" class="headerlink" title="计算机系统的性能评价"></a>计算机系统的性能评价</h3><h4 id="性能测评的常用方法"><a href="#性能测评的常用方法" class="headerlink" title="性能测评的常用方法"></a>性能测评的常用方法</h4><p>（1）时钟频率。主频越高，速度越快</p><p>（2）指令执行速度。加法指令的运算速度衡量计算机的速度。</p><p>（3）等效指令法。统计各类指令在程序中所占的比例，并进行折算。</p><p>（4）数据处理频率法（PDR）。采用计算 PDR 值得方法来衡量机器性能，PDR 值越大，机器性能越好。注意，PDR 值只要对 CPU 和主存储器的速度进行度量，但不适合衡量机器的整体速度，因为它没有涉及到Cache、多功能部件等技术对性能的影响。</p><p>（5）核心程序法。把应用程序中用得最频率的那部分核心程序作为评价计算机性能的标准程序，在不同的计算机上运行，测得其执行时间。机器软/硬件结构的特点能在核心程序中的到反映，但是核心程序各部分之间的联系较小。</p><h4 id="基准测试程序"><a href="#基准测试程序" class="headerlink" title="基准测试程序"></a>基准测试程序</h4><p>目前测试性能较好的方法。有多种多样的基准程序。</p><p>（1）整数测试程序。测试编译器及CPU处理整数指令和控制功能的有效性。</p><p>（2）浮点测试程序。机器的浮点性能对系统的应用有很大的影响。</p><p>（3）SPEC基准程序。</p><p>（4）TPC基准程序。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第1章计算机网络概述&quot;&gt;&lt;a href=&quot;#第1章计算机网络概述&quot; class=&quot;headerlink&quot; title=&quot;第1章计算机网络概述&quot;&gt;&lt;/a&gt;第1章计算机网络概述&lt;/h1&gt;&lt;h2 id=&quot;计算机系统基础知识&quot;&gt;&lt;a href=&quot;#计算机系统基础知识&quot; class=&quot;headerlink&quot; title=&quot;计算机系统基础知识&quot;&gt;&lt;/a&gt;计算机系统基础知识&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://blogimg.nos-eastchina1.126.net/shenwf20190315110740-590645.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;计算机系统硬件基本组成&quot;&gt;&lt;a href=&quot;#计算机系统硬件基本组成&quot; class=&quot;headerlink&quot; title=&quot;计算机系统硬件基本组成&quot;&gt;&lt;/a&gt;计算机系统硬件基本组成&lt;/h3&gt;&lt;p&gt;计算机系统是由硬件和软件组成的。基本硬件系统由 &lt;code&gt;运算器&lt;/code&gt; &lt;code&gt;控制器&lt;/code&gt;  &lt;code&gt;存储器&lt;/code&gt; &lt;code&gt;输入设备&lt;/code&gt; &lt;code&gt;输出设备&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="软件技术" scheme="http://swenfang.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="软件技术" scheme="http://swenfang.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>废掉一个人最隐蔽的方式是让他忙到没时间成长</title>
    <link href="http://swenfang.github.io/2019/03/29/Essay/%E5%BA%9F%E6%8E%89%E4%B8%80%E4%B8%AA%E4%BA%BA%E6%9C%80%E9%9A%90%E8%94%BD%E7%9A%84%E6%96%B9%E5%BC%8F%E6%98%AF%E8%AE%A9%E4%BB%96%E5%BF%99%E5%88%B0%E6%B2%A1%E6%97%B6%E9%97%B4%E6%88%90%E9%95%BF/"/>
    <id>http://swenfang.github.io/2019/03/29/Essay/废掉一个人最隐蔽的方式是让他忙到没时间成长/</id>
    <published>2019-03-29T14:59:59.589Z</published>
    <updated>2019-03-29T15:02:24.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="废掉一个人最隐蔽的方式是让他忙到没时间成长"><a href="#废掉一个人最隐蔽的方式是让他忙到没时间成长" class="headerlink" title="废掉一个人最隐蔽的方式是让他忙到没时间成长"></a>废掉一个人最隐蔽的方式是让他忙到没时间成长</h1><p>大家可能都看过一个观点：废掉一个人最快的方式，就是让他闲着。我认同么？非常认同。但我今天想讲另一个角度，<strong>废掉一个人最隐蔽的方式，是让他忙到没时间成长。</strong>而且我认为这个点更重要。因为大部分人都不闲，大家都在努力的过活，北上广深等大城市的年轻人，尤其是互联网从业者，不仅不闲，还每天忙得要死，甚至周末都不休息。这样一群人，我根本不怕他们太闲，我更怕他们太忙，尤其是怕他们忙到没时间成长。<br><a id="more"></a></p><h2 id="废掉一个人最隐蔽的方式是让他忙到没时间成长-1"><a href="#废掉一个人最隐蔽的方式是让他忙到没时间成长-1" class="headerlink" title="废掉一个人最隐蔽的方式是让他忙到没时间成长"></a>废掉一个人最隐蔽的方式是让他忙到没时间成长</h2><p>我的团队成员都是从我的社群里招的，所以大家价值观一致、做事理念一致、目标一致，我们彼此深度信任。因此即便我不怎么管他们，他们也超级努力，一个表现就是：下班后他们主动加班，周末他们主动给自己工作加量，更快的推进工作，总之特别忙，工作时间超长。很多老板喜欢看到员工这样，但我总是担心，担心他们忙到没时间成长。我经常告诉他们要注意休息，周末也不要一直干活。我有个课程助理，前几天我跟他说了这么一段话：</p><blockquote><p>你一定要控制好自己的工作节奏，不用推进得太猛，每天早点下班，周末也不用这么拼。</p><p>你空出来的时间，除了休息好，就是用来自我成长。</p><p>比如，你的工作需要写东西，那么你必须保证每天拿出固定的时间学习、大量阅读、听课，甚至这要变成一个强制性学习任务，跟你的工作任务同样重要，甚至你上班时间做也没关系。</p><p>我写作三年多，为什么越写越好，永不枯竭，永远有新东西可写，永远能提出新观点。</p><p>因为每天晚上12点到凌晨3点左右，几乎是我雷打不动学习时间，不管当天多累，这个习惯我都没中断。</p></blockquote><p><strong>你必须有时间成长，而不是无休止的工作。</strong>不信你问问自己：过去一个月的忙碌中，过去一年的忙碌中，你有多少时间用来成长？你成长了多少？如果你每天忙到连认真读几篇好文章的时间都没有，忙到连听一个小时课的时间都没有，忙到想在周末精进一下某项能力、某项技能的时间都没有，你必须要正视这个问题了。很多人沉浸在每天的忙碌工作中，早上八点出门，晚上十点多回家，累得洗漱完倒头就睡，明天又这样重复一天，后天又这样重复一天……日复一日。这是废掉一个人最隐蔽的方式，因为你会觉得明明自己每一天都特别充实，每天都干了很多活。你每天都干了很多活，是没错，但你过去半年、一年进步了多少？你自己心里没数么。为什么说这是废掉呢？<strong>因为学习是一种习惯，成长是一种习惯，精进也是一种习惯。你若是一年两年里都忙到没时间成长，你最终也会习惯了每天不成长的状态，毕竟不成长本身也是人最舒服的状态。</strong>因此，时间长了，你就丧失了成长的能力。而大部分老板不关心这个，为什么？比如一个新媒体工作的老板招一个小编，如果这个小编成长很快，可以做更有价值的事情，这对老板来说是意外惊喜。如果这个小编不成长，那完全没关系，老板招你来就是让你做小编的工作的，你一年没进步也没关系，你就日复一日做好你的本职工作就行。因此，你成长，是老板可遇不可求的，是不可控的；而在你能胜任的工作上给你不断加任务、加工作量，是老板可控制的、可明显有更大收益的做法。所以，你需要自己保留成长时间。</p><h2 id="一个人在职场里持续上升必须要有持续的增量成长"><a href="#一个人在职场里持续上升必须要有持续的增量成长" class="headerlink" title="一个人在职场里持续上升必须要有持续的增量成长"></a>一个人在职场里持续上升必须要有持续的增量成长</h2><p>有人说：工作的过程，不就是很好的成长过程么？我认同么？非常认同。但同时，有很大的局限性。</p><p>为什么呢？</p><ul><li><strong>每份工作必然包含大比例的重复性、同质化工作。</strong></li></ul><p>比如我做新媒体讲师时，前期准备课程时，我每天进步很大，我每天在打磨新的东西，等这个课程做出来，我出去讲一次自己进步很大，再去讲第二次还有很大进步….但这毕竟是一个重复的、同质化的工作，我每次出去就是讲那几百页 PPT。当我疲于奔波在一个个公开课和一家家企业，没有时间学新东西时，我的进步就变得很慢了。<strong>事实上，任何一份工作都必然包含大比例的重复性、同质化工作：</strong></p><p>比如：</p><blockquote><p>一个商务每天都要跟一堆人重复说同样的话术；</p><p>一个客服每天要解答成百个同质化问题；</p><p>一个小编每天都要用标准模版给一篇稿子排版；</p><p>一个银行职员每天都是那个流程服务客户；</p><p>一个的士司机每天那样拉客；</p><p>一个电商文案每天用同质化的模版写同质化的句子；</p><p>一个设计师可能做了一年没太有啥区别的课程海报或商品海报……</p></blockquote><p>这个社会分工越细，这个趋势越重，因为这样大家加起来的效率最高，但个人的成长不是如此。</p><ul><li><strong>重复单一的学习，对成长的边际贡献越来越低。</strong></li></ul><p>我有个做销售的朋友，每天特别忙，做了两年了。</p><p>我问：“你做了两年了，有没有自己一套成熟的销售知识体系了？”</p><p>她回：“啥体系？我就每天那套话术给客户讲呗。”</p><p>我说：“最近有个讲怎么做销售的课挺火的，老师也有多年的实战经验，你没去听一下、研究一下么？”</p><p>她回：“朋友圈里看见过，但我哪有时间学啊。”</p><p>我问：“关于营销、品牌的书和文章，你看得多么？”</p><p>她回：“我光谈客户做销售都累死了，哪有时间再学别的……”</p><p>如果一个人只是从工作过程中学习，那么这种单一的学习方式，必然导致它对成长的边际贡献越来越低。<strong>每天一定要让自己有时间成长，其实是让你拓展除工作外的其它成长方式，你学习的方式多元化，对成长的边际贡献就越高，你的成长就越快。</strong></p><p>我跟那个做销售的朋友说：</p><blockquote><p>你做了两年销售了，如果继续这样只是天天谈客户天天谈客户，第三年你可能还是这样。</p><p>你要抽时间多听一些课程，更新完善你的知识体系，并在之后的销售过程中去运用实践。</p><p>你要多学一点品牌的知识、营销的知识，这样对销售工作帮助很大，你要多一点商业知识商业思维，这样你越来越专业，谈客户更有说服力等等。</p></blockquote><p>一个人在职场里持续上升，必须要有持续的增量成长。如果你每天、每周、每个月都忙到没时间成长，那么你每一天的工作，都是在消耗存量。你的存量是有限的，一定是越消耗越少。<strong>一个日复一日消耗存量的员工，必然是一个不能提供惊喜的员工。所谓普通人，就是不能提供惊喜的人，有增量才有惊喜，才能持续上升。</strong></p><h2 id="一份好工作的标准里必须有一条你有时间成长"><a href="#一份好工作的标准里必须有一条你有时间成长" class="headerlink" title="一份好工作的标准里必须有一条你有时间成长"></a>一份好工作的标准里必须有一条你有时间成长</h2><p>人人都说要找份好工作，那什么是好工作？标准有很多，但可以简单归纳为三点：有钱、有闲、有成长。</p><ul><li><strong>有钱</strong>  </li></ul><p>工作不主要为了钱，但钱很少，也从一个侧面反映这不是什么能创造大价值的工作。</p><ul><li><strong>有闲</strong>  </li></ul><p>不能工作量大到每天加班到很晚，周末至少能好好休息一天。</p><ul><li><strong>有成长</strong>  </li></ul><p>工作本身价值高、锻炼人；公司属于行业里专业性很强的，可以学到东西；老板、领导愿意培养你，等等。</p><p>如果一份工作，能同时满足这三点，那一定是很好的工作；如果一份工作，一点都满足不了，那你还留在那耗什么？</p><p>其中第二条有闲非常重要。之前有个同学就跟我吐槽，他说老板经常说的一句话是工作是最好的修行，然后鼓励大家多加班，说那些不怎么加班的员工没有上进心之类的。同学说了很重要一点：我下班就走了，可能有两种状态，一种状态可能是我下班回家去打游戏了、追剧了、刷抖音了，另一种状态是我可能每天下班后都回家学习去了，读书、听课、提升工作技能等。我很同意这种说法，并不是每天加班到凌晨才离开办公室的员工才有上进心，你根本不知道一个人下班后去干嘛了。</p><p>有可能半年后，那个下了班就走的人，表现的比那个天天加班的更好。如果一份工作，钱没有特别多，工作本身也不能给你很大成长，但是你有很多自己的时间，这种工作在很多时候也是好的。因为你可以在自己能力不够强的时候，先领着这份并非高薪但能满足基本生活的工资，在每天快速完成工作后，疯狂的自我成长。</p><p>直到有一天，你有实力找到一份工资更高、价值更大的工作。如果一份工作收入可观，工作价值也可以，但每天忙得要死，没有时间让你持续有增量成长，你就要小心了。因为你虽然现在月薪1万，但没有成长的话你明年、后年可能还是月薪1万，更没机会升职。<strong>一份工作，增长性是最重要的，不要让自己混成一颗钉在一个位置上的零件。</strong>如果一份工作本身价值不够，钱又不多，还每天忙得要死，根本没时间成长，你就很危险了。你很可能会长期在最基层工作很难跳脱，甚至久而久之，你习惯了那状态，丧失了成长的能力。<strong>一个人不怕现状不好，怕的是习惯了，心死了，这是废掉一个人最隐蔽的方式。</strong></p><p>成长这件事，一定是贯穿整个职业生涯的，甚至是一辈子的事。任何时候，都不能让自己忙到连成长的时间都没有，你现在再强，如果你的成长是停滞的，你也很快被别人淘汰。因为别人在成长。</p><p>要有增量思维，持续有增量成长，而不是一直消耗存量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;废掉一个人最隐蔽的方式是让他忙到没时间成长&quot;&gt;&lt;a href=&quot;#废掉一个人最隐蔽的方式是让他忙到没时间成长&quot; class=&quot;headerlink&quot; title=&quot;废掉一个人最隐蔽的方式是让他忙到没时间成长&quot;&gt;&lt;/a&gt;废掉一个人最隐蔽的方式是让他忙到没时间成长&lt;/h1&gt;&lt;p&gt;大家可能都看过一个观点：废掉一个人最快的方式，就是让他闲着。我认同么？非常认同。但我今天想讲另一个角度，&lt;strong&gt;废掉一个人最隐蔽的方式，是让他忙到没时间成长。&lt;/strong&gt;而且我认为这个点更重要。因为大部分人都不闲，大家都在努力的过活，北上广深等大城市的年轻人，尤其是互联网从业者，不仅不闲，还每天忙得要死，甚至周末都不休息。这样一群人，我根本不怕他们太闲，我更怕他们太忙，尤其是怕他们忙到没时间成长。&lt;br&gt;
    
    </summary>
    
      <category term="美文" scheme="http://swenfang.github.io/categories/%E7%BE%8E%E6%96%87/"/>
    
    
      <category term="美文" scheme="http://swenfang.github.io/tags/%E7%BE%8E%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Future 任务机制和 FutureTask</title>
    <link href="http://swenfang.github.io/2019/03/23/Future%20%E4%BB%BB%E5%8A%A1%E6%9C%BA%E5%88%B6%E5%92%8C%20FutureTask/"/>
    <id>http://swenfang.github.io/2019/03/23/Future 任务机制和 FutureTask/</id>
    <published>2019-03-23T15:31:37.276Z</published>
    <updated>2019-03-23T15:33:12.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Future-任务机制和-FutureTask"><a href="#Future-任务机制和-FutureTask" class="headerlink" title="Future 任务机制和 FutureTask"></a>Future 任务机制和 FutureTask</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天在完成功能的时候，使用到 Future 在这里记录一下，自己所了解的到知识，希望可以帮到需要的朋友。<br><a id="more"></a></p><h2 id="Future-类"><a href="#Future-类" class="headerlink" title="Future 类"></a>Future 类</h2><p>Future 类就是对于具体的 Runnable 或者 Callable 任务的执行结果进行取消、查询是否已经完成、获取结果。必要时可以通过 get 方法获取执行结果，该方法会阻塞直到任务返回结果。Future 位于 java.util.concurren 包下，它也是一个接口，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 用来取消任务,如果取消任务成功，则返回 true，失败则返回 false 。参数 mayInterrypIfRunning      </div><div class="line">     * 表示是否允许取消正在执行却没有执行完毕的任务，如果设置 true ，则表示可以取消正在执行中的任务 。</div><div class="line">     * 如果任务已经完成，则无论 mayInterruptIfRunning 为 ture 还是 false ，都返回 false，即如果</div><div class="line">     * 取消已经完成的任务会返回 false ；如果任务正在执行，若 mayInterrupIfRunning 设置为 true 则</div><div class="line">     * 返回 true ，设置为 false 则返回 false；如果任务还没有执行，都返回false。</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 表示任务是否已经完成，若任务完成则返回 true</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回。</div><div class="line">     */</div><div class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException,ExecutionException</span>;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 用来获取执行结果，如果在指定时间内，还没有获取到返回结果，就直接返回 null</div><div class="line">     */</div><div class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout,TimeUnit unit)</span> </span></div><div class="line">        <span class="keyword">throws</span> InterruptedException,ExecutionException,TimeoutException;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>也就是说 Future 提供了三种功能：</p><ul><li>判断任务是否完成。</li><li>能够中断任务。</li><li>能够获取任务执行结果。</li></ul><h2 id="FutureTask-类"><a href="#FutureTask-类" class="headerlink" title="FutureTask 类"></a>FutureTask 类</h2><p>因为 Future 只是一个接口，所以无法直接用来创建对象使用的，因此就有了 FutureTask 。</p><p>FutureTask 目前是 Future 接口的一个唯一实现类：</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190128111337-690350.jpg" alt=""></p><p> FutureTask 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>RunableFuture 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看出 RunnableFuture 继承了 Runnable 和 Future 接口，而 FutureTask  实现了 RunnableFuture 接口。所以 FutureTask 既可以作为 Runnable 被线程执行，又可以作为 Future 得到 Callable 的返回值。</p><p>FutureTask 提供了2个构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个 FutureTask ，一旦运行就执行给定的 Callable</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">this</span>.callable = callable;</div><div class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 创建一个 FutureTask ，一旦运行就执行给定的 Runnable ，并安排成功时 get 返回给定的结果。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</div><div class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>在实际工作中，可能需要统计各种类型的报表呈现结果，可能一个大的报表需要依赖很多很小的模块的运算结果，一个线程做可能比较慢，就可拆分成 N 多个小线程，然后将结果合并起来作为大的报表呈现结果。Fork/Join 就是基于 Future 实现的</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Future-任务机制和-FutureTask&quot;&gt;&lt;a href=&quot;#Future-任务机制和-FutureTask&quot; class=&quot;headerlink&quot; title=&quot;Future 任务机制和 FutureTask&quot;&gt;&lt;/a&gt;Future 任务机制和 FutureTask&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天在完成功能的时候，使用到 Future 在这里记录一下，自己所了解的到知识，希望可以帮到需要的朋友。&lt;br&gt;
    
    </summary>
    
      <category term="多线程" scheme="http://swenfang.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://swenfang.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>lucene搜索之拼写检查和相似度查询提示（spellcheck）</title>
    <link href="http://swenfang.github.io/2019/03/16/Lucene/9%E3%80%81lucene%E6%90%9C%E7%B4%A2%E4%B9%8B%E6%8B%BC%E5%86%99%E6%A3%80%E6%9F%A5%E5%92%8C%E7%9B%B8%E4%BC%BC%E5%BA%A6%E6%9F%A5%E8%AF%A2%E6%8F%90%E7%A4%BA%EF%BC%88spellcheck%EF%BC%89/"/>
    <id>http://swenfang.github.io/2019/03/16/Lucene/9、lucene搜索之拼写检查和相似度查询提示（spellcheck）/</id>
    <published>2019-03-16T01:53:14.279Z</published>
    <updated>2019-03-16T03:33:21.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lucene（9）—lucene搜索之拼写检查和相似度查询提示（spellcheck）"><a href="#lucene（9）—lucene搜索之拼写检查和相似度查询提示（spellcheck）" class="headerlink" title="lucene（9）—lucene搜索之拼写检查和相似度查询提示（spellcheck）"></a>lucene（9）—lucene搜索之拼写检查和相似度查询提示（spellcheck）</h1><h2 id="suggest应用场景"><a href="#suggest应用场景" class="headerlink" title="suggest应用场景"></a>suggest应用场景</h2><p>用户的输入行为是不确定的，而我们在写程序的时候总是想让用户按照指定的内容或指定格式的内容进行搜索，这里就要进行人工干预用户输入的搜索条件了；我们在用百度谷歌等搜索引擎的时候经常会看到按键放下的时候直接会提示用户是否想搜索某些相关的内容，恰好lucene在开发的时候想到了这一点，lucene提供的suggest包正是用来解决上述问题的。</p><a id="more"></a><p>suggest包联想词相关介绍<br>suggest包提供了lucene的自动补全或者拼写检查的支持；</p><p>拼写检查相关的类在org.apache.lucene.search.spell包下；</p><p>联想相关的在org.apache.lucene.search.suggest包下；</p><p>基于联想词分词相关的类在org.apache.lucene.search.suggest.analyzing包下；</p><h2 id="拼写检查原理"><a href="#拼写检查原理" class="headerlink" title="拼写检查原理"></a>拼写检查原理</h2><p>Lucene的拼写检查由org.apache.lucene.search.spell.SpellChecker类提供支持；<br>SpellChecker设置了默认精度0.5，如果我们需要细粒度的支持可以通过调用setAccuracy(float accuracy)来设定；<br>spellChecker会将外部来源的词进行索引；<br>这些来源包括：</p><pre><code>DocumentDictionary查询document中的field对应的值；FileDictionary基于一个文本文件的Directionary,每行一项，词组之间以&quot;\t&quot; TAB分隔符进行，每项中不能含有两个以上的分隔符；HighFrequencyDictionary从原有的索引文件中读取某个term的值，并按照出现次数检查；LuceneDictionary也是从原有索引文件中读取某个term的值，但是不检查出现次数；PlainTextDictionary从文本中读取内容，按行读取，没有分隔符；</code></pre><p> 其索引的原理如下：</p><p>对索引过程加syschronized同步；<br>检查Spellchecker是否已经关闭，如果关闭，抛出异常，提示内容为：Spellchecker has been closed；<br>对外部来源的索引进行遍历，统计被遍历的词的长度，如果长度小于三，忽略该词，反之构建document对象并索引到本地文件，创建索引的时候会对每个单词进行详细拆分（对应addGram方法），其执行过程如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">- Indexes the data from the given &#123;<span class="doctag">@link</span> Dictionary&#125;.</div><div class="line">- <span class="doctag">@param</span> dict Dictionary to index</div><div class="line">- <span class="doctag">@param</span> config &#123;<span class="doctag">@link</span> IndexWriterConfig&#125; to use</div><div class="line">- <span class="doctag">@param</span> fullMerge whether or not the spellcheck index should be fully merged</div><div class="line">- <span class="doctag">@throws</span> AlreadyClosedException if the Spellchecker is already closed</div><div class="line">- <span class="doctag">@throws</span> IOException If there is a low-level I/O error.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">indexDictionary</span><span class="params">(Dictionary dict, IndexWriterConfig config, <span class="keyword">boolean</span> fullMerge)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"><span class="keyword">synchronized</span> (modifyCurrentIndexLock) &#123;</div><div class="line">  ensureOpen();</div><div class="line">  <span class="keyword">final</span> Directory dir = <span class="keyword">this</span>.spellIndex;</div><div class="line">  <span class="keyword">final</span> IndexWriter writer = <span class="keyword">new</span> IndexWriter(dir, config);</div><div class="line">  IndexSearcher indexSearcher = obtainSearcher();</div><div class="line">  <span class="keyword">final</span> List&lt;TermsEnum&gt; termsEnums = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"> </div><div class="line">  <span class="keyword">final</span> IndexReader reader = searcher.getIndexReader();</div><div class="line">  <span class="keyword">if</span> (reader.maxDoc() &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> LeafReaderContext ctx : reader.leaves()) &#123;</div><div class="line">      Terms terms = ctx.reader().terms(F_WORD);</div><div class="line">      <span class="keyword">if</span> (terms != <span class="keyword">null</span>)</div><div class="line">        termsEnums.add(terms.iterator(<span class="keyword">null</span>));</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">boolean</span> isEmpty = termsEnums.isEmpty();</div><div class="line"> </div><div class="line">  <span class="keyword">try</span> &#123; </div><div class="line">    BytesRefIterator iter = dict.getEntryIterator();</div><div class="line">    BytesRef currentTerm;</div><div class="line">    </div><div class="line">    terms: <span class="keyword">while</span> ((currentTerm = iter.next()) != <span class="keyword">null</span>) &#123;</div><div class="line">  </div><div class="line">      String word = currentTerm.utf8ToString();</div><div class="line">      <span class="keyword">int</span> len = word.length();</div><div class="line">      <span class="keyword">if</span> (len &lt; <span class="number">3</span>) &#123;</div><div class="line">        <span class="keyword">continue</span>; <span class="comment">// too short we bail but "too long" is fine...</span></div><div class="line">      &#125;</div><div class="line">  </div><div class="line">      <span class="keyword">if</span> (!isEmpty) &#123;</div><div class="line">        <span class="keyword">for</span> (TermsEnum te : termsEnums) &#123;</div><div class="line">          <span class="keyword">if</span> (te.seekExact(currentTerm)) &#123;</div><div class="line">            <span class="keyword">continue</span> terms;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">  </div><div class="line">      <span class="comment">// ok index the word</span></div><div class="line">      Document doc = createDocument(word, getMin(len), getMax(len));</div><div class="line">      writer.addDocument(doc);</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    releaseSearcher(indexSearcher);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (fullMerge) &#123;</div><div class="line">    writer.forceMerge(<span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// close writer</span></div><div class="line">  writer.close();</div><div class="line">  <span class="comment">// <span class="doctag">TODO:</span> this isn't that great, maybe in the future SpellChecker should take</span></div><div class="line">  <span class="comment">// IWC in its ctor / keep its writer open?</span></div><div class="line">  </div><div class="line">  <span class="comment">// also re-open the spell index to see our own changes when the next suggestion</span></div><div class="line">  <span class="comment">// is fetched:</span></div><div class="line">  swapSearcher(dir);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>  对词语进行遍历拆分的方法为addGram,其实现为：</p><p> <img src="http://blogimg.nos-eastchina1.126.net/shenwf20190316104850-311058.jpg" alt=""></p><p>查看代码可知，联想词的索引不仅关注每个词的起始位置，也关注其倒数的位置；</p><p>联想词查询的时候，先判断grams里边是否包含有待查询的词拆分后的内容，如果有放到结果SuggestWordQueue中，最终结果为遍历SuggestWordQueue得来的String[],其代码实现如下：<br>​     </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> String[] suggestSimilar(String word, <span class="keyword">int</span> numSug, IndexReader ir,String field, SuggestMode suggestMode, <span class="keyword">float</span> accuracy) <span class="keyword">throws</span> IOException &#123;</div><div class="line">  <span class="comment">// obtainSearcher calls ensureOpen</span></div><div class="line">  <span class="keyword">final</span> IndexSearcher indexSearcher = obtainSearcher();</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">   <span class="keyword">if</span> (ir == <span class="keyword">null</span> || field == <span class="keyword">null</span>) &#123;</div><div class="line">   suggestMode = SuggestMode.SUGGEST_ALWAYS;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (suggestMode == SuggestMode.SUGGEST_ALWAYS) &#123;</div><div class="line">     ir = <span class="keyword">null</span>;</div><div class="line">     field = <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> lengthWord = word.length();</div><div class="line"> <span class="keyword">final</span> <span class="keyword">int</span> freq = (ir != <span class="keyword">null</span> &amp;&amp; field != <span class="keyword">null</span>) ? ir.docFreq(<span class="keyword">new</span> Term(field, word)) : <span class="number">0</span>;</div><div class="line"> <span class="keyword">final</span> <span class="keyword">int</span> goalFreq = suggestMode==SuggestMode.SUGGEST_MORE_POPULAR ? freq : <span class="number">0</span>;</div><div class="line"> <span class="comment">// if the word exists in the real index and we don't care for word frequency, return the word itself</span></div><div class="line"> <span class="keyword">if</span> (suggestMode==SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX &amp;&amp; freq &gt; <span class="number">0</span>) &#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123; word &#125;;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> BooleanQuery query = <span class="keyword">new</span> BooleanQuery();</div><div class="line"> String[] grams;</div><div class="line"> String key;</div><div class="line"></div><div class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> ng = getMin(lengthWord); ng &lt;= getMax(lengthWord); ng++) &#123;</div><div class="line"></div><div class="line">   key = <span class="string">"gram"</span> + ng; <span class="comment">// form key</span></div><div class="line"></div><div class="line">   grams = formGrams(word, ng); <span class="comment">// form word into ngrams (allow dups too)</span></div><div class="line"></div><div class="line">   <span class="keyword">if</span> (grams.length == <span class="number">0</span>) &#123;</div><div class="line">     <span class="keyword">continue</span>; <span class="comment">// hmm</span></div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">if</span> (bStart &gt; <span class="number">0</span>) &#123; <span class="comment">// should we boost prefixes?</span></div><div class="line">     add(query, <span class="string">"start"</span> + ng, grams[<span class="number">0</span>], bStart); <span class="comment">// matches start of word</span></div><div class="line"></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (bEnd &gt; <span class="number">0</span>) &#123; <span class="comment">// should we boost suffixes</span></div><div class="line">     add(query, <span class="string">"end"</span> + ng, grams[grams.length - <span class="number">1</span>], bEnd); <span class="comment">// matches end of word</span></div><div class="line"></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grams.length; i++) &#123;</div><div class="line">     add(query, key, grams[i]);</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="keyword">int</span> maxHits = <span class="number">10</span> * numSug;</div><div class="line"> <span class="comment">//    System.out.println("Q: " + query);</span></div><div class="line"> ScoreDoc[] hits = indexSearcher.search(query, maxHits).scoreDocs;</div><div class="line"> <span class="comment">//    System.out.println("HITS: " + hits.length());</span></div><div class="line"> SuggestWordQueue sugQueue = <span class="keyword">new</span> SuggestWordQueue(numSug, comparator);</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">// go thru more than 'maxr' matches in case the distance filter triggers</span></div><div class="line">  <span class="keyword">int</span> stop = Math.min(hits.length, maxHits);</div><div class="line">  SuggestWord sugWord = <span class="keyword">new</span> SuggestWord();</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stop; i++) &#123;</div><div class="line"> </div><div class="line">    sugWord.string = indexSearcher.doc(hits[i].doc).get(F_WORD); <span class="comment">// get orig word</span></div><div class="line"> </div><div class="line">    <span class="comment">// don't suggest a word for itself, that would be silly</span></div><div class="line">    <span class="keyword">if</span> (sugWord.string.equals(word)) &#123;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">// edit distance</span></div><div class="line">    sugWord.score = sd.getDistance(word,sugWord.string);</div><div class="line">    <span class="keyword">if</span> (sugWord.score &lt; accuracy) &#123;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> (ir != <span class="keyword">null</span> &amp;&amp; field != <span class="keyword">null</span>) &#123; <span class="comment">// use the user index</span></div><div class="line">      sugWord.freq = ir.docFreq(<span class="keyword">new</span> Term(field, sugWord.string)); <span class="comment">// freq in the index</span></div><div class="line">      <span class="comment">// don't suggest a word that is not present in the field</span></div><div class="line">      <span class="keyword">if</span> ((suggestMode==SuggestMode.SUGGEST_MORE_POPULAR &amp;&amp; goalFreq &gt; sugWord.freq) || sugWord.freq &lt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    sugQueue.insertWithOverflow(sugWord);</div><div class="line">    <span class="keyword">if</span> (sugQueue.size() == numSug) &#123;</div><div class="line">      <span class="comment">// if queue full, maintain the minScore score</span></div><div class="line">      accuracy = sugQueue.top().score;</div><div class="line">    &#125;</div><div class="line">    sugWord = <span class="keyword">new</span> SuggestWord();</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="comment">// convert to array string</span></div><div class="line">  String[] list = <span class="keyword">new</span> String[sugQueue.size()];</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = sugQueue.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">    list[i] = sugQueue.pop().string;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> list;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">  releaseSearcher(indexSearcher);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="编程实践"><a href="#编程实践" class="headerlink" title="编程实践"></a>编程实践</h2><p>以下是我根据FileDirectory相关描述编写的一个测试程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.lucene.search;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">import</span> java.io.FileInputStream;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.nio.file.Paths;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.Analyzer;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexWriterConfig;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexWriterConfig.OpenMode;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.spell.SpellChecker;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.suggest.FileDictionary;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.store.Directory;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.store.FSDirectory;</div><div class="line"><span class="keyword">import</span> org.wltea.analyzer.lucene.IKAnalyzer;</div><div class="line"> </div><div class="line"> </div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuggestUtil</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Directory spellIndexDirectory;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">spellIndexDirectory = FSDirectory.open(Paths.get(<span class="string">"suggest"</span>, <span class="keyword">new</span> String[<span class="number">0</span>]));</div><div class="line"></div><div class="line">SpellChecker spellchecker = <span class="keyword">new</span> SpellChecker(spellIndexDirectory );</div><div class="line">Analyzer analyzer = <span class="keyword">new</span> IKAnalyzer(<span class="keyword">true</span>);</div><div class="line">IndexWriterConfig config = <span class="keyword">new</span> IndexWriterConfig(analyzer);</div><div class="line">config.setOpenMode(OpenMode.CREATE_OR_APPEND);</div><div class="line">spellchecker.setAccuracy(<span class="number">0f</span>);</div><div class="line"><span class="comment">//HighFrequencyDictionary dire = new HighFrequencyDictionary(reader, field, thresh)</span></div><div class="line">spellchecker.indexDictionary(<span class="keyword">new</span> FileDictionary(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"D:\\hadoop\\lucene_suggest\\src\\suggest.txt"</span>))),config,<span class="keyword">false</span>);</div><div class="line">String[] similars = spellchecker.suggestSimilar(<span class="string">"中国"</span>, <span class="number">10</span>);</div><div class="line"><span class="keyword">for</span> (String similar : similars) &#123;</div><div class="line">System.out.println(similar);</div><div class="line">&#125;</div><div class="line">spellIndexDirectory.close();</div><div class="line">spellchecker.close();</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line"></div><div class="line"> </div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中，我用的suggest.txt内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">中国人民100</div><div class="line">奔驰3101</div><div class="line">奔驰中国102</div><div class="line">奔驰S级103</div><div class="line">奔驰A级104</div><div class="line">奔驰C级105</div></pre></td></tr></table></figure><p>测试结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">中国人民</div><div class="line">奔驰中国</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lucene（9）—lucene搜索之拼写检查和相似度查询提示（spellcheck）&quot;&gt;&lt;a href=&quot;#lucene（9）—lucene搜索之拼写检查和相似度查询提示（spellcheck）&quot; class=&quot;headerlink&quot; title=&quot;lucene（9）—lucene搜索之拼写检查和相似度查询提示（spellcheck）&quot;&gt;&lt;/a&gt;lucene（9）—lucene搜索之拼写检查和相似度查询提示（spellcheck）&lt;/h1&gt;&lt;h2 id=&quot;suggest应用场景&quot;&gt;&lt;a href=&quot;#suggest应用场景&quot; class=&quot;headerlink&quot; title=&quot;suggest应用场景&quot;&gt;&lt;/a&gt;suggest应用场景&lt;/h2&gt;&lt;p&gt;用户的输入行为是不确定的，而我们在写程序的时候总是想让用户按照指定的内容或指定格式的内容进行搜索，这里就要进行人工干预用户输入的搜索条件了；我们在用百度谷歌等搜索引擎的时候经常会看到按键放下的时候直接会提示用户是否想搜索某些相关的内容，恰好lucene在开发的时候想到了这一点，lucene提供的suggest包正是用来解决上述问题的。&lt;/p&gt;
    
    </summary>
    
      <category term="lucene" scheme="http://swenfang.github.io/categories/lucene/"/>
    
    
      <category term="lucene" scheme="http://swenfang.github.io/tags/lucene/"/>
    
  </entry>
  
  <entry>
    <title>lucene搜索之索引的查询原理和查询工具类（支持分页）示例</title>
    <link href="http://swenfang.github.io/2019/03/16/Lucene/8%E3%80%81lucene%E6%90%9C%E7%B4%A2%E4%B9%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9F%A5%E8%AF%A2%E5%8E%9F%E7%90%86%E5%92%8C%E6%9F%A5%E8%AF%A2%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%88%E6%94%AF%E6%8C%81%E5%88%86%E9%A1%B5%EF%BC%89%E7%A4%BA%E4%BE%8B/"/>
    <id>http://swenfang.github.io/2019/03/16/Lucene/8、lucene搜索之索引的查询原理和查询工具类（支持分页）示例/</id>
    <published>2019-03-16T01:53:14.279Z</published>
    <updated>2019-03-16T03:33:14.196Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lucene（8）—lucene搜索之索引的查询原理和查询工具类（支持分页）示例"><a href="#lucene（8）—lucene搜索之索引的查询原理和查询工具类（支持分页）示例" class="headerlink" title="lucene（8）—lucene搜索之索引的查询原理和查询工具类（支持分页）示例"></a>lucene（8）—lucene搜索之索引的查询原理和查询工具类（支持分页）示例</h1><h2 id="IndexSearcher常用方法"><a href="#IndexSearcher常用方法" class="headerlink" title="IndexSearcher常用方法"></a>IndexSearcher常用方法</h2><p>IndexSearcher提供了几个常用的方法：</p><a id="more"></a><ul><li>IndexSearcher.doc(int docID)   获取索引文件中的第n个索引存储的相关字段，返回为Document类型，可以据此读取document中的Field.STORE.YES的字段；</li><li>IndexSearcher.doc(int docID, StoredFieldVisitor fieldVisitor)  获取StoredFieldVisitor指定的字段的document，StoredFieldVisitor定义如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">StoredFieldVisitor visitor = <span class="keyword">new</span> DocumentStoredFieldVisitor(String... fields);</div></pre></td></tr></table></figure><ul><li>IndexSearcher.doc(int docID, Set<string> fieldsToLoad) 此方法同上边的IndexSearcher.doc(int docID, StoredFieldVisitor fieldVisitor) ，其实现如下图</string></li></ul><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190316102208-992593.jpg" alt=""></p><ul><li><p>IndexSearcher.count(Query query) 统计符合query条件的document个数</p></li><li><p>IndexSearcher.searchAfter(final ScoreDoc after, Query query, int numHits) 此方法会返回符合query查询条件的且在after之后的numHits条记录；</p><p>其实现原理为：</p><p>先读取当前索引文件的最大数据条数limit，然后判断after是否为空和after对应的document的下标是否超出limit的限制，如果超出的话抛出非法的参数异常；</p><p>设置读取的条数为numHits和limit中最小的（因为有超出最大条数的可能，避免超出限制而造成的异常）</p><p>接下来创建一个CollectorManager类型的对象，该对象定义了要返回的TopDocs的个数，上一页的document的结尾（after）,并且对查询结果进行分析合并</p><p>最后调用search(query,manager)来查询结果</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190316104446-227930.jpg" alt=""></p></li><li><p>IndexSearcher.search(Query query, int n) 查询符合query条件的前n个记录</p></li><li>IndexSearcher.search(Query query, Collector results) 查询符合collector的记录，collector定义了分页等信息</li><li>IndexSearcher.search(Query query, int n,Sort sort, boolean doDocScores, boolean doMaxScore) 实现任意排序的查询，同时控制是否计算hit score和max score是否被计算在内，查询前n条符合query条件的document;</li><li><p>IndexSearcher.search(Query query, CollectorManager&lt;C, T&gt; collectorManager) 利用给定的collectorManager获取符合query条件的结果，其执行流程如下：</p><p>先判断是否有ExecutorService执行查询的任务，如果没有executor，IndexSearcher会在单个任务下进行查询操作；</p><p>如果IndexSearcher有executor，则会由每个线程控制一部分索引的读取，而且查询的过程中采用的是future机制，此种方式是边读边往结果集里边追加数据，这种异</p><p>步的处理机制也提升了效率，其执行过程如下：</p></li></ul><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190316104636-782439.jpg" alt=""></p><h2 id="编码实践"><a href="#编码实践" class="headerlink" title="编码实践"></a>编码实践</h2><p>我中午的时候写了一个SearchUtil的工具类，里边添加了多目录查询和分页查询的功能，经测试可用，工具类和测试的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.lucene.search.util;</div><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.nio.file.Paths;</div><div class="line"><span class="keyword">import</span> java.util.Set;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.Document;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.DirectoryReader;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexReader;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.MultiReader;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.BooleanQuery;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.IndexSearcher;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.Query;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.ScoreDoc;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.TopDocs;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.BooleanClause.Occur;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.store.FSDirectory;</div><div class="line"> </div><div class="line"><span class="comment">/**lucene索引查询工具类</span></div><div class="line"> * <span class="doctag">@author</span> lenovo</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchUtil</span> </span>&#123;</div><div class="line"><span class="comment">/**获取IndexSearcher对象</span></div><div class="line"> * <span class="doctag">@param</span> indexPath</div><div class="line"> * <span class="doctag">@param</span> service</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> * <span class="doctag">@throws</span> IOException</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IndexSearcher <span class="title">getIndexSearcherByParentPath</span><span class="params">(String parentPath,ExecutorService service)</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">MultiReader reader = <span class="keyword">null</span>;</div><div class="line"><span class="comment">//设置</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">File[] files = <span class="keyword">new</span> File(parentPath).listFiles();</div><div class="line">IndexReader[] readers = <span class="keyword">new</span> IndexReader[files.length];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; files.length ; i ++) &#123;</div><div class="line">readers[i] = DirectoryReader.open(FSDirectory.open(Paths.get(files[i].getPath(), <span class="keyword">new</span> String[<span class="number">0</span>])));</div><div class="line">&#125;</div><div class="line">reader = <span class="keyword">new</span> MultiReader(readers);</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> IndexSearcher(reader,service);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">/**根据索引路径获取IndexReader</span></div><div class="line"> * <span class="doctag">@param</span> indexPath</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> * <span class="doctag">@throws</span> IOException</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DirectoryReader <span class="title">getIndexReader</span><span class="params">(String indexPath)</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line"><span class="keyword">return</span> DirectoryReader.open(FSDirectory.open(Paths.get(indexPath, <span class="keyword">new</span> String[<span class="number">0</span>])));</div><div class="line">&#125;</div><div class="line"><span class="comment">/**根据索引路径获取IndexSearcher</span></div><div class="line"> * <span class="doctag">@param</span> indexPath</div><div class="line"> * <span class="doctag">@param</span> service</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> * <span class="doctag">@throws</span> IOException</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IndexSearcher <span class="title">getIndexSearcherByIndexPath</span><span class="params">(String indexPath,ExecutorService service)</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">IndexReader reader = getIndexReader(indexPath);</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> IndexSearcher(reader,service);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**如果索引目录会有变更用此方法获取新的IndexSearcher这种方式会占用较少的资源</span></div><div class="line"> * <span class="doctag">@param</span> oldSearcher</div><div class="line"> * <span class="doctag">@param</span> service</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> * <span class="doctag">@throws</span> IOException</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IndexSearcher <span class="title">getIndexSearcherOpenIfChanged</span><span class="params">(IndexSearcher oldSearcher,ExecutorService service)</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">DirectoryReader reader = (DirectoryReader) oldSearcher.getIndexReader();</div><div class="line">DirectoryReader newReader = DirectoryReader.openIfChanged(reader);</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> IndexSearcher(newReader, service);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**多条件查询类似于sql in</span></div><div class="line"> * <span class="doctag">@param</span> querys</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Query <span class="title">getMultiQueryLikeSqlIn</span><span class="params">(Query ... querys)</span></span>&#123;</div><div class="line">BooleanQuery query = <span class="keyword">new</span> BooleanQuery();</div><div class="line"><span class="keyword">for</span> (Query subQuery : querys) &#123;</div><div class="line">query.add(subQuery,Occur.SHOULD);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> query;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**多条件查询类似于sql and</span></div><div class="line"> * <span class="doctag">@param</span> querys</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Query <span class="title">getMultiQueryLikeSqlAnd</span><span class="params">(Query ... querys)</span></span>&#123;</div><div class="line">BooleanQuery query = <span class="keyword">new</span> BooleanQuery();</div><div class="line"><span class="keyword">for</span> (Query subQuery : querys) &#123;</div><div class="line">query.add(subQuery,Occur.MUST);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> query;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**根据IndexSearcher和docID获取默认的document</span></div><div class="line"> * <span class="doctag">@param</span> searcher</div><div class="line"> * <span class="doctag">@param</span> docID</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> * <span class="doctag">@throws</span> IOException</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Document <span class="title">getDefaultFullDocument</span><span class="params">(IndexSearcher searcher,<span class="keyword">int</span> docID)</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line"><span class="keyword">return</span> searcher.doc(docID);</div><div class="line">&#125;</div><div class="line"><span class="comment">/**根据IndexSearcher和docID</span></div><div class="line"> * <span class="doctag">@param</span> searcher</div><div class="line"> * <span class="doctag">@param</span> docID</div><div class="line"> * <span class="doctag">@param</span> listField</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> * <span class="doctag">@throws</span> IOException</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Document <span class="title">getDocumentByListField</span><span class="params">(IndexSearcher searcher,<span class="keyword">int</span> docID,Set&lt;String&gt; listField)</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line"><span class="keyword">return</span> searcher.doc(docID, listField);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**分页查询</span></div><div class="line"> * <span class="doctag">@param</span> page 当前页数</div><div class="line"> * <span class="doctag">@param</span> perPage 每页显示条数</div><div class="line"> * <span class="doctag">@param</span> searcher searcher查询器</div><div class="line"> * <span class="doctag">@param</span> query 查询条件</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> * <span class="doctag">@throws</span> IOException</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TopDocs <span class="title">getScoreDocsByPerPage</span><span class="params">(<span class="keyword">int</span> page,<span class="keyword">int</span> perPage,IndexSearcher searcher,Query query)</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">TopDocs result = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">if</span>(query == <span class="keyword">null</span>)&#123;</div><div class="line">System.out.println(<span class="string">" Query is null return null "</span>);</div><div class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line">ScoreDoc before = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">if</span>(page != <span class="number">1</span>)&#123;</div><div class="line">TopDocs docsBefore = searcher.search(query, (page-<span class="number">1</span>)*perPage);</div><div class="line">ScoreDoc[] scoreDocs = docsBefore.scoreDocs;</div><div class="line"><span class="keyword">if</span>(scoreDocs.length &gt; <span class="number">0</span>)&#123;</div><div class="line">before = scoreDocs[scoreDocs.length - <span class="number">1</span>];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">result = searcher.searchAfter(before, query, perPage);</div><div class="line"><span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TopDocs <span class="title">getScoreDocs</span><span class="params">(IndexSearcher searcher,Query query)</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">TopDocs docs = searcher.search(query, getMaxDocId(searcher));</div><div class="line"><span class="keyword">return</span> docs;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**统计document的数量,此方法等同于matchAllDocsQuery查询</span></div><div class="line"> * <span class="doctag">@param</span> searcher</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxDocId</span><span class="params">(IndexSearcher searcher)</span></span>&#123;</div><div class="line"><span class="keyword">return</span> searcher.getIndexReader().maxDoc();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>相关测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.lucene.index.test;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.HashSet;</div><div class="line"><span class="keyword">import</span> java.util.Set;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.Document;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.Term;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.IndexSearcher;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.Query;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.ScoreDoc;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.TermQuery;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.TopDocs;</div><div class="line"><span class="keyword">import</span> com.lucene.search.util.SearchUtil;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSearch</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">ExecutorService service = Executors.newCachedThreadPool();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">IndexSearcher searcher = SearchUtil.getIndexSearcherByParentPath(<span class="string">"index"</span>,service);</div><div class="line">System.out.println(SearchUtil.getMaxDocId(searcher));</div><div class="line">Term term = <span class="keyword">new</span> Term(<span class="string">"content"</span>, <span class="string">"lucene"</span>);</div><div class="line">Query query = <span class="keyword">new</span> TermQuery(term);</div><div class="line">TopDocs docs = SearchUtil.getScoreDocsByPerPage(<span class="number">2</span>, <span class="number">20</span>, searcher, query);</div><div class="line">ScoreDoc[] scoreDocs = docs.scoreDocs;</div><div class="line">System.out.println(<span class="string">"所有的数据总数为："</span>+docs.totalHits);</div><div class="line">System.out.println(<span class="string">"本页查询到的总数为："</span>+scoreDocs.length);</div><div class="line"><span class="keyword">for</span> (ScoreDoc scoreDoc : scoreDocs) &#123;</div><div class="line">Document doc = SearchUtil.getDefaultFullDocument(searcher, scoreDoc.doc);</div><div class="line"><span class="comment">//System.out.println(doc);</span></div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"\n\n"</span>);</div><div class="line">TopDocs docsAll = SearchUtil.getScoreDocs(searcher, query);</div><div class="line">Set&lt;String&gt; fieldSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</div><div class="line">fieldSet.add(<span class="string">"path"</span>);</div><div class="line">fieldSet.add(<span class="string">"modified"</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">20</span> ; i ++) &#123;</div><div class="line">Document doc = SearchUtil.getDocumentByListField(searcher, docsAll.scoreDocs[i].doc,fieldSet);</div><div class="line">System.out.println(doc);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125;<span class="keyword">finally</span>&#123;</div><div class="line">service.shutdownNow();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a>代码下载</h2><p>代码下载请点击<a href="http://download.csdn.net/detail/wuyinggui10000/8703067" target="_blank" rel="external">http://download.csdn.net/detail/wuyinggui10000/8703165</a>，运行时请先运行IndexTest类进行索引的创建~！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lucene（8）—lucene搜索之索引的查询原理和查询工具类（支持分页）示例&quot;&gt;&lt;a href=&quot;#lucene（8）—lucene搜索之索引的查询原理和查询工具类（支持分页）示例&quot; class=&quot;headerlink&quot; title=&quot;lucene（8）—lucene搜索之索引的查询原理和查询工具类（支持分页）示例&quot;&gt;&lt;/a&gt;lucene（8）—lucene搜索之索引的查询原理和查询工具类（支持分页）示例&lt;/h1&gt;&lt;h2 id=&quot;IndexSearcher常用方法&quot;&gt;&lt;a href=&quot;#IndexSearcher常用方法&quot; class=&quot;headerlink&quot; title=&quot;IndexSearcher常用方法&quot;&gt;&lt;/a&gt;IndexSearcher常用方法&lt;/h2&gt;&lt;p&gt;IndexSearcher提供了几个常用的方法：&lt;/p&gt;
    
    </summary>
    
      <category term="lucene" scheme="http://swenfang.github.io/categories/lucene/"/>
    
    
      <category term="lucene" scheme="http://swenfang.github.io/tags/lucene/"/>
    
  </entry>
  
  <entry>
    <title>lucene搜索之IndexSearcher构建过程</title>
    <link href="http://swenfang.github.io/2019/03/16/Lucene/7%E3%80%81lucene%E6%90%9C%E7%B4%A2%E4%B9%8BIndexSearcher%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
    <id>http://swenfang.github.io/2019/03/16/Lucene/7、lucene搜索之IndexSearcher构建过程/</id>
    <published>2019-03-16T01:53:14.269Z</published>
    <updated>2019-03-16T03:33:05.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lucene（7）—lucene搜索之IndexSearcher构建过程"><a href="#lucene（7）—lucene搜索之IndexSearcher构建过程" class="headerlink" title="lucene（7）—lucene搜索之IndexSearcher构建过程"></a>lucene（7）—lucene搜索之IndexSearcher构建过程</h1><h2 id="IndexSearcher"><a href="#IndexSearcher" class="headerlink" title="IndexSearcher"></a>IndexSearcher</h2><p>搜索引擎的构建分为索引内容和查询索引两个大方面，这里要介绍的是lucene索引查询器即IndexSearcher的构建过程；</p><a id="more"></a><p>首先了解下IndexSearcher：</p><ul><li>IndexSearcher提供了对单个IndexReader的查询实现；</li><li>我们对索引的查询，可以通过调用search(Query,n)或者search(Query,Filter,n)方法；</li><li>在索引内容变动不大的情况下，我们可以对索引的搜索采用单个IndexSearcher共享的方式来提升性能；</li><li>如果索引有变动，我们就需要使用DirectoryReader.openIfChanged(DirectoryReader)来获取新的reader，然后创建新的IndexSearcher对象；</li><li>为了使查询延迟率低，我们最好使用近实时搜索的方法（此时我们的DirectoryReader的构建就要采用<code>DirectoryReader.open(IndexWriter, boolean)</code>）</li><li>IndexSearcher实例是完全线程安全的,这意味着多个线程可以并发调用任何方法。如果需要外部同步,无需添加IndexSearcher的同步；</li></ul><h2 id="IndexSearcher的创建过程"><a href="#IndexSearcher的创建过程" class="headerlink" title="IndexSearcher的创建过程"></a>IndexSearcher的创建过程</h2><ul><li><p>根据索引文件路径创建FSDirectory的实例，返回的FSDirectory实例跟系统或运行环境有关，对于Linux, MacOSX, Solaris, and Windows 64-bit JREs返回的是一个MMapDirectory实例，对于其他非windows JREs环境返回的是NIOFSDirectory，而对于其他Windows的JRE环境返回的是SimpleFSDirectory，其执行效率依次降低</p></li><li><p>接着DirectoryReader根据获取到的FSDirectory实例读取索引文件并得到DirectoryReader对象；DirectoryReader的open方法返回实例的原理：读取索引目录中的Segments文件内容，倒序遍历SegmentInfos并填充到SegmentReader（IndexReader的一种实现）数组，并构建StandardDirectoryReader的实例</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190316101614-894853.jpg" alt=""></p></li><li><p>有了IndexReader，IndexSearcher对象实例化就手到拈来了，new IndexSearcher(DirectoryReader)就可以得到其实例；如果我们想提高IndexSearcher的执行效率可以new IndexSearcher(DirecotoryReader,ExcuterService)来创建IndexSearcher对象，这样做的好处为对每块segment采用了分工查询，但是要注意IndexSearcher并不维护ExcuterService的生命周期，我们还需要自行调用ExcuterService的close/awaitTermination</p></li></ul><h2 id="相关实践"><a href="#相关实践" class="headerlink" title="相关实践"></a>相关实践</h2><p>以下是根据IndexSearcher相关的构建过程及其特性编写的一个搜索的工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.lucene.search;</div><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.nio.file.Paths;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.Analyzer;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.standard.StandardAnalyzer;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.Document;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.DirectoryReader;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexReader;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.MultiReader;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.Term;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.BooleanClause.Occur;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.BooleanQuery;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.IndexSearcher;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.MatchAllDocsQuery;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.NumericRangeQuery;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.Query;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.ScoreDoc;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.Sort;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.SortField;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.SortField.Type;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.TermQuery;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.TopDocs;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.search.TopFieldCollector;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.store.FSDirectory;</div><div class="line"><span class="keyword">import</span> com.lucene.index.IndexUtil;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchUtil</span> </span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Analyzer analyzer = <span class="keyword">new</span> StandardAnalyzer();</div><div class="line"><span class="comment">/**获取IndexSearcher对象（适合单索引目录查询使用）</span></div><div class="line"> * <span class="doctag">@param</span> indexPath 索引目录</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> * <span class="doctag">@throws</span> IOException</div><div class="line"> * <span class="doctag">@throws</span> InterruptedException </div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IndexSearcher <span class="title">getIndexSearcher</span><span class="params">(String indexPath,ExecutorService service,<span class="keyword">boolean</span> realtime)</span> <span class="keyword">throws</span> IOException, InterruptedException</span>&#123;</div><div class="line">DirectoryReader reader = DirectoryReader.open(IndexUtil.getIndexWriter(indexPath, <span class="keyword">true</span>), realtime);</div><div class="line">IndexSearcher searcher = <span class="keyword">new</span> IndexSearcher(reader,service);</div><div class="line"><span class="keyword">if</span>(service != <span class="keyword">null</span>)&#123;</div><div class="line">service.shutdown();</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> searcher;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**多目录多线程查询</span></div><div class="line"> * <span class="doctag">@param</span> parentPath 父级索引目录</div><div class="line"> * <span class="doctag">@param</span> service 多线程查询</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> * <span class="doctag">@throws</span> IOException</div><div class="line"> * <span class="doctag">@throws</span> InterruptedException </div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IndexSearcher <span class="title">getMultiSearcher</span><span class="params">(String parentPath,ExecutorService service,<span class="keyword">boolean</span> realtime)</span> <span class="keyword">throws</span> IOException, InterruptedException</span>&#123;</div><div class="line">MultiReader multiReader;</div><div class="line">File file = <span class="keyword">new</span> File(parentPath);</div><div class="line">File[] files = file.listFiles();</div><div class="line">IndexReader[] readers = <span class="keyword">new</span> IndexReader[files.length];</div><div class="line"><span class="keyword">if</span>(!realtime)&#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; files.length ; i ++) &#123;</div><div class="line">readers[i] = DirectoryReader.open(FSDirectory.open(Paths.get(files[i].getPath(), <span class="keyword">new</span> String[<span class="number">0</span>])));</div><div class="line">&#125;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; files.length ; i ++) &#123;</div><div class="line">readers[i] = DirectoryReader.open(IndexUtil.getIndexWriter(files[i].getPath(), <span class="keyword">true</span>), <span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">multiReader = <span class="keyword">new</span> MultiReader(readers);</div><div class="line">IndexSearcher searcher = <span class="keyword">new</span> IndexSearcher(multiReader,service);</div><div class="line"><span class="keyword">if</span>(service != <span class="keyword">null</span>)&#123;</div><div class="line">service.shutdown();</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> searcher;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**从指定配置项中查询</span></div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> * <span class="doctag">@param</span> analyzer 分词器</div><div class="line"> * <span class="doctag">@param</span> field 字段</div><div class="line"> * <span class="doctag">@param</span> fieldType字段类型</div><div class="line"> * <span class="doctag">@param</span> queryStr 查询条件</div><div class="line"> * <span class="doctag">@param</span> range 是否区间查询</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Query <span class="title">getQuery</span><span class="params">(String field,String fieldType,String queryStr,<span class="keyword">boolean</span> range)</span></span>&#123;</div><div class="line">Query q = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">if</span>(queryStr != <span class="keyword">null</span> &amp;&amp; !<span class="string">""</span>.equals(queryStr))&#123;</div><div class="line"><span class="keyword">if</span>(range)&#123;</div><div class="line">String[] strs = queryStr.split(<span class="string">"\\|"</span>);</div><div class="line"><span class="keyword">if</span>(<span class="string">"int"</span>.equals(fieldType))&#123;</div><div class="line"><span class="keyword">int</span> min = <span class="keyword">new</span> Integer(strs[<span class="number">0</span>]);</div><div class="line"><span class="keyword">int</span> max = <span class="keyword">new</span> Integer(strs[<span class="number">1</span>]);</div><div class="line">q = NumericRangeQuery.newIntRange(field, min, max, <span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"double"</span>.equals(fieldType))&#123;</div><div class="line">Double min = <span class="keyword">new</span> Double(strs[<span class="number">0</span>]);</div><div class="line">Double max = <span class="keyword">new</span> Double(strs[<span class="number">1</span>]);</div><div class="line">q = NumericRangeQuery.newDoubleRange(field, min, max, <span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"float"</span>.equals(fieldType))&#123;</div><div class="line">Float min = <span class="keyword">new</span> Float(strs[<span class="number">0</span>]);</div><div class="line">Float max = <span class="keyword">new</span> Float(strs[<span class="number">1</span>]);</div><div class="line">q = NumericRangeQuery.newFloatRange(field, min, max, <span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"long"</span>.equals(fieldType))&#123;</div><div class="line">Long min = <span class="keyword">new</span> Long(strs[<span class="number">0</span>]);</div><div class="line">Long max = <span class="keyword">new</span> Long(strs[<span class="number">1</span>]);</div><div class="line">q = NumericRangeQuery.newLongRange(field, min, max, <span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line"><span class="keyword">if</span>(<span class="string">"int"</span>.equals(fieldType))&#123;</div><div class="line">q = NumericRangeQuery.newIntRange(field, <span class="keyword">new</span> Integer(queryStr), <span class="keyword">new</span> Integer(queryStr), <span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"double"</span>.equals(fieldType))&#123;</div><div class="line">q = NumericRangeQuery.newDoubleRange(field, <span class="keyword">new</span> Double(queryStr), <span class="keyword">new</span> Double(queryStr), <span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"float"</span>.equals(fieldType))&#123;</div><div class="line">q = NumericRangeQuery.newFloatRange(field, <span class="keyword">new</span> Float(queryStr), <span class="keyword">new</span> Float(queryStr), <span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">Term term = <span class="keyword">new</span> Term(field, queryStr);</div><div class="line">q = <span class="keyword">new</span> TermQuery(term);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">q= <span class="keyword">new</span> MatchAllDocsQuery();</div><div class="line">&#125;</div><div class="line"></div><div class="line">System.out.println(q);</div><div class="line"><span class="keyword">return</span> q;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**多条件查询类似于sql in</span></div><div class="line"> * <span class="doctag">@param</span> querys</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Query <span class="title">getMultiQueryLikeSqlIn</span><span class="params">(Query ... querys)</span></span>&#123;</div><div class="line">BooleanQuery query = <span class="keyword">new</span> BooleanQuery();</div><div class="line"><span class="keyword">for</span> (Query subQuery : querys) &#123;</div><div class="line">query.add(subQuery,Occur.SHOULD);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> query;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**多条件查询类似于sql and</span></div><div class="line"> * <span class="doctag">@param</span> querys</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Query <span class="title">getMultiQueryLikeSqlAnd</span><span class="params">(Query ... querys)</span></span>&#123;</div><div class="line">BooleanQuery query = <span class="keyword">new</span> BooleanQuery();</div><div class="line"><span class="keyword">for</span> (Query subQuery : querys) &#123;</div><div class="line">query.add(subQuery,Occur.MUST);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> query;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**对多个条件进行排序构建排序条件</span></div><div class="line"> * <span class="doctag">@param</span> fields</div><div class="line"> * <span class="doctag">@param</span> type</div><div class="line"> * <span class="doctag">@param</span> reverses</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sort <span class="title">getSortInfo</span><span class="params">(String[] fields,Type[] types,<span class="keyword">boolean</span>[] reverses)</span></span>&#123;</div><div class="line">SortField[] sortFields = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">int</span> fieldLength = fields.length;</div><div class="line"><span class="keyword">int</span> typeLength = types.length;</div><div class="line"><span class="keyword">int</span> reverLength = reverses.length;</div><div class="line"><span class="keyword">if</span>(!(fieldLength == typeLength) || !(fieldLength == reverLength))&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">sortFields = <span class="keyword">new</span> SortField[fields.length];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</div><div class="line">sortFields[i] = <span class="keyword">new</span> SortField(fields[i], types[i], reverses[i]);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> Sort(sortFields);</div><div class="line">&#125;</div><div class="line"><span class="comment">/**根据查询器、查询条件、每页数、排序条件进行查询</span></div><div class="line"> * <span class="doctag">@param</span> query 查询条件</div><div class="line"> * <span class="doctag">@param</span> first 起始值</div><div class="line"> * <span class="doctag">@param</span> max 最大值</div><div class="line"> * <span class="doctag">@param</span> sort 排序条件</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TopDocs <span class="title">getScoreDocsByPerPageAndSortField</span><span class="params">(IndexSearcher searcher,Query query, <span class="keyword">int</span> first,<span class="keyword">int</span> max, Sort sort)</span></span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="keyword">if</span>(query == <span class="keyword">null</span>)&#123;</div><div class="line">System.out.println(<span class="string">" Query is null return null "</span>);</div><div class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line">TopFieldCollector collector = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">if</span>(sort != <span class="keyword">null</span>)&#123;</div><div class="line">collector = TopFieldCollector.create(sort, first+max, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">sort = <span class="keyword">new</span> Sort(<span class="keyword">new</span> SortField[]&#123;<span class="keyword">new</span> SortField(<span class="string">"modified"</span>, SortField.Type.LONG)&#125;);</div><div class="line">collector = TopFieldCollector.create(sort, first+max, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line">searcher.search(query, collector);</div><div class="line"><span class="keyword">return</span> collector.topDocs(first, max);</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**获取上次索引的id,增量更新使用</span></div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">getLastIndexBeanID</span><span class="params">(IndexReader multiReader)</span></span>&#123;</div><div class="line">Query query = <span class="keyword">new</span> MatchAllDocsQuery();</div><div class="line">IndexSearcher searcher = <span class="keyword">null</span>;</div><div class="line">searcher = <span class="keyword">new</span> IndexSearcher(multiReader);</div><div class="line">SortField sortField = <span class="keyword">new</span> SortField(<span class="string">"id"</span>, SortField.Type.INT,<span class="keyword">true</span>);</div><div class="line">Sort sort = <span class="keyword">new</span> Sort(<span class="keyword">new</span> SortField[]&#123;sortField&#125;);</div><div class="line">TopDocs docs = getScoreDocsByPerPageAndSortField(searcher,query, <span class="number">0</span>, <span class="number">1</span>, sort);</div><div class="line">ScoreDoc[] scoreDocs = docs.scoreDocs;</div><div class="line"><span class="keyword">int</span> total = scoreDocs.length;</div><div class="line"><span class="keyword">if</span>(total &gt; <span class="number">0</span>)&#123;</div><div class="line">ScoreDoc scoreDoc = scoreDocs[<span class="number">0</span>];</div><div class="line">Document doc = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">doc = searcher.doc(scoreDoc.doc);</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> Integer(doc.get(<span class="string">"id"</span>));</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="相关代码下载"><a href="#相关代码下载" class="headerlink" title="相关代码下载"></a>相关代码下载</h2><p><a href="http://download.csdn.net/detail/wuyinggui10000/8697451" target="_blank" rel="external">http://download.csdn.net/detail/wuyinggui10000/8697451</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lucene（7）—lucene搜索之IndexSearcher构建过程&quot;&gt;&lt;a href=&quot;#lucene（7）—lucene搜索之IndexSearcher构建过程&quot; class=&quot;headerlink&quot; title=&quot;lucene（7）—lucene搜索之IndexSearcher构建过程&quot;&gt;&lt;/a&gt;lucene（7）—lucene搜索之IndexSearcher构建过程&lt;/h1&gt;&lt;h2 id=&quot;IndexSearcher&quot;&gt;&lt;a href=&quot;#IndexSearcher&quot; class=&quot;headerlink&quot; title=&quot;IndexSearcher&quot;&gt;&lt;/a&gt;IndexSearcher&lt;/h2&gt;&lt;p&gt;搜索引擎的构建分为索引内容和查询索引两个大方面，这里要介绍的是lucene索引查询器即IndexSearcher的构建过程；&lt;/p&gt;
    
    </summary>
    
      <category term="lucene" scheme="http://swenfang.github.io/categories/lucene/"/>
    
    
      <category term="lucene" scheme="http://swenfang.github.io/tags/lucene/"/>
    
  </entry>
  
  <entry>
    <title>lucene索引优化之多线程创建索引</title>
    <link href="http://swenfang.github.io/2019/03/16/Lucene/6%E3%80%81lucene%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95/"/>
    <id>http://swenfang.github.io/2019/03/16/Lucene/6、lucene索引优化之多线程创建索引/</id>
    <published>2019-03-16T01:53:14.259Z</published>
    <updated>2019-03-16T03:15:32.801Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lucene（6）—lucene索引优化之多线程创建索引"><a href="#lucene（6）—lucene索引优化之多线程创建索引" class="headerlink" title="lucene（6）—lucene索引优化之多线程创建索引"></a>lucene（6）—lucene索引优化之多线程创建索引</h1><p>前面了解到lucene在索引创建的时候一个IndexWriter获取到一个读写锁，这样势在lucene创建大数据量的索引的时候，执行效率低下的问题；</p><a id="more"></a><p>查看前面文档 lucene（5）—lucene的索引构建原理 可以看出，lucene索引的建立，跟以下几点关联很大；</p><ol><li>磁盘空间大小，这个直接影响索引的建立，甚至会造成索引写入提示完成，但是没有同步的问题；</li><li>索引合并策略的选择，这个类似于sql里边的批量操作，批量操作的数量过多直接影响执行效率，对于lucene来讲，索引合并前是将document放在内存中，因此选择合适的合并策略也可以提升索引的效率；</li><li>唯一索引对应的term的选择，lucene索引的创建过程中是先从索引中删除包含相同term的document然后重新添加document到索引中，这里如果term对应的document过多，会占用磁盘IO，同时造成IndexWriter的写锁占用时间延长，相应的执行效率低下；</li></ol><p>综上所述，索引优化要保证磁盘空间，同时在term选择上可以以ID等标识来确保唯一性，这样第一条和第三条的风险就规避了；</p><p>本文旨在对合并策略和采用多线程创建的方式提高索引的效率；</p><p>多线程创建索引，我这边还设计了多目录索引创建，这样避免了同一目录数据量过大索引块合并和索引块重新申请；</p><p>废话不多说，这里附上代码，代码示例是读取lucene官网下载并解压的文件夹并给文件信息索引起来</p><p>首先定义FileBean来存储文件信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.lucene.bean;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileBean</span> </span>&#123;</div><div class="line"><span class="comment">//路径</span></div><div class="line"><span class="keyword">private</span> String path;</div><div class="line"><span class="comment">//修改时间</span></div><div class="line"><span class="keyword">private</span> Long modified;</div><div class="line"><span class="comment">//内容</span></div><div class="line"><span class="keyword">private</span> String content;</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPath</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> path;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPath</span><span class="params">(String path)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.path = path;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">getModified</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> modified;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setModified</span><span class="params">(Long modified)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.modified = modified;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> content;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.content = content;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>接下来是一个工具类，用以将文件夹的信息遍历读取并转换成FileBean的集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.lucene.index.util;</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.nio.file.Files;</div><div class="line"><span class="keyword">import</span> java.nio.file.Paths;</div><div class="line"><span class="keyword">import</span> java.util.LinkedList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> com.lucene.bean.FileBean;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUtil</span> </span>&#123;</div><div class="line"> </div><div class="line"><span class="comment">/**读取文件信息和下属文件夹</span></div><div class="line"> * <span class="doctag">@param</span> folder</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> * <span class="doctag">@throws</span> IOException</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;FileBean&gt; <span class="title">getFolderFiles</span><span class="params">(String folder)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">List&lt;FileBean&gt; fileBeans = <span class="keyword">new</span> LinkedList&lt;FileBean&gt;();</div><div class="line">File file = <span class="keyword">new</span> File(folder);</div><div class="line"><span class="keyword">if</span>(file.isDirectory())&#123;</div><div class="line">File[] files = file.listFiles();</div><div class="line"><span class="keyword">if</span>(files != <span class="keyword">null</span>)&#123;</div><div class="line"><span class="keyword">for</span> (File file2 : files) &#123;</div><div class="line">fileBeans.addAll(getFolderFiles(file2.getAbsolutePath()));</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">FileBean bean = <span class="keyword">new</span> FileBean();</div><div class="line">bean.setPath(file.getAbsolutePath());</div><div class="line">bean.setModified(file.lastModified());</div><div class="line">bean.setContent(<span class="keyword">new</span> String(Files.readAllBytes(Paths.get(folder))));</div><div class="line">fileBeans.add(bean);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> fileBeans;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>定义一个公共的用于处理索引的类 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.lucene.index;</div><div class="line"> </div><div class="line"> </div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.text.ParseException;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexWriter;</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseIndex</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 父级索引路径</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> String parentIndexPath;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 索引编写器</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> IndexWriter writer;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> subIndex;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 主线程</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch countDownLatch1;  </div><div class="line"><span class="comment">/**</span></div><div class="line"> *工作线程 </div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch countDownLatch2; </div><div class="line"><span class="comment">/**</span></div><div class="line"> * 对象列表</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> List&lt;T&gt; list;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaseIndex</span><span class="params">(IndexWriter writer,CountDownLatch countDownLatch1, CountDownLatch countDownLatch2,</span></span></div><div class="line">List&lt;T&gt; list)&#123;</div><div class="line"><span class="keyword">super</span>();</div><div class="line"><span class="keyword">this</span>.writer = writer;</div><div class="line"><span class="keyword">this</span>.countDownLatch1 = countDownLatch1;</div><div class="line"><span class="keyword">this</span>.countDownLatch2 = countDownLatch2;</div><div class="line"><span class="keyword">this</span>.list = list;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaseIndex</span><span class="params">(String parentIndexPath, <span class="keyword">int</span> subIndex,</span></span></div><div class="line">CountDownLatch countDownLatch1, CountDownLatch countDownLatch2,</div><div class="line">List&lt;T&gt; list) &#123;</div><div class="line"><span class="keyword">super</span>();</div><div class="line"><span class="keyword">this</span>.parentIndexPath = parentIndexPath;</div><div class="line"><span class="keyword">this</span>.subIndex = subIndex;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="comment">//多目录索引创建</span></div><div class="line">File file = <span class="keyword">new</span> File(parentIndexPath+<span class="string">"/index"</span>+subIndex);</div><div class="line"><span class="keyword">if</span>(!file.exists())&#123;</div><div class="line">file.mkdir();</div><div class="line">&#125;</div><div class="line"><span class="keyword">this</span>.writer = IndexUtil.getIndexWriter(parentIndexPath+<span class="string">"/index"</span>+subIndex, <span class="keyword">true</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125;;</div><div class="line"><span class="keyword">this</span>.subIndex = subIndex;</div><div class="line"><span class="keyword">this</span>.countDownLatch1 = countDownLatch1;</div><div class="line"><span class="keyword">this</span>.countDownLatch2 = countDownLatch2;</div><div class="line"><span class="keyword">this</span>.list = list;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaseIndex</span><span class="params">(String path,CountDownLatch countDownLatch1, CountDownLatch countDownLatch2,</span></span></div><div class="line">List&lt;T&gt; list) &#123;</div><div class="line"><span class="keyword">super</span>();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="comment">//单目录索引创建</span></div><div class="line">File file = <span class="keyword">new</span> File(path);</div><div class="line"><span class="keyword">if</span>(!file.exists())&#123;</div><div class="line">file.mkdir();</div><div class="line">&#125;</div><div class="line"><span class="keyword">this</span>.writer = IndexUtil.getIndexWriter(path,<span class="keyword">true</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125;;</div><div class="line"><span class="keyword">this</span>.countDownLatch1 = countDownLatch1;</div><div class="line"><span class="keyword">this</span>.countDownLatch2 = countDownLatch2;</div><div class="line"><span class="keyword">this</span>.list = list;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**创建索引</span></div><div class="line"> * <span class="doctag">@param</span> writer</div><div class="line"> * <span class="doctag">@param</span> carSource</div><div class="line"> * <span class="doctag">@param</span> create</div><div class="line"> * <span class="doctag">@throws</span> IOException </div><div class="line"> * <span class="doctag">@throws</span> ParseException </div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">indexDoc</span><span class="params">(IndexWriter writer,T t)</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line"><span class="comment">/**批量索引创建</span></div><div class="line"> * <span class="doctag">@param</span> writer</div><div class="line"> * <span class="doctag">@param</span> t</div><div class="line"> * <span class="doctag">@throws</span> Exception</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">indexDocs</span><span class="params">(IndexWriter writer,List&lt;T&gt; t)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line"><span class="keyword">for</span> (T t2 : t) &#123;</div><div class="line">indexDoc(writer,t2);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">countDownLatch1.await();</div><div class="line">System.out.println(writer);</div><div class="line">indexDocs(writer,list);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125;<span class="keyword">finally</span>&#123;</div><div class="line">countDownLatch2.countDown();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">writer.commit();</div><div class="line">writer.close();</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>FileBeanIndex类用于处理FileBean的索引创建 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.lucene.index;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.Document;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.Field;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.LongField;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.StringField;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.document.TextField;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexWriter;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexWriterConfig;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.Term;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> com.lucene.bean.FileBean;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileBeanIndex</span> <span class="keyword">extends</span> <span class="title">BaseIndex</span>&lt;<span class="title">FileBean</span>&gt;</span>&#123;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileBeanIndex</span><span class="params">(IndexWriter writer, CountDownLatch countDownLatch1,</span></span></div><div class="line">CountDownLatch countDownLatch2, List&lt;FileBean&gt; list) &#123;</div><div class="line"><span class="keyword">super</span>(writer, countDownLatch1, countDownLatch2, list);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileBeanIndex</span><span class="params">(String parentIndexPath, <span class="keyword">int</span> subIndex, CountDownLatch countDownLatch1,</span></span></div><div class="line">CountDownLatch countDownLatch2, List&lt;FileBean&gt; list) &#123;</div><div class="line"><span class="keyword">super</span>(parentIndexPath, subIndex, countDownLatch1, countDownLatch2, list);</div><div class="line">&#125;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">indexDoc</span><span class="params">(IndexWriter writer, FileBean t)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">Document doc = <span class="keyword">new</span> Document();</div><div class="line">System.out.println(t.getPath());</div><div class="line">doc.add(<span class="keyword">new</span> StringField(<span class="string">"path"</span>, t.getPath(), Field.Store.YES));</div><div class="line">doc.add(<span class="keyword">new</span> LongField(<span class="string">"modified"</span>, t.getModified(), Field.Store.YES));</div><div class="line">doc.add(<span class="keyword">new</span> TextField(<span class="string">"content"</span>, t.getContent(), Field.Store.YES));</div><div class="line"><span class="keyword">if</span> (writer.getConfig().getOpenMode() == IndexWriterConfig.OpenMode.CREATE)&#123;</div><div class="line">        writer.addDocument(doc);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">    writer.updateDocument(<span class="keyword">new</span> Term(<span class="string">"path"</span>, t.getPath()), doc);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>IndexUtil工具类里边设置索引合并的策略 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.lucene.index;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.nio.file.Paths;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.Analyzer;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.standard.StandardAnalyzer;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexWriter;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexWriterConfig;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.LogByteSizeMergePolicy;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.LogMergePolicy;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.store.Directory;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.store.FSDirectory;</div><div class="line"> </div><div class="line"> </div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexUtil</span> </span>&#123;</div><div class="line"><span class="comment">/**创建索引写入器</span></div><div class="line"> * <span class="doctag">@param</span> indexPath</div><div class="line"> * <span class="doctag">@param</span> create</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> * <span class="doctag">@throws</span> IOException</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IndexWriter <span class="title">getIndexWriter</span><span class="params">(String indexPath,<span class="keyword">boolean</span> create)</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">Directory dir = FSDirectory.open(Paths.get(indexPath, <span class="keyword">new</span> String[<span class="number">0</span>]));</div><div class="line">    Analyzer analyzer = <span class="keyword">new</span> StandardAnalyzer();</div><div class="line">    IndexWriterConfig iwc = <span class="keyword">new</span> IndexWriterConfig(analyzer);</div><div class="line">    LogMergePolicy mergePolicy = <span class="keyword">new</span> LogByteSizeMergePolicy();</div><div class="line">    <span class="comment">//设置segment添加文档(Document)时的合并频率          //值较小,建立索引的速度就较慢          //值较大,建立索引的速度就较快,&gt;10适合批量建立索引        </span></div><div class="line">    mergePolicy.setMergeFactor(<span class="number">50</span>);                     </div><div class="line">    <span class="comment">//设置segment最大合并文档(Document)数         </span></div><div class="line">    <span class="comment">//值较小有利于追加索引的速度         </span></div><div class="line">    <span class="comment">//值较大,适合批量建立索引和更快的搜索         </span></div><div class="line">    mergePolicy.setMaxMergeDocs(<span class="number">5000</span>);                     </div><div class="line">    <span class="keyword">if</span> (create)&#123;</div><div class="line">        iwc.setOpenMode(IndexWriterConfig.OpenMode.CREATE);</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        iwc.setOpenMode(IndexWriterConfig.OpenMode.CREATE_OR_APPEND);</div><div class="line">    &#125;</div><div class="line">    IndexWriter writer = <span class="keyword">new</span> IndexWriter(dir, iwc);</div><div class="line">    <span class="keyword">return</span> writer;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>TestIndex类执行测试程序 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.lucene.index.test;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> org.apache.lucene.index.IndexWriter;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> com.lucene.bean.FileBean;</div><div class="line"><span class="keyword">import</span> com.lucene.index.FileBeanIndex;</div><div class="line"><span class="keyword">import</span> com.lucene.index.util.FileUtil;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIndex</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">List&lt;FileBean&gt; fileBeans = FileUtil.getFolderFiles(<span class="string">"C:\\Users\\lenovo\\Desktop\\lucene\\lucene-5.1.0"</span>);</div><div class="line"><span class="keyword">int</span> totalCount = fileBeans.size();</div><div class="line"><span class="keyword">int</span> perThreadCount = <span class="number">3000</span>;</div><div class="line">System.out.println(<span class="string">"查询到的数据总数是"</span>+fileBeans.size());</div><div class="line"><span class="keyword">int</span> threadCount = totalCount/perThreadCount + (totalCount%perThreadCount == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>);  </div><div class="line">ExecutorService pool = Executors.newFixedThreadPool(threadCount);  </div><div class="line">CountDownLatch countDownLatch1 = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);  </div><div class="line">CountDownLatch countDownLatch2 = <span class="keyword">new</span> CountDownLatch(threadCount);  </div><div class="line">System.out.println(fileBeans.size());</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123; </div><div class="line"><span class="keyword">int</span> start = i*perThreadCount;</div><div class="line"><span class="keyword">int</span> end = (i+<span class="number">1</span>) * perThreadCount &lt; totalCount ? (i+<span class="number">1</span>) * perThreadCount : totalCount;</div><div class="line">List&lt;FileBean&gt; subList = fileBeans.subList(start, end);</div><div class="line">Runnable runnable = <span class="keyword">new</span> FileBeanIndex(<span class="string">"index"</span>,i, countDownLatch1, countDownLatch2, subList);</div><div class="line"><span class="comment">//子线程交给线程池管理  </span></div><div class="line">pool.execute(runnable);  </div><div class="line">&#125;  </div><div class="line">countDownLatch1.countDown();  </div><div class="line">System.out.println(<span class="string">"开始创建索引"</span>);  </div><div class="line"><span class="comment">//等待所有线程都完成  </span></div><div class="line">countDownLatch2.await();  </div><div class="line"> <span class="comment">//线程全部完成工作  </span></div><div class="line">System.out.println(<span class="string">"所有线程都创建索引完毕"</span>);  </div><div class="line"><span class="comment">//释放线程池资源  </span></div><div class="line">pool.shutdown();  </div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>以上即是多线程多目录索引，大家有什么疑问的欢迎交流； </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lucene（6）—lucene索引优化之多线程创建索引&quot;&gt;&lt;a href=&quot;#lucene（6）—lucene索引优化之多线程创建索引&quot; class=&quot;headerlink&quot; title=&quot;lucene（6）—lucene索引优化之多线程创建索引&quot;&gt;&lt;/a&gt;lucene（6）—lucene索引优化之多线程创建索引&lt;/h1&gt;&lt;p&gt;前面了解到lucene在索引创建的时候一个IndexWriter获取到一个读写锁，这样势在lucene创建大数据量的索引的时候，执行效率低下的问题；&lt;/p&gt;
    
    </summary>
    
      <category term="lucene" scheme="http://swenfang.github.io/categories/lucene/"/>
    
    
      <category term="lucene" scheme="http://swenfang.github.io/tags/lucene/"/>
    
  </entry>
  
  <entry>
    <title>lucene的索引构建原理</title>
    <link href="http://swenfang.github.io/2019/03/16/Lucene/5%E3%80%81lucene%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA%E5%8E%9F%E7%90%86/"/>
    <id>http://swenfang.github.io/2019/03/16/Lucene/5、lucene索引构建原理/</id>
    <published>2019-03-16T01:53:14.249Z</published>
    <updated>2019-03-16T03:15:16.338Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lucene（5）—lucene的索引构建原理"><a href="#lucene（5）—lucene的索引构建原理" class="headerlink" title="lucene（5）—lucene的索引构建原理"></a>lucene（5）—lucene的索引构建原理</h1><h2 id="lucene创建索引的原理"><a href="#lucene创建索引的原理" class="headerlink" title="lucene创建索引的原理"></a>lucene创建索引的原理</h2><h3 id="IndexWriter的addDocument方法详解"><a href="#IndexWriter的addDocument方法详解" class="headerlink" title="IndexWriter的addDocument方法详解"></a>IndexWriter的addDocument方法详解</h3><p>今天看了IndexWriter类的addDocument方法，IndexWriter对此方法的说明如下：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Adds a document to this index. </div><div class="line">Note that if an Exception is hit (for example disk full) then the index will be consistent, but this document may not have been added. Furthermore, it&apos;s possible the index will have one segment in non-compound format even when using compound files (when a merge has partially succeeded).</div><div class="line">This method periodically flushes pending documents to the Directory (see above), and also periodically triggers segment merges in the index according to the MergePolicy in use.</div><div class="line">Merges temporarily consume space in the directory. The amount of space required is up to 1X the size of all segments being merged, when no readers/searchers are open against the index, and up to 2X the size of all segments being merged when readers/searchers are open against the index (see forceMerge(int) for details). The sequence of primitive merge operations performed is governed by the merge policy. </div><div class="line">Note that each term in the document can be no longer than MAX_TERM_LENGTH in bytes, otherwise an IllegalArgumentException will be thrown.</div></pre></td></tr></table></figure><p>大意如下：</p><p>此方法向索引中添加一个document；</p><p>需要注意的是如果执行过程中发生异常（比如磁盘空间不足）的时候索引会保持一致性，但是这个document也许并没有被添加，此外，即使使用符合文件也有可能索引包含一个非复合格式的segment（当合并索引有部分成功的时候）</p><p>此方法会定期的flush索引文件目录，并且会根据合并策略定期去触发索引文件中segment的合并操作；</p><p>刚方法会对合并临时的索引空间，当没有reader或者searcher读取或写入索引文件的时候所需要占用的磁盘空间至少要超过需要合并的segments文件的一倍，反之将会占用两倍以上的空间；序列的合并操作的优化取决于合并策略‘</p><p>要确保document中的每一个term占用的字节长度都不能超过MAX_TERM_LENGTH，否则会抛出IllegalArgumentException异常；</p><p>其实际的执行方法为：</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190316100523-767792.jpg" alt=""></p><p>继续跟进updateDocument方法，其实现如下</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190316100618-658422.jpg" alt=""></p><p>可以看见updateDocument是先从索引中删除包含相同term的document然后重新添加document到索引中；</p><p>此操作需要确保IndexWriter没有被关闭，其实现是先有<a href="https://blog.csdn.net/wuyinggui10000/article/details/45625351" target="_blank" rel="external">DocumentsWriter</a>类的updateDocument方法判断，这里先判断将根据term找到对应的document，并先放到待删除的document队列中，然后从队列中读取document，再将要flush的documents写入磁盘，同时更新flush队列中的索引状态；</p><p>相关源码如下</p><p><img src="http://blogimg.nos-eastchina1.126.net/shenwf20190316101101-308029.jpg" alt=""></p><p>在此期间有一个ThreadState类型的<a href="https://www.baidu.com/s?wd=%E8%AF%BB%E5%86%99%E9%94%81&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="external">读写锁</a>，lucene判断ThreadState的状态，如果此锁被激活，从内存中获取document并更新到索引文件且重置内存中索引的数量和状态，最后释放相关的资源。</p><p>此即为IndexWriter的索引构建过程，看代码<a href="https://www.baidu.com/s?wd=%E6%99%95%E5%A4%B4%E8%BD%AC%E5%90%91&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="external">晕头转向</a>的，以后为大家带来一点干货，明天带来lucene索引优化之多线程创建索引。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lucene（5）—lucene的索引构建原理&quot;&gt;&lt;a href=&quot;#lucene（5）—lucene的索引构建原理&quot; class=&quot;headerlink&quot; title=&quot;lucene（5）—lucene的索引构建原理&quot;&gt;&lt;/a&gt;lucene（5）—lucene的索引构建原理&lt;/h1&gt;&lt;h2 id=&quot;lucene创建索引的原理&quot;&gt;&lt;a href=&quot;#lucene创建索引的原理&quot; class=&quot;headerlink&quot; title=&quot;lucene创建索引的原理&quot;&gt;&lt;/a&gt;lucene创建索引的原理&lt;/h2&gt;&lt;h3 id=&quot;IndexWriter的addDocument方法详解&quot;&gt;&lt;a href=&quot;#IndexWriter的addDocument方法详解&quot; class=&quot;headerlink&quot; title=&quot;IndexWriter的addDocument方法详解&quot;&gt;&lt;/a&gt;IndexWriter的addDocument方法详解&lt;/h3&gt;&lt;p&gt;今天看了IndexWriter类的addDocument方法，IndexWriter对此方法的说明如下：&lt;/p&gt;
    
    </summary>
    
      <category term="lucene" scheme="http://swenfang.github.io/categories/lucene/"/>
    
    
      <category term="lucene" scheme="http://swenfang.github.io/tags/lucene/"/>
    
  </entry>
  
  <entry>
    <title>lucene的中文分词器jcseg和IKAnalyzer分词器及其使用说明</title>
    <link href="http://swenfang.github.io/2019/03/16/Lucene/4%E3%80%81lucene%E7%9A%84%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E5%99%A8jcseg%E5%92%8CIK%20Analyzer%E5%88%86%E8%AF%8D%E5%99%A8%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <id>http://swenfang.github.io/2019/03/16/Lucene/4、lucene的中文分词器jcseg和IK Analyzer分词器及其使用说明/</id>
    <published>2019-03-16T01:53:14.239Z</published>
    <updated>2019-03-16T03:14:59.541Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lucene（4）—lucene的中文分词器jcseg和IK-Analyzer分词器及其使用说明"><a href="#lucene（4）—lucene的中文分词器jcseg和IK-Analyzer分词器及其使用说明" class="headerlink" title="lucene（4）—lucene的中文分词器jcseg和IK Analyzer分词器及其使用说明"></a>lucene（4）—lucene的中文分词器jcseg和IK Analyzer分词器及其使用说明</h1><h2 id="为什么要使用lucene中文分词器"><a href="#为什么要使用lucene中文分词器" class="headerlink" title="为什么要使用lucene中文分词器"></a>为什么要使用lucene中文分词器</h2><p>在lucene的开发过程中，我们常会遇到分词时中文识别的问题，lucene提供了</p><p>lucene-analyzers-common-5.0.0.jar包来支持分词，但多的是对英国，法国，意大利等过语言的支持，</p><p>因此我们需要引入中文分词的概念。</p><a id="more"></a><h2 id="各种中文分词器及其对比"><a href="#各种中文分词器及其对比" class="headerlink" title="各种中文分词器及其对比"></a>各种中文分词器及其对比</h2><h3 id="jcseg中文分词器"><a href="#jcseg中文分词器" class="headerlink" title="jcseg中文分词器"></a>jcseg中文分词器</h3><p>jcseg是使用Java开发的一款开源的中文分词器, 使用mmseg算法. 分词准确率高达<br>98.4%, 支持中文人名识别, 同义词匹配, 停止词过滤…</p><p>jcseg支持三种切分模式：<br>(1).简易模式：FMM算法，适合速度要求场合。<br>(2).复杂模式-MMSEG四种过滤算法，具有较高的岐义去除，分词准确率达到了98.41%。<br>(3).检测模式：只返回词库中已有的词条，很适合某些应用场合。(1.9.4开始)</p><p>就分词效率而言，简易模式速度最快</p><p>jcseg词库配置丰富，自我感觉功能最强大，详见jcseg开发文档；</p><p>jcseg现版本不兼容lucene5，我修改了其analyzer包，相关示例代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.lucene.analyzer;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.Analyzer;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.TokenStream;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.tokenattributes.CharTermAttribute;</div><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"><span class="keyword">import</span> org.lionsoul.jcseg.analyzer.JcsegAnalyzer5X;</div><div class="line"><span class="keyword">import</span> org.lionsoul.jcseg.core.JcsegTaskConfig;</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JcsegAnalyzerTest</span> </span>&#123;</div><div class="line"> </div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tokenTest</span><span class="params">()</span> </span>&#123;</div><div class="line">Analyzer analyzer = <span class="keyword">new</span> JcsegAnalyzer5X(JcsegTaskConfig.SIMPLE_MODE);</div><div class="line"><span class="comment">//非必须(用于修改默认配置): 获取分词任务配置实例</span></div><div class="line">JcsegAnalyzer5X jcseg = (JcsegAnalyzer5X) analyzer;</div><div class="line">JcsegTaskConfig config = jcseg.getTaskConfig();</div><div class="line"><span class="comment">//追加同义词到分词结果中, 需要在jcseg.properties中配置jcseg.loadsyn=1</span></div><div class="line">config.setAppendCJKSyn(<span class="keyword">true</span>);</div><div class="line"><span class="comment">//追加拼音到分词结果中, 需要在jcseg.properties中配置jcseg.loadpinyin=1</span></div><div class="line">config.setAppendCJKPinyin(<span class="keyword">true</span>);</div><div class="line"><span class="comment">//更多配置, 请查看com.webssky.jcseg.core.JcsegTaskConfig类</span></div><div class="line">String words = <span class="string">"中华人民共和国"</span>;</div><div class="line">TokenStream stream = <span class="keyword">null</span>;</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">stream = analyzer.tokenStream(<span class="string">"myfield"</span>, words);</div><div class="line">stream.reset(); </div><div class="line">CharTermAttribute  offsetAtt = stream.addAttribute(CharTermAttribute.class);</div><div class="line"><span class="keyword">while</span> (stream.incrementToken()) &#123;</div><div class="line">System.out.println(offsetAtt.toString());</div><div class="line">&#125;</div><div class="line">stream.end();</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125;<span class="keyword">finally</span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="keyword">if</span>(stream != <span class="keyword">null</span>)</div><div class="line">stream.close();</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">中华</div><div class="line">人民共和国</div></pre></td></tr></table></figure><h3 id="IKAnalyzer"><a href="#IKAnalyzer" class="headerlink" title="IKAnalyzer"></a>IKAnalyzer</h3><p>IK Analyzer是一个开源的，基亍java语言开发的轻量级的中文分词工具包。</p><p>采用了特有的“正向迭代最细粒度切分算法“，支持细粒度和智能分词两种切分模式；<br>在系统环境：Core2 i7 3.4G双核，4G内存，window 7 64位， Sun JDK 1.6_29 64位 普通pc环境测试，IK2012具有160万字/秒（3000KB/S）的高速处理能力。<br>2012版本的智能分词模式支持简单的分词排歧义处理和数量词合并输出。<br>采用了多子处理器分析模式，支持：英文字母、数字、中文词汇等分词处理，兼容韩文、日文字符<br>优化的词典存储，更小的内存占用。支持用户词典扩展定义。特别的，在2012版本，词典支持中文，英文，数字混合词语。</p><p>IK Analyzer支持细粒度切分和智能切分两种分词模式;</p><p>在细粒度切分下，词语分解到很细的力度，比如“一个苹果”，会被切分成如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">一个</div><div class="line">一</div><div class="line">个</div><div class="line">苹果</div></pre></td></tr></table></figure><p>在智能切分模式下，则会分词如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">一个</div><div class="line">苹果</div></pre></td></tr></table></figure><p>和jcseg相同，现版本的IK Analyzer只兼容至lucene4版本，我修改了相关源码，使其提供了对lucene5的支持。</p><p>IK Analyzer示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.lucene.analyzer;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.Analyzer;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.TokenStream;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.tokenattributes.CharTermAttribute;</div><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"><span class="keyword">import</span> org.wltea.analyzer.lucene.IKAnalyzer;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IKAnalyzerTest</span> </span>&#123;</div><div class="line"> </div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tokenTest</span><span class="params">()</span> </span>&#123;</div><div class="line">Analyzer analyzer = <span class="keyword">new</span> IKAnalyzer();</div><div class="line">String words = <span class="string">"中华人民共和国"</span>;</div><div class="line">TokenStream stream = <span class="keyword">null</span>;</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">stream = analyzer.tokenStream(<span class="string">"myfield"</span>, words);</div><div class="line">stream.reset(); </div><div class="line">CharTermAttribute  offsetAtt = stream.addAttribute(CharTermAttribute.class);</div><div class="line"><span class="keyword">while</span> (stream.incrementToken()) &#123;</div><div class="line">System.out.println(offsetAtt.toString());</div><div class="line">&#125;</div><div class="line">stream.end();</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125;<span class="keyword">finally</span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">stream.close();</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">中华人民共和国</div><div class="line">中华人民</div><div class="line">中华</div><div class="line">华人</div><div class="line">人民共和国</div><div class="line">人民</div><div class="line">共和国</div><div class="line">共和</div><div class="line">国</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lucene（4）—lucene的中文分词器jcseg和IK-Analyzer分词器及其使用说明&quot;&gt;&lt;a href=&quot;#lucene（4）—lucene的中文分词器jcseg和IK-Analyzer分词器及其使用说明&quot; class=&quot;headerlink&quot; title=&quot;lucene（4）—lucene的中文分词器jcseg和IK Analyzer分词器及其使用说明&quot;&gt;&lt;/a&gt;lucene（4）—lucene的中文分词器jcseg和IK Analyzer分词器及其使用说明&lt;/h1&gt;&lt;h2 id=&quot;为什么要使用lucene中文分词器&quot;&gt;&lt;a href=&quot;#为什么要使用lucene中文分词器&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用lucene中文分词器&quot;&gt;&lt;/a&gt;为什么要使用lucene中文分词器&lt;/h2&gt;&lt;p&gt;在lucene的开发过程中，我们常会遇到分词时中文识别的问题，lucene提供了&lt;/p&gt;
&lt;p&gt;lucene-analyzers-common-5.0.0.jar包来支持分词，但多的是对英国，法国，意大利等过语言的支持，&lt;/p&gt;
&lt;p&gt;因此我们需要引入中文分词的概念。&lt;/p&gt;
    
    </summary>
    
      <category term="lucene" scheme="http://swenfang.github.io/categories/lucene/"/>
    
    
      <category term="lucene" scheme="http://swenfang.github.io/tags/lucene/"/>
    
  </entry>
  
  <entry>
    <title>lucene的analysis相关和自定义分词器</title>
    <link href="http://swenfang.github.io/2019/03/16/Lucene/3%E3%80%81lucene%E7%9A%84analysis%E7%9B%B8%E5%85%B3%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E8%AF%8D%E5%99%A8/"/>
    <id>http://swenfang.github.io/2019/03/16/Lucene/3、lucene的analysis相关和自定义分词器/</id>
    <published>2019-03-16T01:53:14.239Z</published>
    <updated>2019-03-16T03:14:38.705Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lucene（3）—lucene的analysis相关和自定义分词器"><a href="#lucene（3）—lucene的analysis相关和自定义分词器" class="headerlink" title="lucene（3）—lucene的analysis相关和自定义分词器"></a>lucene（3）—lucene的analysis相关和自定义分词器</h1><h2 id="analysis说明"><a href="#analysis说明" class="headerlink" title="analysis说明"></a>analysis说明</h2><h3 id="lucene-ananlysis应用场景"><a href="#lucene-ananlysis应用场景" class="headerlink" title="lucene ananlysis应用场景"></a>lucene ananlysis应用场景</h3><p>lucene提供了analysis用来将文本转换到索引文件或提供给IndexSearcher查询索引；</p><p>对于lucene而言，不管是索引还是检索，都是针对于纯文本输入来讲的；</p><p>通过lucene的强大类库我们可以访问各种格式的文档，如HTML、XML、PDF、<a href="https://www.baidu.com/s?wd=Word&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="external">Word</a>、TXT等，</p><p>我们需要传递给lucene的只是文件中的纯文本内容；</p><a id="more"></a><h3 id="lucene的词语切分"><a href="#lucene的词语切分" class="headerlink" title="lucene的词语切分"></a>lucene的词语切分</h3><p>lucene的索引和检索前提是其对文本内容的分析和词组的切分；比如，文档中有一句话叫“Hello World,Welcome to China”</p><p>我们想找到包含这段话的文档，而用户输入的查询条件又不尽详细（可能只是hello）</p><p>这里我们就需要用到lucene索引该文档的时候预先对文档内容进行切分，将词源和文本对应起来。</p><p>有时候对词语进行简单切分还远远不够，我们还需要对字符串进行深度切分，lucene不仅能够对索引内容预处理还可以对请求参数进行切分；</p><h3 id="使用analyzer"><a href="#使用analyzer" class="headerlink" title="使用analyzer"></a>使用analyzer</h3><p>lucene的索引使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.lucene.analysis;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.StringReader;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.Analyzer;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.TokenStream;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.standard.StandardAnalyzer;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.tokenattributes.OffsetAttribute;</div><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnalysisTest</span> </span>&#123;</div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tokenTest</span><span class="params">()</span> </span>&#123;</div><div class="line">Analyzer analyzer = <span class="keyword">new</span> StandardAnalyzer(); <span class="comment">// or any other analyzer</span></div><div class="line">TokenStream ts = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">ts = analyzer.tokenStream(<span class="string">"myfield"</span>, <span class="keyword">new</span> StringReader(</div><div class="line"><span class="string">"some text goes here"</span>));</div><div class="line">OffsetAttribute offsetAtt = ts.addAttribute(OffsetAttribute.class);</div><div class="line">ts.reset(); <span class="comment">// Resets this stream to the beginning. (Required)</span></div><div class="line"><span class="keyword">while</span> (ts.incrementToken()) &#123;</div><div class="line"><span class="comment">// Use AttributeSource.reflectAsString(boolean)</span></div><div class="line"><span class="comment">// for token stream debugging.</span></div><div class="line">System.out.println(<span class="string">"token: "</span> + ts.reflectAsString(<span class="keyword">true</span>));</div><div class="line"> </div><div class="line">System.out.println(<span class="string">"token start offset: "</span></div><div class="line">+ offsetAtt.startOffset());</div><div class="line">System.out.println(<span class="string">"token end offset: "</span></div><div class="line">+ offsetAtt.endOffset());</div><div class="line">&#125;</div><div class="line">ts.end(); </div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">ts.close();</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="自定义Analyzer和实现自己的analysis模块"><a href="#自定义Analyzer和实现自己的analysis模块" class="headerlink" title="自定义Analyzer和实现自己的analysis模块"></a>自定义Analyzer和实现自己的analysis模块</h2><p>1.要实现自己的analyzer，我们需要继承Analyzer并重写其中的分词模块。</p><p>2.维护停止词词典</p><p>3.重写TokenStreamComponents方法，选择合适的分词方法，对词语进行过滤</p><p>示例代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.lucene.analysis.self;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.Analyzer;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.TokenStream;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.Tokenizer;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.core.LowerCaseTokenizer;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.core.StopAnalyzer;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.core.StopFilter;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.tokenattributes.CharTermAttribute;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.util.CharArraySet;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnalyzer</span> <span class="keyword">extends</span> <span class="title">Analyzer</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> CharArraySet stopWordSet;<span class="comment">//停止词词典</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> CharArraySet <span class="title">getStopWordSet</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> stopWordSet;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStopWordSet</span><span class="params">(CharArraySet stopWordSet)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.stopWordSet = stopWordSet;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyAnalyzer</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">super</span>();</div><div class="line"><span class="keyword">this</span>.stopWordSet = StopAnalyzer.ENGLISH_STOP_WORDS_SET;<span class="comment">//可在此基础上拓展停止词</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**扩展停止词</span></div><div class="line"> * <span class="doctag">@param</span> stops</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyAnalyzer</span><span class="params">(String[] stops)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>();</div><div class="line">stopWordSet.addAll(StopFilter.makeStopSet(stops));</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> TokenStreamComponents <span class="title">createComponents</span><span class="params">(String fieldName)</span> </span>&#123;</div><div class="line"><span class="comment">//正则匹配分词</span></div><div class="line">Tokenizer source = <span class="keyword">new</span> LowerCaseTokenizer();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TokenStreamComponents(source, <span class="keyword">new</span> StopFilter(source, stopWordSet));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Analyzer analyzer = <span class="keyword">new</span> MyAnalyzer();</div><div class="line">String words = <span class="string">"A AN yuyu"</span>;</div><div class="line">TokenStream stream = <span class="keyword">null</span>;</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">stream = analyzer.tokenStream(<span class="string">"myfield"</span>, words);</div><div class="line">stream.reset(); </div><div class="line">CharTermAttribute  offsetAtt = stream.addAttribute(CharTermAttribute.class);</div><div class="line"><span class="keyword">while</span> (stream.incrementToken()) &#123;</div><div class="line">System.out.println(offsetAtt.toString());</div><div class="line">&#125;</div><div class="line">stream.end();</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125;<span class="keyword">finally</span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">stream.close();</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yuyu</div></pre></td></tr></table></figure><p>说明该分词器对a an 进行了过滤，这些过滤的词在stopWordSet中</p><h3 id="添加字长过滤器"><a href="#添加字长过滤器" class="headerlink" title="添加字长过滤器"></a>添加字长过滤器</h3><p>有时候我们需要对字符串中的短字符进行过滤，比如welcome to BeiJIng中过滤掉长度小于2的字符串，我们期望的结果就变成了Welcome BeiJing,我们仅需要重新实现createComponents方法，相关代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.lucene.analysis.self;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.Analyzer;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.TokenStream;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.Tokenizer;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.core.LowerCaseTokenizer;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.core.StopAnalyzer;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.core.StopFilter;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.core.WhitespaceTokenizer;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.miscellaneous.LengthFilter;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.tokenattributes.CharTermAttribute;</div><div class="line"><span class="keyword">import</span> org.apache.lucene.analysis.util.CharArraySet;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LengFilterAanlyzer</span> <span class="keyword">extends</span> <span class="title">Analyzer</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> len;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLen</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> len;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLen</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.len = len;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LengFilterAanlyzer</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">super</span>();</div><div class="line">&#125;</div><div class="line"></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LengFilterAanlyzer</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line"><span class="keyword">super</span>();</div><div class="line"><span class="keyword">this</span>.len = len;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> TokenStreamComponents <span class="title">createComponents</span><span class="params">(String fieldName)</span> </span>&#123;</div><div class="line"><span class="keyword">final</span> Tokenizer source = <span class="keyword">new</span> WhitespaceTokenizer();</div><div class="line">    TokenStream result = <span class="keyword">new</span> LengthFilter(source, len, Integer.MAX_VALUE);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TokenStreamComponents(source,result);</div><div class="line"> </div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Analyzer analyzer = <span class="keyword">new</span> LengFilterAanlyzer(<span class="number">2</span>);</div><div class="line">String words = <span class="string">"I am a java coder"</span>;</div><div class="line">TokenStream stream = <span class="keyword">null</span>;</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">stream = analyzer.tokenStream(<span class="string">"myfield"</span>, words);</div><div class="line">stream.reset(); </div><div class="line">CharTermAttribute  offsetAtt = stream.addAttribute(CharTermAttribute.class);</div><div class="line"><span class="keyword">while</span> (stream.incrementToken()) &#123;</div><div class="line">System.out.println(offsetAtt.toString());</div><div class="line">&#125;</div><div class="line">stream.end();</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125;<span class="keyword">finally</span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">stream.close();</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>程序的执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">am</div><div class="line">java</div><div class="line">coder</div></pre></td></tr></table></figure><p>说明小于2个字符的文本被过滤了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lucene（3）—lucene的analysis相关和自定义分词器&quot;&gt;&lt;a href=&quot;#lucene（3）—lucene的analysis相关和自定义分词器&quot; class=&quot;headerlink&quot; title=&quot;lucene（3）—lucene的analysis相关和自定义分词器&quot;&gt;&lt;/a&gt;lucene（3）—lucene的analysis相关和自定义分词器&lt;/h1&gt;&lt;h2 id=&quot;analysis说明&quot;&gt;&lt;a href=&quot;#analysis说明&quot; class=&quot;headerlink&quot; title=&quot;analysis说明&quot;&gt;&lt;/a&gt;analysis说明&lt;/h2&gt;&lt;h3 id=&quot;lucene-ananlysis应用场景&quot;&gt;&lt;a href=&quot;#lucene-ananlysis应用场景&quot; class=&quot;headerlink&quot; title=&quot;lucene ananlysis应用场景&quot;&gt;&lt;/a&gt;lucene ananlysis应用场景&lt;/h3&gt;&lt;p&gt;lucene提供了analysis用来将文本转换到索引文件或提供给IndexSearcher查询索引；&lt;/p&gt;
&lt;p&gt;对于lucene而言，不管是索引还是检索，都是针对于纯文本输入来讲的；&lt;/p&gt;
&lt;p&gt;通过lucene的强大类库我们可以访问各种格式的文档，如HTML、XML、PDF、&lt;a href=&quot;https://www.baidu.com/s?wd=Word&amp;amp;tn=24004469_oem_dg&amp;amp;rsv_dl=gh_pl_sl_csd&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Word&lt;/a&gt;、TXT等，&lt;/p&gt;
&lt;p&gt;我们需要传递给lucene的只是文件中的纯文本内容；&lt;/p&gt;
    
    </summary>
    
      <category term="lucene" scheme="http://swenfang.github.io/categories/lucene/"/>
    
    
      <category term="lucene" scheme="http://swenfang.github.io/tags/lucene/"/>
    
  </entry>
  
</feed>
