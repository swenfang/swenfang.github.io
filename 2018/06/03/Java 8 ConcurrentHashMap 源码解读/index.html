<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="基础数据类型," />










<meta name="description" content="Java 8 ConcurrentHashMap 源码解读 ConcurrentHashMap 当之无愧是支持并发最好的键值对（Map）集合。在日常编码中，出场率也相当之高。在jdk8中，集合类 ConcurrentHashMap 经 Doug Lea 大师之手，借助volatile语义以及CAS操作进行优化，使得该集合类更好地发挥出了并发的优势。与jdk7中相比，在原有段锁（Segment）的基">
<meta name="keywords" content="基础数据类型">
<meta property="og:type" content="article">
<meta property="og:title" content="ConcurrentHashMap 源码解读">
<meta property="og:url" content="http://swenfang.github.io/2018/06/03/Java 8 ConcurrentHashMap 源码解读/index.html">
<meta property="og:site_name" content="ShenWenFang">
<meta property="og:description" content="Java 8 ConcurrentHashMap 源码解读 ConcurrentHashMap 当之无愧是支持并发最好的键值对（Map）集合。在日常编码中，出场率也相当之高。在jdk8中，集合类 ConcurrentHashMap 经 Doug Lea 大师之手，借助volatile语义以及CAS操作进行优化，使得该集合类更好地发挥出了并发的优势。与jdk7中相比，在原有段锁（Segment）的基">
<meta property="og:image" content="https://blogimg.nos-eastchina1.126.net/171214/93aB6f3iC1.png">
<meta property="og:image" content="https://blogimg.nos-eastchina1.126.net/171214/g3HD7ABdjH.png">
<meta property="og:image" content="https://blogimg.nos-eastchina1.126.net/171214/CEj7GLmk1G.png">
<meta property="og:image" content="https://blogimg.nos-eastchina1.126.net/171214/k7LKAjJm0m.png">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/6283837-95df888f4f738601.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700">
<meta property="og:updated_time" content="2019-02-17T09:06:33.684Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ConcurrentHashMap 源码解读">
<meta name="twitter:description" content="Java 8 ConcurrentHashMap 源码解读 ConcurrentHashMap 当之无愧是支持并发最好的键值对（Map）集合。在日常编码中，出场率也相当之高。在jdk8中，集合类 ConcurrentHashMap 经 Doug Lea 大师之手，借助volatile语义以及CAS操作进行优化，使得该集合类更好地发挥出了并发的优势。与jdk7中相比，在原有段锁（Segment）的基">
<meta name="twitter:image" content="https://blogimg.nos-eastchina1.126.net/171214/93aB6f3iC1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://swenfang.github.io/2018/06/03/Java 8 ConcurrentHashMap 源码解读/"/>





  <title>ConcurrentHashMap 源码解读 | ShenWenFang</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/another"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://camo.githubusercontent.com/c6286ade715e9bea433b4705870de482a654f78a/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f77686974655f6666666666662e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_left_white_ffffff.png"></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ShenWenFang</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://swenfang.github.io/2018/06/03/Java 8 ConcurrentHashMap 源码解读/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ShenWenFang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShenWenFang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ConcurrentHashMap 源码解读</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-03T17:19:36+08:00">
                2018-06-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ConcurrentHashMap/" itemprop="url" rel="index">
                    <span itemprop="name">ConcurrentHashMap</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/06/03/Java 8 ConcurrentHashMap 源码解读/" class="leancloud_visitors" data-flag-title="ConcurrentHashMap 源码解读">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  14,185 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  61 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Java-8-ConcurrentHashMap-源码解读"><a href="#Java-8-ConcurrentHashMap-源码解读" class="headerlink" title="Java 8 ConcurrentHashMap 源码解读"></a>Java 8 ConcurrentHashMap 源码解读</h1><p> <strong>ConcurrentHashMap</strong> 当之无愧是支持并发最好的键值对（Map）集合。在日常编码中，出场率也相当之高。在jdk8中，集合类 ConcurrentHashMap 经 <em>Doug Lea</em> 大师之手，借助volatile语义以及CAS操作进行优化，使得该集合类更好地发挥出了并发的优势。与jdk7中相比，在原有段锁（Segment）的基础上，引入了数组＋链表＋红黑树的存储模型，在查询效率上花费了不少心思。</p>
<p><img src="https://blogimg.nos-eastchina1.126.net/171214/93aB6f3iC1.png" alt="mark"></p>
<h2 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h2><p>ConcurrentHashMap内存存储结构图大致如下：</p>
<p><img src="https://blogimg.nos-eastchina1.126.net/171214/g3HD7ABdjH.png" alt="mark"></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>1、设计首要目的：维护并发可读性（get、迭代相关）；次要目的：使空间消耗比HashMap相同或更好，且支持多线程高效率的初始插入（empty table）。</p>
<p>2、HashTable线程安全，但采用synchronized，多线程下效率低下。线程1put时，线程2无法put或get。</p>
<h3 id="阅前了解"><a href="#阅前了解" class="headerlink" title="阅前了解"></a>阅前了解</h3><p>在真正阅读 ConcurrentHashMap 源码之前，我们简单复习下关于volatile和CAS的概念，这样才能更好地帮助我们理解源码中的关键方法。</p>
<h4 id="volatile语义"><a href="#volatile语义" class="headerlink" title="volatile语义"></a>volatile语义</h4><p>java提供的关键字volatile是最轻量级的同步机制。当定义一个变量为volatile时，它就具备了三层语义： - 可见性（Visibility）：在多线程环境下，一个变量的写操作总是对其后的读取线程可见 - 原子性（Atomicity）：volatile的读/写操作具有原子性 - 有序性（Ordering）：禁止指令的重排序优化，JVM会通过插入内存屏障（Memory Barrier）指令来保证</p>
<p>就同步性能而言，大多数场景下volatile的总开销是要比锁低的。在ConcurrentHashMap的源码中，我们能看到频繁的volatile变量读取与写入。</p>
<h4 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h4><p>CAS一般被理解为<strong>原子操作</strong>。在java中，正是利用了处理器的CMPXCHG（intel）指令实现CAS操作。CAS需要接受原有期望值expected以及想要修改的新值x，只有在原有期望值与当前值相等时才会更新为x，否则为失败。在ConcurrentHashMap的方法中，大量使用CAS获取/修改互斥量，以达到多线程并发环境下的正确性。</p>
<h2 id="ConcurrentHashMap-的常量"><a href="#ConcurrentHashMap-的常量" class="headerlink" title="ConcurrentHashMap 的常量"></a>ConcurrentHashMap 的常量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// maximum_capacity table的最大容量，必须为2次幂形式</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// default_capacity table的默认初始容量，必须为2次幂形式</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// max_array_size MAX_VALUE=2^31-1=2147483647</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// default_concurrency_leve 未被用到，用来兼容之前版本</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> finalint DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// load_factor table的负载因子，当前节点数量超过 n * LOAD_FACTOR，执行扩容</span></div><div class="line"><span class="comment">// 位操作表达式为 n - (n &gt;&gt;&gt; 2)</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// treeify_threshold 针对每个桶（bin），链表转换为红黑树的节点数阈值</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 针对每个桶（bin），红黑树退化为链表的节点数阈值</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// min_treeify_capacity 最小的树的容量</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 扩容线程每次最少要迁移16个hash桶</span></div><div class="line"><span class="comment">// min_transfer_stride 在扩容中，参与的单个线程允许处理的最少table桶首节点个数</span></div><div class="line"><span class="comment">// 虽然适当添加线程，会使得整个扩容过程变快，但需要考虑多线程内存同时分配的问题</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// resize stamp bits sizeCtl 中记录 size 的 bit 数</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// max_resizers 2^15-1 参与扩容的最大线程数</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span>&lt;&lt;(<span class="number">32</span>-RESIZE_STAMP_BITS))-<span class="number">1</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 32 - 16 = 16, sizeCtl 中记录 size 大小的偏移量</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS = <span class="number">16</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 转为 nodes的hash值、标示位</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED = -<span class="number">1</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 树的根节点的 hash 值</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN = -<span class="number">2</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ReservationNode 的 hash 值</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED = -<span class="number">3</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一些特定的哈希值代表不同含义</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// hash for forwarding nodes</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// hash for roots of trees</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// CPU数</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors()</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 真正存储Node数据（桶首）节点的数组table</div><div class="line"> * 所有Node节点根据hash分桶存储</div><div class="line"> * table数组中存储的是所有桶（bin）的首节点</div><div class="line"> * hash值相同的节点以链表形式分装在桶中</div><div class="line"> * 当一个桶中节点数达到8个时，转换为红黑树，提高查询效率</div><div class="line"> * 装载Node的数组，作为ConcurrentHashMap的数据容器，采用懒加载的方式</div><div class="line"> * 直到第一次插入数据的时候才会进行初始化操作，数组的大小总是为2的幂次方。</div><div class="line"> */</div><div class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</div><div class="line"><span class="comment">// 扩容时候使用,平时为null，只有在扩容的时候才为非null</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</div><div class="line"><span class="comment">// 没有竞争条件时，使用</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</div><div class="line"></div><div class="line"><span class="comment">// 扩容时，将table中的元素迁移至nextTable . 扩容时非空</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  重要控制变量</div><div class="line"> *  根据变量的数值不同，类实例处于不同阶段</div><div class="line"> *  1. = -1 : 正在初始化</div><div class="line"> *  2. &lt; -1 : 正在扩容，数值为 -(1 + 参与扩容的线程数)</div><div class="line"> *  3. = 0  : 创建时初始为0</div><div class="line"> *  4. &gt; 0  : 下一次扩容的大小</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</div></pre></td></tr></table></figure>
<h2 id="ConcurrentHashMap-重要属性"><a href="#ConcurrentHashMap-重要属性" class="headerlink" title="ConcurrentHashMap 重要属性"></a>ConcurrentHashMap 重要属性</h2><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>Key-value entry, 继承自Map.Entry<k,v>对象。</k,v></p>
<p>Node<k,v>节点是ConcurrentHashMap存储数据的最<strong>基本结构</strong>。一个数据mapping节点中，存储4个变量：当前节点hash值、节点的key值、节点的value值、指向下一个节点的指针next。其中在子类中的hash可以为负数，具有特殊的并发处理意义，后文会解释。除了具有特殊意义的子类，Node中的key和val不允许为null。</k,v></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;  </div><div class="line">  		<span class="comment">// Node节点的hash值和key的hash值相同</span></div><div class="line">  		<span class="comment">// TreeNode节点的hash值</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;  </div><div class="line">        <span class="keyword">final</span> K key;  </div><div class="line">        <span class="keyword">volatile</span> V val; <span class="comment">//带有同步锁的value(保证可见性)  </span></div><div class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;<span class="comment">//带有同步锁的next指针</span></div><div class="line">   </div><div class="line">        Node(inthash, K key, V val, Node&lt;K,V&gt; next) &#123;  </div><div class="line">            <span class="keyword">this</span>.hash = hash;  </div><div class="line">            <span class="keyword">this</span>.key = key;  </div><div class="line">            <span class="keyword">this</span>.val = val;  </div><div class="line">            <span class="keyword">this</span>.next = next;  </div><div class="line">        &#125;  </div><div class="line">   </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>       </span>&#123; <span class="keyword">return</span> key; &#125;  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> val; &#125;  </div><div class="line">        <span class="comment">// HashMap调用Objects.hashCode()，最终也是调用Object.hashCode()；效果一样  </span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>   </span>&#123; returnkey.hashCode() ^ val.hashCode(); &#125;  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; returnkey + <span class="string">"="</span> + val; &#125;  </div><div class="line">  		<span class="comment">//不允许直接改变value的值</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123; <span class="comment">// 不允许修改value值，HashMap允许  </span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();  </div><div class="line">        &#125;  </div><div class="line">        <span class="comment">// HashMap使用if (o == this)，且嵌套if；concurrent使用&amp;&amp;  </span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;  </div><div class="line">            Object k, v, u; Map.Entry&lt;?,?&gt; e;  </div><div class="line">            <span class="keyword">return</span> ((oinstanceof Map.Entry) &amp;&amp;  </div><div class="line">                    (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != <span class="keyword">null</span> &amp;&amp;  </div><div class="line">                    (v = e.getValue()) != <span class="keyword">null</span> &amp;&amp;  </div><div class="line">                    (k == key || k.equals(key)) &amp;&amp;  </div><div class="line">                    (v == (u = val) || v.equals(u)));  </div><div class="line">        &#125;  </div><div class="line">   </div><div class="line">        <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(inth, Object k)</span> </span>&#123; <span class="comment">// 增加find方法辅助get方法  </span></div><div class="line">            Node&lt;K,V&gt; e = <span class="keyword">this</span>;  </div><div class="line">            <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;  </div><div class="line">                <span class="keyword">do</span> &#123;  </div><div class="line">                    K ek;  </div><div class="line">                    <span class="keyword">if</span> (e.hash == h &amp;&amp;  </div><div class="line">                        ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))  </div><div class="line">                        <span class="keyword">return</span> e;  </div><div class="line">                  <span class="comment">/**</span></div><div class="line">                  *  以链表形式查找桶中下一个Node信息</div><div class="line">                  *  当转换为subclass红黑树节点TreeNode</div><div class="line">                  *  则使用TreeNode中的find进行查询操作</div><div class="line">                  */</div><div class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);  </div><div class="line">            &#125;  </div><div class="line">            returnnull;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>另外可以看出很多属性都是用volatile进行修饰的，也就是为了保证内存可见性。</p>
<ol>
<li>这个Node内部类与HashMap中定义的Node类很相似，但是有一些差别  </li>
<li>它对value和next属性设置了volatile同步锁  </li>
<li>它不允许调用setValue方法直接改变Node的value域  </li>
<li>它增加了find方法辅助map.get()方法  </li>
</ol>
<h3 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode"></a>TreeNode</h3><p>Node的子类，红黑树节点，当Node链表过长时，会转换成红黑树。</p>
<p>位于 ConcurrentHashMap 类的 2653行 或 搜索 /<em> —————- TreeNodes ————– </em>/</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Nodes for use in TreeBins，链表&gt;8，才可能转为TreeNode.  </span></div><div class="line"><span class="comment">// HashMap的TreeNode继承至LinkedHashMap.Entry；而这里继承至自己实现的Node，将带有next指针，便于treebin访问。  </span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;   </div><div class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links  </span></div><div class="line">        TreeNode&lt;K,V&gt; left;  </div><div class="line">        TreeNode&lt;K,V&gt; right;  </div><div class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion  </span></div><div class="line">        <span class="keyword">boolean</span> red;  </div><div class="line">   </div><div class="line">        TreeNode(inthash, K key, V val, Node&lt;K,V&gt; next,  </div><div class="line">                 TreeNode&lt;K,V&gt; parent) &#123;  </div><div class="line">            <span class="keyword">super</span>(hash, key, val, next);  </div><div class="line">            <span class="keyword">this</span>.parent = parent;  </div><div class="line">        &#125;  </div><div class="line">   </div><div class="line">        <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(inth, Object k)</span> </span>&#123;  </div><div class="line">            <span class="keyword">return</span> findTreeNode(h, k, <span class="keyword">null</span>);  </div><div class="line">        &#125;  </div><div class="line">   </div><div class="line">        <span class="comment">/** </span></div><div class="line">         * Returns the TreeNode (or null if not found) for the given key </div><div class="line">         * starting at given root. </div><div class="line">         */ <span class="comment">// 查找hash为h，key为k的节点  </span></div><div class="line">        <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">findTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;  </div><div class="line">            <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123; <span class="comment">// 比HMap增加判空  </span></div><div class="line">                TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;  </div><div class="line">                <span class="keyword">do</span>  &#123;  </div><div class="line">                    intph, dir; K pk; TreeNode&lt;K,V&gt; q;  </div><div class="line">                    TreeNode&lt;K,V&gt; pl = p.left, pr = p.right;  </div><div class="line">                    <span class="keyword">if</span> ((ph = p.hash) &gt; h)  </div><div class="line">                        p = pl;  </div><div class="line">                    elseif (ph &lt; h)  </div><div class="line">                        p = pr;  </div><div class="line">                    elseif ((pk = p.key) == k || (pk != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))  </div><div class="line">                        returnp;  </div><div class="line">                    elseif (pl == <span class="keyword">null</span>)  </div><div class="line">                        p = pr;  </div><div class="line">                    elseif (pr == <span class="keyword">null</span>)  </div><div class="line">                        p = pl;  </div><div class="line">                    elseif ((kc != <span class="keyword">null</span> ||  </div><div class="line">                              (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;  </div><div class="line">                             (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)  </div><div class="line">                        p = (dir &lt; <span class="number">0</span>) ? pl : pr;  </div><div class="line">                    elseif ((q = pr.findTreeNode(h, k, kc)) != <span class="keyword">null</span>)  </div><div class="line">                        returnq;  </div><div class="line">                    <span class="keyword">else</span>  </div><div class="line">                        p = pl;  </div><div class="line">                &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);  </div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line"><span class="comment">// 和HashMap相比，这里的TreeNode相当简洁；ConcurrentHashMap链表转树时，并不会直接转，</span></div><div class="line"><span class="comment">// 正如注释（Nodes for use in TreeBins）所说，只是把这些节点包装成TreeNode放到TreeBin中，</span></div><div class="line"><span class="comment">// 再由TreeBin来转化红黑树。</span></div></pre></td></tr></table></figure>
<p>树节点，继承于承载数据的Node类。而红黑树的操作是针对TreeBin类的，从该类的注释也可以看出，也就是TreeBin会将TreeNode进行再一次封装</p>
<h3 id="TreeBin"><a href="#TreeBin" class="headerlink" title="TreeBin"></a>TreeBin</h3><p>位于 ConcurrentHashMap 类的 2709 行 或 搜索 /<em> —————- TreeBins ————– </em>/    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// TreeBin用于封装维护TreeNode，包含putTreeVal、lookRoot、UNlookRoot、remove、</span></div><div class="line"><span class="comment">// balanceInsetion、balanceDeletion等方法，这里只分析其构造函数。当链表转树时，</span></div><div class="line"><span class="comment">// 用于封装TreeNode，也就是说，ConcurrentHashMap的红黑树存放的是TreeBin，而不是treeNode。  </span></div><div class="line">TreeBin(TreeNode&lt;K,V&gt; b) &#123;  </div><div class="line">    <span class="keyword">super</span>(TREEBIN, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);<span class="comment">//hash值为常量TREEBIN=-2,表示roots of trees  </span></div><div class="line">    <span class="keyword">this</span>.first = b;  </div><div class="line">    TreeNode&lt;K,V&gt; r = <span class="keyword">null</span>;  </div><div class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = b, next; x != <span class="keyword">null</span>; x = next) &#123;  </div><div class="line">        next = (TreeNode&lt;K,V&gt;)x.next;  </div><div class="line">        x.left = x.right = <span class="keyword">null</span>;  </div><div class="line">        <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;  </div><div class="line">            x.parent = <span class="keyword">null</span>;  </div><div class="line">            x.red = <span class="keyword">false</span>;  </div><div class="line">            r = x;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">else</span> &#123;  </div><div class="line">            K k = x.key;  </div><div class="line">            inth = x.hash;  </div><div class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;  </div><div class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = r;;) &#123;  </div><div class="line">                intdir, ph;  </div><div class="line">                K pk = p.key;  </div><div class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)  </div><div class="line">                    dir = -<span class="number">1</span>;  </div><div class="line">                elseif (ph &lt; h)  </div><div class="line">                    dir = <span class="number">1</span>;  </div><div class="line">                elseif ((kc == <span class="keyword">null</span> &amp;&amp;  </div><div class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||  </div><div class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)  </div><div class="line">                    dir = tieBreakOrder(k, pk);  </div><div class="line">                    TreeNode&lt;K,V&gt; xp = p;  </div><div class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;  </div><div class="line">                    x.parent = xp;  </div><div class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)  </div><div class="line">                        xp.left = x;  </div><div class="line">                    <span class="keyword">else</span>  </div><div class="line">                        xp.right = x;  </div><div class="line">                    r = balanceInsertion(r, x);  </div><div class="line">                    <span class="keyword">break</span>;  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">this</span>.root = r;  </div><div class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个类并不负责包装用户的key、value信息，而是包装的很多TreeNode节点。实际的ConcurrentHashMap“数组”中，存放的是TreeBin对象，而不是TreeNode对象。</p>
<h3 id="threeifyBin"><a href="#threeifyBin" class="headerlink" title="threeifyBin"></a>threeifyBin</h3><p>位于 ConcurrentHashMap 类的 2611 行 或 搜索 “private final void treeifyBin”    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;  </div><div class="line">        Node&lt;K,V&gt; b; intn, sc;  </div><div class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123; </div><div class="line">      	<span class="comment">// 数组的大小还未超过64</span></div><div class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)  </div><div class="line">            tryPresize(n &lt;&lt; <span class="number">1</span>); <span class="comment">// 容量&lt;64，则table两倍扩容，不转树了  </span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;  </div><div class="line">            <span class="keyword">synchronized</span> (b) &#123; <span class="comment">// 读写锁  </span></div><div class="line">                <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;  </div><div class="line">                    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;  </div><div class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;  </div><div class="line">                        TreeNode&lt;K,V&gt; p =  </div><div class="line">                            <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,  </div><div class="line">                                              <span class="keyword">null</span>, <span class="keyword">null</span>);  </div><div class="line">                        <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)  </div><div class="line">                            hd = p;  </div><div class="line">                        <span class="keyword">else</span>  </div><div class="line">                            tl.next = p;  </div><div class="line">                        tl = p;  </div><div class="line">                    &#125;  </div><div class="line">                    setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ForwardingNode"><a href="#ForwardingNode" class="headerlink" title="ForwardingNode"></a>ForwardingNode</h3><p>位于 ConcurrentHashMap 类的 2163 行 或 搜索 “static final class ForwardingNode”    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// A node inserted at head of bins during transfer operations.连接两个table  </span></div><div class="line"><span class="comment">// 并不是我们传统的包含key-value的节点，只是一个标志节点，并且指向nextTable，提供find方法而已。</span></div><div class="line"><span class="comment">// 生命周期：仅存活于扩容操作且bin不为null时，一定会出现在每个bin的首位。  </span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;  </div><div class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;  </div><div class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;  </div><div class="line">        <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>); <span class="comment">// 此节点hash=-1，key、value、next均为null  </span></div><div class="line">        <span class="keyword">this</span>.nextTable = tab;  </div><div class="line">    &#125;  </div><div class="line">   </div><div class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;  </div><div class="line">        <span class="comment">// 查nextTable节点，outer避免深度递归  </span></div><div class="line">        outer: <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = nextTable;;) &#123;  </div><div class="line">            Node&lt;K,V&gt; e; intn;  </div><div class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span> || tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||  </div><div class="line">                (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) == <span class="keyword">null</span>)  </div><div class="line">                returnnull;  </div><div class="line">            <span class="keyword">for</span> (;;) &#123; <span class="comment">// CAS算法多和死循环搭配！直到查到或null  </span></div><div class="line">                <span class="keyword">int</span> eh; K ek;  </div><div class="line">                <span class="keyword">if</span> ((eh = e.hash) == h &amp;&amp;  </div><div class="line">                    ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))  </div><div class="line">                    returne;  </div><div class="line">                <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) &#123;  </div><div class="line">                    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ForwardingNode) &#123;  </div><div class="line">                        tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;  </div><div class="line">                        <span class="keyword">continue</span> outer;  </div><div class="line">                    &#125;  </div><div class="line">                    <span class="keyword">else</span>  </div><div class="line">                        <span class="keyword">return</span> e.find(h, k);  </div><div class="line">                &#125;  </div><div class="line">                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)  </div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在扩容时才会出现的特殊节点，其key,value,hash全部为null。并拥有nextTable指针引用新的table数组。</p>
<h3 id="Traverser"><a href="#Traverser" class="headerlink" title="Traverser"></a>Traverser</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Traverser</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; </div><div class="line">  	<span class="comment">//下一个要访问的entry</span></div><div class="line">    Node&lt;K,V&gt; next;</div><div class="line">  	<span class="comment">//发现forwardingNode时，保存当前tab相关信息</span></div><div class="line">    TableStack&lt;K,V&gt; stack, spare; </div><div class="line">    <span class="comment">//下一个要访问的hash桶索引</span></div><div class="line">    <span class="keyword">int</span> index;             </div><div class="line">  	<span class="comment">//当前正在访问的初始tab的hash桶索引</span></div><div class="line">    <span class="keyword">int</span> baseIndex;          </div><div class="line">    <span class="comment">//初始tab的hash桶索引边界</span></div><div class="line">    <span class="keyword">int</span> baseLimit; </div><div class="line">    <span class="comment">//初始tab的长度</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> baseSize; </div><div class="line"></div><div class="line">    Traverser(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> size, <span class="keyword">int</span> index, <span class="keyword">int</span> limit) &#123;</div><div class="line">        <span class="keyword">this</span>.tab = tab;</div><div class="line">        <span class="keyword">this</span>.baseSize = size;</div><div class="line">        <span class="keyword">this</span>.baseIndex = <span class="keyword">this</span>.index = index;</div><div class="line">        <span class="keyword">this</span>.baseLimit = limit;</div><div class="line">        <span class="keyword">this</span>.next = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 如果有可能，返回下一个有效节点，否则返回null。</span></div><div class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">advance</span><span class="params">()</span> </span>&#123;</div><div class="line">        Node&lt;K,V&gt; e;</div><div class="line">      	<span class="comment">//获取Node链表的下一个元素e</span></div><div class="line">        <span class="keyword">if</span> ((e = next) != <span class="keyword">null</span>)</div><div class="line">            e = e.next;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            Node&lt;K,V&gt;[] t; <span class="keyword">int</span> i, n;  </div><div class="line">          	<span class="comment">// e不为空，返回e</span></div><div class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> next = e;</div><div class="line">          	<span class="comment">//e为空，说明此链表已经遍历完成，准备遍历下一个hash桶</span></div><div class="line">            <span class="keyword">if</span> (baseIndex &gt;= baseLimit || (t = tab) == <span class="keyword">null</span> ||</div><div class="line">                (n = t.length) &lt;= (i = index) || i &lt; <span class="number">0</span>)</div><div class="line">              	<span class="comment">//到达边界，返回null</span></div><div class="line">                <span class="keyword">return</span> next = <span class="keyword">null</span>;</div><div class="line">          	<span class="comment">//获取下一个hash桶对应的node链表的头节点</span></div><div class="line">            <span class="keyword">if</span> ((e = tabAt(t, i)) != <span class="keyword">null</span> &amp;&amp; e.hash &lt; <span class="number">0</span>) &#123;</div><div class="line">              	<span class="comment">//转发节点,说明此hash桶中的节点已经迁移到了nextTable</span></div><div class="line">                <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ForwardingNode) &#123;</div><div class="line">                    tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;</div><div class="line">                    e = <span class="keyword">null</span>;</div><div class="line">                  	<span class="comment">//保存当前tab的遍历状态</span></div><div class="line">                    pushState(t, i, n);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//红黑树</span></div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeBin)</div><div class="line">                    e = ((TreeBin&lt;K,V&gt;)e).first;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    e = <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (stack != <span class="keyword">null</span>)</div><div class="line">              	<span class="comment">// 此时遍历的是迁移目标nextTable,尝试回退到源table，</span></div><div class="line">                <span class="comment">// 继续遍历源table中的节点</span></div><div class="line">                recoverState(n);</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((index = i + baseSize) &gt;= n)</div><div class="line">              	<span class="comment">//初始tab的hash桶索引+1 ，即遍历下一个hash桶</span></div><div class="line">                index = ++baseIndex; </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 在遇到转发节点时保存遍历状态。</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushState</span><span class="params">(Node&lt;K,V&gt;[] t, <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        TableStack&lt;K,V&gt; s = spare;  <span class="comment">// reuse if possible</span></div><div class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</div><div class="line">            spare = s.next;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            s = <span class="keyword">new</span> TableStack&lt;K,V&gt;();</div><div class="line">        s.tab = t;</div><div class="line">        s.length = n;</div><div class="line">        s.index = i;</div><div class="line">        s.next = stack;</div><div class="line">        stack = s;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">// 可能会弹出遍历状态</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recoverState</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        TableStack&lt;K,V&gt; s; <span class="keyword">int</span> len;</div><div class="line">      <span class="comment">// (s = stack) != null :stack不空，说明此时遍历的是nextTable</span></div><div class="line">      <span class="comment">//  (index += (len = s.length)) &gt;= n: 确保了按照index,</span></div><div class="line">      <span class="comment">//index+tab.length的顺序遍历nextTable,条件成立表示nextTable已经遍历完毕</span></div><div class="line">        </div><div class="line">        <span class="comment">//nextTable中的桶遍历完毕</span></div><div class="line">        <span class="keyword">while</span> ((s = stack) != <span class="keyword">null</span> &amp;&amp; (index += (len = s.length)) &gt;= n) &#123;</div><div class="line">          	<span class="comment">//弹出tab，获取tab的遍历状态，开始遍历tab中的桶</span></div><div class="line">            n = len;</div><div class="line">            index = s.index;</div><div class="line">            tab = s.tab;</div><div class="line">            s.tab = <span class="keyword">null</span>;</div><div class="line">            TableStack&lt;K,V&gt; next = s.next;</div><div class="line">            s.next = spare; <span class="comment">// save for reuse</span></div><div class="line">            stack = next;</div><div class="line">            spare = s;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> &amp;&amp; (index += baseSize) &gt;= n)</div><div class="line">            index = ++baseIndex;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="tryPresize-扩容"><a href="#tryPresize-扩容" class="headerlink" title="tryPresize(扩容)"></a>tryPresize(扩容)</h2><p>协调多个线程如何调用transfer方法进行hash桶的迁移（addCount，helpTransfer 方法中也有类似的逻辑）</p>
<p>tryPresize在putAll以及treeifyBin中调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryPresize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;  </div><div class="line">  	    <span class="comment">//计算扩容的目标size</span></div><div class="line">        <span class="comment">// 给定的容量若&gt;=MAXIMUM_CAPACITY的一半，直接扩容到允许的最大值，否则调用函数扩容  </span></div><div class="line">        <span class="keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY :  </div><div class="line">            tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);  </div><div class="line">        <span class="keyword">int</span> sc;  </div><div class="line">        <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123; <span class="comment">//没有正在初始化或扩容，或者说表还没有被初始化  </span></div><div class="line">            Node&lt;K,V&gt;[] tab = table; <span class="keyword">int</span> n;  </div><div class="line">           <span class="comment">//tab没有初始化	</span></div><div class="line">           <span class="keyword">if</span>(tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;  </div><div class="line">                n = (sc &gt; c) ? sc : c; <span class="comment">// 扩容阀值取较大者  </span></div><div class="line">         <span class="comment">// 期间没有其他线程对表操作，则CAS将SIZECTL状态置为-1，表示正在进行初始化  </span></div><div class="line">             	<span class="comment">//初始化之前，CAS设置sizeCtl=-1</span></div><div class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;  </div><div class="line">                    <span class="keyword">try</span> &#123;  </div><div class="line">                        <span class="keyword">if</span> (table == tab) &#123;  </div><div class="line">                            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)  </div><div class="line">                            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];  </div><div class="line">                            table = nt;  </div><div class="line">                          	<span class="comment">//sc=0.75n,相当于扩容阈值</span></div><div class="line">                            sc = n - (n &gt;&gt;&gt; <span class="number">2</span>); <span class="comment">//无符号右移2位，此即0.75*n  </span></div><div class="line">                        &#125;  </div><div class="line">                    &#125; <span class="keyword">finally</span> &#123;  </div><div class="line">                      	<span class="comment">// 此时并没有通过CAS赋值，因为其他想要执行初始化的线程，</span></div><div class="line">                        <span class="comment">// 发现sizeCtl=-1，就直接返回，从而确保任何情况，</span></div><div class="line">                        <span class="comment">// 只会有一个线程执行初始化操作。</span></div><div class="line">                        sizeCtl = sc;</div><div class="line">                    &#125;  </div><div class="line">                &#125;  </div><div class="line">            &#125;<span class="comment">// 若欲扩容值不大于原阀值，或现有容量&gt;=最值，什么都不用做了 </span></div><div class="line">          	<span class="comment">//目标扩容size小于扩容阈值，或者容量超过最大限制时，不需要扩容</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)  </div><div class="line">                <span class="keyword">break</span>;  </div><div class="line">          	<span class="comment">//扩容</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123; </div><div class="line">                <span class="keyword">int</span> rs = resizeStamp(n);  </div><div class="line">              	<span class="comment">// sc&lt;0表示，已经有其他线程正在扩容</span></div><div class="line">                <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;  </div><div class="line">                    Node&lt;K,V&gt;[] nt;<span class="comment">//RESIZE_STAMP_SHIFT=16,MAX_RESIZERS=2^15-1 </span></div><div class="line">               <span class="comment">// 1. (sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs ：扩容线程数 &gt; MAX_RESIZERS-1</span></div><div class="line">               <span class="comment">// 2. sc == rs + 1 和 sc == rs + MAX_RESIZERS ：表示什么？？？</span></div><div class="line">               <span class="comment">// 3. (nt = nextTable) == null ：表示nextTable正在初始化</span></div><div class="line">               <span class="comment">// transferIndex &lt;= 0 ：表示所有hash桶均分配出去</span></div><div class="line">                    <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||  </div><div class="line">                        sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||  </div><div class="line">                        transferIndex &lt;= <span class="number">0</span>)  </div><div class="line">                      	<span class="comment">//如果不需要帮其扩容，直接返回</span></div><div class="line">                        <span class="keyword">break</span>;  </div><div class="line">                  	<span class="comment">//CAS设置sizeCtl=sizeCtl+1</span></div><div class="line">                    <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) </div><div class="line">                      	<span class="comment">//帮其扩容</span></div><div class="line">                        transfer(tab, nt);  </div><div class="line">                &#125;  </div><div class="line">              	<span class="comment">// 第一个执行扩容操作的线程，将sizeCtl设置为：</span></div><div class="line">                <span class="comment">// (resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</span></div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,  </div><div class="line">                                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))  </div><div class="line">                    transfer(tab, <span class="keyword">null</span>);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;<span class="comment">//和HashMap一样,返回&gt;=n的最小2的自然数幂  </span></div><div class="line">  <span class="keyword">int</span> n = c - <span class="number">1</span>;  </div><div class="line">  n |= n &gt;&gt;&gt; <span class="number">1</span>;  </div><div class="line">  n |= n &gt;&gt;&gt; <span class="number">2</span>;  </div><div class="line">  n |= n &gt;&gt;&gt; <span class="number">4</span>;  </div><div class="line">  n |= n &gt;&gt;&gt; <span class="number">8</span>;  </div><div class="line">  n |= n &gt;&gt;&gt; <span class="number">16</span>;  </div><div class="line">  <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="spread-重新哈希"><a href="#spread-重新哈希" class="headerlink" title="spread 重新哈希"></a>spread 重新哈希</h2><p>spread()重哈希，以减小Hash冲突。我们知道对于一个hash表来说，hash值分散的不够均匀的话会大大增加哈希冲突的概率，从而影响到hash表的性能。因此通过spread方法进行了一次重hash从而大大减小哈希冲突的可能性。spread方法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">static final int spread(int h) &#123;</div><div class="line">  return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法主要是<strong>将key的hashCode的低16位于高16位进行异或运算</strong>，这样不仅能够使得hash值能够分散能够均匀减小hash冲突的概率，另外另外只用到了异或运算，在性能开销上也能兼顾，做到平衡的trade-off。</p>
<h2 id="get-查找"><a href="#get-查找" class="headerlink" title="get(查找)"></a>get(查找)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</div><div class="line">  		 <span class="comment">// 1. 重hash</span></div><div class="line">        <span class="keyword">int</span> h = spread(key.hashCode());</div><div class="line">  </div><div class="line">  		<span class="comment">// 2. table[i]桶节点的key与查找的key相同，则直接返回</span></div><div class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">            <span class="comment">// 唯一一处volatile读操作</span></div><div class="line">            (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;  </div><div class="line">            <span class="comment">// 注意：因为容器大小为2的次方，所以 h mod n = h &amp; (n -1)</span></div><div class="line">          </div><div class="line">            <span class="keyword">if</span> ((eh = e.hash) == h) &#123;<span class="comment">// 如果hash值相等</span></div><div class="line">              	<span class="comment">// 检查第一个Node</span></div><div class="line">                <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</div><div class="line">                    <span class="keyword">return</span> e.val;</div><div class="line">            &#125;</div><div class="line">          	<span class="comment">// hash为负表示是扩容中的ForwardingNode节点</span></div><div class="line">            <span class="comment">// 直接调用ForwardingNode的find方法(可以是代理到扩容中的nextTable)</span></div><div class="line">          	<span class="comment">// 3. 当前节点hash小于0说明为树节点，在红黑树中查找即可</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</div><div class="line">                <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</div><div class="line">            <span class="comment">// 遍历链表，对比key值</span></div><div class="line">          	<span class="comment">// 通过next指针，逐一查找</span></div><div class="line">            <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</div><div class="line">              	<span class="comment">//4. 从链表中查找，查找到则返回该节点的value，否则就返回null即可</span></div><div class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</div><div class="line">                    ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</div><div class="line">                    <span class="keyword">return</span> e.val;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>代码的逻辑请看注释，首先先看当前的hash桶数组节点即table[i]是否为查找的节点，若是则直接返回；若不是，则继续再看当前是不是树节点？通过看节点的hash值是否为小于0，如果小于0则为树节点。如果是树节点在红黑树中查找节点；如果不是树节点，那就只剩下为链表的形式的一种可能性了，就向后遍历查找节点，若查找到则返回节点的value即可，若没有找到就返回null。</p>
<p>这个 get 请求，我们需要 cas 来保证变量的原子性。如果 tab[i] 正被锁住，那么 CAS 就会失败，失败之后就会不断的重试。这也保证了在高并发情况下不会出错。</p>
<p>我们来分析一下哪些情况会导致 get 在并发的情况下可能取不到值。</p>
<ol>
<li>一个线程在 get 的时候，另一个线程在对同一个 key 的 node 进行 remove 操作</li>
<li>一个线程在 get 的时候，另一个线程正在重排 table 。可能导致旧 table 取不到值</li>
</ol>
<p>那么本质是，我在get的时候，有其他线程在对同一桶的链表或树进行修改。那么get是怎么保证同步性的呢？我们看到e = tabAt(tab, (n - 1) &amp; h)) != null，在看下tablAt到底是干嘛的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123;</div><div class="line">    return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它是对tab[i]进行原子性的读取，因为我们知道putVal等对table的桶操作是有加锁的，那么一般情况下我们对桶的读也是要加锁的，但是我们这边为什么不需要加锁呢？因为我们用了Unsafe的getObjectVolatile，因为table是volatile类型，所以对tab[i]的原子请求也是可见的。因为如果同步正确的情况下，根据happens-before原则，<strong>对volatile域的写入操作happens-before于每一个后续对同一域的读操作</strong>。所以不管其他线程对table链表或树的修改，都对get读取可见。用一张图说明，协调读-写线程可见示意图：</p>
<p>jdk7是没有用到CAS操作和Unsafe类的，下面是jdk7的get方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">V get(Object key, int hash) &#123; </div><div class="line">            if(count != 0) &#123;       // 首先读 count 变量</div><div class="line">                HashEntry&lt;K,V&gt; e = getFirst(hash); </div><div class="line">                while(e != null) &#123; </div><div class="line">                    if(e.hash == hash &amp;&amp; key.equals(e.key)) &#123; </div><div class="line">                        V v = e.value; </div><div class="line">                        if(v != null)            </div><div class="line">                            return v; </div><div class="line">                        // 如果读到 value 域为 null，说明发生了重排序，加锁后重新读取</div><div class="line">                        return readValueUnderLock(e); </div><div class="line">                    &#125; </div><div class="line">                    e = e.next; </div><div class="line">                &#125; </div><div class="line">            &#125; </div><div class="line">            return null; </div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>为什么我们在get的时候需要判断count不等于0呢？如果是在HashMap的源码中是没有这个判断的，不用判断不是也是可以的吗？这个就是用到线程安全发布情况下happens-before原则之volatile变量法则：<strong>对volatile域的写入操作happens-before于每一个后续对同一域的读操作</strong>，看下面的示意图：</p>
<h2 id="tabAt"><a href="#tabAt" class="headerlink" title="tabAt"></a>tabAt</h2><p>以 volatile 读的方式读取 table 数组中的元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这边为什么i要等于((long)i &lt;&lt; ASHIFT) + ABASE呢,计算偏移量</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">  <span class="comment">// Key对应的数组元素的可见性，由Unsafe的getObjectVolatile方法保证。</span></div><div class="line">  <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>tabAt 方法用来获取table数组中索引为i的Node元素。</p>
<h2 id="put-putVal"><a href="#put-putVal" class="headerlink" title="put/putVal"></a>put/putVal</h2><p>putVal是将一个新key-value mapping插入到当前ConcurrentHashMap的关键方法。</p>
<p>此方法的具体流程如下图：</p>
<p><img src="https://blogimg.nos-eastchina1.126.net/171214/CEj7GLmk1G.png" alt="mark"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</div><div class="line">    <span class="comment">// 不允许 key 和 value 为空</span></div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">  	<span class="comment">// 1.计算 key 的 hash 值(计算新节点的hash值)</span></div><div class="line">    <span class="keyword">int</span> hash = spread(key.hashCode()); <span class="comment">// 返回 (h^(h&gt;&gt;&gt;16))&amp;HASH_BITS</span></div><div class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</div><div class="line">  	<span class="comment">// 获取当前table，进入死循环,直到插入成功！</span></div><div class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123; </div><div class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</div><div class="line">      	<span class="comment">// 2. 如果当前 table 还没初始化先调用 initTable 方法将 tab 进行初始化</span></div><div class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">            tab = initTable(); <span class="comment">// 如果table为空，执行初始化，也即是延迟初始化</span></div><div class="line">      	<span class="comment">// 3. tab中索引为i的位置的元素为null,则直接使用 CAS 将值插入即可</span></div><div class="line">      	<span class="comment">// 如果bin为空，则采用cas算法赋值，无需加锁</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,<span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</div><div class="line">              	<span class="comment">// 直接设置为桶首节点成功，退出死循环（出口之一）</span></div><div class="line">                <span class="keyword">break</span>;              </div><div class="line">        &#125;</div><div class="line">      	<span class="comment">// 4. 当前正在扩容</span></div><div class="line">      	<span class="comment">// 当前桶首节点正在特殊的扩容状态下，当前线程尝试参与扩容</span></div><div class="line">        <span class="comment">// 然后重新进入死循环</span></div><div class="line">        <span class="comment">//f.hash == MOVED 表示为：ForwardingNode，说明其他线程正在扩容</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) <span class="comment">// MOVED = -1 </span></div><div class="line">            tab = helpTransfer(tab, f); <span class="comment">// 当发现其他线程扩容时，帮其扩容</span></div><div class="line">       <span class="comment">// 通过桶首节点，将新节点加入table</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            V oldVal = <span class="keyword">null</span>;</div><div class="line">          	<span class="comment">// 获取桶首节点实例对象锁，进入临界区进行添加操作</span></div><div class="line">            <span class="keyword">synchronized</span> (f) &#123;</div><div class="line">              	<span class="comment">// 再判断以此f是否仍是第一个Node，如果不是，退出临界区，重复添加操作</span></div><div class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</div><div class="line">                    <span class="comment">//5. 当前为链表，在链表中插入新的键值对</span></div><div class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; <span class="comment">// 桶首节点hash值&gt;0，表示为链表</span></div><div class="line">                        binCount = <span class="number">1</span>;</div><div class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</div><div class="line">                            K ek;</div><div class="line">                          	<span class="comment">// 找到hash值相同的key,覆盖旧值即可</span></div><div class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                                ((ek = e.key) == key ||</div><div class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</div><div class="line">                                oldVal = e.val;</div><div class="line">                              	<span class="comment">// 仅 putIfAbsent() 方法中的 onlyIfAbsend 为 true;</span></div><div class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">                                  	<span class="comment">// putIfAbsend() 包含 key 则返回 get ,否则 put 并返回</span></div><div class="line">                                    e.val = value; </div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            &#125;</div><div class="line">                            Node&lt;K,V&gt; pred = e;</div><div class="line">                            <span class="comment">//如果到链表末尾仍未找到，则直接将新值插入到链表末尾即可</span></div><div class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</div><div class="line">                                                          value, <span class="keyword">null</span>);</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                  	<span class="comment">// 桶首节点为Node子类型TreeBin，表示为红黑树</span></div><div class="line">                    <span class="comment">// 6.当前为红黑树，将新的键值对插入到红黑树中</span></div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</div><div class="line">                        Node&lt;K,V&gt; p;</div><div class="line">                        binCount = <span class="number">2</span>;</div><div class="line">                      	<span class="comment">// 调用putTreeVal方法，插入新值</span></div><div class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</div><div class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</div><div class="line">                          	<span class="comment">// key已经存在，则替换</span></div><div class="line">                            oldVal = p.val;</div><div class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">                                p.val = value;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">             <span class="comment">// 7.插入完键值对后再根据实际大小看是否需要转换成红黑树</span></div><div class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</div><div class="line">                  	<span class="comment">// 插入新节点后，达到链表转换红黑树阈值，则执行转换操作</span></div><div class="line">                  	<span class="comment">// 此函数内部会判断是树化，还是扩容：tryPresize</span></div><div class="line">                    treeifyBin(tab, i);</div><div class="line">              	<span class="comment">// 退出死循环（出口之二）</span></div><div class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</div><div class="line">                    <span class="keyword">return</span> oldVal;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  	<span class="comment">// 更新计算count时的base和counterCells数组</span></div><div class="line">  	<span class="comment">//8.对当前容量大小进行检查，如果超过了临界值（实际大小*加载因子）就需要扩容 </span></div><div class="line">    addCount(<span class="number">1L</span>, binCount);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当table[i]为链表的头结点，在链表中插入新值在table[i]不为null并且不为forwardingNode时，并且当前Node f的hash值大于0（fh &gt;= 0）的话说明当前节点f为当前桶的所有的节点组成的链表的头结点。那么接下来，要想向ConcurrentHashMap插入新值的话就是向这个链表插入新值。通过synchronized (f)的方式进行加锁以实现线程安全性。往链表中插入节点的部分代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</div><div class="line">    binCount = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</div><div class="line">        K ek;</div><div class="line">        <span class="comment">// 找到hash值相同的key,覆盖旧值即可</span></div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">            ((ek = e.key) == key ||</div><div class="line">             (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</div><div class="line">            oldVal = e.val;</div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">                e.val = value;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        Node&lt;K,V&gt; pred = e;</div><div class="line">        <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//如果到链表末尾仍未找到，则直接将新值插入到链表末尾即可</span></div><div class="line">            pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</div><div class="line">                                      value, <span class="keyword">null</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这部分代码很好理解，就是两种情况：1. 在链表中如果找到了与待插入的键值对的key相同的节点，就直接覆盖即可；2. 如果直到找到了链表的末尾都没有找到的话，就直接将待插入的键值对追加到链表的末尾即可。</p>
<p>当table[i]为红黑树的根节点，在红黑树中插入新值按照之前的数组+链表的设计方案，这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，甚至在极端情况下，查找一个节点会出现时间复杂度为O(n)的情况，则会严重影响ConcurrentHashMap的性能，于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高ConcurrentHashMap的性能，其中会用到红黑树的插入、删除、查找等算法。当table[i]为红黑树的树节点时的操作为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</div><div class="line">    Node&lt;K,V&gt; p;</div><div class="line">    binCount = <span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</div><div class="line">                                   value)) != <span class="keyword">null</span>) &#123;</div><div class="line">        oldVal = p.val;</div><div class="line">        <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">            p.val = value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先在if中通过<code>f instanceof TreeBin</code>判断当前table[i]是否是树节点，这下也正好验证了我们在最上面介绍时说的TreeBin会对TreeNode做进一步封装，对红黑树进行操作的时候针对的是TreeBin而不是TreeNode。这段代码很简单，调用putTreeVal方法完成向红黑树插入新节点，同样的逻辑，<strong>如果在红黑树中存在于待插入键值对的Key相同（hash值相等并且equals方法判断为true）的节点的话，就覆盖旧值，否则就向红黑树追加新节点</strong>。</p>
<p>当table[i]为红黑树的根节点，在红黑树中插入新值。按照之前的数组+链表的设计方案，这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，甚至在极端情况下，查找一个节点会出现时间复杂度为O(n)的情况，则会严重影响ConcurrentHashMap的性能，于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高ConcurrentHashMap的性能，其中会用到红黑树的插入、删除、查找等算法。当table[i]为红黑树的树节点时的操作为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</div><div class="line"> Node&lt;K,V&gt; p;</div><div class="line"> binCount = <span class="number">2</span>;</div><div class="line"> <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,value)) != <span class="keyword">null</span>) &#123;</div><div class="line"> 			oldVal = p.val;</div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">            p.val = value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先在if中通过<code>f instanceof TreeBin</code>判断当前table[i]是否是树节点，这下也正好验证了我们在最上面介绍时说的TreeBin会对TreeNode做进一步封装，对红黑树进行操作的时候针对的是TreeBin而不是TreeNode。这段代码很简单，调用putTreeVal方法完成向红黑树插入新节点，同样的逻辑，<strong>如果在红黑树中存在于待插入键值对的Key相同（hash值相等并且equals方法判断为true）的节点的话，就覆盖旧值，否则就向红黑树追加新节点</strong>。</p>
<p>根据当前节点个数进行调整当完成数据新节点插入之后，会进一步对当前链表大小进行调整，这部分代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (binCount != 0) &#123;</div><div class="line">    if (binCount &gt;= TREEIFY_THRESHOLD)</div><div class="line">        treeifyBin(tab, i);</div><div class="line">    if (oldVal != null)</div><div class="line">        return oldVal;</div><div class="line">    break;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很容易理解，如果当前链表节点个数大于等于8（TREEIFY_THRESHOLD）的时候，就会调用treeifyBin方法将tabel[i]（第i个散列桶）拉链转换成红黑树。</p>
<p><strong>关于Put方法的逻辑就基本说的差不多了，现在来做一些总结：</strong></p>
<p><strong>整体流程：</strong></p>
<ol>
<li>首先对于每一个放入的值，首先利用spread方法对key的hashcode进行一次hash计算，由此来确定这个值在 table中的位置；</li>
<li>如果当前table数组还未初始化，先将table数组进行初始化操作；</li>
<li>如果这个位置是null的，那么使用CAS操作直接放入；</li>
<li>如果这个位置存在结点，说明发生了hash碰撞，首先判断这个节点的类型。如果该节点fh==MOVED(代表forwardingNode,数组正在进行扩容)的话，说明正在进行扩容；</li>
<li>如果是链表节点（fh&gt;0）,则得到的结点就是hash值相同的节点组成的链表的头节点。需要依次向后遍历确定这个新加入的值所在位置。如果遇到hash值与key值都与新加入节点是一致的情况，则只需要更新value值即可。否则依次向后遍历，直到链表尾插入这个结点；</li>
<li>如果这个节点的类型是TreeBin的话，直接调用红黑树的插入方法进行插入新的节点；</li>
<li>插入完节点之后再次检查链表长度，如果长度大于8，就把这个链表转换成红黑树；</li>
<li>对当前容量大小进行检查，如果超过了临界值（实际大小*加载因子）就需要扩容。</li>
</ol>
<p><strong>该流程中，可以细细品味的环节有： - 初始化方法 initTable - 扩容方法 transfer (在多线程扩容方法 helpTransfer 中被调用)</strong></p>
<h2 id="initTable"><a href="#initTable" class="headerlink" title="initTable"></a>initTable</h2><p>initTable方法允许多线程同时进入，但只有一个线程可以完成table的初始化，其他线程都会通过yield方法让出cpu。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</div><div class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</div><div class="line">      	<span class="comment">// 前文提及sizeCtl是重要的控制变量</span></div><div class="line">        <span class="comment">// sizeCtl = -1 表示正在初始化</span></div><div class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</div><div class="line">            <span class="comment">// 已经有其他线程在执行初始化，则主动让出cpu</span></div><div class="line">            <span class="comment">// 1. 保证只有一个线程正在进行初始化操作</span></div><div class="line">            Thread.yield();</div><div class="line">      </div><div class="line">      	<span class="comment">// 利用CAS操作设置sizeCtl为-1</span></div><div class="line">        <span class="comment">// 设置成功表示当前线程为执行初始化的唯一线程</span></div><div class="line">        <span class="comment">// 此处进入临界区</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">              	<span class="comment">// 由于让出cpu的线程也会后续进入该临界区</span></div><div class="line">                <span class="comment">// 需要进行再次确认table是否为null</span></div><div class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</div><div class="line">                    <span class="comment">// 2. 得出数组的大小</span></div><div class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</div><div class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">                    <span class="comment">// 3. 这里才真正的初始化数组，即分配Node数组</span></div><div class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</div><div class="line">                    table = tab = nt;</div><div class="line">                  	<span class="comment">// 默认负载为0.75</span></div><div class="line">                    <span class="comment">// 4. 计算数组中可用的大小：实际大小n*0.75（加载因子）</span></div><div class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                sizeCtl = sc;</div><div class="line">            &#125;</div><div class="line">          	<span class="comment">// 退出死循环的唯一出口</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> tab;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码的逻辑请见注释，有可能存在一个情况是多个线程同时走到这个方法中，为了保证能够正确初始化，在第1步中会先通过if进行判断，<strong>若当前已经有一个线程正在初始化即sizeCtl值变为-1</strong>，这个时候其他线程在If判断为true从而调用Thread.yield()让出CPU时间片。正在进行初始化的线程会调用U.compareAndSwapInt方法将sizeCtl改为-1即正在初始化的状态。另外还需要注意的事情是，在第四步中会进一步计算数组中可用的大小即为数组实际大小n乘以加载因子0.75.可以看看这里乘以0.75是怎么算的，0.75为四分之三，这里<code>n - (n &gt;&gt;&gt; 2)</code>是不是刚好是n-(1/4)n=(3/4)n，挺有意思的吧:)。如果选择是无参的构造器的话，这里在new Node数组的时候会使用默认大小为<code>DEFAULT_CAPACITY</code>（16），然后乘以加载因子0.75为12，也就是说数组的可用大小为12。</p>
<h2 id="casTabAt-原子操作方法"><a href="#casTabAt-原子操作方法" class="headerlink" title="casTabAt(原子操作方法)"></a>casTabAt(原子操作方法)</h2><p>以 CAS 的方式，将元素插入到 table 数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">  *这边为什么i要等于((long)i &lt;&lt; ASHIFT) + ABASE呢,计算偏移量</div><div class="line">  *ASHIFT是指tab[i]中第i个元素在相对于数组第一个元素的偏移量，而ABASE就算第一数组的内存素的偏移地址</div><div class="line">  *所以呢，((long)i &lt;&lt; ASHIFT) + ABASE就算i最后的地址</div><div class="line">  * 那么compareAndSwapObject的作用就算tab[i]和c比较，如果相等就tab[i]=v否则tab[i]=c;</div><div class="line">  */</div><div class="line">  <span class="comment">// 利用CAS算法设置i位置上的Node节点（将c和table[i]比较，相同则插入v）。  </span></div><div class="line">  <span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,  </span></span></div><div class="line">                                      Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123;  </div><div class="line">    	<span class="comment">//原子的执行如下逻辑：如果tab[i]==c,则设置tab[i]=v，并返回ture.否则返回false</span></div><div class="line">      <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);  </div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>利用CAS操作设置table数组中索引为i的元素</p>
<h2 id="setTabAt"><a href="#setTabAt" class="headerlink" title="setTabAt"></a>setTabAt</h2><p>以 valatile 写的方式，将元素插入 table 数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">static final &lt;K,V&gt; void setTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v) &#123;</div><div class="line">    U.putObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, v);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法用来设置table数组中索引为i的元素</p>
<h2 id="实例构造器方法"><a href="#实例构造器方法" class="headerlink" title="实例构造器方法"></a>实例构造器方法</h2><p>在使用ConcurrentHashMap第一件事自然而然就是new 出来一个ConcurrentHashMap对象，一共提供了如下几个构造器方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 构造一个空的map，即table数组还未初始化，初始化放在第一次插入数据时，默认大小为16</span></div><div class="line">ConcurrentHashMap()</div><div class="line"><span class="comment">// 2. 给定map的大小</span></div><div class="line">ConcurrentHashMap(<span class="keyword">int</span> initialCapacity) </div><div class="line"><span class="comment">// 3. 给定一个map</span></div><div class="line">ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)</div><div class="line"><span class="comment">// 4. 给定map的大小以及加载因子</span></div><div class="line">ConcurrentHashMap(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</div><div class="line"><span class="comment">// 5. 给定map大小，加载因子以及并发度（预计同时操作数据的线程）</span></div><div class="line">ConcurrentHashMap(<span class="keyword">int</span> initialCapacity,<span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</div></pre></td></tr></table></figure>
<p>ConcurrentHashMap一共给我们提供了5中构造器方法，具体使用请看注释，我们来看看第2种构造器，传入指定大小时的情况，该构造器源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">//1. 小于0直接抛异常</span></div><div class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">    <span class="comment">//2. 判断是否超过了允许的最大值，超过了话则取最大值，否则再对该值进一步处理</span></div><div class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</div><div class="line">               MAXIMUM_CAPACITY :</div><div class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</div><div class="line">    <span class="comment">//3. 赋值给sizeCtl</span></div><div class="line">    <span class="keyword">this</span>.sizeCtl = cap;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码的逻辑请看注释，很容易理解，如果小于0就直接抛出异常，如果指定值大于了所允许的最大值的话就取最大值，否则，在对指定值做进一步处理。最后将cap赋值给sizeCtl,关于sizeCtl的说明请看上面的说明，<strong>当调用构造器方法之后，sizeCtl的大小应该就代表了ConcurrentHashMap的大小，即table数组长度</strong>。tableSizeFor做了哪些事情了？源码为：</p>
<h2 id="tableSizeFor"><a href="#tableSizeFor" class="headerlink" title="tableSizeFor"></a>tableSizeFor</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private static final int tableSizeFor(int c) &#123;</div><div class="line">    int n = c - 1;</div><div class="line">    n |= n &gt;&gt;&gt; 1;</div><div class="line">    n |= n &gt;&gt;&gt; 2;</div><div class="line">    n |= n &gt;&gt;&gt; 4;</div><div class="line">    n |= n &gt;&gt;&gt; 8;</div><div class="line">    n |= n &gt;&gt;&gt; 16;</div><div class="line">    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过注释就很清楚了，该方法会将调用构造器方法时指定的大小转换成一个2的幂次方数，也就是说ConcurrentHashMap的大小一定是2的幂次方，比如，当指定大小为18时，为了满足2的幂次方特性，实际上concurrentHashMapd的大小为2的5次方（32）。另外，需要注意的是，<strong>调用构造器方法的时候并未构造出table数组（可以理解为ConcurrentHashMap的数据容器），只是算出table数组的长度，当第一次向ConcurrentHashMap插入数据的时候才真正的完成初始化创建table数组的工作</strong>。</p>
<h2 id="helpTransfer-协助扩容"><a href="#helpTransfer-协助扩容" class="headerlink" title="helpTransfer(协助扩容)"></a>helpTransfer(协助扩容)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 协助扩容方法。多线程下，当前线程检测到其他线程正进行扩容操作，则协助其一起扩容；（只有这种情况会被调用）从某种程度上说，其“优先级”很高，只要检测到扩容，就会放下其他工作，先扩容。  </span></div><div class="line"><span class="comment">// 调用之前，nextTable一定已存在。  </span></div><div class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;  </div><div class="line">    Node&lt;K,V&gt;[] nextTab; intsc;  </div><div class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (finstanceof ForwardingNode) &amp;&amp;  </div><div class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;  </div><div class="line">        intrs = resizeStamp(tab.length); <span class="comment">//标志位  </span></div><div class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;  </div><div class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;  </div><div class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||  </div><div class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)  </div><div class="line">                <span class="keyword">break</span>;  </div><div class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;  </div><div class="line">                transfer(tab, nextTab);<span class="comment">//调用扩容方法，直接进入复制阶段  </span></div><div class="line">                <span class="keyword">break</span>;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> nextTab;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> table;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="addCount"><a href="#addCount" class="headerlink" title="addCount"></a>addCount</h2><p>在put方法结尾处调用了addCount方法，把当前ConcurrentHashMap的元素个数+1这个方法一共做了两件事,更新baseCount的值，检测是否进行扩容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</div><div class="line">     CounterCell[] as; <span class="keyword">long</span> b, s;</div><div class="line">  </div><div class="line">  	<span class="comment">//利用CAS方法更新baseCount的值</span></div><div class="line">     <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</div><div class="line">         !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;<span class="comment">// 1</span></div><div class="line">         CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</div><div class="line">         <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</div><div class="line">         <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</div><div class="line">             (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</div><div class="line">             !(uncontended =</div><div class="line">               U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</div><div class="line">           	<span class="comment">// 多线程 CAS 发生失败的时候执行</span></div><div class="line">             fullAddCount(x, uncontended); <span class="comment">// 2</span></div><div class="line">             <span class="keyword">return</span>;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</div><div class="line">             <span class="keyword">return</span>;</div><div class="line">         s = sumCount();</div><div class="line">     &#125;</div><div class="line">  	<span class="comment">//如果check值大于等于0 则需要检验是否需要进行扩容操作</span></div><div class="line">     <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</div><div class="line">         Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</div><div class="line">       	<span class="comment">// 当条件满足的时候开始扩容</span></div><div class="line">         <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">                (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</div><div class="line">             <span class="keyword">int</span> rs = resizeStamp(n);</div><div class="line">           	<span class="comment">// 如果小于0 说明已经有线程在进行扩容了</span></div><div class="line">             <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</div><div class="line">     <span class="comment">// 一下的情况说明已经有在扩容或者多线程进行了扩容，其他线程直接 break 不要进入扩容</span></div><div class="line">                 <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</div><div class="line">                     sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</div><div class="line">                     transferIndex &lt;= <span class="number">0</span>)</div><div class="line">                     <span class="keyword">break</span>;</div><div class="line">               	<span class="comment">// 如果已经有其他线程在执行扩容操作</span></div><div class="line">               	<span class="comment">// 如果相等说明已经完成，可以继续扩容</span></div><div class="line">                 <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</div><div class="line">                     transfer(tab, nt);</div><div class="line">             &#125;</div><div class="line">           	<span class="comment">// 当前线程是唯一的或是第一个发起扩容的线程  此时nextTable=null</span></div><div class="line">    			<span class="comment">// 这个时候 sizeCtl 已经等于(rs&lt;&lt;RESIZE_STAMP_SHIFT)+2 等于一个大的负数，这边</span></div><div class="line">           	<span class="comment">// 加上2很巧，因为 transfer 后面对 sizeCtl-- 操作的时候，最多只能减两个就结束</span></div><div class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</div><div class="line">                                          (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</div><div class="line">                 transfer(tab, <span class="keyword">null</span>);</div><div class="line">             s = sumCount();</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>看上面的注释1,每次都会对 baseCount 加1,如果并发竞争太大，那么可能导致 U.compareAndSwapLong(this,BASECOUNT,b=baseCount,s = b + x) 失败,那么为了提高高并发的时候 baseCount 可见性的失败的问题,又避免一直重试，这样性能会有很大的影响,那么在 jdk 8的时候是有引入一个类 Striped64 ,其中 LongAdder 和 DoubleAdder 就是对这个类的实现。这两个方法都是为了解决高并发场景而生的，是 AtomicLong 的加强版,AtomicLong 在高并发场景性能会比 LongAdder 差。但是 LongAdder 的空间复杂度会高点。</p>
<h2 id="fullAddCount"><a href="#fullAddCount" class="headerlink" title="fullAddCount"></a>fullAddCount</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">fullAddCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</div><div class="line">     <span class="keyword">int</span> h;</div><div class="line">     <span class="comment">// 获取当前线程的 probe 值作为 hash 值,如果0则强制初始化当前线程的 Probe 值，</span></div><div class="line">  	<span class="comment">// 初始化 probe 值不为 0</span></div><div class="line">     <span class="keyword">if</span> ((h = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</div><div class="line">         ThreadLocalRandom.localInit();      <span class="comment">// force initialization</span></div><div class="line">         h = ThreadLocalRandom.getProbe();</div><div class="line">       	<span class="comment">// 设置未竞争标记为true</span></div><div class="line">         wasUncontended = <span class="keyword">true</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></div><div class="line">     <span class="keyword">for</span> (;;) &#123;</div><div class="line">         CounterCell[] as; CounterCell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</div><div class="line">         <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</div><div class="line">             <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</div><div class="line">               	<span class="comment">// Try to attach new Cell 如果当前没有 CounterCell 就创建一个</span></div><div class="line">                 <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;            </div><div class="line">                     CounterCell r = <span class="keyword">new</span> CounterCell(x); <span class="comment">// Optimistic create</span></div><div class="line">                     <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</div><div class="line">                         <span class="comment">// 这边加上 cellsBusy 锁  </span></div><div class="line">                         U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</div><div class="line">                         <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</div><div class="line">                         <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></div><div class="line">                             CounterCell[] rs; <span class="keyword">int</span> m, j;</div><div class="line">                             <span class="keyword">if</span> ((rs = counterCells) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">                                 (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">                                 rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;</div><div class="line">                                 rs[j] = r;</div><div class="line">                                 created = <span class="keyword">true</span>;</div><div class="line">                             &#125;</div><div class="line">                         &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                             <span class="comment">// 释放 cellsBusy 锁定，让其他线程可以进来</span></div><div class="line">                             cellsBusy = <span class="number">0</span>; </div><div class="line">                         &#125;</div><div class="line">                         <span class="keyword">if</span> (created)</div><div class="line">                             <span class="keyword">break</span>;</div><div class="line">                         <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></div><div class="line">                     &#125;</div><div class="line">                 &#125;</div><div class="line">                 collide = <span class="keyword">false</span>;</div><div class="line">             &#125;</div><div class="line">           	<span class="comment">// wasUncontended 为 false 说明已经发生了竞争，重置为true重新执行上面代码</span></div><div class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></div><div class="line">                 wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></div><div class="line">           	<span class="comment">// 对 cell 的值进行累计x(1)</span></div><div class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</div><div class="line">                 <span class="keyword">break</span>;</div><div class="line">           	<span class="comment">// 表明 as 已经过时，说明 cells 已经初始化完成，看下面，</span></div><div class="line">           	<span class="comment">// 重置 collide 为 false 表明已经存在竞争</span></div><div class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (counterCells != as || n &gt;= NCPU)</div><div class="line">                 collide = <span class="keyword">false</span>;            <span class="comment">// At max size or stale</span></div><div class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</div><div class="line">                 collide = <span class="keyword">true</span>;</div><div class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</div><div class="line">                      U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</div><div class="line">                 <span class="keyword">try</span> &#123;</div><div class="line">                   	<span class="comment">// 下面的方法主要是给 counterCells 扩容，尽可能避免冲突</span></div><div class="line">                     <span class="keyword">if</span> (counterCells == as) &#123;<span class="comment">// Expand table unless stale</span></div><div class="line">                         CounterCell[] rs = <span class="keyword">new</span> CounterCell[n &lt;&lt; <span class="number">1</span>];</div><div class="line">                         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">                             rs[i] = as[i];</div><div class="line">                         counterCells = rs;</div><div class="line">                     &#125;</div><div class="line">                 &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                     cellsBusy = <span class="number">0</span>;</div><div class="line">                 &#125;</div><div class="line">                 collide = <span class="keyword">false</span>;</div><div class="line">                 <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></div><div class="line">             &#125;</div><div class="line">             h = ThreadLocalRandom.advanceProbe(h);</div><div class="line">         &#125;</div><div class="line">       	<span class="comment">// 表明 counterCells 还没初始化，则初始化，这边用 cellsBusy 加锁</span></div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; counterCells == as &amp;&amp;</div><div class="line">                  U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</div><div class="line">             <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</div><div class="line">             <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></div><div class="line">                 <span class="keyword">if</span> (counterCells == as) &#123;</div><div class="line">                     CounterCell[] rs = <span class="keyword">new</span> CounterCell[<span class="number">2</span>];</div><div class="line">                     rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> CounterCell(x);</div><div class="line">                     counterCells = rs;</div><div class="line">                     init = <span class="keyword">true</span>;</div><div class="line">                 &#125;</div><div class="line">             &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                 cellsBusy = <span class="number">0</span>;</div><div class="line">             &#125;</div><div class="line">             <span class="keyword">if</span> (init)</div><div class="line">                 <span class="keyword">break</span>;</div><div class="line">         &#125;</div><div class="line">       	<span class="comment">// 最终如果上面的都失败就把 x 累计到 baseCount</span></div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, v = baseCount, v + x))</div><div class="line">             <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>回到 addCount 来,我们每次竞争都对 baseCount 进行加 1 当达到一定的容量时，就需要对 table 进行扩容。 使用 transfer 方法。</p>
<h2 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h2><p>负责迁移node节点</p>
<p>扩容transfer方法是一个设计极为精巧的方法。通过互斥读写ForwardingNode，多线程可以协同完成扩容任务。</p>
<p><img src="https://blogimg.nos-eastchina1.126.net/171214/k7LKAjJm0m.png" alt="mark"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = tab.length, stride;</div><div class="line">  		<span class="comment">//计算每次迁移的node个数（MIN_TRANSFER_STRIDE该值作为下限，以避免扩容线程过多）</span></div><div class="line">        <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</div><div class="line">          	<span class="comment">// 确保每次迁移的node个数不少于16个</span></div><div class="line">            stride = MIN_TRANSFER_STRIDE; </div><div class="line">  		<span class="comment">// nextTab为扩容中的临时table</span></div><div class="line">        <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">              	<span class="comment">//扩容一倍	</span></div><div class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">              	<span class="comment">// 1. 新建一个 node 数组，容量为之前的两倍</span></div><div class="line">                Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</div><div class="line">                nextTab = nt;</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></div><div class="line">                sizeCtl = Integer.MAX_VALUE;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            nextTable = nextTab;</div><div class="line">          	<span class="comment">// transferIndex为扩容复制过程中的桶首节点遍历索引</span></div><div class="line">            <span class="comment">// 所以从n开始，表示从后向前遍历</span></div><div class="line">            transferIndex = n;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> nextn = nextTab.length;</div><div class="line">  		<span class="comment">// ForwardingNode是Node节点的直接子类，是扩容过程中的特殊桶首节点</span></div><div class="line">      	<span class="comment">// 该类中没有key,value,next</span></div><div class="line">      	<span class="comment">// hash值为特定的-1</span></div><div class="line">        <span class="comment">// 附加Node&lt;K,V&gt;[] nextTable变量指向扩容中的nextTab</span></div><div class="line">        <span class="comment">// 在find方法中，将扩容中的查询操作导入到nextTab上</span></div><div class="line">  		<span class="comment">//2. 新建forwardingNode引用，在之后会用到</span></div><div class="line">        ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</div><div class="line">        <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</div><div class="line">  		<span class="comment">// 循环的关键变量，判断是否已经扩容完成，完成就 return , 退出循环</span></div><div class="line">        <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; </div><div class="line">  		 <span class="comment">//【1】逆序迁移已经获取到的hash桶集合，如果迁移完毕，则更新transferIndex，</span></div><div class="line">         <span class="comment">// 获取下一批待迁移的hash桶</span></div><div class="line">         <span class="comment">//【2】如果transferIndex=0，表示所以hash桶均被分配，将i置为-1，</span></div><div class="line">  		<span class="comment">// 准备退出transfer方法</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</div><div class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</div><div class="line">          	<span class="comment">// 3. 确定遍历中的索引i（更新待迁移的hash桶索引）</span></div><div class="line">          	<span class="comment">// 循环的关键 i , i-- 操作保证了倒叙遍历数组</span></div><div class="line">            <span class="keyword">while</span> (advance) &#123;</div><div class="line">                <span class="keyword">int</span> nextIndex, nextBound;</div><div class="line">              	<span class="comment">// 更新迁移索引i</span></div><div class="line">                <span class="keyword">if</span> (--i &gt;= bound || finishing)</div><div class="line">                    advance = <span class="keyword">false</span>;</div><div class="line">              	<span class="comment">// transferIndex = 0表示table中所有数组元素都已经有其他线程负责扩容</span></div><div class="line">              	<span class="comment">// nextIndex=transferIndex=n=tab.length(默认16)</span></div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</div><div class="line">                  	<span class="comment">// transferIndex&lt;=0表示已经没有需要迁移的hash桶，</span></div><div class="line">                  	<span class="comment">// 将i置为-1，线程准备退出</span></div><div class="line">                    i = -<span class="number">1</span>;</div><div class="line">                    advance = <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">             <span class="comment">//cas无锁算法设置 transferIndex = transferIndex - stride		</span></div><div class="line">             <span class="comment">// 尝试更新transferIndex，获取当前线程执行扩容复制的索引区间</span></div><div class="line">             <span class="comment">// 更新成功，则当前线程负责完成索引为(nextBound，nextIndex)之间的桶首节点扩容</span></div><div class="line">             <span class="comment">//当迁移完bound这个桶后，尝试更新transferIndex，获取下一批待迁移的hash桶</span></div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</div><div class="line">                         (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</div><div class="line">                          nextBound = (nextIndex &gt; stride ?</div><div class="line">                                       nextIndex - stride : <span class="number">0</span>))) &#123;</div><div class="line">                    bound = nextBound;</div><div class="line">                    i = nextIndex - <span class="number">1</span>;</div><div class="line">                    advance = <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="comment">//退出transfer</span></div><div class="line">          	<span class="comment">//4.将原数组中的元素复制到新数组中去</span></div><div class="line">            <span class="comment">//4.5 for循环退出，扩容结束修改sizeCtl属性</span></div><div class="line"><span class="comment">// i&lt;0 说明已经遍历完旧的数组tab;i&gt;=n什么时候有可能呢？在下面看到i=n,所以目前i最大应该是n吧</span></div><div class="line"><span class="comment">// i+n&gt;=nextn,nextn=nextTab.length,所以如果满足i+n&gt;=nextn说明已经扩容完成</span></div><div class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</div><div class="line">                <span class="keyword">int</span> sc;</div><div class="line">                <span class="keyword">if</span> (finishing) &#123;   <span class="comment">// a</span></div><div class="line">                  	<span class="comment">//最后一个迁移的线程，recheck后，做收尾工作，然后退出</span></div><div class="line">                    nextTable = <span class="keyword">null</span>;</div><div class="line">                    table = nextTab;</div><div class="line">                  	<span class="comment">// 扩容成功，设置新sizeCtl，仍然为总大小的0.75</span></div><div class="line">                    sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">			</div><div class="line">                <span class="comment">// 第一个扩容的线程，执行transfer方法之前，会设置 sizeCtl = </span></div><div class="line">                <span class="comment">// (resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) + 2) 	</span></div><div class="line">                <span class="comment">// 后续帮其扩容的线程，执行transfer方法之前，会设置 sizeCtl = sizeCtl+1</span></div><div class="line">                <span class="comment">// 每一个退出transfer的方法的线程，退出之前，会设置 sizeCtl = sizeCtl-1</span></div><div class="line">                <span class="comment">// 那么最后一个线程退出时：</span></div><div class="line">                <span class="comment">// 必然有sc == (resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) + 2)，</span></div><div class="line">                <span class="comment">// 即 (sc - 2) == resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT</span></div><div class="line">              </div><div class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;                  </div><div class="line">                  	<span class="comment">// 如果有多个线程进行扩容，那么这个值在第二个线程以后就不会相等，因为 </span></div><div class="line">                  	<span class="comment">// sizeCtl 已经被减1了，所以后面的线程只能直接返回，</span></div><div class="line">                  	<span class="comment">// 始终保证只有一个线程执行了a(上面的注释a)</span></div><div class="line">                    <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                  	<span class="comment">// finishing 和 advance 保证线程已经扩容完成了可以退出循环</span></div><div class="line">                    finishing = advance = <span class="keyword">true</span>;</div><div class="line">                  	<span class="comment">//最后退出的线程要重新check下是否全部迁移完毕</span></div><div class="line">                    i = n;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">          	<span class="comment">// 当前table节点为空，不需要复制，直接放入ForwardingNode</span></div><div class="line">          	<span class="comment">//4.1 当前数组中第i个元素为null，用CAS设置成特殊节点forwardingNode(可以理解成占位符)</span></div><div class="line">          	<span class="comment">// 如果 tab[i] 为 null,那么就把 fwd 插入到 tab[i],表明这个节点已经处理过了</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</div><div class="line">                advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</div><div class="line">          	<span class="comment">// 当前table节点已经是ForwardingNode</span></div><div class="line">            <span class="comment">// 表示已经被其他线程处理了，则直接往前遍历</span></div><div class="line">            <span class="comment">// 通过CAS读写ForwardingNode节点状态，达到多线程互斥处理</span></div><div class="line">          	<span class="comment">// 4.2 如果遍历到ForwardingNode节点说明这个点已经被处理过了直接跳过</span></div><div class="line">            <span class="comment">// 这里是控制并发扩容的核心</span></div><div class="line">          	<span class="comment">// 如果 f.hash=-1 的话说明该节点为 ForwardingNode,说明该节点已经处理过了</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</div><div class="line">                advance = <span class="keyword">true</span>; </div><div class="line">          	<span class="comment">//迁移node节点</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">              	<span class="comment">// 锁住当前桶首节点</span></div><div class="line">                <span class="keyword">synchronized</span> (f) &#123;</div><div class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</div><div class="line">                        Node&lt;K,V&gt; ln, hn;</div><div class="line">                      	<span class="comment">// 链表节点复制(链表迁移)</span></div><div class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</div><div class="line">                        <span class="comment">// 4.3 处理当前节点为链表的头结点的情况，构造两个链表，一个是原链表  </span></div><div class="line">                        <span class="comment">// 另一个是原链表的反序排列</span></div><div class="line">                            <span class="keyword">int</span> runBit = fh &amp; n;</div><div class="line">                            Node&lt;K,V&gt; lastRun = f;</div><div class="line">                <span class="comment">//将node链表，分成2个新的node链表</span></div><div class="line">                <span class="comment">// 这边还对链表进行遍历，这边的算法和hashMap的算法又不一样了，对半拆分</span></div><div class="line">                <span class="comment">// 把链表拆分为，hash&amp;n 等于0和不等于0的，然后分别放在新表的i和i+n位置           	</span></div><div class="line">                <span class="comment">// 此方法同 HashMap 的 resize</span></div><div class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</div><div class="line">                                <span class="keyword">int</span> b = p.hash &amp; n;</div><div class="line">                                <span class="keyword">if</span> (b != runBit) &#123;</div><div class="line">                                    runBit = b;</div><div class="line">                                    lastRun = p;</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</div><div class="line">                                ln = lastRun;</div><div class="line">                                hn = <span class="keyword">null</span>;</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">else</span> &#123;</div><div class="line">                                hn = lastRun;</div><div class="line">                                ln = <span class="keyword">null</span>;</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</div><div class="line">                                <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</div><div class="line">                                <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</div><div class="line">                                    ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</div><div class="line">                                <span class="keyword">else</span></div><div class="line">                                    hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</div><div class="line">                            &#125;</div><div class="line">                          	<span class="comment">//将新node链表赋给nextTab</span></div><div class="line">                          	<span class="comment">//在nextTable的i位置上插入一个链表</span></div><div class="line">                            setTabAt(nextTab, i, ln);</div><div class="line">                            <span class="comment">//在nextTable的i+n的位置上插入另一个链表</span></div><div class="line">                            setTabAt(nextTab, i + n, hn);</div><div class="line">                          	<span class="comment">// 扩容成功后，设置ForwardingNode节点</span></div><div class="line">                          	<span class="comment">//在table的i位置上插入forwardNode节点表示已经处理过该节点</span></div><div class="line">                          	<span class="comment">// 把已经替换的节点的旧tab的i的位置用fwd替换，fwd包含nextTab</span></div><div class="line">                            setTabAt(tab, i, fwd);</div><div class="line">                            <span class="comment">//设置advance为true 返回到上面的while循环中 就可以执行i--操作</span></div><div class="line">                            advance = <span class="keyword">true</span>;</div><div class="line">                        &#125;</div><div class="line">                      	<span class="comment">// 红黑树节点复制(红黑树迁移)</span></div><div class="line">                      	<span class="comment">//4.4 处理当前节点是TreeBin时的情况，操作和上面的类似</span></div><div class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</div><div class="line">                            TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</div><div class="line">                            TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</div><div class="line">                            TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line">                            <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</div><div class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">                                <span class="keyword">int</span> h = e.hash;</div><div class="line">                                TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</div><div class="line">                                    (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">                                <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</div><div class="line">                                    <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</div><div class="line">                                        lo = p;</div><div class="line">                                    <span class="keyword">else</span></div><div class="line">                                        loTail.next = p;</div><div class="line">                                    loTail = p;</div><div class="line">                                    ++lc;</div><div class="line">                                &#125;</div><div class="line">                                <span class="keyword">else</span> &#123;</div><div class="line">                                    <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</div><div class="line">                                        hi = p;</div><div class="line">                                    <span class="keyword">else</span></div><div class="line">                                        hiTail.next = p;</div><div class="line">                                    hiTail = p;</div><div class="line">                                    ++hc;</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                          	<span class="comment">// 判断扩容后是否还需要红黑树</span></div><div class="line">                            ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</div><div class="line">                                (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</div><div class="line">                            hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</div><div class="line">                                (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</div><div class="line">                            setTabAt(nextTab, i, ln);</div><div class="line">                            setTabAt(nextTab, i + n, hn);</div><div class="line">                          	<span class="comment">// 扩容成功后，设置ForwardingNode节点</span></div><div class="line">                            setTabAt(tab, i, fwd);</div><div class="line">                            advance = <span class="keyword">true</span>;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>代码逻辑请看注释,整个扩容操作分为<strong>两个部分</strong>：</p>
<p><strong>第一部分</strong>是构建一个nextTable,它的容量是原来的两倍，这个操作是单线程完成的。新建table数组的代码为:<code>Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1]</code>,在原容量大小的基础上右移一位。</p>
<p><strong>第二个部分</strong>就是将原来table中的元素复制到nextTable中，主要是遍历复制的过程。<br>根据运算得到当前遍历的数组的位置i，然后利用tabAt方法获得i位置的元素再进行判断：</p>
<ol>
<li>如果这个位置为空，就在原table中的i位置放入forwardNode节点，这个也是触发并发扩容的关键点；</li>
<li>如果这个位置是Node节点（fh&gt;=0），如果它是一个链表的头节点，就构造一个反序链表，把他们分别放在nextTable的i和i+n的位置上</li>
<li>如果这个位置是TreeBin节点（fh&lt;0），也做一个反序处理，并且判断是否需要untreefi，把处理的结果分别放在nextTable的i和i+n的位置上</li>
<li>遍历过所有的节点以后就完成了复制工作，这时让nextTable作为新的table，并且更新sizeCtl为新容量的0.75倍 ，完成扩容。设置为新容量的0.75倍代码为 <code>sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1)</code>，仔细体会下是不是很巧妙，n&lt;<1相当于n右移一位表示n的两倍即2n,n>&gt;&gt;1左右一位相当于n除以2即0.5n,然后两者相减为2n-0.5n=1.5n,是不是刚好等于新容量的0.75倍即2n*0.75=1.5n。最后用一个示意图来进行总结（图片摘自网络）：</1相当于n右移一位表示n的两倍即2n,n></li>
</ol>
<h2 id="mappingCount-与-size"><a href="#mappingCount-与-size" class="headerlink" title="mappingCount 与 size"></a>mappingCount 与 size</h2><p><strong>mappingCount</strong>与<strong>size</strong>方法的类似 从给出的注释来看，应该使用mappingCount代替size方法 两个方法都没有直接返回basecount 而是统计一次这个值，而这个值其实也是一个大概的数值，因此可能在统计的时候有其他线程正在执行插入或删除操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> n = sumCount();</div><div class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</div><div class="line">            (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</div><div class="line">            (<span class="keyword">int</span>)n);</div><div class="line">&#125;</div><div class="line"> <span class="comment">/**</span></div><div class="line"> * Returns the number of mappings. This method should be used</div><div class="line"> * instead of &#123;<span class="doctag">@link</span> #size&#125; because a ConcurrentHashMap may</div><div class="line"> * contain more mappings than can be represented as an int. The</div><div class="line"> * value returned is an estimate; the actual count may differ if</div><div class="line"> * there are concurrent insertions or removals.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@return</span> the number of mappings</div><div class="line"> * <span class="doctag">@since</span> 1.8</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">mappingCount</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> n = sumCount();</div><div class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0L</span>) ? <span class="number">0L</span> : n; <span class="comment">// ignore transient negative values</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</div><div class="line">    CounterCell[] as = counterCells; CounterCell a;</div><div class="line">    <span class="keyword">long</span> sum = baseCount;</div><div class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</div><div class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</div><div class="line">                sum += a.value;<span class="comment">//所有counter的值求和</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><p><strong>和put方法一样，多个remove线程请求不同的hash桶时，可以并发执行</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/6283837-95df888f4f738601.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>如图所示：删除的node节点的next依然指着下一个元素。此时若有一个遍历线程正在遍历这个已经删除的节点，这个遍历线程依然可以通过next属性访问下一个元素。从遍历线程的角度看，他并没有感知到此节点已经删除了，这说明了ConcurrentHashMap提供了弱一致性的迭代器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> replaceNode(key, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">    <span class="comment">// 当参数 value == null 时，删除节点。否则更新节点的值为value</span></div><div class="line">    <span class="comment">// cv 是个期望值，当 map[key].value 等于期望值 cv 或 cv == null 时，</span></div><div class="line">    <span class="comment">// 删除节点，或者更新节点的值</span></div><div class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">replaceNode</span><span class="params">(Object key, V value, Object cv)</span> </span>&#123;</div><div class="line">      <span class="keyword">int</span> hash = spread(key.hashCode());</div><div class="line">      <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</div><div class="line">          Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</div><div class="line">        	<span class="comment">// table 还没初始化或key对应的 hash 桶为空</span></div><div class="line">          <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||</div><div class="line">              (f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>)</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">        	<span class="comment">// 正在扩容</span></div><div class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</div><div class="line">              tab = helpTransfer(tab, f);</div><div class="line">          <span class="keyword">else</span> &#123;</div><div class="line">              V oldVal = <span class="keyword">null</span>;</div><div class="line">              <span class="keyword">boolean</span> validated = <span class="keyword">false</span>;</div><div class="line">              <span class="keyword">synchronized</span> (f) &#123;</div><div class="line">                	<span class="comment">// CAS 获取 tab[i] ,如果此时 tab[i] != f,说明其他线程修改了 tab[i]</span></div><div class="line">                  <span class="comment">// 回到 for 循环开始处，重新执行</span></div><div class="line">                  <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</div><div class="line">                    	<span class="comment">// node 链表</span></div><div class="line">                      <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</div><div class="line">                          validated = <span class="keyword">true</span>;</div><div class="line">                          <span class="keyword">for</span> (Node&lt;K,V&gt; e = f, pred = <span class="keyword">null</span>;;) &#123;</div><div class="line">                              K ek;</div><div class="line">                              <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                                  ((ek = e.key) == key ||</div><div class="line">                                   (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</div><div class="line">                                  V ev = e.val;</div><div class="line">                                	<span class="comment">// ev 代表参数期望值</span></div><div class="line">                                	<span class="comment">// cv == null:直接更新value/删除节点</span></div><div class="line">                                	<span class="comment">// cv 不为空，则只有在 key 的 oldVal 等于</span></div><div class="line">                                	<span class="comment">// 期望值的时候，才更新 value/删除节点</span></div><div class="line">                                  <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == ev ||</div><div class="line">                                      (ev != <span class="keyword">null</span> &amp;&amp; cv.equals(ev))) &#123;</div><div class="line">                                      oldVal = ev;</div><div class="line">                                    	<span class="comment">//更新value</span></div><div class="line">                                      <span class="keyword">if</span> (value != <span class="keyword">null</span>)</div><div class="line">                                          e.val = value;</div><div class="line">                                    	<span class="comment">//删除非头节点</span></div><div class="line">                                      <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>)</div><div class="line">                                          pred.next = e.next;</div><div class="line">                                    	<span class="comment">//删除头节点</span></div><div class="line">                                      <span class="keyword">else</span></div><div class="line">                                        	<span class="comment">// 因为已经获取了头结点锁，所以此时</span></div><div class="line">                                        	<span class="comment">// 不需要使用casTabAt</span></div><div class="line">                                          setTabAt(tab, i, e.next);</div><div class="line">                                  &#125;</div><div class="line">                                  <span class="keyword">break</span>;</div><div class="line">                              &#125;</div><div class="line">                            	<span class="comment">//当前节点不是目标节点，继续遍历下一个节点</span></div><div class="line">                              pred = e;</div><div class="line">                              <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)</div><div class="line">                                	<span class="comment">//到达链表尾部，依旧没有找到，跳出循环</span></div><div class="line">                                  <span class="keyword">break</span>;</div><div class="line">                          &#125;</div><div class="line">                      &#125;</div><div class="line">                    	<span class="comment">//红黑树</span></div><div class="line">                      <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</div><div class="line">                          validated = <span class="keyword">true</span>;</div><div class="line">                          TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</div><div class="line">                          TreeNode&lt;K,V&gt; r, p;</div><div class="line">                          <span class="keyword">if</span> ((r = t.root) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">                              (p = r.findTreeNode(hash, key, <span class="keyword">null</span>)) != <span class="keyword">null</span>) &#123;</div><div class="line">                              V pv = p.val;</div><div class="line">                              <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == pv ||</div><div class="line">                                  (pv != <span class="keyword">null</span> &amp;&amp; cv.equals(pv))) &#123;</div><div class="line">                                  oldVal = pv;</div><div class="line">                                  <span class="keyword">if</span> (value != <span class="keyword">null</span>)</div><div class="line">                                      p.val = value;</div><div class="line">                                  <span class="keyword">else</span> <span class="keyword">if</span> (t.removeTreeNode(p))</div><div class="line">                                      setTabAt(tab, i, untreeify(t.first));</div><div class="line">                              &#125;</div><div class="line">                          &#125;</div><div class="line">                      &#125;</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">              <span class="keyword">if</span> (validated) &#123;</div><div class="line">                  <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>) &#123;</div><div class="line">                    	<span class="comment">//如果删除了节点，更新size</span></div><div class="line">                      <span class="keyword">if</span> (value == <span class="keyword">null</span>)</div><div class="line">                          addCount(-<span class="number">1L</span>, -<span class="number">1</span>);</div><div class="line">                      <span class="keyword">return</span> oldVal;</div><div class="line">                  &#125;</div><div class="line">                  <span class="keyword">break</span>;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h2 id="ForwardingNode-1"><a href="#ForwardingNode-1" class="headerlink" title="ForwardingNode"></a>ForwardingNode</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</div><div class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</div><div class="line">      	<span class="comment">//hash值为MOVED（-1）的节点就是ForwardingNode</span></div><div class="line">        <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">        <span class="keyword">this</span>.nextTable = tab;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  	<span class="comment">//通过此方法，访问被迁移到nextTable中的数据</span></div><div class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</div><div class="line">        <span class="comment">// loop to avoid arbitrarily deep recursion on forwarding nodes</span></div><div class="line">        outer: <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = nextTable;;) &#123;</div><div class="line">            Node&lt;K,V&gt; e; <span class="keyword">int</span> n;</div><div class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span> || tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||</div><div class="line">                (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) == <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                <span class="keyword">int</span> eh; K ek;</div><div class="line">                <span class="keyword">if</span> ((eh = e.hash) == h &amp;&amp;</div><div class="line">                    ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))</div><div class="line">                    <span class="keyword">return</span> e;</div><div class="line">                <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ForwardingNode) &#123;</div><div class="line">                        tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;</div><div class="line">                        <span class="keyword">continue</span> outer;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span></div><div class="line">                        <span class="keyword">return</span> e.find(h, k);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>JDK6,7中的ConcurrentHashmap主要使用Segment来实现减小锁粒度，分割成若干个Segment，在put的时候需要锁住Segment，get时候不加锁，使用volatile来保证可见性，当要统计全局时（比如size），首先会尝试多次计算modcount来确定，这几次尝试中，是否有其他线程进行了修改操作，如果没有，则直接返回size。如果有，则需要依次锁住所有的Segment来计算。</p>
<p>而在1.8的时候摒弃了segment臃肿的设计，这种设计在定位到具体的桶时，要先定位到具体的segment，然后再<br>在segment中定位到具体的桶。而到了1.8的时候是针对的是Node[] tale数组中的每一个桶，进一步减小了锁粒度。并且防止拉链过长导致性能下降，当链表长度大于8的时候采用红黑树的设计。</p>
<p>主要设计上的变化有以下几点:</p>
<ol>
<li>不采用segment而采用node，锁住node来实现减小锁粒度。</li>
<li>设计了MOVED状态 当resize的中过程中 线程2还在put数据，线程2会帮助resize。</li>
<li>使用3个CAS操作来确保node的一些操作的原子性，这种方式代替了锁。</li>
<li>sizeCtl的不同值来代表不同含义，起到了控制的作用。</li>
<li>采用synchronized而不是ReentrantLock</li>
<li>volatile语义提供更细颗粒度的轻量级锁，使得多线程可以(几乎)同时读写实例中的关键量，正确理解当前类所处的状态，进入对应if语句中执行相关逻辑。</li>
<li>采用更加细粒度的hash桶级别锁，扩容期间，依然可以保证写操作的并发度。</li>
<li>多线程无锁扩容的关键就是通过CAS设置sizeCtl与transferIndex变量，协调多个线程对table数组中的node进行迁移。</li>
</ol>
<p>参考文章：<a href="http://www.cnblogs.com/huaizuo/p/5413069.html" target="_blank" rel="external">http://www.cnblogs.com/huaizuo/p/5413069.html</a></p>
<p>参考文章：<a href="http://www.bijishequ.com/detail/560964?p=" target="_blank" rel="external">http://www.bijishequ.com/detail/560964?p=</a></p>
<p>参考文章：<a href="https://bentang.me/tech/2016/12/01/jdk8-concurrenthashmap-1/" target="_blank" rel="external">https://bentang.me/tech/2016/12/01/jdk8-concurrenthashmap-1/</a></p>
<p>参考文章:   <a href="http://www.jianshu.com/p/5bc70d9e5410" target="_blank" rel="external">http://www.jianshu.com/p/5bc70d9e5410</a></p>
<p>扩容原理:   <a href="http://www.jianshu.com/p/487d00afe6ca" target="_blank" rel="external">http://www.jianshu.com/p/487d00afe6ca</a></p>
<p>遍历操作：<a href="http://www.jianshu.com/p/3e85ac8f8662" target="_blank" rel="external">http://www.jianshu.com/p/3e85ac8f8662</a></p>
<p>改进说明带例子:<a href="http://www.voidcn.com/article/p-gdbewnlb-qh.html" target="_blank" rel="external">http://www.voidcn.com/article/p-gdbewnlb-qh.html</a></p>
<p><a href="http://nannan408.iteye.com/blog/2217042" target="_blank" rel="external">http://nannan408.iteye.com/blog/2217042</a></p>

      
    </div>
    
    
    



    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="ShenWenFang 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="ShenWenFang 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    ShenWenFang
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://swenfang.github.io/2018/06/03/Java 8 ConcurrentHashMap 源码解读/" title="ConcurrentHashMap 源码解读">http://swenfang.github.io/2018/06/03/Java 8 ConcurrentHashMap 源码解读/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    	
          <div>
            <div class="recommended_posts">
    
    
    <strong>推荐文章 </strong>
    <ul>
        
            <li><a href="http://swenfang.github.io/2018/06/03/Java 红黑树源码解读/">Java 红黑树源码解读</a></li>
        
            <li><a href="http://swenfang.github.io/2018/06/03/Java Map 的常用方法/">Java Map 用法、遍历、排序和常用 API</a></li>
        
            <li><a href="http://swenfang.github.io/2018/06/03/IntelliJ IDEA  调试教程/">IntelliJ IDEA  调试教程</a></li>
        
            <li><a href="http://swenfang.github.io/2018/06/03/IDEA 版本控制/">IntelliJ IDEA  版本控制的使用</a></li>
        
    </ul>
    
</div>

          </div>
        

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/基础数据类型/" rel="tag"># 基础数据类型</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/03/IntelliJ IDEA  调试教程/" rel="next" title="IntelliJ IDEA  调试教程">
                <i class="fa fa-chevron-left"></i> IntelliJ IDEA  调试教程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/06/03/Java Map 的常用方法/" rel="prev" title="Java Map 用法、遍历、排序和常用 API">
                Java Map 用法、遍历、排序和常用 API <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ4My82MDUx"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="ShenWenFang" />
            
              <p class="site-author-name" itemprop="name">ShenWenFang</p>
              <p class="site-description motion-element" itemprop="description">每一个你不满意的现在，都有一个你没有努力的曾经。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">44</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

         <div id="music163player">
             <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=31861269&auto=0&height=66"></iframe>
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-8-ConcurrentHashMap-源码解读"><span class="nav-number">1.</span> <span class="nav-text">Java 8 ConcurrentHashMap 源码解读</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础数据结构"><span class="nav-number">1.1.</span> <span class="nav-text">基础数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述"><span class="nav-number">1.1.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#阅前了解"><span class="nav-number">1.1.2.</span> <span class="nav-text">阅前了解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile语义"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">volatile语义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS操作"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">CAS操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentHashMap-的常量"><span class="nav-number">1.2.</span> <span class="nav-text">ConcurrentHashMap 的常量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentHashMap-重要属性"><span class="nav-number">1.3.</span> <span class="nav-text">ConcurrentHashMap 重要属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Node"><span class="nav-number">1.3.1.</span> <span class="nav-text">Node</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeNode"><span class="nav-number">1.3.2.</span> <span class="nav-text">TreeNode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeBin"><span class="nav-number">1.3.3.</span> <span class="nav-text">TreeBin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#threeifyBin"><span class="nav-number">1.3.4.</span> <span class="nav-text">threeifyBin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ForwardingNode"><span class="nav-number">1.3.5.</span> <span class="nav-text">ForwardingNode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Traverser"><span class="nav-number">1.3.6.</span> <span class="nav-text">Traverser</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tryPresize-扩容"><span class="nav-number">1.4.</span> <span class="nav-text">tryPresize(扩容)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spread-重新哈希"><span class="nav-number">1.5.</span> <span class="nav-text">spread 重新哈希</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#get-查找"><span class="nav-number">1.6.</span> <span class="nav-text">get(查找)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tabAt"><span class="nav-number">1.7.</span> <span class="nav-text">tabAt</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#put-putVal"><span class="nav-number">1.8.</span> <span class="nav-text">put/putVal</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#initTable"><span class="nav-number">1.9.</span> <span class="nav-text">initTable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#casTabAt-原子操作方法"><span class="nav-number">1.10.</span> <span class="nav-text">casTabAt(原子操作方法)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#setTabAt"><span class="nav-number">1.11.</span> <span class="nav-text">setTabAt</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例构造器方法"><span class="nav-number">1.12.</span> <span class="nav-text">实例构造器方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tableSizeFor"><span class="nav-number">1.13.</span> <span class="nav-text">tableSizeFor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#helpTransfer-协助扩容"><span class="nav-number">1.14.</span> <span class="nav-text">helpTransfer(协助扩容)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#addCount"><span class="nav-number">1.15.</span> <span class="nav-text">addCount</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fullAddCount"><span class="nav-number">1.16.</span> <span class="nav-text">fullAddCount</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#transfer"><span class="nav-number">1.17.</span> <span class="nav-text">transfer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mappingCount-与-size"><span class="nav-number">1.18.</span> <span class="nav-text">mappingCount 与 size</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#remove"><span class="nav-number">1.19.</span> <span class="nav-text">remove</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ForwardingNode-1"><span class="nav-number">1.20.</span> <span class="nav-text">ForwardingNode</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">2.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ShenWenFang</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("9lk8dNt56FULANV18qHRXIff-gzGzoHsz", "lSea2qzYEcPELI1zQN1wWQGt");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
