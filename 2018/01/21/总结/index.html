<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="基础面试题," />










<meta name="description" content="基础面试题引言：以下各方面知识点的面试题，是为了将要出来工作的小师妹和小师弟而精心整理的。希望对你们都帮助。这些面试题都是很基础的，希望你们能够好好利用起来。有问题，或者不对的地方欢迎给我留言哈！ forward 和redirect的区别forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪">
<meta name="keywords" content="基础面试题">
<meta property="og:type" content="article">
<meta property="og:title" content="基础面试题">
<meta property="og:url" content="http://yoursite.com/2018/01/21/总结/index.html">
<meta property="og:site_name" content="ShenWenFang">
<meta property="og:description" content="基础面试题引言：以下各方面知识点的面试题，是为了将要出来工作的小师妹和小师弟而精心整理的。希望对你们都帮助。这些面试题都是很基础的，希望你们能够好好利用起来。有问题，或者不对的地方欢迎给我留言哈！ forward 和redirect的区别forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪">
<meta property="og:updated_time" content="2018-01-21T12:35:03.127Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="基础面试题">
<meta name="twitter:description" content="基础面试题引言：以下各方面知识点的面试题，是为了将要出来工作的小师妹和小师弟而精心整理的。希望对你们都帮助。这些面试题都是很基础的，希望你们能够好好利用起来。有问题，或者不对的地方欢迎给我留言哈！ forward 和redirect的区别forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/01/21/总结/"/>





  <title>基础面试题 | ShenWenFang</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/another"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://camo.githubusercontent.com/c6286ade715e9bea433b4705870de482a654f78a/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f77686974655f6666666666662e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_left_white_ffffff.png"></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ShenWenFang</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/21/总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ShenWenFang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShenWenFang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">基础面试题</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-21T20:01:03+08:00">
                2018-01-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/基础面试题/" itemprop="url" rel="index">
                    <span itemprop="name">基础面试题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/01/21/总结/" class="leancloud_visitors" data-flag-title="基础面试题">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  9,442 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  34 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="基础面试题"><a href="#基础面试题" class="headerlink" title="基础面试题"></a>基础面试题</h1><h2 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h2><p>以下各方面知识点的面试题，是为了将要出来工作的小师妹和小师弟而精心整理的。希望对你们都帮助。这些面试题都是很基础的，希望你们能够好好利用起来。有问题，或者不对的地方欢迎给我留言哈！</p>
<h2 id="forward-和redirect的区别"><a href="#forward-和redirect的区别" class="headerlink" title="forward 和redirect的区别"></a>forward 和redirect的区别</h2><p>forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。</p>
<p>redirect就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求，所以session,request参数都可以获取。</p>
<h2 id="int-和-Integer-有什么区别"><a href="#int-和-Integer-有什么区别" class="headerlink" title="int 和 Integer 有什么区别"></a>int 和 Integer 有什么区别</h2><p>Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int是java的原始数据类型，Integer是java为int提供的封装类。Java为每个原始类型提供了封装类。</p>
<p>原始类封装类，booleanBoolean,charCharacter、byteByte、shortShort、intInteger、longLong、floatFloat、doubleDouble 引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为 null，而原始类型实例变量的缺省值与它们的类型有关</p>
<h2 id="error和exception有什么区别"><a href="#error和exception有什么区别" class="headerlink" title="error和exception有什么区别"></a>error和exception有什么区别</h2><p>error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。</p>
<h2 id="Overload和Override区别，Overloaded方法可以改变返回值的类型吗"><a href="#Overload和Override区别，Overloaded方法可以改变返回值的类型吗" class="headerlink" title="Overload和Override区别，Overloaded方法可以改变返回值的类型吗"></a>Overload和Override区别，Overloaded方法可以改变返回值的类型吗</h2><p>方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被”屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。</p>
<h2 id="java中有哪些集合，主要方法有哪些"><a href="#java中有哪些集合，主要方法有哪些" class="headerlink" title="java中有哪些集合，主要方法有哪些"></a>java中有哪些集合，主要方法有哪些</h2><p>主要有LinkedList，ArrayList，Vector等。下面是详细：<br>Collection<br>├List<br>│├LinkedList<br>│├ArrayList<br>│└Vector<br>│ └Stack<br>└Set<br>Map<br>├Hashtable<br>├HashMap<br>└WeakHashMap<br>最常用的集合类是 List 和 Map。 List 的具体实现包括 ArrayList 和 Vector，它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。 List 适用于按数值索引访问元素的情形。 Map 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作“键”和“值”）其中每个键映射到一个值。</p>
<h2 id="List、Map、Set接口，存取元素时各自特点"><a href="#List、Map、Set接口，存取元素时各自特点" class="headerlink" title="List、Map、Set接口，存取元素时各自特点"></a>List、Map、Set接口，存取元素时各自特点</h2><p>List 以特定次序来持有元素，可有重复元素。Set 无法拥有重复元素,内部排序。Map 保存key-value值，value可多值。<br>  List的遍历： List接口有size()和get()方法，用这两个方法可以实现对List的遍历。size()方法得到List中的元素个数。get()方法取得某个位置上的元素</p>
<h2 id="HashMap与HashTable的区别"><a href="#HashMap与HashTable的区别" class="headerlink" title="HashMap与HashTable的区别"></a>HashMap与HashTable的区别</h2><p>1、HashMap是非线程安全的，HashTable是线程安全的。</p>
<p>2、HashMap的键和值都允许有null值存在，而HashTable则不行。</p>
<p>3、因为线程安全的问题，HashMap效率比HashTable的要高。<br>HashMap的实现机制：<br>维护一个每个元素是一个链表的数组，而且链表中的每个节点是一个Entry[]键值对的数据结构。<br>实现了数组+链表的特性，查找快，插入删除也快。<br>对于每个key,他对应的数组索引下标是 int i = hash(key.hashcode)&amp;(len-1);<br>每个新加入的节点放在链表首，然后该新加入的节点指向原链表首</p>
<h2 id="HashMap，ConcurrentHashMap与LinkedHashMap的区别"><a href="#HashMap，ConcurrentHashMap与LinkedHashMap的区别" class="headerlink" title="HashMap，ConcurrentHashMap与LinkedHashMap的区别"></a>HashMap，ConcurrentHashMap与LinkedHashMap的区别</h2><p>ConcurrentHashMap是使用了锁分段技术技术来保证线程安全的，锁分段技术：首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问<br>ConcurrentHashMap 是在每个段（segment）中线程安全的<br>LinkedHashMap维护一个双链表，可以将里面的数据按写入的顺序读出</p>
<p>ConcurrentHashMap应用场景<br>1：ConcurrentHashMap的应用场景是高并发，但是并不能保证线程安全，而同步的HashMap和HashMap的是锁住整个容器，而加锁之后ConcurrentHashMap不需要锁住整个容器，只需要锁住对应的Segment就好了，所以可以保证高并发同步访问，提升了效率。<br>2：可以多线程写。<br>ConcurrentHashMap把HashMap分成若干个Segmenet<br>1.get时，不加锁，先定位到segment然后在找到头结点进行读取操作。而value是volatile变量，所以可以保证在竞争条件时保证读取最新的值，如果读到的value是null，则可能正在修改，那么久调用ReadValueUnderLock函数，加锁保证读到的数据是正确的。</p>
<p>2.Put时会加锁，一律添加到hash链的头部。</p>
<p>3.Remove时也会加锁，由于next是final类型不可改变，所以必须把删除的节点之前的节点都复制一遍。</p>
<p>4.ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对Hash表的不同Segment进行的修改。<br>ConcurrentHashMap的应用场景是高并发，但是并不能保证线程安全，而同步的HashMap和HashTable的是锁住整个容器，而加锁之后ConcurrentHashMap不需要锁住整个容器，只需要锁住对应的segment就好了，所以可以保证高并发同步访问，提升了效率。</p>
<h2 id="Vector和ArrayList的区别"><a href="#Vector和ArrayList的区别" class="headerlink" title="Vector和ArrayList的区别"></a>Vector和ArrayList的区别</h2><p>  首先看这两类都实现List接口，而List接口一共有三个实现类，分别是ArrayList、Vector和LinkedList。List用于存放多个元素，能够维护元素的次序，并且允许元素的重复。3个具体实现类的相关区别如下：</p>
<p>1.ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要讲已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。<br>2.Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。<br>3.LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。</p>
<h2 id="ArrayList-与-LinkedList-的不区别"><a href="#ArrayList-与-LinkedList-的不区别" class="headerlink" title="ArrayList 与 LinkedList 的不区别"></a>ArrayList 与 LinkedList 的不区别</h2><p>最明显的区别是 ArrrayList 底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。<br>1.LinkedList内部存储的是Node<e>，不仅要维护数据域，还要维护prev和next，如果LinkedList中的结点特别多，则LinkedList比ArrayList更占内存。<br>插入删除操作效率：<br>2.LinkedList在做插入和删除操作时，插入或删除头部或尾部时是高效的，操作越靠近中间位置的元素时，需要遍历查找，速度相对慢一些，如果在数据量较大时，每次插入或删除时遍历查找比较费时。所以LinkedList插入与删除，慢在遍历查找，快在只需要更改相关结点的引用地址。<br>ArrayList在做插入和删除操作时，插入或删除尾部时也一样是高效的，操作其他位置，则需要批量移动元素，所以ArrayList插入与删除，快在遍历查找，慢在需要批量移动元素。<br>3.循环遍历效率：<br>由于ArrayList实现了RandomAccess随机访问接口，所以使用for(int i = 0; i &lt; size; i++)遍历会比使用Iterator迭代器来遍历快<br>而由于LinkedList未实现RandomAccess接口，所以推荐使用Iterator迭代器来遍历数据。<br>因此，如果我们需要频繁在列表的中部改变插入或删除元素时，建议使用LinkedList，否则，建议使用ArrayList，因为ArrayList遍历查找元素较快，并且只需存储元素的数据域，不需要额外记录其他数据的位置信息，可以节省内存空间。</e></p>
<h2 id="Java-中的-LinkedList-是单向链表还是双向链表"><a href="#Java-中的-LinkedList-是单向链表还是双向链表" class="headerlink" title="Java 中的 LinkedList 是单向链表还是双向链表"></a>Java 中的 LinkedList 是单向链表还是双向链表</h2><p>是双向链表。</p>
<h2 id="String、StringBuffer、StringBuilder之间区别"><a href="#String、StringBuffer、StringBuilder之间区别" class="headerlink" title="String、StringBuffer、StringBuilder之间区别"></a>String、StringBuffer、StringBuilder之间区别</h2><p>1.三者在执行速度方面的比较：StringBuilder &gt;  StringBuffer  &gt;  String<br>2.在线程方面：StringBuilder是线程非安全的;StringBuffer是线程安全的</p>
<p>3.对于三者的使用：如果要操作少量的数据用 = String；单线程操作字符串缓冲区 下操作大量数据 = StringBuilder；多线程操作字符串缓冲区 下操作大量数据 = StringBuffer；</p>
<h2 id="Object-的常用方有哪些"><a href="#Object-的常用方有哪些" class="headerlink" title="Object 的常用方有哪些"></a>Object 的常用方有哪些</h2><p>clone()、equals()、hashCode()、notify()、notifyAll()、toString()、wait()、finalize()</p>
<h2 id="Mysql-的分页-SQL-语句"><a href="#Mysql-的分页-SQL-语句" class="headerlink" title="Mysql 的分页 SQL 语句"></a>Mysql 的分页 SQL 语句</h2><p>select * from tablename limit m,n(n是指从第m+1条开始，取n条)</p>
<h2 id="Hibernate与MyBatis的异同"><a href="#Hibernate与MyBatis的异同" class="headerlink" title="Hibernate与MyBatis的异同"></a>Hibernate与MyBatis的异同</h2><p>相同点：<br>Hibernate与MyBatis都可以是通过SessionFactoryBuider由XML配置文件生成SessionFactory，然后由SessionFactory 生成Session，最后由Session来开启执行事务和SQL语句。其中SessionFactoryBuider，SessionFactory，Session的生命周期都是差不多的。Hibernate和MyBatis都支持JDBC和JTA事务处理。<br>Mybatis优势：<br>MyBatis可以进行更为细致的SQL优化，可以减少查询字段。<br>MyBatis容易掌握，而Hibernate门槛较高。<br>Hibernate优势：<br>Hibernate的DAO层开发比MyBatis简单，Mybatis需要维护SQL和结果映射。<br>Hibernate对对象的维护和缓存要比MyBatis好，对增删改查的对象的维护要方便。<br>Hibernate数据库移植性很好，MyBatis的数据库移植性不好，不同的数据库需要写不同SQL。<br>Hibernate有更好的二级缓存机制，可以使用第三方缓存。MyBatis本身提供的缓存机制不佳。</p>
<h2 id="Hibernate与MyBatis在sql优化方面异同"><a href="#Hibernate与MyBatis在sql优化方面异同" class="headerlink" title="Hibernate与MyBatis在sql优化方面异同"></a>Hibernate与MyBatis在sql优化方面异同</h2><p>Hibernate的查询会将表中的所有字段查询出来，这一点会有性能消耗。Hibernate也可以自己写SQL来指定需要查询的字段，但这样就破坏了Hibernate开发的简洁性。<br>而Mybatis的SQL是手动编写的，所以可以按需求指定查询的字段。<br>Hibernate HQL语句的调优需要将SQL打印出来，而Hibernate的SQL被很多人嫌弃因为太丑了。<br>MyBatis的SQL是自己手动写的所以调整方便。但Hibernate具有自己的日志统计。Mybatis本身不带日志统计，使用Log4j进行日志记录。</p>
<h2 id="Hibernate与MyBatis对象管理对比"><a href="#Hibernate与MyBatis对象管理对比" class="headerlink" title="Hibernate与MyBatis对象管理对比"></a>Hibernate与MyBatis对象管理对比</h2><p>Hibernate 是完整的对象/关系映射解决方案，它提供了对象状态管理（state management）的功能，使开发者不再需要理会底层数据库系统的细节。也就是说，相对于常见的 JDBC/SQL 持久层方案中需要管理 SQL 语句，Hibernate采用了更自然的面向对象的视角来持久化 Java 应用中的数据。<br>换句话说，使用 Hibernate 的开发者应该总是关注对象的状态（state），不必考虑 SQL 语句的执行。这部分细节已经由 Hibernate 掌管妥当，只有开发者在进行系统性能调优的时候才需要进行了解。而MyBatis在这一块没有文档说明，用户需要对对象自己进行详细的管理。</p>
<h2 id="Jsp九大内置对象"><a href="#Jsp九大内置对象" class="headerlink" title="Jsp九大内置对象"></a>Jsp九大内置对象</h2><p>1.Request:   request对象主要用于客户端请求处理<br>2.Response:   response对象提供了多个方法用来处理HTTP响应，可以调用response中的方法修改ContentType中的MIME类型以及实现页面的跳转等等，<br>3.Page:  page对象有点类似于Java编程中的this指针，就是指当前JSP页面本身。page是java.lang.Object类的对象。<br>4.Session:  session是与请求有关的会话期，它是java.servlet.http.HttpSession类的对象，用来表示和存储当前页面的请求信息。<br>5.Application:  application是javax.servlet.ServletContext类对象的一个实例，用于实现用户之间的数据共享<br>6.Out:<br>7.Exception:  exception内置对象是用来处理页面出现的异常错误<br>8.Config:  config内置对象是ServletConfig类的一个实例。在Servlet初始化的时候，JSP引擎通过config向它传递信息。这种信息可以是属性名/值匹配的参数，也可以是通过ServletContext对象传递的服务器的有关信息。<br>9.pageContext:  pageContext对象是一个比较特殊的对象。它相当于页面中所有其他对象功能的最大集成者，即使用它可以访问到本页面中所有其他对象</p>
<h2 id="Comparator-与-Comparable-有什么不同"><a href="#Comparator-与-Comparable-有什么不同" class="headerlink" title="Comparator 与 Comparable 有什么不同"></a>Comparator 与 Comparable 有什么不同</h2><p>Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。</p>
<h2 id="Collection-和-Collections的区别"><a href="#Collection-和-Collections的区别" class="headerlink" title="Collection 和 Collections的区别"></a>Collection 和 Collections的区别</h2><p>Collection是集合类的上级接口，继承与他的接口主要有Set 和List.<br>Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</p>
<h2 id="线程同步的方法"><a href="#线程同步的方法" class="headerlink" title="线程同步的方法"></a>线程同步的方法</h2><p>wait():使一个线程处于等待状态，并且释放所持有的对象的lock。<br>sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。<br>notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。<br>Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。</p>
<h2 id="Volatile和Synchronized四个不同点"><a href="#Volatile和Synchronized四个不同点" class="headerlink" title="Volatile和Synchronized四个不同点"></a>Volatile和Synchronized四个不同点</h2><ol>
<li>粒度不同，前者锁对象和类，后者针对变量</li>
<li>syn阻塞，volatile线程不阻塞</li>
<li>syn保证三大特性，volatile不保证原子性</li>
<li>syn编译器优化，volatile不优化<br>volatile具备两种特性：<br>保证此变量对所有线程的可见性，指一条线程修改了这个变量的值，新值对于其他线程来说是可见的，但并不是多线程安全的。<br>禁止指令重排序优化。<br>Volatile如何保证内存可见性:<br>1.当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。<br>2.当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。<br>同步：就是一个任务的完成需要依赖另外一个任务，只有等待被依赖的任务完成后，依赖任务才能完成。<br>异步：不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，只要自己任务完成了就算完成了，被依赖的任务是否完成会通知回来。（异步的特点就是通知）。<br>打电话和发短信来比喻同步和异步操作。<br>阻塞：CPU停下来等一个慢的操作完成以后，才会接着完成其他的工作。<br>非阻塞：非阻塞就是在这个慢的执行时，CPU去做其他工作，等这个慢的完成后，CPU才会接着完成后续的操作。<br>非阻塞会造成线程切换增加，增加CPU的使用时间能不能补偿系统的切换成本需要考虑。</li>
</ol>
<h2 id="SpringMVC运行原理"><a href="#SpringMVC运行原理" class="headerlink" title="SpringMVC运行原理"></a>SpringMVC运行原理</h2><ol>
<li>客户端请求提交到DispatcherServlet</li>
<li>由DispatcherServlet控制器查询HandlerMapping，找到并分发到指定的Controller中。</li>
<li>Controller调用业务逻辑处理后，返回ModelAndView</li>
<li>DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图</li>
<li>视图负责将结果显示到客户端</li>
</ol>
<h2 id="SpringMVC与Struts2区别与比较总结"><a href="#SpringMVC与Struts2区别与比较总结" class="headerlink" title="SpringMVC与Struts2区别与比较总结"></a>SpringMVC与Struts2区别与比较总结</h2><p>1、Struts2是类级别的拦截， 一个类对应一个request上下文，SpringMVC是方法级别的拦截，一个方法对应一个request上下文，而方法同时又跟一个url对应,所以说从架构本身上SpringMVC就容易实现restful url,而struts2的架构实现起来要费劲，因为Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了。</p>
<p>2、由上边原因，SpringMVC的方法之间基本上独立的，独享request response数据，请求数据通过参数获取，处理结果通过ModelMap交回给框架，方法之间不共享变量，而Struts2搞的就比较乱，虽然方法之间也是独立的，但其所有Action变量是共享的，这不会影响程序运行，却给我们编码 读程序时带来麻烦，每次来了请求就创建一个Action，一个Action对象对应一个request上下文。<br>3、由于Struts2需要针对每个request进行封装，把request，session等servlet生命周期的变量封装成一个一个Map，供给每个Action使用，并保证线程安全，所以在原则上，是比较耗费内存的。</p>
<p>4、 拦截器实现机制上，Struts2有以自己的interceptor机制，SpringMVC用的是独立的AOP方式，这样导致Struts2的配置文件量还是比SpringMVC大。</p>
<p>5、SpringMVC的入口是servlet，而Struts2是filter（这里要指出，filter和servlet是不同的。以前认为filter是servlet的一种特殊），这就导致了二者的机制不同，这里就牵涉到servlet和filter的区别了。</p>
<p>6、SpringMVC集成了Ajax，使用非常方便，只需一个注解@ResponseBody就可以实现，然后直接返回响应文本即可，而Struts2拦截器集成了Ajax，在Action中处理时一般必须安装插件或者自己写代码集成进去，使用起来也相对不方便。</p>
<p>7、SpringMVC验证支持JSR303，处理起来相对更加灵活方便，而Struts2验证比较繁琐，感觉太烦乱。</p>
<p>8、Spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高（当然Struts2也可以通过不同的目录结构和相关配置做到SpringMVC一样的效果，但是需要xml配置的地方不少）。</p>
<p>9、 设计思想上，Struts2更加符合OOP的编程思想， SpringMVC就比较谨慎，在servlet上扩展。</p>
<p>10、SpringMVC开发效率和性能高于Struts2。<br>11、SpringMVC可以认为已经100%零配置。</p>
<h2 id="简单总结springMVC和struts2的区别"><a href="#简单总结springMVC和struts2的区别" class="headerlink" title="简单总结springMVC和struts2的区别"></a>简单总结springMVC和struts2的区别</h2><ol>
<li>springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过虑器。</li>
<li>springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。</li>
<li>Struts采用值栈存储请求和响应的数据，通过OGNL存取数据， springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。</li>
</ol>
<h2 id="SpringMvc怎么和AJAX相互调用的"><a href="#SpringMvc怎么和AJAX相互调用的" class="headerlink" title="SpringMvc怎么和AJAX相互调用的"></a>SpringMvc怎么和AJAX相互调用的</h2><p>通过Jackson框架就可以把Java里面的对象直接转化成Js可以识别的Json对象<br>具体步骤如下<br>1.加入Jackson.jar<br>2.在配置文件中配置json的映射<br>3.在接受Ajax方法里面可以直接返回Object,List等,但方法前面要加上@ResponseBody注解</p>
<h2 id="Spring有哪些优点"><a href="#Spring有哪些优点" class="headerlink" title="Spring有哪些优点"></a>Spring有哪些优点</h2><p>1.轻量级：Spring在大小和透明性方面绝对属于轻量级的，基础版本的Spring框架大约只有2MB。<br>2.控制反转(IOC)：Spring使用控制反转技术实现了松耦合。依赖被注入到对象，而不是创建或寻找依赖对象。<br>3.面向切面编程(AOP)： Spring支持面向切面编程，同时把应用的业务逻辑与系统的服务分离开来。<br>4.容器：Spring包含并管理应用程序对象的配置及生命周期。<br>5.MVC框架：Spring的web框架是一个设计优良的web MVC框架，很好的取代了一些web框架。<br>6.事务管理：Spring对下至本地业务上至全局业务(JAT)提供了统一的事务管理接口。<br>7.异常处理：Spring提供一个方便的API将特定技术的异常(由JDBC, Hibernate, 或JDO抛出)转化为一致的、Unchecked异常。</p>
<h2 id="解释AOP模块"><a href="#解释AOP模块" class="headerlink" title="解释AOP模块"></a>解释AOP模块</h2><p>AOP模块用来开发Spring应用程序中具有切面性质的部分。该模块的大部分服务由AOP Aliance提供，这就保证了Spring框架和其他AOP框架之间的互操作性。另外，该模块将元数据编程引入到了Spring。</p>
<h2 id="IoC容器是什么其优点"><a href="#IoC容器是什么其优点" class="headerlink" title="IoC容器是什么其优点"></a>IoC容器是什么其优点</h2><p>Spring IOC负责创建对象、管理对象(通过依赖注入)、整合对象、配置对象以及管理这些对象的生命周期。<br>优点:<br>IOC或依赖注入减少了应用程序的代码量。它使得应用程序的测试很简单，因为在单元测试中不再需要单例或JNDI查找机制。简单的实现以及较少的干扰机制使得松耦合得以实现。IOC容器支持勤性单例及延迟加载服务。</p>
<h2 id="Spring-的依赖注入方式有哪一些"><a href="#Spring-的依赖注入方式有哪一些" class="headerlink" title="Spring 的依赖注入方式有哪一些"></a>Spring 的依赖注入方式有哪一些</h2><p>Spring 的依赖注入可以有两种方式来完成:setter 方法注入和构造方法注入。<br>构造器依赖注入：构造器依赖注入在容器触发构造器的时候完成，该构造器有一系列的参数，每个参数代表注入的对象。<br>Setter方法依赖注入：首先容器会触发一个无参构造函数或无参静态工厂方法实例化对象，之后容器调用bean中的setter方法完成Setter方法依赖注入。</p>
<h2 id="Spring支持的事务管理类型"><a href="#Spring支持的事务管理类型" class="headerlink" title="Spring支持的事务管理类型"></a>Spring支持的事务管理类型</h2><p>Spring支持如下两种方式的事务管理：<br>编程式事务管理：这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。<br>声明式事务管理：这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者XML配置管理事务。</p>
<h2 id="ThreadLocal-线程变量副本"><a href="#ThreadLocal-线程变量副本" class="headerlink" title="ThreadLocal(线程变量副本)"></a>ThreadLocal(线程变量副本)</h2><p>Synchronized实现内存共享，ThreadLocal为每个线程维护一个本地变量。</p>
<p>采用空间换时间，它用于线程间的数据隔离，为每一个使用该变量的线程提供一个副本，每个线程都可以独立地改变自己的副本，而不会和其他线程的副本冲突。</p>
<p>ThreadLocal类中维护一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值为对应线程的变量副本。</p>
<p>ThreadLocal在Spring中发挥着巨大的作用，在管理Request作用域中的Bean、事务管理、任务调度、AOP等模块都出现了它的身影。</p>
<p>Spring中绝大部分Bean都可以声明成Singleton作用域，采用ThreadLocal进行封装，因此有状态的Bean就能够以singleton的方式在多线程中正常工作了。</p>
<h2 id="throw-和-throws-的区别"><a href="#throw-和-throws-的区别" class="headerlink" title="throw 和 throws 的区别"></a>throw 和 throws 的区别</h2><p>throw 用于抛出 java.lang.Throwable 类的一个实例化对象，意思是说你可以通过关键字 throw 抛出一个 Error 或者 一个Exception，如：</p>
<p>throw new IllegalArgumentException(“size must be multiple of 2″)</p>
<p>而throws 的作用是作为方法声明和签名的一部分，方法被抛出相应的异常以便调用者能处理。Java 中，任何未处理的受检查异常强制在 throws 子句中声明。</p>
<h2 id="final关键字的作用"><a href="#final关键字的作用" class="headerlink" title="final关键字的作用"></a>final关键字的作用</h2><p>final class    表示此类不允许有子类。<br>final virable  表示一个常量。<br>final method   表示一个方法不能被重写</p>
<h2 id="String是最基本的数据类型吗"><a href="#String是最基本的数据类型吗" class="headerlink" title="String是最基本的数据类型吗"></a>String是最基本的数据类型吗</h2><p>基本数据类型包括byte、int、char、long、float、double、boolean和short。java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类。</p>
<h2 id="synchronized和java-util-concurrent-locks-Lock的异同"><a href="#synchronized和java-util-concurrent-locks-Lock的异同" class="headerlink" title="synchronized和java.util.concurrent.locks.Lock的异同"></a>synchronized和java.util.concurrent.locks.Lock的异同</h2><p>主要相同点:<br>Lock能完成synchronized所实现的所有功能.(其它不重要)<br>主要不同点:<br>Lock有比synchronized更精确的线程语义和更好的性能(在相同点中回答此点也行)<br>synchronized会自动释放锁.而Lock一定要求程序员手工释放.并且必须在finally从句<br>中释放,如果没有答出在finally中释放不得分.就如Connection没有在finally中关闭一<br>样.连最基本的资源释放都做不好,还谈什么多线程编程.</p>
<h2 id="spring的事务有几种它的隔离级别和传播行为"><a href="#spring的事务有几种它的隔离级别和传播行为" class="headerlink" title="spring的事务有几种它的隔离级别和传播行为"></a>spring的事务有几种它的隔离级别和传播行为</h2><p>声明式事务和编程式事务<br>隔离级别：</p>
<ul>
<li>DEFAULT使用数据库默认的隔离级别</li>
<li>READ_UNCOMMITTED会出现脏读，不可重复读和幻影读问题</li>
<li>READ_COMMITTED会出现重复读和幻影读</li>
<li>REPEATABLE_READ会出现幻影读</li>
<li>SERIALIZABLE最安全，但是代价最大，性能影响极其严重<br>和传播行：</li>
<li>REQUIRED存在事务就融入该事务，不存在就创建事务</li>
<li>SUPPORTS存在事务就融入事务，不存在则不创建事务</li>
<li>MANDATORY存在事务则融入该事务，不存在，抛异常</li>
<li>REQUIRES_NEW总是创建新事务</li>
<li>NOT_SUPPORTED存在事务则挂起，一直执行非事务操作</li>
<li>NEVER总是执行非事务，如果当前存在事务则抛异常</li>
<li>NESTED嵌入式事务</li>
</ul>
<h2 id="sleep-和-wait-有什么区别"><a href="#sleep-和-wait-有什么区别" class="headerlink" title="sleep() 和 wait() 有什么区别"></a>sleep() 和 wait() 有什么区别</h2><p>sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。<br>wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。</p>
<h2 id="多线程和同步有几种实现方法"><a href="#多线程和同步有几种实现方法" class="headerlink" title="多线程和同步有几种实现方法"></a>多线程和同步有几种实现方法</h2><p>多线程有两种实现方法，分别是继承Thread类与实现Runnable接口<br>同步的实现方面有两种，分别是synchronized,wait与notify</p>
<h2 id="启动一个线程是用run-还是start"><a href="#启动一个线程是用run-还是start" class="headerlink" title="启动一个线程是用run()还是start()"></a>启动一个线程是用run()还是start()</h2><p>启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行。run()方法可以产生必须退出的标志来停止一个线程。 </p>
<h2 id="final-finally-finalize的区别"><a href="#final-finally-finalize的区别" class="headerlink" title="final,finally,finalize的区别"></a>final,finally,finalize的区别</h2><p>final—修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载。<br>　　finally—再异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。<br>　　finalize—方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。 </p>
<h2 id="abstract-class和interface有什么区别"><a href="#abstract-class和interface有什么区别" class="headerlink" title="abstract class和interface有什么区别"></a>abstract class和interface有什么区别</h2><p>抽象类与接口的区别：<br>1.接口可以多重继承 ，抽象类不可以<br>2.接口定义方法，不给实现；而抽象类可以实现部分方法<br>3.接口中基本数据类型的数据成员，都默认为static和final，抽象类则不是<br>如果事先知道某种东西会成为基础类，那么第一个选择就是把它变成一个接口。<br>只有在必须使用方法定义或者成员变量的时候，才应考虑采用抽象类。</p>
<h2 id="Set里的元素不能重复，用-还是equals-判断"><a href="#Set里的元素不能重复，用-还是equals-判断" class="headerlink" title="Set里的元素不能重复，用==还是equals ()判断"></a>Set里的元素不能重复，用==还是equals ()判断</h2><p>Set里的元素是不能重复的，那么用iterator()方法来区分重复与否。equals()是判读两个Set是否相等。<br>equals()和==方法决定引用值是否指向同一对象equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。</p>
<h2 id="struts-框架是如何体现MVC模式"><a href="#struts-框架是如何体现MVC模式" class="headerlink" title="struts 框架是如何体现MVC模式"></a>struts 框架是如何体现MVC模式</h2><p>struts 框架为开发者提供了MVC 的3个逻辑组成部分，主要由ActionServlet、Action和strust-config.xml配置文件组成控制层，由ActionForm 来承担模型层的功能，而struts 下的视图由JSP来完成。<br>处理请求：由ActionServlet接收请求，然后根据 struts-config.xml 中的配置，类判断由于哪个Action来处理请求和由哪个ActionForm来保存数据，在通过Action的返回值来判断应该由哪个JSP来负责页面的展示，最后由 JSP 来完成结果响应。</p>
<h2 id="Hibernate-的实体存在哪几种状态"><a href="#Hibernate-的实体存在哪几种状态" class="headerlink" title="Hibernate 的实体存在哪几种状态"></a>Hibernate 的实体存在哪几种状态</h2><p>Hibernate 中的实体在它的生命周期里面，存在 3 中状态。<br>瞬时：new语句创建的实体类对象是就是瞬时状态，它一般没有id。<br>持久：存放在 Session 中的实体对象就属于持久状态，一般通过 save() 或 saveOrUpdate()等等，方法转换而来。<br>托管：实体中Session中脱离出来的时候，它的状态就属于托管状态了，尽管它具有 id 值，但已经不存在Session 中了，即使 实体中的数据发生变化也不能同步到数据库中。通过 close()、evict()等方法转化而来。</p>
<h2 id="Hibernate-的get-和load-的区别"><a href="#Hibernate-的get-和load-的区别" class="headerlink" title="Hibernate 的get()和load()的区别"></a>Hibernate 的get()和load()的区别</h2><p>Hibernate 对于 load() 方法该方法认为数据一定存在于数据，可以放心的代理来延迟加载，如果在使用过程中发现了问题，只能抛出异常，而get()方法可以不存在。</p>
<h2 id="为什么wait和notify方法要在同步块中调用"><a href="#为什么wait和notify方法要在同步块中调用" class="headerlink" title="为什么wait和notify方法要在同步块中调用"></a>为什么wait和notify方法要在同步块中调用</h2><p>主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。还有一个原因是为了避免wait和notify之间产生竞态条件。</p>
<h2 id="什么是ThreadLocal变量"><a href="#什么是ThreadLocal变量" class="headerlink" title="什么是ThreadLocal变量"></a>什么是ThreadLocal变量</h2><p>ThreadLocal是Java里一种特殊的变量。每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用ThreadLocal让SimpleDateFormat变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。线程局部变量的另一个不错的例子是ThreadLocalRandom类，它在多线程环境中减少了创建代价高昂的Random对象的个数。</p>
<h2 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h2><p>Java多线程中的死锁<br>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件：<br>互斥条件：一个资源每次只能被一个进程使用。<br>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。<br>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。<br>避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。</p>
<h2 id="Java中活锁和死锁有什么区别"><a href="#Java中活锁和死锁有什么区别" class="headerlink" title="Java中活锁和死锁有什么区别"></a>Java中活锁和死锁有什么区别</h2><p>这是上题的扩展，活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者进程的状态可以改变但是却不能继续执行。</p>
<h2 id="怎么检测一个线程是否拥有锁"><a href="#怎么检测一个线程是否拥有锁" class="headerlink" title="怎么检测一个线程是否拥有锁"></a>怎么检测一个线程是否拥有锁</h2><p>我一直不知道我们竟然可以检测一个线程是否拥有锁，直到我参加了一次电话面试。在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。</p>
<h2 id="Maven有哪些优点"><a href="#Maven有哪些优点" class="headerlink" title="Maven有哪些优点"></a>Maven有哪些优点</h2><p>优点如下：<br>简化了项目依赖管理：<br>易于上手，对于新手可能一个”mvn clean package”命令就可能满足他的工作<br>便于与持续集成工具（jenkins）整合<br>便于项目升级，无论是项目本身升级还是项目使用的依赖升级。<br>有助于多模块项目的开发，一个模块开发好后，发布到仓库，依赖该模块时可以直接从仓库更新，而不用自己去编译。<br>maven有很多插件，便于功能扩展，比如生产站点，自动发布版本等</p>
<h2 id="Maven常见的依赖范围有哪些"><a href="#Maven常见的依赖范围有哪些" class="headerlink" title="Maven常见的依赖范围有哪些"></a>Maven常见的依赖范围有哪些</h2><p>1.compile:编译依赖，默认的依赖方式，在编译（编译项目和编译测试用例），运行测试用例，运行（项目实际运行）三个阶段都有效，典型地有spring-core等jar。<br>2.test:测试依赖，只在编译测试用例和运行测试用例有效，典型地有JUnit。<br>provided:对于编译和测试有效，不会打包进发布包中，典型的例子为servlet-api,一般的web工程运行时都使用容器的servlet-api。<br>3.runtime:只在运行测试用例和实际运行时有效，典型地是jdbc驱动jar包。<br>4.system: 不从maven仓库获取该jar,而是通过systemPath指定该jar的路径。<br>5.import: 用于一个dependencyManagement对另一个dependencyManagement的继承。</p>
<h2 id="使用“Mvn-Clean-Package”进行项目打包-其过程执行了哪些动作"><a href="#使用“Mvn-Clean-Package”进行项目打包-其过程执行了哪些动作" class="headerlink" title="使用“Mvn Clean Package”进行项目打包,其过程执行了哪些动作"></a>使用“Mvn Clean Package”进行项目打包,其过程执行了哪些动作</h2><p>在这个命令中我们调用了maven的clean周期的clean阶段绑定的插件任务，以及default周期的package阶段绑定的插件任务<br>默认执行的任务有（maven的术语叫goal, 也有人翻译成目标，我这里用任务啦）：</p>
<p>maven-clean-plugin:clean-&gt;<br>maven-resources-plugin:resources-&gt;<br>maven-compile-plugin:compile-&gt;<br>mavne-resources-plugin:testResources-&gt;<br>maven-compile-plugin:testCompile-&gt;<br>maven-jar-plugin:jar</p>
<h2 id="Maven-多模块如何聚合"><a href="#Maven-多模块如何聚合" class="headerlink" title="Maven 多模块如何聚合"></a>Maven 多模块如何聚合</h2><p>配置一个打包类型为pom的聚合模块，然后在该pom中使用<module>元素声明要聚合的模块</module></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/基础面试题/" rel="tag"># 基础面试题</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/01/15/Python 的基本要素/" rel="next" title="Python 的基本要素">
                <i class="fa fa-chevron-left"></i> Python 的基本要素
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ4My82MDUx"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="ShenWenFang" />
            
              <p class="site-author-name" itemprop="name">ShenWenFang</p>
              <p class="site-description motion-element" itemprop="description">每一个你不满意的现在，都有一个你没有努力的曾经。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

         <div id="music163player">
             <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=31861269&auto=0&height=66"></iframe>
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基础面试题"><span class="nav-number">1.</span> <span class="nav-text">基础面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言："><span class="nav-number">1.1.</span> <span class="nav-text">引言：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#forward-和redirect的区别"><span class="nav-number">1.2.</span> <span class="nav-text">forward 和redirect的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#int-和-Integer-有什么区别"><span class="nav-number">1.3.</span> <span class="nav-text">int 和 Integer 有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#error和exception有什么区别"><span class="nav-number">1.4.</span> <span class="nav-text">error和exception有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Overload和Override区别，Overloaded方法可以改变返回值的类型吗"><span class="nav-number">1.5.</span> <span class="nav-text">Overload和Override区别，Overloaded方法可以改变返回值的类型吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java中有哪些集合，主要方法有哪些"><span class="nav-number">1.6.</span> <span class="nav-text">java中有哪些集合，主要方法有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List、Map、Set接口，存取元素时各自特点"><span class="nav-number">1.7.</span> <span class="nav-text">List、Map、Set接口，存取元素时各自特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap与HashTable的区别"><span class="nav-number">1.8.</span> <span class="nav-text">HashMap与HashTable的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap，ConcurrentHashMap与LinkedHashMap的区别"><span class="nav-number">1.9.</span> <span class="nav-text">HashMap，ConcurrentHashMap与LinkedHashMap的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vector和ArrayList的区别"><span class="nav-number">1.10.</span> <span class="nav-text">Vector和ArrayList的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayList-与-LinkedList-的不区别"><span class="nav-number">1.11.</span> <span class="nav-text">ArrayList 与 LinkedList 的不区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-中的-LinkedList-是单向链表还是双向链表"><span class="nav-number">1.12.</span> <span class="nav-text">Java 中的 LinkedList 是单向链表还是双向链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String、StringBuffer、StringBuilder之间区别"><span class="nav-number">1.13.</span> <span class="nav-text">String、StringBuffer、StringBuilder之间区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-的常用方有哪些"><span class="nav-number">1.14.</span> <span class="nav-text">Object 的常用方有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mysql-的分页-SQL-语句"><span class="nav-number">1.15.</span> <span class="nav-text">Mysql 的分页 SQL 语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hibernate与MyBatis的异同"><span class="nav-number">1.16.</span> <span class="nav-text">Hibernate与MyBatis的异同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hibernate与MyBatis在sql优化方面异同"><span class="nav-number">1.17.</span> <span class="nav-text">Hibernate与MyBatis在sql优化方面异同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hibernate与MyBatis对象管理对比"><span class="nav-number">1.18.</span> <span class="nav-text">Hibernate与MyBatis对象管理对比</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Jsp九大内置对象"><span class="nav-number">1.19.</span> <span class="nav-text">Jsp九大内置对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Comparator-与-Comparable-有什么不同"><span class="nav-number">1.20.</span> <span class="nav-text">Comparator 与 Comparable 有什么不同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collection-和-Collections的区别"><span class="nav-number">1.21.</span> <span class="nav-text">Collection 和 Collections的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程同步的方法"><span class="nav-number">1.22.</span> <span class="nav-text">线程同步的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Volatile和Synchronized四个不同点"><span class="nav-number">1.23.</span> <span class="nav-text">Volatile和Synchronized四个不同点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringMVC运行原理"><span class="nav-number">1.24.</span> <span class="nav-text">SpringMVC运行原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringMVC与Struts2区别与比较总结"><span class="nav-number">1.25.</span> <span class="nav-text">SpringMVC与Struts2区别与比较总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简单总结springMVC和struts2的区别"><span class="nav-number">1.26.</span> <span class="nav-text">简单总结springMVC和struts2的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringMvc怎么和AJAX相互调用的"><span class="nav-number">1.27.</span> <span class="nav-text">SpringMvc怎么和AJAX相互调用的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring有哪些优点"><span class="nav-number">1.28.</span> <span class="nav-text">Spring有哪些优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解释AOP模块"><span class="nav-number">1.29.</span> <span class="nav-text">解释AOP模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IoC容器是什么其优点"><span class="nav-number">1.30.</span> <span class="nav-text">IoC容器是什么其优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-的依赖注入方式有哪一些"><span class="nav-number">1.31.</span> <span class="nav-text">Spring 的依赖注入方式有哪一些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring支持的事务管理类型"><span class="nav-number">1.32.</span> <span class="nav-text">Spring支持的事务管理类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal-线程变量副本"><span class="nav-number">1.33.</span> <span class="nav-text">ThreadLocal(线程变量副本)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#throw-和-throws-的区别"><span class="nav-number">1.34.</span> <span class="nav-text">throw 和 throws 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final关键字的作用"><span class="nav-number">1.35.</span> <span class="nav-text">final关键字的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String是最基本的数据类型吗"><span class="nav-number">1.36.</span> <span class="nav-text">String是最基本的数据类型吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized和java-util-concurrent-locks-Lock的异同"><span class="nav-number">1.37.</span> <span class="nav-text">synchronized和java.util.concurrent.locks.Lock的异同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spring的事务有几种它的隔离级别和传播行为"><span class="nav-number">1.38.</span> <span class="nav-text">spring的事务有几种它的隔离级别和传播行为</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sleep-和-wait-有什么区别"><span class="nav-number">1.39.</span> <span class="nav-text">sleep() 和 wait() 有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程和同步有几种实现方法"><span class="nav-number">1.40.</span> <span class="nav-text">多线程和同步有几种实现方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#启动一个线程是用run-还是start"><span class="nav-number">1.41.</span> <span class="nav-text">启动一个线程是用run()还是start()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final-finally-finalize的区别"><span class="nav-number">1.42.</span> <span class="nav-text">final,finally,finalize的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#abstract-class和interface有什么区别"><span class="nav-number">1.43.</span> <span class="nav-text">abstract class和interface有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Set里的元素不能重复，用-还是equals-判断"><span class="nav-number">1.44.</span> <span class="nav-text">Set里的元素不能重复，用==还是equals ()判断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#struts-框架是如何体现MVC模式"><span class="nav-number">1.45.</span> <span class="nav-text">struts 框架是如何体现MVC模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hibernate-的实体存在哪几种状态"><span class="nav-number">1.46.</span> <span class="nav-text">Hibernate 的实体存在哪几种状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hibernate-的get-和load-的区别"><span class="nav-number">1.47.</span> <span class="nav-text">Hibernate 的get()和load()的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么wait和notify方法要在同步块中调用"><span class="nav-number">1.48.</span> <span class="nav-text">为什么wait和notify方法要在同步块中调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是ThreadLocal变量"><span class="nav-number">1.49.</span> <span class="nav-text">什么是ThreadLocal变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何避免死锁"><span class="nav-number">1.50.</span> <span class="nav-text">如何避免死锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java中活锁和死锁有什么区别"><span class="nav-number">1.51.</span> <span class="nav-text">Java中活锁和死锁有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#怎么检测一个线程是否拥有锁"><span class="nav-number">1.52.</span> <span class="nav-text">怎么检测一个线程是否拥有锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Maven有哪些优点"><span class="nav-number">1.53.</span> <span class="nav-text">Maven有哪些优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Maven常见的依赖范围有哪些"><span class="nav-number">1.54.</span> <span class="nav-text">Maven常见的依赖范围有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用“Mvn-Clean-Package”进行项目打包-其过程执行了哪些动作"><span class="nav-number">1.55.</span> <span class="nav-text">使用“Mvn Clean Package”进行项目打包,其过程执行了哪些动作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Maven-多模块如何聚合"><span class="nav-number">1.56.</span> <span class="nav-text">Maven 多模块如何聚合</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ShenWenFang</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("9lk8dNt56FULANV18qHRXIff-gzGzoHsz", "lSea2qzYEcPELI1zQN1wWQGt");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
