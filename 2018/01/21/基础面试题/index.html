<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="基础面试题," />










<meta name="description" content="基础面试题引言：以下各方面知识点的面试题，是为了将要出来工作的小师妹和小师弟而精心整理的。希望对你们都帮助。这些面试题都是很基础的，希望你们能够好好利用起来。有问题，或者不对的地方欢迎给我留言哈！">
<meta name="keywords" content="基础面试题">
<meta property="og:type" content="article">
<meta property="og:title" content="基础面试题">
<meta property="og:url" content="http://yoursite.com/2018/01/21/基础面试题/index.html">
<meta property="og:site_name" content="ShenWenFang">
<meta property="og:description" content="基础面试题引言：以下各方面知识点的面试题，是为了将要出来工作的小师妹和小师弟而精心整理的。希望对你们都帮助。这些面试题都是很基础的，希望你们能够好好利用起来。有问题，或者不对的地方欢迎给我留言哈！">
<meta property="og:updated_time" content="2018-04-01T15:08:13.525Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="基础面试题">
<meta name="twitter:description" content="基础面试题引言：以下各方面知识点的面试题，是为了将要出来工作的小师妹和小师弟而精心整理的。希望对你们都帮助。这些面试题都是很基础的，希望你们能够好好利用起来。有问题，或者不对的地方欢迎给我留言哈！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/01/21/基础面试题/"/>





  <title>基础面试题 | ShenWenFang</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/another"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://camo.githubusercontent.com/c6286ade715e9bea433b4705870de482a654f78a/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f77686974655f6666666666662e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_left_white_ffffff.png"></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ShenWenFang</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/21/基础面试题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ShenWenFang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShenWenFang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">基础面试题</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-21T20:01:03+08:00">
                2018-01-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/基础面试题/" itemprop="url" rel="index">
                    <span itemprop="name">基础面试题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/01/21/基础面试题/" class="leancloud_visitors" data-flag-title="基础面试题">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  25,071 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  91 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="基础面试题"><a href="#基础面试题" class="headerlink" title="基础面试题"></a>基础面试题</h1><h2 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h2><p>以下各方面知识点的面试题，是为了将要出来工作的小师妹和小师弟而精心整理的。希望对你们都帮助。这些面试题都是很基础的，希望你们能够好好利用起来。有问题，或者不对的地方欢迎给我留言哈！</p>
<a id="more"></a>
<h2 id="forward-和redirect的区别"><a href="#forward-和redirect的区别" class="headerlink" title="forward 和redirect的区别"></a>forward 和redirect的区别</h2><p>forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。</p>
<p>redirect就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求，所以session,request参数都可以获取。</p>
<h2 id="int-和-Integer-有什么区别"><a href="#int-和-Integer-有什么区别" class="headerlink" title="int 和 Integer 有什么区别"></a>int 和 Integer 有什么区别</h2><p>Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int 是 java 的原始数据类型，Integer 是 java为int提供的封装类。Java为每个原始类型提供了封装类。<br>原始类型封装类，booleanBoolean,charCharacter,byteByte,shortShort,intInteger,longLong,floatFloat,doubleDouble<br>引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为 null，而原始类型实例变量的缺省值与它们的类型有关</p>
<h2 id="error和exception有什么区别"><a href="#error和exception有什么区别" class="headerlink" title="error和exception有什么区别"></a>error和exception有什么区别</h2><p>error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。</p>
<h2 id="最常见到的runtime-exception"><a href="#最常见到的runtime-exception" class="headerlink" title="最常见到的runtime exception"></a>最常见到的runtime exception</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ArithmeticException, ArrayStoreException, </div><div class="line">BufferOverflowException, BufferUnderflowException, </div><div class="line">CannotRedoException, CannotUndoException, </div><div class="line">ClassCastException, CMMException, </div><div class="line">ConcurrentModificationException, DOMException, </div><div class="line">EmptyStackException, IllegalArgumentException, </div><div class="line">IllegalMonitorStateException, IllegalPathStateException, </div><div class="line">IllegalStateException, ImagingOpException, </div><div class="line">IndexOutOfBoundsException, MissingResourceException, </div><div class="line">NegativeArraySizeException, NoSuchElementException, </div><div class="line">NullPointerException, ProfileDataException, </div><div class="line">ProviderException, RasterFormatException, SecurityException, </div><div class="line">SystemException, UndeclaredThrowableException, </div><div class="line">UnmodifiableSetException, UnsupportedOperationException</div></pre></td></tr></table></figure>
<h2 id="Overload和Override区别，Overloaded方法可以改变返回值的类型吗"><a href="#Overload和Override区别，Overloaded方法可以改变返回值的类型吗" class="headerlink" title="Overload和Override区别，Overloaded方法可以改变返回值的类型吗"></a>Overload和Override区别，Overloaded方法可以改变返回值的类型吗</h2><p>方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被”屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。</p>
<h2 id="java中有哪些集合，主要方法有哪些"><a href="#java中有哪些集合，主要方法有哪些" class="headerlink" title="java中有哪些集合，主要方法有哪些"></a>java中有哪些集合，主要方法有哪些</h2><p>主要有LinkedList，ArrayList，Vector等。下面是详细：<br>Collection<br>├List<br>│├LinkedList<br>│├ArrayList<br>│└Vector<br>│ └Stack<br>└Set<br>Map<br>├Hashtable<br>├HashMap<br>└WeakHashMap<br>最常用的集合类是 List 和 Map。 List 的具体实现包括 ArrayList 和 Vector，它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。 List 适用于按数值索引访问元素的情形。 Map 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作“键”和“值”）其中每个键映射到一个值。</p>
<h2 id="List、Map、Set接口，存取元素时各自特点"><a href="#List、Map、Set接口，存取元素时各自特点" class="headerlink" title="List、Map、Set接口，存取元素时各自特点"></a>List、Map、Set接口，存取元素时各自特点</h2><p>List 以特定次序来持有元素，可有重复元素。Set 无法拥有重复元素,内部排序。Map 保存key-value值，value可多值。<br>  List的遍历： List接口有size()和get()方法，用这两个方法可以实现对List的遍历。size()方法得到List中的元素个数。get()方法取得某个位置上的元素</p>
<h2 id="HashMap与HashTable的区别"><a href="#HashMap与HashTable的区别" class="headerlink" title="HashMap与HashTable的区别"></a>HashMap与HashTable的区别</h2><p>1、HashMap 是非线程安全的，HashTable 是线程安全的。</p>
<p>2、HashMap 的键和值都允许有 null 值存在，而 HashTable 则不行。</p>
<p>3、因为线程安全的问题，HashMap 效率比 HashTable 的要高。<br>HashMap 的实现机制：<br>维护一个每个元素是一个链表的数组，而且链表中的每个节点是一个 Entry[] 键值对的数据结构。<br>实现了 数组+链表 的特性，查找快，插入删除也快。<br>对于每个 key , 他对应的数组索引下标是 int i = hash(key.hashcode)&amp;(len-1);<br>每个新加入的节点放在链表首，然后该新加入的节点指向原链表首</p>
<h2 id="HashMap，ConcurrentHashMap与LinkedHashMap的区别"><a href="#HashMap，ConcurrentHashMap与LinkedHashMap的区别" class="headerlink" title="HashMap，ConcurrentHashMap与LinkedHashMap的区别"></a>HashMap，ConcurrentHashMap与LinkedHashMap的区别</h2><p>ConcurrentHashMap是使用了锁分段技术技术来保证线程安全的，锁分段技术：首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问<br>ConcurrentHashMap 是在每个段（segment）中线程安全的<br>LinkedHashMap维护一个双链表，可以将里面的数据按写入的顺序读出</p>
<p>ConcurrentHashMap应用场景<br>1：ConcurrentHashMap 的应用场景是高并发，但是并不能保证线程安全，而同步的 HashMap 和 HashMap 的是锁住整个容器，而加锁之后 ConcurrentHashMap 不需要锁住整个容器，只需要锁住对应的 Segment 就好了，所以可以保证高并发同步访问，提升了效率。<br>2：可以多线程写。<br>ConcurrentHashMap把HashMap分成若干个Segmenet<br>1.get时，不加锁，先定位到segment然后在找到头结点进行读取操作。而value是volatile变量，所以可以保证在竞争条件时保证读取最新的值，如果读到的value是null，则可能正在修改，那么久调用ReadValueUnderLock函数，加锁保证读到的数据是正确的。</p>
<p>2.Put时会加锁，一律添加到hash链的头部。</p>
<p>3.Remove时也会加锁，由于next是final类型不可改变，所以必须把删除的节点之前的节点都复制一遍。</p>
<p>4.ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对Hash表的不同Segment进行的修改。<br>ConcurrentHashMap的应用场景是高并发，但是并不能保证线程安全，而同步的HashMap和HashTable的是锁住整个容器，而加锁之后ConcurrentHashMap不需要锁住整个容器，只需要锁住对应的segment就好了，所以可以保证高并发同步访问，提升了效率。</p>
<h2 id="Vector和ArrayList的区别"><a href="#Vector和ArrayList的区别" class="headerlink" title="Vector和ArrayList的区别"></a>Vector和ArrayList的区别</h2><p>  首先看这两类都实现List接口，而List接口一共有三个实现类，分别是 ArrayList、Vector 和 LinkedList 。List 用于存放多个元素，能够维护元素的次序，并且允许元素的重复。3个具体实现类的相关区别如下：</p>
<p>1.ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。<br>2.Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。<br>3.LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。</p>
<h2 id="ArrayList-与-LinkedList-的区别"><a href="#ArrayList-与-LinkedList-的区别" class="headerlink" title="ArrayList 与 LinkedList 的区别"></a>ArrayList 与 LinkedList 的区别</h2><p>最明显的区别是 ArrrayList 底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。<br>1.LinkedList内部存储的是Node<e>，不仅要维护数据域，还要维护prev和next，如果LinkedList中的结点特别多，则LinkedList比ArrayList更占内存。<br>插入删除操作效率：<br>2.LinkedList在做插入和删除操作时，插入或删除头部或尾部时是高效的，操作越靠近中间位置的元素时，需要遍历查找，速度相对慢一些，如果在数据量较大时，每次插入或删除时遍历查找比较费时。所以LinkedList插入与删除，慢在遍历查找，快在只需要更改相关结点的引用地址。<br>ArrayList在做插入和删除操作时，插入或删除尾部时也一样是高效的，操作其他位置，则需要批量移动元素，所以ArrayList插入与删除，快在遍历查找，慢在需要批量移动元素。<br>3.循环遍历效率：<br>由于ArrayList实现了RandomAccess随机访问接口，所以使用for(int i = 0; i &lt; size; i++)遍历会比使用Iterator迭代器来遍历快<br>而由于LinkedList未实现RandomAccess接口，所以推荐使用Iterator迭代器来遍历数据。<br>因此，如果我们需要频繁在列表的中部改变插入或删除元素时，建议使用LinkedList，否则，建议使用ArrayList，因为ArrayList遍历查找元素较快，并且只需存储元素的数据域，不需要额外记录其他数据的位置信息，可以节省内存空间。</e></p>
<h2 id="Java-中的-LinkedList-是单向链表还是双向链表"><a href="#Java-中的-LinkedList-是单向链表还是双向链表" class="headerlink" title="Java 中的 LinkedList 是单向链表还是双向链表"></a>Java 中的 LinkedList 是单向链表还是双向链表</h2><p>是双向链表。</p>
<h2 id="String、StringBuffer、StringBuilder之间区别"><a href="#String、StringBuffer、StringBuilder之间区别" class="headerlink" title="String、StringBuffer、StringBuilder之间区别"></a>String、StringBuffer、StringBuilder之间区别</h2><p>1.三者在执行速度方面的比较：StringBuilder &gt;  StringBuffer  &gt;  String<br>2.在线程方面：StringBuilder是线程非安全的;StringBuffer是线程安全的</p>
<p>3.对于三者的使用：如果要操作少量的数据用 = String；单线程操作字符串缓冲区 下操作大量数据 = StringBuilder；多线程操作字符串缓冲区 下操作大量数据 = StringBuffer；</p>
<h2 id="Object-的常用方有哪些"><a href="#Object-的常用方有哪些" class="headerlink" title="Object 的常用方有哪些"></a>Object 的常用方有哪些</h2><p>clone()、equals()、hashCode()、notify()、notifyAll()、toString()、wait()、finalize()</p>
<h2 id="Mysql-的分页-SQL-语句"><a href="#Mysql-的分页-SQL-语句" class="headerlink" title="Mysql 的分页 SQL 语句"></a>Mysql 的分页 SQL 语句</h2><p>select * from tablename limit m,n(n是指从第m+1条开始，取n条)</p>
<h2 id="Hibernate与MyBatis的异同"><a href="#Hibernate与MyBatis的异同" class="headerlink" title="Hibernate与MyBatis的异同"></a>Hibernate与MyBatis的异同</h2><p>相同点：<br>Hibernate与MyBatis都可以是通过SessionFactoryBuider由XML配置文件生成SessionFactory，然后由SessionFactory 生成Session，最后由Session来开启执行事务和SQL语句。其中SessionFactoryBuider，SessionFactory，Session的生命周期都是差不多的。Hibernate和MyBatis都支持JDBC和JTA事务处理。<br>Mybatis优势：<br>MyBatis可以进行更为细致的SQL优化，可以减少查询字段。<br>MyBatis容易掌握，而Hibernate门槛较高。<br>Hibernate优势：<br>Hibernate的DAO层开发比MyBatis简单，Mybatis需要维护SQL和结果映射。<br>Hibernate对对象的维护和缓存要比MyBatis好，对增删改查的对象的维护要方便。<br>Hibernate数据库移植性很好，MyBatis的数据库移植性不好，不同的数据库需要写不同SQL。<br>Hibernate有更好的二级缓存机制，可以使用第三方缓存。MyBatis本身提供的缓存机制不佳。</p>
<h2 id="Hibernate与MyBatis在sql优化方面异同"><a href="#Hibernate与MyBatis在sql优化方面异同" class="headerlink" title="Hibernate与MyBatis在sql优化方面异同"></a>Hibernate与MyBatis在sql优化方面异同</h2><p>Hibernate的查询会将表中的所有字段查询出来，这一点会有性能消耗。Hibernate也可以自己写SQL来指定需要查询的字段，但这样就破坏了Hibernate开发的简洁性。<br>而Mybatis的SQL是手动编写的，所以可以按需求指定查询的字段。<br>Hibernate HQL语句的调优需要将SQL打印出来，而Hibernate的SQL被很多人嫌弃因为太丑了。<br>MyBatis的SQL是自己手动写的所以调整方便。但Hibernate具有自己的日志统计。Mybatis本身不带日志统计，使用Log4j进行日志记录。</p>
<h2 id="Hibernate与MyBatis对象管理对比"><a href="#Hibernate与MyBatis对象管理对比" class="headerlink" title="Hibernate与MyBatis对象管理对比"></a>Hibernate与MyBatis对象管理对比</h2><p>Hibernate 是完整的对象/关系映射解决方案，它提供了对象状态管理（state management）的功能，使开发者不再需要理会底层数据库系统的细节。也就是说，相对于常见的 JDBC/SQL 持久层方案中需要管理 SQL 语句，Hibernate采用了更自然的面向对象的视角来持久化 Java 应用中的数据。<br>换句话说，使用 Hibernate 的开发者应该总是关注对象的状态（state），不必考虑 SQL 语句的执行。这部分细节已经由 Hibernate 掌管妥当，只有开发者在进行系统性能调优的时候才需要进行了解。而MyBatis在这一块没有文档说明，用户需要对对象自己进行详细的管理。</p>
<h2 id="Jsp九大内置对象"><a href="#Jsp九大内置对象" class="headerlink" title="Jsp九大内置对象"></a>Jsp九大内置对象</h2><p>1.Request:   request对象主要用于客户端请求处理<br>2.Response:   response对象提供了多个方法用来处理HTTP响应，可以调用response中的方法修改ContentType中的MIME类型以及实现页面的跳转等等，<br>3.Page:  page对象有点类似于Java编程中的this指针，就是指当前JSP页面本身。page是java.lang.Object类的对象。<br>4.Session:  session是与请求有关的会话期，它是java.servlet.http.HttpSession类的对象，用来表示和存储当前页面的请求信息。<br>5.Application:  application是javax.servlet.ServletContext类对象的一个实例，用于实现用户之间的数据共享<br>6.Out:<br>7.Exception:  exception内置对象是用来处理页面出现的异常错误<br>8.Config:  config内置对象是ServletConfig类的一个实例。在Servlet初始化的时候，JSP引擎通过config向它传递信息。这种信息可以是属性名/值匹配的参数，也可以是通过ServletContext对象传递的服务器的有关信息。<br>9.pageContext:  pageContext对象是一个比较特殊的对象。它相当于页面中所有其他对象功能的最大集成者，即使用它可以访问到本页面中所有其他对象</p>
<h2 id="Comparator-与-Comparable-有什么不同"><a href="#Comparator-与-Comparable-有什么不同" class="headerlink" title="Comparator 与 Comparable 有什么不同"></a>Comparator 与 Comparable 有什么不同</h2><p>Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。</p>
<h2 id="Collection-和-Collections的区别"><a href="#Collection-和-Collections的区别" class="headerlink" title="Collection 和 Collections的区别"></a>Collection 和 Collections的区别</h2><p>Collection是集合类的上级接口，继承与他的接口主要有Set 和List.<br>Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</p>
<h2 id="String-s-new-String-“xyz”-创建了几个String-Object"><a href="#String-s-new-String-“xyz”-创建了几个String-Object" class="headerlink" title="String s = new String(“xyz”);创建了几个String Object"></a>String s = new String(“xyz”);创建了几个String Object</h2><p>两个对象，一个是“xyx”,一个是指向“xyx”的引用对象s。</p>
<h2 id="线程同步的方法"><a href="#线程同步的方法" class="headerlink" title="线程同步的方法"></a>线程同步的方法</h2><p>wait():使一个线程处于等待状态，并且释放所持有的对象的lock。<br>sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。<br>notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。<br>Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。</p>
<h2 id="Volatile和Synchronized四个不同点"><a href="#Volatile和Synchronized四个不同点" class="headerlink" title="Volatile和Synchronized四个不同点"></a>Volatile和Synchronized四个不同点</h2><ol>
<li>粒度不同，前者锁对象和类，后者针对变量</li>
<li>syn阻塞，volatile线程不阻塞</li>
<li>syn保证三大特性，volatile不保证原子性</li>
<li>syn编译器优化，volatile不优化<br>volatile具备两种特性：<br>保证此变量对所有线程的可见性，指一条线程修改了这个变量的值，新值对于其他线程来说是可见的，但并不是多线程安全的。<br>禁止指令重排序优化。<br>Volatile如何保证内存可见性:<br>1.当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。<br>2.当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。<br>同步：就是一个任务的完成需要依赖另外一个任务，只有等待被依赖的任务完成后，依赖任务才能完成。<br>异步：不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，只要自己任务完成了就算完成了，被依赖的任务是否完成会通知回来。（异步的特点就是通知）。<br>打电话和发短信来比喻同步和异步操作。<br>阻塞：CPU停下来等一个慢的操作完成以后，才会接着完成其他的工作。<br>非阻塞：非阻塞就是在这个慢的执行时，CPU去做其他工作，等这个慢的完成后，CPU才会接着完成后续的操作。<br>非阻塞会造成线程切换增加，增加CPU的使用时间能不能补偿系统的切换成本需要考虑。</li>
</ol>
<h2 id="SpringMVC运行原理"><a href="#SpringMVC运行原理" class="headerlink" title="SpringMVC运行原理"></a>SpringMVC运行原理</h2><ol>
<li>客户端请求提交到DispatcherServlet</li>
<li>由DispatcherServlet控制器查询HandlerMapping，找到并分发到指定的Controller中。</li>
<li>Controller调用业务逻辑处理后，返回ModelAndView</li>
<li>DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图</li>
<li>视图负责将结果显示到客户端</li>
</ol>
<h2 id="SpringMVC与Struts2区别与比较总结"><a href="#SpringMVC与Struts2区别与比较总结" class="headerlink" title="SpringMVC与Struts2区别与比较总结"></a>SpringMVC与Struts2区别与比较总结</h2><p>1、Struts2是类级别的拦截， 一个类对应一个request上下文，SpringMVC是方法级别的拦截，一个方法对应一个request上下文，而方法同时又跟一个url对应,所以说从架构本身上SpringMVC就容易实现restful url,而struts2的架构实现起来要费劲，因为Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了。</p>
<p>2、由上边原因，SpringMVC的方法之间基本上独立的，独享request response数据，请求数据通过参数获取，处理结果通过ModelMap交回给框架，方法之间不共享变量，而Struts2搞的就比较乱，虽然方法之间也是独立的，但其所有Action变量是共享的，这不会影响程序运行，却给我们编码 读程序时带来麻烦，每次来了请求就创建一个Action，一个Action对象对应一个request上下文。<br>3、由于Struts2需要针对每个request进行封装，把request，session等servlet生命周期的变量封装成一个一个Map，供给每个Action使用，并保证线程安全，所以在原则上，是比较耗费内存的。</p>
<p>4、 拦截器实现机制上，Struts2有以自己的interceptor机制，SpringMVC用的是独立的AOP方式，这样导致Struts2的配置文件量还是比SpringMVC大。</p>
<p>5、SpringMVC的入口是servlet，而Struts2是filter（这里要指出，filter和servlet是不同的。以前认为filter是servlet的一种特殊），这就导致了二者的机制不同，这里就牵涉到servlet和filter的区别了。</p>
<p>6、SpringMVC集成了Ajax，使用非常方便，只需一个注解@ResponseBody就可以实现，然后直接返回响应文本即可，而Struts2拦截器集成了Ajax，在Action中处理时一般必须安装插件或者自己写代码集成进去，使用起来也相对不方便。</p>
<p>7、SpringMVC验证支持JSR303，处理起来相对更加灵活方便，而Struts2验证比较繁琐，感觉太烦乱。</p>
<p>8、Spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高（当然Struts2也可以通过不同的目录结构和相关配置做到SpringMVC一样的效果，但是需要xml配置的地方不少）。</p>
<p>9、 设计思想上，Struts2更加符合OOP的编程思想， SpringMVC就比较谨慎，在servlet上扩展。</p>
<p>10、SpringMVC开发效率和性能高于Struts2。<br>11、SpringMVC可以认为已经100%零配置。</p>
<h2 id="简单总结springMVC和struts2的区别"><a href="#简单总结springMVC和struts2的区别" class="headerlink" title="简单总结springMVC和struts2的区别"></a>简单总结springMVC和struts2的区别</h2><ol>
<li>springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过虑器。</li>
<li>springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。</li>
<li>Struts采用值栈存储请求和响应的数据，通过OGNL存取数据， springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。</li>
</ol>
<h2 id="SpringMvc怎么和AJAX相互调用的"><a href="#SpringMvc怎么和AJAX相互调用的" class="headerlink" title="SpringMvc怎么和AJAX相互调用的"></a>SpringMvc怎么和AJAX相互调用的</h2><p>通过Jackson框架就可以把Java里面的对象直接转化成Js可以识别的Json对象<br>具体步骤如下<br>1.加入Jackson.jar<br>2.在配置文件中配置json的映射<br>3.在接受Ajax方法里面可以直接返回Object,List等,但方法前面要加上@ResponseBody注解</p>
<h2 id="Spring有哪些优点"><a href="#Spring有哪些优点" class="headerlink" title="Spring有哪些优点"></a>Spring有哪些优点</h2><p>1.轻量级：Spring在大小和透明性方面绝对属于轻量级的，基础版本的Spring框架大约只有2MB。<br>2.控制反转(IOC)：Spring使用控制反转技术实现了松耦合。依赖被注入到对象，而不是创建或寻找依赖对象。<br>3.面向切面编程(AOP)： Spring支持面向切面编程，同时把应用的业务逻辑与系统的服务分离开来。<br>4.容器：Spring包含并管理应用程序对象的配置及生命周期。<br>5.MVC框架：Spring的web框架是一个设计优良的web MVC框架，很好的取代了一些web框架。<br>6.事务管理：Spring对下至本地业务上至全局业务(JAT)提供了统一的事务管理接口。<br>7.异常处理：Spring提供一个方便的API将特定技术的异常(由JDBC, Hibernate, 或JDO抛出)转化为一致的、Unchecked异常。</p>
<h2 id="spring-主要使用了哪些-，IOC和AOP实现原理是什么"><a href="#spring-主要使用了哪些-，IOC和AOP实现原理是什么" class="headerlink" title="spring 主要使用了哪些 ，IOC和AOP实现原理是什么"></a>spring 主要使用了哪些 ，IOC和AOP实现原理是什么</h2><p>spring主要功能有IOC，AOP，MVC等，IOC实现原理：先反射生成实例，然后调用时主动注入。AOP原理：主要使用java动态代理。</p>
<h2 id="解释AOP模块"><a href="#解释AOP模块" class="headerlink" title="解释AOP模块"></a>解释AOP模块</h2><p>AOP模块用来开发Spring应用程序中具有切面性质的部分。该模块的大部分服务由AOP Aliance提供，这就保证了Spring框架和其他AOP框架之间的互操作性。另外，该模块将元数据编程引入到了Spring。</p>
<h2 id="IoC容器是什么其优点"><a href="#IoC容器是什么其优点" class="headerlink" title="IoC容器是什么其优点"></a>IoC容器是什么其优点</h2><p>Spring IOC负责创建对象、管理对象(通过依赖注入)、整合对象、配置对象以及管理这些对象的生命周期。<br>优点:<br>IOC或依赖注入减少了应用程序的代码量。它使得应用程序的测试很简单，因为在单元测试中不再需要单例或JNDI查找机制。简单的实现以及较少的干扰机制使得松耦合得以实现。IOC容器支持勤性单例及延迟加载服务。</p>
<h2 id="Spring-的依赖注入方式有哪一些"><a href="#Spring-的依赖注入方式有哪一些" class="headerlink" title="Spring 的依赖注入方式有哪一些"></a>Spring 的依赖注入方式有哪一些</h2><p>Spring 的依赖注入可以有两种方式来完成:setter 方法注入和构造方法注入。<br>构造器依赖注入：构造器依赖注入在容器触发构造器的时候完成，该构造器有一系列的参数，每个参数代表注入的对象。<br>Setter方法依赖注入：首先容器会触发一个无参构造函数或无参静态工厂方法实例化对象，之后容器调用bean中的setter方法完成Setter方法依赖注入。</p>
<h2 id="Spring支持的事务管理类型"><a href="#Spring支持的事务管理类型" class="headerlink" title="Spring支持的事务管理类型"></a>Spring支持的事务管理类型</h2><p>Spring支持如下两种方式的事务管理：<br>编程式事务管理：这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。<br>声明式事务管理：这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者XML配置管理事务。</p>
<h2 id="ThreadLocal-线程变量副本"><a href="#ThreadLocal-线程变量副本" class="headerlink" title="ThreadLocal(线程变量副本)"></a>ThreadLocal(线程变量副本)</h2><p>Synchronized实现内存共享，ThreadLocal为每个线程维护一个本地变量。</p>
<p>采用空间换时间，它用于线程间的数据隔离，为每一个使用该变量的线程提供一个副本，每个线程都可以独立地改变自己的副本，而不会和其他线程的副本冲突。</p>
<p>ThreadLocal类中维护一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值为对应线程的变量副本。</p>
<p>ThreadLocal在Spring中发挥着巨大的作用，在管理Request作用域中的Bean、事务管理、任务调度、AOP等模块都出现了它的身影。</p>
<p>Spring中绝大部分Bean都可以声明成Singleton作用域，采用ThreadLocal进行封装，因此有状态的Bean就能够以singleton的方式在多线程中正常工作了。</p>
<h2 id="throw-和-throws-的区别"><a href="#throw-和-throws-的区别" class="headerlink" title="throw 和 throws 的区别"></a>throw 和 throws 的区别</h2><p>throw 用于抛出 java.lang.Throwable 类的一个实例化对象，意思是说你可以通过关键字 throw 抛出一个 Error 或者 一个Exception，如：</p>
<p>throw new IllegalArgumentException(“size must be multiple of 2″)</p>
<p>而throws 的作用是作为方法声明和签名的一部分，方法被抛出相应的异常以便调用者能处理。Java 中，任何未处理的受检查异常强制在 throws 子句中声明。</p>
<h2 id="final关键字的作用"><a href="#final关键字的作用" class="headerlink" title="final关键字的作用"></a>final关键字的作用</h2><p>final class    表示此类不允许有子类。<br>final virable  表示一个常量。<br>final method   表示一个方法不能被重写</p>
<h2 id="static关键字有哪些作用"><a href="#static关键字有哪些作用" class="headerlink" title="static关键字有哪些作用"></a>static关键字有哪些作用</h2><p>static 修饰变量、修饰方法;静态块;静态内部类;静态导包;</p>
<h2 id="String是最基本的数据类型吗"><a href="#String是最基本的数据类型吗" class="headerlink" title="String是最基本的数据类型吗"></a>String是最基本的数据类型吗</h2><p>基本数据类型包括byte、int、char、long、float、double、boolean和short。java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类。</p>
<h2 id="synchronized和java-util-concurrent-locks-Lock的异同"><a href="#synchronized和java-util-concurrent-locks-Lock的异同" class="headerlink" title="synchronized和java.util.concurrent.locks.Lock的异同"></a>synchronized和java.util.concurrent.locks.Lock的异同</h2><p>主要相同点:<br>Lock 能完成 synchronized 所实现的所有功能.<br>主要不同点:<br>Lock 有比 synchronized 更精确的线程语义和更好的性能(在相同点中回答此点也行)<br>synchronized 会自动释放锁. 而 Lock 一定要求程序员手工释放.并且必须在 finally 从句<br>中释放,如果没有答出在 finally 中释放不得分.就如 Connection 没有在 finally 中关闭一<br>样.连最基本的资源释放都做不好,还谈什么多线程编程.</p>
<h2 id="spring的事务有几种它的隔离级别和传播行为"><a href="#spring的事务有几种它的隔离级别和传播行为" class="headerlink" title="spring的事务有几种它的隔离级别和传播行为"></a>spring的事务有几种它的隔离级别和传播行为</h2><p>声明式事务和编程式事务<br>隔离级别：</p>
<ul>
<li>DEFAULT使用数据库默认的隔离级别</li>
<li>READ_UNCOMMITTED会出现脏读，不可重复读和幻影读问题</li>
<li>READ_COMMITTED会出现重复读和幻影读</li>
<li>REPEATABLE_READ会出现幻影读</li>
<li>SERIALIZABLE最安全，但是代价最大，性能影响极其严重<br>和传播行：</li>
<li>REQUIRED存在事务就融入该事务，不存在就创建事务</li>
<li>SUPPORTS存在事务就融入事务，不存在则不创建事务</li>
<li>MANDATORY存在事务则融入该事务，不存在，抛异常</li>
<li>REQUIRES_NEW总是创建新事务</li>
<li>NOT_SUPPORTED存在事务则挂起，一直执行非事务操作</li>
<li>NEVER总是执行非事务，如果当前存在事务则抛异常</li>
<li>NESTED嵌入式事务</li>
</ul>
<h2 id="sleep-和-wait-有什么区别"><a href="#sleep-和-wait-有什么区别" class="headerlink" title="sleep() 和 wait() 有什么区别"></a>sleep() 和 wait() 有什么区别</h2><p>最大区别是等待时wait会释放锁，而sleep会一直持有锁，wait通常用于线程时交互，sleep通常被用于暂停执行。</p>
<p>sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。<br>wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。</p>
<h2 id="多线程和同步有几种实现方法"><a href="#多线程和同步有几种实现方法" class="headerlink" title="多线程和同步有几种实现方法"></a>多线程和同步有几种实现方法</h2><p>多线程有两种实现方法，分别是继承Thread类与实现Runnable接口<br>同步的实现方面有两种，分别是synchronized,wait与notify</p>
<h2 id="启动一个线程是用run-还是start"><a href="#启动一个线程是用run-还是start" class="headerlink" title="启动一个线程是用run()还是start()"></a>启动一个线程是用run()还是start()</h2><p>启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行。run()方法可以产生必须退出的标志来停止一个线程。 </p>
<h2 id="final-finally-finalize的区别"><a href="#final-finally-finalize的区别" class="headerlink" title="final,finally,finalize的区别"></a>final,finally,finalize的区别</h2><p>final—修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载。<br>　　finally—再异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。<br>　　finalize—方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。 </p>
<h2 id="abstract-class和interface有什么区别"><a href="#abstract-class和interface有什么区别" class="headerlink" title="abstract class和interface有什么区别"></a>abstract class和interface有什么区别</h2><p>抽象类与接口的区别：<br>1.接口可以多重继承 ，抽象类不可以<br>2.接口定义方法，不给实现；而抽象类可以实现部分方法<br>3.接口中基本数据类型的数据成员，都默认为static和final，抽象类则不是<br>如果事先知道某种东西会成为基础类，那么第一个选择就是把它变成一个接口。<br>只有在必须使用方法定义或者成员变量的时候，才应考虑采用抽象类。</p>
<h2 id="Set里的元素不能重复，用-还是equals-判断"><a href="#Set里的元素不能重复，用-还是equals-判断" class="headerlink" title="Set里的元素不能重复，用==还是equals ()判断"></a>Set里的元素不能重复，用==还是equals ()判断</h2><p>Set里的元素是不能重复的，那么用iterator()方法来区分重复与否。equals()是判读两个Set是否相等。<br>equals()和==方法决定引用值是否指向同一对象equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。</p>
<h2 id="struts-框架是如何体现MVC模式"><a href="#struts-框架是如何体现MVC模式" class="headerlink" title="struts 框架是如何体现MVC模式"></a>struts 框架是如何体现MVC模式</h2><p>struts 框架为开发者提供了MVC 的3个逻辑组成部分，主要由ActionServlet、Action和strust-config.xml配置文件组成控制层，由ActionForm 来承担模型层的功能，而struts 下的视图由JSP来完成。<br>处理请求：由ActionServlet接收请求，然后根据 struts-config.xml 中的配置，类判断由于哪个Action来处理请求和由哪个ActionForm来保存数据，在通过Action的返回值来判断应该由哪个JSP来负责页面的展示，最后由 JSP 来完成结果响应。</p>
<h2 id="Hibernate-的实体存在哪几种状态"><a href="#Hibernate-的实体存在哪几种状态" class="headerlink" title="Hibernate 的实体存在哪几种状态"></a>Hibernate 的实体存在哪几种状态</h2><p>Hibernate 中的实体在它的生命周期里面，存在 3 中状态。<br>瞬时：new语句创建的实体类对象是就是瞬时状态，它一般没有id。<br>持久：存放在 Session 中的实体对象就属于持久状态，一般通过 save() 或 saveOrUpdate()等等，方法转换而来。<br>托管：实体中Session中脱离出来的时候，它的状态就属于托管状态了，尽管它具有 id 值，但已经不存在Session 中了，即使 实体中的数据发生变化也不能同步到数据库中。通过 close()、evict()等方法转化而来。</p>
<h2 id="Hibernate-的get-和load-的区别"><a href="#Hibernate-的get-和load-的区别" class="headerlink" title="Hibernate 的get()和load()的区别"></a>Hibernate 的get()和load()的区别</h2><p>Hibernate 对于 load() 方法该方法认为数据一定存在于数据，可以放心的代理来延迟加载，如果在使用过程中发现了问题，只能抛出异常，而get()方法可以不存在。</p>
<h2 id="为什么wait和notify方法要在同步块中调用"><a href="#为什么wait和notify方法要在同步块中调用" class="headerlink" title="为什么wait和notify方法要在同步块中调用"></a>为什么wait和notify方法要在同步块中调用</h2><p>主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。还有一个原因是为了避免wait和notify之间产生竞态条件。</p>
<h2 id="什么是ThreadLocal变量"><a href="#什么是ThreadLocal变量" class="headerlink" title="什么是ThreadLocal变量"></a>什么是ThreadLocal变量</h2><p>ThreadLocal是Java里一种特殊的变量。每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用ThreadLocal让SimpleDateFormat变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。线程局部变量的另一个不错的例子是ThreadLocalRandom类，它在多线程环境中减少了创建代价高昂的Random对象的个数。</p>
<h2 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h2><p>Java多线程中的死锁<br>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件：<br>互斥条件：一个资源每次只能被一个进程使用。<br>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。<br>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。<br>避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。</p>
<h2 id="Java中活锁和死锁有什么区别"><a href="#Java中活锁和死锁有什么区别" class="headerlink" title="Java中活锁和死锁有什么区别"></a>Java中活锁和死锁有什么区别</h2><p>这是上题的扩展，活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者进程的状态可以改变但是却不能继续执行。</p>
<h2 id="怎么检测一个线程是否拥有锁"><a href="#怎么检测一个线程是否拥有锁" class="headerlink" title="怎么检测一个线程是否拥有锁"></a>怎么检测一个线程是否拥有锁</h2><p>我一直不知道我们竟然可以检测一个线程是否拥有锁，直到我参加了一次电话面试。在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。</p>
<h2 id="Maven有哪些优点"><a href="#Maven有哪些优点" class="headerlink" title="Maven有哪些优点"></a>Maven有哪些优点</h2><p>优点如下：<br>简化了项目依赖管理：<br>易于上手，对于新手可能一个”mvn clean package”命令就可能满足他的工作<br>便于与持续集成工具（jenkins）整合<br>便于项目升级，无论是项目本身升级还是项目使用的依赖升级。<br>有助于多模块项目的开发，一个模块开发好后，发布到仓库，依赖该模块时可以直接从仓库更新，而不用自己去编译。<br>maven有很多插件，便于功能扩展，比如生产站点，自动发布版本等</p>
<h2 id="Maven常见的依赖范围有哪些"><a href="#Maven常见的依赖范围有哪些" class="headerlink" title="Maven常见的依赖范围有哪些"></a>Maven常见的依赖范围有哪些</h2><p>1.compile:编译依赖，默认的依赖方式，在编译（编译项目和编译测试用例），运行测试用例，运行（项目实际运行）三个阶段都有效，典型地有spring-core等jar。<br>2.test:测试依赖，只在编译测试用例和运行测试用例有效，典型地有JUnit。<br>provided:对于编译和测试有效，不会打包进发布包中，典型的例子为servlet-api,一般的web工程运行时都使用容器的servlet-api。<br>3.runtime:只在运行测试用例和实际运行时有效，典型地是jdbc驱动jar包。<br>4.system: 不从maven仓库获取该jar,而是通过systemPath指定该jar的路径。<br>5.import: 用于一个dependencyManagement对另一个dependencyManagement的继承。</p>
<h2 id="使用“Mvn-Clean-Package”进行项目打包-其过程执行了哪些动作"><a href="#使用“Mvn-Clean-Package”进行项目打包-其过程执行了哪些动作" class="headerlink" title="使用“Mvn Clean Package”进行项目打包,其过程执行了哪些动作"></a>使用“Mvn Clean Package”进行项目打包,其过程执行了哪些动作</h2><p>在这个命令中我们调用了maven的clean周期的clean阶段绑定的插件任务，以及default周期的package阶段绑定的插件任务<br>默认执行的任务有（maven的术语叫goal, 也有人翻译成目标，我这里用任务啦）：</p>
<p>maven-clean-plugin:clean-&gt;<br>maven-resources-plugin:resources-&gt;<br>maven-compile-plugin:compile-&gt;<br>mavne-resources-plugin:testResources-&gt;<br>maven-compile-plugin:testCompile-&gt;<br>maven-jar-plugin:jar</p>
<h2 id="Maven-多模块如何聚合"><a href="#Maven-多模块如何聚合" class="headerlink" title="Maven 多模块如何聚合"></a>Maven 多模块如何聚合</h2><p>配置一个打包类型为pom的聚合模块，然后在该pom中使用<module>元素声明要聚合的模块</module></p>
<h2 id="缓存框架memcache和redis的区别？项目中，怎么去选择？"><a href="#缓存框架memcache和redis的区别？项目中，怎么去选择？" class="headerlink" title="缓存框架memcache和redis的区别？项目中，怎么去选择？"></a>缓存框架memcache和redis的区别？项目中，怎么去选择？</h2><p>ehcache,memcache和redis等。</p>
<p>区别：</p>
<ol>
<li>Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等。</li>
<li>Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储。</li>
<li>虚拟内存–Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘。</li>
<li>过期策略–memcache在set时就指定，例如set key1 0 0 8,即永不过期。Redis可以通 过例如expire 设定，例如expire name 10。</li>
<li>分布式–设定memcache集群，利用magent做一主多从;redis可以做一主多从。都 可以一主一从。</li>
<li>存储数据安全–memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）。</li>
<li>灾难恢复–memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复。</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份。</li>
</ol>
<h2 id="java的原子类，实现原理是什么"><a href="#java的原子类，实现原理是什么" class="headerlink" title="java的原子类，实现原理是什么"></a>java的原子类，实现原理是什么</h2><p>采用硬件提供原子操作指令实现的，即CAS。每次调用都会先判断预期的值是否符合，才进行写操作，保证数据安全。</p>
<h2 id="数据库性能优化有哪些方法"><a href="#数据库性能优化有哪些方法" class="headerlink" title="数据库性能优化有哪些方法"></a>数据库性能优化有哪些方法</h2><p>使用explain进行优化，查看sql是否充分使用索引。避免使用in,用exist替代，字段值尽可能使用更小的值，任何对列的操作都将导致表扫描，它包括数据库函数、计算表达式等等，查询时要尽可能将操作移至等号右边。使用连接查询(join)代替子查询。</p>
<p>在表的多列字段上建立一个索引，但只有在查询这些字段的第一个字段时，索引才会被使用。</p>
<h2 id="HTTP请求方法get和post有什么区别"><a href="#HTTP请求方法get和post有什么区别" class="headerlink" title="HTTP请求方法get和post有什么区别"></a>HTTP请求方法get和post有什么区别</h2><ol>
<li>Post传输数据时，不需要在URL中显示出来，而Get方法要在URL中显示。</li>
<li>Post传输的数据量大，可以达到2M，而Get方法由于受到URL长度限制,只能传递大约1024字节.</li>
<li>Post就是为了将数据传送到服务器段,Get就是为了从服务器段取得数据.而Get之所以也能传送数据,只是用来设计告诉服务器,你到底需要什么样的数据.Post的信息作为http请求的内容，而Get是在Http头部传输的。</li>
<li>其他 HTTP 请求方法</li>
</ol>
<ul>
<li>HEAD 与 GET 相同，但只返回 HTTP 报头，不返回文档主体。</li>
<li>PUT上传指定的 URI 表示。<br> DELETE    删除指定资源。</li>
<li>OPTIONS 返回服务器支持的 HTTP 方法</li>
<li>CONNECT 把请求连接转换到透明的 TCP/IP 通道。</li>
</ul>
<h2 id="linux命令，查看某个线程，整个机器负载和文件内容快速查找的命令"><a href="#linux命令，查看某个线程，整个机器负载和文件内容快速查找的命令" class="headerlink" title="linux命令，查看某个线程，整个机器负载和文件内容快速查找的命令"></a>linux命令，查看某个线程，整个机器负载和文件内容快速查找的命令</h2><p>查看线程：ps -ef|greptomcat</p>
<p>查看负载：top</p>
<p>文件内容查找：vi  /aa test.txt 或者先打开文件，再查找: vi test.txt   /aa</p>
<h2 id="JVM内存的模型，垃圾回收的机制，如何对JVM进行调优"><a href="#JVM内存的模型，垃圾回收的机制，如何对JVM进行调优" class="headerlink" title="JVM内存的模型，垃圾回收的机制，如何对JVM进行调优"></a>JVM内存的模型，垃圾回收的机制，如何对JVM进行调优</h2><p>由栈和堆组成，栈是运行时单位，堆内存则分为年轻代、年老代、持久代等，年轻代中的对象经过几次的回收，仍然存在则被移到年老代；持久代主要是保存class,method,filed等对象。</p>
<p>sun回收机制：主要对年轻代和年老代中的存活对象进行回收，分为以下：</p>
<p>年轻代串行（Serial Copying）、年轻代并行（ParNew）、年老代串行（SerialMSC），年老代并行（Parallel Mark Sweep），年老代并发（Concurrent Mark-Sweep GC，即CMS）等等,目前CMS回收算法使用最广泛。</p>
<p>JVM调优主要是对堆内容和回收算法进行配置，需要对jdk产生的回收日志进行观察，同时通过工具（Jconsole，jProfile，VisualVM）对堆内存不断分析，这些优化是一个过程，需要不断地进行观察和维护。</p>
<h2 id="高并发时，又如何保证性能和数据正确"><a href="#高并发时，又如何保证性能和数据正确" class="headerlink" title="高并发时，又如何保证性能和数据正确"></a>高并发时，又如何保证性能和数据正确</h2><p>如果是单机内完成这些操作，那使用数据库的事务，即可轻松实现。</p>
<h2 id="分布式事务如何实现"><a href="#分布式事务如何实现" class="headerlink" title="分布式事务如何实现"></a>分布式事务如何实现</h2><p>分布式事务可以采用分布式锁进行实现，目前zookeeper就提供此锁；分布式锁需要牺牲一定性能去实现，若业务支付最终一致性，那此方法是最佳方案。如在京东下订单，过一会才会告诉你订单审核通过，而不是马上响应订单结果。</p>
<h2 id="抽象类和接口的区别，项目中如何使用它们"><a href="#抽象类和接口的区别，项目中如何使用它们" class="headerlink" title="抽象类和接口的区别，项目中如何使用它们"></a>抽象类和接口的区别，项目中如何使用它们</h2><p> 相同点：</p>
<ol>
<li>两者都是抽象类，都不能实例化。</li>
<li>interface实现类及abstractclass的子类都必须要实现已经声明的抽象方法。</li>
</ol>
<p>不同点：</p>
<ol>
<li>interface需要实现，要用implements，而abstractclass需要继承，要用extends。</li>
<li>一个类可以实现多个interface，但一个类只能继承一个abstractclass。</li>
<li>interface强调特定功能的实现，而abstractclass强调所属关系。</li>
<li>尽管interface实现类及abstrctclass的子类都必须要实现相应的抽象方法，但实现的形式不同。interface中的每一个方法都是抽象方法，都只是声明的 (declaration, 没有方法体)，实现类必须要实现。而abstractclass的子类可以有选择地实现。</li>
</ol>
<p>使用：</p>
<ol>
<li>abstract：在既需要统一的接口，又需要实例变量或缺省的方法的情况下，使用abstract;</li>
<li>​ interface：类与类之前需要特定的接口进行协调，而不在乎其如何实现。 作为能够实现特定功能的标识存在，也可以是什么接口方法都没有的纯粹标识。需要将一组类视为单一的类，而调用者只通过接口来与这组类发生联系。需要实现特定的多项功能，而这些功能之间可能完全没有任何联系。        </li>
</ol>
<h2 id="TCP通讯有几次握手，有使用过哪些socket框架"><a href="#TCP通讯有几次握手，有使用过哪些socket框架" class="headerlink" title="TCP通讯有几次握手，有使用过哪些socket框架"></a>TCP通讯有几次握手，有使用过哪些socket框架</h2><p>​         3次握手，客户端–&gt;服务端，服务端–&gt;客户端，客户端–&gt;服务端，当这些过程完成之后，才真正建立起通信。java中比较有名的socket框架有：mina,netty,都是韩国小棒子写的。</p>
<h2 id="java反射机制，反射生成类，可否访问私有变量"><a href="#java反射机制，反射生成类，可否访问私有变量" class="headerlink" title="java反射机制，反射生成类，可否访问私有变量"></a>java反射机制，反射生成类，可否访问私有变量</h2><p>​       即动态生成java的实例，可以。</p>
<p>Java反射机制是一个非常强大的功能，在很多的项目比如Spring，Mybatis都都可以看到反射的身影。通过反射机制，我们可以在运行期间获取对象的类型信息。利用这一点我们可以实现工厂模式和代理模式等设计模式，同时也可以解决java泛型擦除等令人苦恼的问题。</p>
<p>获取一个对象对应的反射类，在Java中有三种方法可以获取一个对象的反射类，</p>
<ul>
<li>通过getClass()方法</li>
<li>通过Class.forName()方法</li>
<li>使用类.class</li>
<li>通过类加载器实现，getClassLoader()</li>
</ul>
<h2 id="RPC是什么，有使用过哪些RPC框架"><a href="#RPC是什么，有使用过哪些RPC框架" class="headerlink" title="RPC是什么，有使用过哪些RPC框架"></a>RPC是什么，有使用过哪些RPC框架</h2><p>​     远程进程调用，本地机器调用远程的服务，在项目规模大到一定程度，需要使用RPC相关框架进行服务化部署。如：hessian 、webservice等</p>
<h2 id="jquery如何绑定页面某元素的点击事件"><a href="#jquery如何绑定页面某元素的点击事件" class="headerlink" title="jquery如何绑定页面某元素的点击事件"></a>jquery如何绑定页面某元素的点击事件</h2><p>​    $(“#btn”).click(function(){ …. })</p>
<h2 id="volatile实现原理"><a href="#volatile实现原理" class="headerlink" title="volatile实现原理"></a>volatile实现原理</h2><p>volatile如何保证可见性和禁止指令重排序的：</p>
<p>观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令，lock前缀指令实际上相当于一个 <strong>内存屏障</strong>（也成内存栅栏），内存屏障会提供3个功能：</p>
<ul>
<li><p>它 <strong>确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面</strong>；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p>
</li>
<li><p>它会 强制将对缓存的修改操作立即写入主存；</p>
</li>
<li><p>如果是写操作，它会导致其他CPU中对应的缓存行无效。</p>
</li>
</ul>
<h2 id="session-与-cookie-区别"><a href="#session-与-cookie-区别" class="headerlink" title="session 与 cookie 区别"></a>session 与 cookie 区别</h2><ol>
<li>cookie数据存放在客户的浏览器上，session数据放在服务器上。</li>
<li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。</li>
<li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。</li>
<li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li>
<li>所以个人建议： 将登陆信息等重要信息存放为SESSION 其他信息如果需要保留，可以放在COOKIE中</li>
</ol>
<h2 id="session-分布式处理"><a href="#session-分布式处理" class="headerlink" title="session 分布式处理"></a>session 分布式处理</h2><p>第一种：粘性session</p>
<p>粘性Session是指将用户锁定到某一个服务器上，比如上面说的例子，用户第一次请求时，负载均衡器将用户的请求转发到了A服务器上，如果负载均衡器设置了粘性Session的话，那么用户以后的每次请求都会转发到A服务器上，相当于把用户和A服务器粘到了一块，这就是粘性Session机制。</p>
<p>第二种：服务器session复制</p>
<p>原理：任何一个服务器上的session发生改变（增删改），该节点会把这个 session的所有内容序列化，然后广播给所有其它节点，不管其他服务器需不需要session，以此来保证Session同步。</p>
<p>第三种：session共享机制</p>
<p>使用分布式缓存方案比如memcached、Redis，但是要求Memcached或Redis必须是集群。</p>
<p>原理：不同的 tomcat指定访问不同的主memcached。多个Memcached之间信息是同步的，能主从备份和高可用。用户访问时首先在tomcat中创建session，然后将session复制一份放到它对应的memcahed上</p>
<p>第四种：session持久化到数据库</p>
<p>原理：就不用多说了吧，拿出一个数据库，专门用来存储session信息。保证session的持久化。 优点：服务器出现问题，session不会丢失 缺点：如果网站的访问量很大，把session存储到数据库中，会对数据库造成很大压力，还需要增加额外的开销维护数据库。</p>
<p>第五种terracotta实现session复制</p>
<p>原理：就不用多说了吧，拿出一个数据库，专门用来存储session信息。保证session的持久化。 优点：服务器出现问题，session不会丢失 缺点：如果网站的访问量很大，把session存储到数据库中，会对数据库造成很大压力，还需要增加额外的开销维护数据库。</p>
<h2 id="说说自定义注解的场景及实现"><a href="#说说自定义注解的场景及实现" class="headerlink" title="说说自定义注解的场景及实现"></a>说说自定义注解的场景及实现</h2><p>跟踪代码的依赖性，实现代替配置文件的功能。比较常见的是Spring等框架中的基于注解配置。</p>
<p>还可以生成文档常见的@See@param@return等。如@override放在方法签名，如果这个方法 并不是覆盖了超类方法，则编译时就能检查出。</p>
<p>使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节，在定义注解时，不能继承其他注解或接口。</p>
<h2 id="HashSet-和-HashMap-区别"><a href="#HashSet-和-HashMap-区别" class="headerlink" title="HashSet 和 HashMap 区别"></a>HashSet 和 HashMap 区别</h2><p> <strong>HashSet：</strong></p>
<p>HashSet实现了Set接口，它不允许集合中出现重复元素。当我们提到HashSet时，第一件事就是在将对象存储在</p>
<p>HashSet之前，要确保重写hashCode（）方法和equals（）方法，这样才能比较对象的值是否相等，确保集合中没有储存相同的对象。如果不重写上述两个方法，那么将使用下面方法默认实现：</p>
<p>public boolean add(Object obj)方法用在Set添加元素时，如果元素值重复时返回 “false”，如果添加成功则返回”true”</p>
<p><strong>HashMap：</strong></p>
<p>HashMap实现了Map接口，Map接口对键值对进行映射。Map中不允许出现重复的键（Key）。Map接口有两个基本的实现TreeMap和HashMap。TreeMap保存了对象的排列次序，而HashMap不能。HashMap可以有空的键值对（Key（null）-Value（null））HashMap是非线程安全的（非Synchronize），要想实现线程安全，那么需要调用collections类的静态方法synchronizeMap（）实现。</p>
<p>public Object put(Object Key,Object value)方法用来将元素添加到map中。</p>
<p>总结：</p>
<p>HashMap 实现了 Map 接口；存储键值对；调用put（）向map中添加元素；HashMap使用键（Key）计算Hashcode；HashMap相对于HashSet较快，因为它是使用唯一的键获取对象。</p>
<p>HashSet 实现了 Set 接口；仅存储对象；调用add（）方法向Set中添加元素；HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false；HashSet较HashMap来说比较慢。</p>
<h2 id="HashMap-的工作原理及代码实现"><a href="#HashMap-的工作原理及代码实现" class="headerlink" title="HashMap 的工作原理及代码实现"></a>HashMap 的工作原理及代码实现</h2><ol>
<li>HashMap是基于哈希表的Map接口的非同步实现，允许使用null值和null键，但不保证映射的顺序。</li>
<li>底层使用数组实现，数组中每一项是个单向链表，即数组和链表的结合体；当链表长度大于一定阈值时，链表转换为红黑树，这样减少链表查询时间。</li>
<li>HashMap在底层将key-value当成一个整体进行处理，这个整体就是一个Node对象。HashMap底层采用一个Node[]数组来保存所有的key-value对，当需要存储一个Node对象时，会根据key的hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Node时，也会根据key的hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Node。</li>
<li>HashMap进行数组扩容需要重新计算扩容后每个元素在数组中的位置，很耗性能</li>
<li>采用了Fail-Fast机制，通过一个modCount值记录修改次数，对HashMap内容的修改都将增加这个值。迭代器初始化过程中会将这个值赋给迭代器的expectedModCount，在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map，马上抛出异常</li>
</ol>
<h2 id="ConcurrentHashMap-的工作原理及代码实现"><a href="#ConcurrentHashMap-的工作原理及代码实现" class="headerlink" title="ConcurrentHashMap 的工作原理及代码实现"></a>ConcurrentHashMap 的工作原理及代码实现</h2><ol>
<li>ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。</li>
<li>它使用了多个锁来控制对hash表的不同段进行的修改，每个段其实就是一个小的hashtable，它们有自己的锁。只要多个并发发生在不同的段上，它们就可以并发进行。</li>
<li>ConcurrentHashMap在底层将key-value当成一个整体进行处理，这个整体就是一个Entry对象。Hashtable底层采用一个Entry[]数组来保存所有的key-value对，当需要存储一个Entry对象时，会根据key的hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据key的hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。</li>
<li>与HashMap不同的是，ConcurrentHashMap使用多个子Hash表，也就是段(Segment)</li>
<li>ConcurrentHashMap完全允许多个读操作并发进行，读操作并不需要加锁。如果使用传统的技术，如HashMap中的实现，如果允许可以在hash链的中间添加或删除元素，读操作不加锁将得到不一致的数据。ConcurrentHashMap实现技术是保证HashEntry几乎是不可变的。</li>
</ol>
<h2 id="ThreadLocal-原理分析"><a href="#ThreadLocal-原理分析" class="headerlink" title="ThreadLocal 原理分析"></a>ThreadLocal 原理分析</h2><p>ThreadLocal 为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。当使用 ThreadLocal 维护变量时，ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p>
<p>每个线程中都保有一个 ThreadLocalMap 的成员变量，ThreadLocalMap 内部采用 WeakReference 数组保存，数组的key即为 ThreadLocal 内部的Hash值。</p>
<h2 id="创建线程的方式及实现"><a href="#创建线程的方式及实现" class="headerlink" title="创建线程的方式及实现"></a>创建线程的方式及实现</h2><p>Java使用Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。Java可以用三种方式来创建线程，如下所示：</p>
<ol>
<li>继承Thread类创建线程</li>
<li>实现Runnable接口创建线程</li>
<li><p>使用Callable和Future创建线程</p>
<p><strong>继承Thread类创建线程</strong></p>
</li>
</ol>
<p>通过继承Thread类来创建并启动多线程的一般步骤如下</p>
<p>1】d定义Thread类的子类，并重写该类的<strong>run()</strong>方法，该方法的方法体就是线程需要完成的任务，run()方法也称为线程执行体。</p>
<p>2】创建Thread子类的实例，也就是创建了线程对象</p>
<p>3】启动线程，即调用线程的<strong>start()</strong>方法</p>
<p>代码实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;<span class="comment">//继承Thread类</span></div><div class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">　　<span class="comment">//重写run方法</span></div><div class="line">　　&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">　　　　<span class="keyword">new</span> MyThread().start();<span class="comment">//创建并启动线程</span></div><div class="line">　　&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>实现Runnable接口创建线程</strong></p>
<p>通过实现Runnable接口创建并启动线程一般步骤如下：</p>
<p>1】定义Runnable接口的实现类，一样要重写run()方法，这个run（）方法和Thread中的run()方法一样是线程的执行体</p>
<p>2】创建Runnable实现类的实例，并用这个实例作为Thread的target来创建Thread对象，这个Thread对象才是真正的线程对象</p>
<p>3】第三部依然是通过调用线程对象的start()方法来启动线程</p>
<p>代码实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;<span class="comment">//实现Runnable接口</span></div><div class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">　　<span class="comment">//重写run方法</span></div><div class="line">　　&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">　　　　<span class="comment">//创建并启动线程</span></div><div class="line">　　　　MyThread2 myThread=<span class="keyword">new</span> MyThread2();</div><div class="line">　　　　Thread thread=<span class="keyword">new</span> Thread(myThread);</div><div class="line">　　　　thread().start();</div><div class="line">　　　　<span class="comment">//或者    new Thread(new MyThread2()).start();</span></div><div class="line">　　&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>使用Callable和Future创建线程</strong></p>
<p>和Runnable接口不一样，Callable接口提供了一个call（）方法作为线程执行体，call()方法比run()方法<em>**</em>功能要强大。</p>
<p>》call()方法可以有返回值</p>
<p>》call()方法可以声明抛出异常</p>
<p>Java5提供了Future接口来代表Callable接口里call()方法的返回值，并且为Future接口提供了一个实现类FutureTask，这个实现类既实现了Future接口，还实现了Runnable接口，因此可以作为Thread类的target。在Future接口里定义了几个公共方法来控制它关联的Callable任务。</p>
<p>>boolean cancel(boolean mayInterruptIfRunning)：视图取消该Future里面关联的Callable任务</p>
<p>>V get()：返回Callable里call（）方法的返回值，调用这个方法会导致程序阻塞，必须等到子线程结束后才会得到返回值</p>
<p>>V get(long timeout,TimeUnit unit)：返回Callable里call（）方法的返回值，最多阻塞timeout时间，经过指定时间没有返回抛出TimeoutException</p>
<p>>boolean isDone()：若Callable任务完成，返回True</p>
<p>>boolean isCancelled()：如果在Callable任务正常完成前被取消，返回True</p>
<p>介绍了相关的概念之后，创建并启动有返回值的线程的步骤如下：</p>
<p>1】创建Callable接口的实现类，并实现call()方法，然后创建该实现类的实例（从java8开始可以直接使用Lambda表达式创建Callable对象）。</p>
<p>2】使用FutureTask类来包装Callable对象，该FutureTask对象封装了Callable对象的call()方法的返回值</p>
<p>3】使用FutureTask对象作为Thread对象的target创建并启动线程（因为FutureTask实现了Runnable接口）</p>
<p>4】调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p>
<p>代码实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line"></div><div class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line"></div><div class="line">　　　MyThread3 th=<span class="keyword">new</span> MyThread3();</div><div class="line"></div><div class="line">　　　<span class="comment">//使用Lambda表达式创建Callable对象</span></div><div class="line"></div><div class="line">　　   <span class="comment">//使用FutureTask类来包装Callable对象</span></div><div class="line"></div><div class="line">　　　FutureTask&lt;Integer&gt; future=<span class="keyword">new</span> FutureTask&lt;Integer&gt;(</div><div class="line"></div><div class="line">　　　　(Callable&lt;Integer&gt;)()-&gt;&#123;</div><div class="line"></div><div class="line">　　　　　　<span class="keyword">return</span> <span class="number">5</span>;</div><div class="line"></div><div class="line">　　　　&#125;</div><div class="line"></div><div class="line">　　  );</div><div class="line"></div><div class="line">　　　<span class="keyword">new</span> Thread(task,<span class="string">"有返回值的线程"</span>).start();<span class="comment">//实质上还是以Callable对象来创建并启动线程</span></div><div class="line"></div><div class="line">　　  <span class="keyword">try</span>&#123;</div><div class="line">　　　　System.out.println(<span class="string">"子线程的返回值："</span>+future.get());</div><div class="line">       <span class="comment">//get()方法会阻塞，直到子线程执行结束才返回</span></div><div class="line"></div><div class="line"> 　　 &#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">　　　　ex.printStackTrace();</div><div class="line">　　　&#125;</div><div class="line"></div><div class="line">　　&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>————————————–三种创建线程方法对比————————————–</strong></p>
<p>实现Runnable和实现Callable接口的方式基本相同，不过是后者执行call()方法有返回值，后者线程执行体run()方法无返回值，因此可以把这两种方式归为一种这种方式与继承Thread类的方法之间的差别如下：</p>
<p>1、线程只是实现Runnable或实现Callable接口，还可以继承其他类。</p>
<p>2、这种方式下，多个线程可以共享一个target对象，非常适合多线程处理同一份资源的情形。</p>
<p>3、但是编程稍微复杂，如果需要访问当前线程，必须调用Thread.currentThread()方法。</p>
<p>4、继承Thread类的线程类不能再继承其他父类（Java单继承决定）。</p>
<p>注：一般推荐采用实现接口的方式来创建多线程</p>
<h2 id="sleep-、join（）、yield（）有什么区别"><a href="#sleep-、join（）、yield（）有什么区别" class="headerlink" title="sleep() 、join（）、yield（）有什么区别"></a>sleep() 、join（）、yield（）有什么区别</h2><p>sleep():方法导致了程序暂停执行指定的时间，让出cpu给其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态，但不会释放“锁标志”，不推荐使用。</p>
<p>wait():在其他线程调用对象的notify或notifyAll方法前，导致当前线程等待。线程会释放掉它所占有的“锁标志”，从而使别的线程有机会抢占该锁。</p>
<p>yield():暂停当前正在执行的线程对象。yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。yield()只能使同优先级或更高优先级的线程有执行的机会。</p>
<p>join():等待调用join方法的线程结束，再继续执行。</p>
<p>sleep是针对于thread对象，wait是针对于Object对象。</p>
<h2 id="ConcurrentHashMap如何保证线程安全"><a href="#ConcurrentHashMap如何保证线程安全" class="headerlink" title="ConcurrentHashMap如何保证线程安全"></a>ConcurrentHashMap如何保证线程安全</h2><p>JDK 1.7及以前：</p>
<p>ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对hash表的不同部分进行的修改。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。</p>
<p>JDK 1.8：</p>
<p>Segment虽保留，但已经简化属性，仅仅是为了兼容旧版本。</p>
<p>插入时使用CAS算法：unsafe.compareAndSwapInt(this, valueOffset, expect, update)。 CAS(Compare And Swap)意思是如果valueOffset位置包含的值与expect值相同，则更新valueOffset位置的值为update，并返回true，否则不更新，返回false。插入时不允许key或value为null</p>
<p>与Java8的HashMap有相通之处，底层依然由“数组”+链表+红黑树；</p>
<p>底层结构存放的是TreeBin对象，而不是TreeNode对象；</p>
<p>CAS作为知名无锁算法，那ConcurrentHashMap就没用锁了么？当然不是，当hash值与链表的头结点相同还是会synchronized上锁，锁链表。</p>
<h2 id="new与newInstance-的区别"><a href="#new与newInstance-的区别" class="headerlink" title="new与newInstance()的区别"></a>new与newInstance()的区别</h2><ul>
<li>new是一个关键字，它是调用new指令创建一个对象，然后调用构造方法来初始化这个对象，可以使用带参数的构造器</li>
<li>newInstance()是Class的一个方法，在这个过程中，是先取了这个类的不带参数的构造器Constructor，然后调用构造器的newInstance方法来创建对象。</li>
<li>Class.newInstance不能带参数，如果要带参数需要取得对应的构造器，然后调用该构造器的Constructor.newInstance(Object … initargs)方法</li>
</ul>
<h2 id="JDK中用到的设计模式"><a href="#JDK中用到的设计模式" class="headerlink" title="JDK中用到的设计模式"></a>JDK中用到的设计模式</h2><ul>
<li>装饰模式：java.io</li>
<li>单例模式：Runtime类</li>
<li>简单工厂模式：Integer.valueOf方法</li>
<li>享元模式：String常量池、Integer.valueOf(int i)、Character.valueOf(char c)</li>
<li>迭代器模式：Iterator</li>
<li>职责链模式：ClassLoader的双亲委派模型</li>
<li>解释器模式：正则表达式java.util.regex.Pattern</li>
</ul>
<h2 id="hashCode-amp-amp-equals"><a href="#hashCode-amp-amp-equals" class="headerlink" title="hashCode() &amp;&amp; equals()"></a>hashCode() &amp;&amp; equals()</h2><p><code>hashcode()</code> 返回该对象的哈希码值，支持该方法是为哈希表提供一些优点，例如，<code>java.util.Hashtable</code> 提供的哈希表。</p>
<p>在 Java 应用程序执行期间，在同一对象上多次调用 <code>hashCode</code> 方法时，必须一致地返回相同的整数，前提是对象上 <code>equals</code> 比较中所用的信息没有被修改（<code>equals</code>默认返回对象地址是否相等）。如果根据 <code>equals(Object)</code>方法，两个对象是相等的，那么在两个对象中的每个对象上调用 <code>hashCode</code> 方法都必须生成相同的整数结果。</p>
<p>以下情况不是必需的：如果根据 <code>equals(java.lang.Object)</code> 方法，两个对象不相等，那么在两个对象中的任一对象上调用 <code>hashCode</code> 方法必定会生成不同的整数结果。但是，<strong>程序员应该知道，为不相等的对象生成不同整数结果可以提高哈希表的性能</strong>。</p>
<p>实际上，由 <code>Object</code> 类定义的 <code>hashCode</code> 方法确实会针对不同的对象返回不同的整数。（<strong>这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧I</strong>。）</p>
<ul>
<li><strong>hashCode的存在主要是用于查找的快捷性</strong>，如 Hashtable，HashMap等，hashCode 是用来在散列存储结构中确定对象的存储地址的；</li>
<li>如果两个对象相同，就是适用于 <code>equals(java.lang.Object)</code> 方法，那么这两个对象的 <code>hashCode</code> 一定要相同；</li>
<li>如果对象的 <code>equals</code> 方法被重写，那么对象的 <code>hashCode</code> 也尽量重写，并且产生 <code>hashCode</code>使用的对象，一定要和 <code>equals</code> 方法中使用的一致，否则就会违反上面提到的第2点；</li>
<li><strong>两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里”</strong>。</li>
</ul>
<h2 id="Object类的finalize方法的实现原理"><a href="#Object类的finalize方法的实现原理" class="headerlink" title="Object类的finalize方法的实现原理"></a>Object类的finalize方法的实现原理</h2><p>Object 类提供的实现不Finalize方法和垃圾回收器将派生的类型不标记Object终止除非它们将覆盖Finalize方法。</p>
<p>如果类型未重写Finalize方法，则垃圾回收器会将类型的每个实例的条目添加到调用终止队列中的内部结构。 终止队列中包含垃圾回收器才能回收其内存之前，必须运行其终止代码托管堆中的所有对象的条目。 然后，垃圾回收器调用Finalize在以下情况下自动的方法︰</p>
<ul>
<li>垃圾回收器发现，一个对象不可访问，除非您通过调用从终止豁免已对象后 GC.SuppressFinalize 方法。</li>
<li>在关闭应用程序域中，除非该对象是免于终止的对象。 在关闭期间，终止甚至仍是可访问的对象。</li>
</ul>
<p>Finalize将自动调用一次在给定实例中，除非的对象重新注册通过使用一种机制，如GC.ReRegisterForFinalize和GC.SuppressFinalize尚未随后调用方法。</p>
<p>Finalize操作具有以下限制︰</p>
<ul>
<li>终结器执行时的确切时间不确定。 若要确保确定性释放资源，对你的类的实例实现<strong>Close</strong>方法，或者提供IDisposable.Dispose实现。</li>
<li>两个对象的终结器不保证任何特定顺序运行即使另一个对象引用。 也就是说，如果对象 A 具有对对象 B 的引用，并且二者的终结器，对象 B 可能已经被终结的对象 A 终结器启动时。</li>
<li>终结器运行的线程未指定。</li>
</ul>
<p>Finalize方法可能无法运行完成，或可能根本不运行下列异常情况下︰</p>
<ul>
<li>如果另一个终结器会无限期阻止 （进入无限循环，尝试获取的锁，它可以永远不会获取，等等）。 运行时尝试运行终结器来完成，因为其他终结器可能不会调用终结器块如果无限期。</li>
<li>如果不提供机会清理的运行时，进程将终止。 在这种情况下，运行时的第一个通知的进程是终止的一个 DLL_PROCESS_DETACH 通知。</li>
</ul>
<p>运行时将继续完成在关闭过程的对象，仅当可终结对象数目继续减少。</p>
<p>如果Finalize或的重写Finalize引发异常，并且运行时不承载的应用程序将替代默认策略，运行时终止进程，且无活动<strong>try</strong>/<strong>finally</strong>执行块或终结器。如果终结器无法释放或销毁资源，则此行为确保处理完整性。</p>
<p><strong>实施者注意事项</strong></p>
<p>应重写Finalize类使用非托管的资源，如文件句柄或数据库必须在垃圾回收期间放弃使用它们的托管的对象时释放的连接。</p>
<p>Lock是Java 5以后引入的新的API，和关键字synchronized相比主要相同点：Lock 能完成synchronized所实现的所有功能；主要不同点：Lock有比synchronized更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且最好在finally 块中释放（这是释放外部资源的最好的地方）。</p>
<h2 id="CAS-乐观锁"><a href="#CAS-乐观锁" class="headerlink" title="CAS 乐观锁"></a>CAS 乐观锁</h2><p>CAS是通过unsafe类的compareAndSwap方法实现的；方法参数作用，第一个参数是要修改的对象，第二个参数是对象中要修改变量的偏移量，第三个参数是修改之前的值，第四个参数是预想修改后的值；CAS指令有缺点，存在ABA问题。</p>
<h2 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h2><p>就是一个变量V，如果变量V初次读取的时候是A，并且在准备赋值的时候检查到它仍然是A，那能说明它的值没有被其他线程修改过了吗？如果在这段期间它的值曾经被改成了B，然后又改回A，那CAS操作就会误认为它从来没有被修改过。解决：针对这种情况，java并发包中提供了一个带有标记的原子引类”AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。</p>
<h2 id="乐观锁的业务场景及实现方式"><a href="#乐观锁的业务场景及实现方式" class="headerlink" title="乐观锁的业务场景及实现方式"></a>乐观锁的业务场景及实现方式</h2><p>1.我们经常会在访问数据库的时候用到锁，怎么实现乐观锁和悲观锁呢？以Hibernate为例，可以通过为记录添加版本或时间戳字段来实现乐观锁。可以用session.Lock()锁定对象来实现悲观锁（本质上就是执行了SELECT * FROM t FOR UPDATE语句）。</p>
<p>2.如果把乐观锁看作是关于冲突检测的，那么悲观锁就是关于冲突避免的。在实际应用的源代码控制系统中，</p>
<p>这两种策略都可以被使用，但是现在大多数源代码开发者更倾向于使用乐观锁策略。（有一种很有道理的说法：乐观锁并不是真正的锁定，但是这种叫法很方便并且广泛流传，以至于不容忽略。）</p>
<p>在乐观锁和悲观锁之间进行选择的标准是：冲突的频率与严重性。如果冲突很少，或者冲突的后果不会很严重，那么通常情况下应该选择乐观锁，因为它能得到更好的并发性，而且更容易实现。但是，如果冲突的结果对于用户来说痛苦的，那么就需要使用悲观策略。</p>
<h2 id="访问修饰符public-private-protected-以及不写时的区别"><a href="#访问修饰符public-private-protected-以及不写时的区别" class="headerlink" title="访问修饰符public,private,protected,以及不写时的区别"></a>访问修饰符public,private,protected,以及不写时的区别</h2><table>
<thead>
<tr>
<th>修饰符</th>
<th>当前类</th>
<th>同 包</th>
<th>子 类</th>
<th>其他包</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>default</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody>
</table>
<p>类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。Java中，外部类的修饰符只能是public或默认，类的成员（包括内部类）的修饰符可以是以上四种。</p>
<h2 id="String-是不是最基本的数据类型"><a href="#String-是不是最基本的数据类型" class="headerlink" title="String 是不是最基本的数据类型"></a>String 是不是最基本的数据类型</h2><p>不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（reference type），Java 5以后引入的枚举类型也算是一种比较特殊的引用类型。</p>
<h2 id="short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗"><a href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗" class="headerlink" title="short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗"></a>short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗</h2><p>对于short s1 = 1; s1 = s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型可修改为s1 =(short)(s1 + 1)。而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。</p>
<h2 id="是否可以继承String类"><a href="#是否可以继承String类" class="headerlink" title="是否可以继承String类"></a>是否可以继承String类</h2><p>String 类是final类，不可以被继承。</p>
<p><strong>补充：</strong>继承String本身就是一个错误的行为，对String类型最好的重用方式是关联关系（Has-A）和依赖关系（Use-A）而不是继承关系（Is-A）</p>
<h2 id="JVM加载class文件的原理机制"><a href="#JVM加载class文件的原理机制" class="headerlink" title="JVM加载class文件的原理机制"></a>JVM加载class文件的原理机制</h2><p>JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。<br>由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。<br>类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：</p>
<ul>
<li>Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；</li>
<li>Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；</li>
<li>System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。</li>
</ul>
<h2 id="静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同"><a href="#静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同" class="headerlink" title="静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同"></a>静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同</h2><p>Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化，其语法看起来挺诡异的，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 扑克类（一副扑克）</div><div class="line"> * <span class="doctag">@author</span> 骆昊</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poker</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] suites = &#123;<span class="string">"黑桃"</span>, <span class="string">"红桃"</span>, <span class="string">"草花"</span>, <span class="string">"方块"</span>&#125;;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] faces = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>&#125;;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Card[] cards;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造器</div><div class="line">     * </div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Poker</span><span class="params">()</span> </span>&#123;</div><div class="line">        cards = <span class="keyword">new</span> Card[<span class="number">52</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; suites.length; i++) &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; faces.length; j++) &#123;</div><div class="line">                cards[i * <span class="number">13</span> + j] = <span class="keyword">new</span> Card(suites[i], faces[j]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 洗牌 （随机乱序）</div><div class="line">     * </div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, len = cards.length; i &lt; len; i++) &#123;</div><div class="line">            <span class="keyword">int</span> index = (<span class="keyword">int</span>) (Math.random() * len);</div><div class="line">            Card temp = cards[index];</div><div class="line">            cards[index] = cards[i];</div><div class="line">            cards[i] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 发牌</div><div class="line">     * <span class="doctag">@param</span> index 发牌的位置</div><div class="line">     * </div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Card <span class="title">deal</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> cards[index];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 卡片类（一张扑克）</div><div class="line">     * [内部类]</div><div class="line">     * <span class="doctag">@author</span> 骆昊</div><div class="line">     *</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Card</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> String suite;   <span class="comment">// 花色</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> face;       <span class="comment">// 点数</span></div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Card</span><span class="params">(String suite, <span class="keyword">int</span> face)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.suite = suite;</div><div class="line">            <span class="keyword">this</span>.face = face;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">            String faceStr = <span class="string">""</span>;</div><div class="line">            <span class="keyword">switch</span>(face) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="number">1</span>: faceStr = <span class="string">"A"</span>; <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="number">11</span>: faceStr = <span class="string">"J"</span>; <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="number">12</span>: faceStr = <span class="string">"Q"</span>; <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="number">13</span>: faceStr = <span class="string">"K"</span>; <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>: faceStr = String.valueOf(face);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> suite + faceStr;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​ 测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PokerTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Poker poker = <span class="keyword">new</span> Poker();</div><div class="line">        poker.shuffle();                <span class="comment">// 洗牌</span></div><div class="line">        Poker.Card c1 = poker.deal(<span class="number">0</span>);  <span class="comment">// 发第一张牌</span></div><div class="line">        <span class="comment">// 对于非静态内部类Card</span></div><div class="line">        <span class="comment">// 只有通过其外部类Poker对象才能创建Card对象</span></div><div class="line">        Poker.Card c2 = poker.new Card(<span class="string">"红心"</span>, <span class="number">1</span>);    <span class="comment">// 自己创建一张牌</span></div><div class="line"></div><div class="line">        System.out.println(c1);     <span class="comment">// 洗牌后的第一张</span></div><div class="line">        System.out.println(c2);     <span class="comment">// 打印: 红心A</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="GC是什么？为什么要有GC？"><a href="#GC是什么？为什么要有GC？" class="headerlink" title="GC是什么？为什么要有GC？"></a>GC是什么？为什么要有GC？</h2><p>GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() ，但JVM可以屏蔽掉显示的垃圾回收调用。<br>垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在Java诞生初期，垃圾回收是Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今Java的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得iOS的系统比Android系统有更好的用户体验，其中一个深层次的原因就在于Android系统中垃圾回收的不可预知性。</p>
<p><strong>补充：</strong>垃圾回收机制有很多种，包括：分代复制垃圾回收、标记垃圾回收、增量垃圾回收等方式。标准的Java进程既有栈又有堆。栈保存了原始型局部变量，堆保存了要创建的对象。Java平台对堆内存回收和再利用的基本算法被称为标记和清除，但是Java对其进行了改进，采用“分代式垃圾收集”。这种方法会跟Java对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域： </p>
<p>伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。 </p>
<p>幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。 </p>
<p>终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。</p>
<h2 id="String-s-new-String-“xyz”-创建了几个字符串对象"><a href="#String-s-new-String-“xyz”-创建了几个字符串对象" class="headerlink" title="String s = new String(“xyz”);创建了几个字符串对象"></a>String s = new String(“xyz”);创建了几个字符串对象</h2><p>两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。</p>
<h2 id="如何实现字符串的反转及替换"><a href="#如何实现字符串的反转及替换" class="headerlink" title="如何实现字符串的反转及替换"></a>如何实现字符串的反转及替换</h2><p>方法很多，可以自己写实现也可以使用String或StringBuffer/StringBuilder中的方法。有一道很常见的面试题是用递归实现字符串反转，代码如下所示：</p>
<p>public static String reverse(String originStr) {<br>​        if(originStr == null || originStr.length() &lt;= 1)<br>​            return originStr;<br>​        return reverse(originStr.substring(1)) + originStr.charAt(0);<br>​    }</p>
<h2 id="List、Set、Map是否继承自Collection接口"><a href="#List、Set、Map是否继承自Collection接口" class="headerlink" title="List、Set、Map是否继承自Collection接口"></a>List、Set、Map是否继承自Collection接口</h2><p>List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。</p>
<h2 id="List、Map、Set三个接口存取元素时，各有什么特点"><a href="#List、Map、Set三个接口存取元素时，各有什么特点" class="headerlink" title="List、Map、Set三个接口存取元素时，各有什么特点"></a>List、Map、Set三个接口存取元素时，各有什么特点</h2><p>List以特定索引来存取元素，可以有重复元素。Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。</p>
<h2 id="当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B"><a href="#当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B" class="headerlink" title="当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B"></a>当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B</h2><p>不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（<strong>注意不是等待池哦</strong>）中等待对象的锁。</p>
<h2 id="线程同步以及线程调度相关的方法"><a href="#线程同步以及线程调度相关的方法" class="headerlink" title="线程同步以及线程调度相关的方法"></a>线程同步以及线程调度相关的方法</h2><ul>
<li>wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁； </li>
<li>sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常； </li>
<li>notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关； </li>
<li>notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</li>
</ul>
<h2 id="启动一个线程是调用run-还是start-方法"><a href="#启动一个线程是调用run-还是start-方法" class="headerlink" title="启动一个线程是调用run()还是start()方法"></a>启动一个线程是调用run()还是start()方法</h2><p>启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM 调度并执行，这并不意味着线程就会立即运行。run()方法是线程启动后要进行回调（callback）的方法。</p>
<h2 id="Java中有几种类型的流"><a href="#Java中有几种类型的流" class="headerlink" title="Java中有几种类型的流"></a>Java中有几种类型的流</h2><p>字节流和字符流。字节流继承于InputStream、OutputStream，字符流继承于Reader、Writer。在java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。关于Java的I/O需要注意的有两点：一是两种对称性（输入和输出的对称性，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模式）。另外Java中的流不同于C#的是它只有一个维度一个方向。</p>
<h2 id="在项目中哪些地方用到了XML"><a href="#在项目中哪些地方用到了XML" class="headerlink" title="在项目中哪些地方用到了XML"></a>在项目中哪些地方用到了XML</h2><p>XML的主要作用有两个方面：数据交换和信息配置。在做数据交换时，XML将数据用标签组装成起来，然后压缩打包加密后通过网络传送给接收者，接收解密与解压缩后再从XML文件中还原相关信息进行处理，XML曾经是异构系统间交换数据的事实标准，但此项功能几乎已经被JSON（JavaScript Object Notation）取而代之。当然，目前很多软件仍然使用XML来存储配置信息，我们在很多项目中通常也会将作为配置信息的硬代码写在XML文件中，Java的很多框架也是这么做的，而且这些框架都选择了<a href="http://www.dom4j.org/" target="_blank" rel="external">dom4j</a>作为处理XML的工具，因为Sun公司的官方API实在不怎么好用。</p>
<h2 id="vector、ArrayList、LinkedList-的区别是什么"><a href="#vector、ArrayList、LinkedList-的区别是什么" class="headerlink" title="vector、ArrayList、LinkedList 的区别是什么"></a>vector、ArrayList、LinkedList 的区别是什么</h2><p>vector是同步的，arraylist和linkedlist不是同步的。底层方面，vector与arraylist都是基于object[]array实现的，但考虑vector线程安全，所以arraylist效率上回比vector较快。元素随机访问上，vector与arraylist是基本相同的，时间复杂度是O(1)，linkedlist的随机访问元素的复杂度为O(n)。但在插入删除数据上，linkedlist则比arraylist要快很多。linkedlist比arraylist更占内存，因为linkedlist每个节点上还要存储对前后两个节点的引用。</p>
<h2 id="如何通过反射创建对象"><a href="#如何通过反射创建对象" class="headerlink" title="如何通过反射创建对象"></a>如何通过反射创建对象</h2><ul>
<li>方法1：通过类对象调用newInstance()方法，例如：String.class.newInstance() </li>
<li>方法2：通过类对象的getConstructor()或getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象，例如：String.class.getConstructor(String.class).newInstance(“Hello”);</li>
</ul>
<h2 id="Statement与PreparedStatement的区别-什么是SQL注入，如何防止SQL注入"><a href="#Statement与PreparedStatement的区别-什么是SQL注入，如何防止SQL注入" class="headerlink" title="Statement与PreparedStatement的区别,什么是SQL注入，如何防止SQL注入"></a>Statement与PreparedStatement的区别,什么是SQL注入，如何防止SQL注入</h2><p>使用PreparedStatement可以提升代码的可读性和可维护性，可以尽最大可能提高性能。因为Statement每次执行一个SQL命令都会对其编译，但PreparedStatement则只编译一次。PreparedStatement就类似于流水线生产。另一方面PreparedStatement可以极大提高安全性：它对传递过来的参数进行了强制参数类型转换，确保插入或查询数据时，与底层数据库格式匹配。<br>SQL注入：就是通过将sql命令插入到web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意SQL命令。如sql命令：select id from test where name=’1’ or 1=1; drop table test,但用PreparedStatement就可以避免这种问题。</p>
<h2 id="用Java写一个单例类"><a href="#用Java写一个单例类" class="headerlink" title="用Java写一个单例类"></a>用Java写一个单例类</h2><p>饿汉式单例:</p>
<p>public class Singleton {<br>​    private Singleton(){}<br>​    private static Singleton instance = new Singleton();<br>​    public static Singleton getInstance(){<br>​        return instance;<br>​    }<br>}</p>
<p>懒汉式单例:</p>
<p>public class Singleton {<br>​    private static Singleton instance = null;<br>​    private Singleton() {}<br>​    public static synchronized Singleton getInstance(){<br>​        if (instance == null) instance ＝ new Singleton();<br>​        return instance;<br>​    }<br>}</p>
<h2 id="用Java写一个冒泡排序"><a href="#用Java写一个冒泡排序" class="headerlink" title="用Java写一个冒泡排序"></a>用Java写一个冒泡排序</h2><p>冒泡排序几乎是个程序员都写得出来，但是面试的时候如何写一个逼格高的冒泡排序却不是每个人都能做到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 排序器接口(策略模式: 将算法封装到具有共同接口的独立的类中使得它们可以相互替换)</div><div class="line"> * <span class="doctag">@author</span>骆昊</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sorter</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 排序</div><div class="line">    * <span class="doctag">@param</span> list 待排序的数组</div><div class="line">    */</div><div class="line">   <span class="keyword">public</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] list)</span></span>;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 排序</div><div class="line">    * <span class="doctag">@param</span> list 待排序的数组</div><div class="line">    * <span class="doctag">@param</span> comp 比较两个对象的比较器</div><div class="line">    */</div><div class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] list, Comparator&lt;T&gt; comp)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 冒泡排序</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span>骆昊</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSorter</span> <span class="keyword">implements</span> <span class="title">Sorter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] list)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> swapped = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, len = list.length; i &lt; len &amp;&amp; swapped; ++i) &#123;</div><div class="line">            swapped = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - i; ++j) &#123;</div><div class="line">                <span class="keyword">if</span> (list[j].compareTo(list[j + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123;</div><div class="line">                    T temp = list[j];</div><div class="line">                    list[j] = list[j + <span class="number">1</span>];</div><div class="line">                    list[j + <span class="number">1</span>] = temp;</div><div class="line">                    swapped = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] list, Comparator&lt;T&gt; comp)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> swapped = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, len = list.length; i &lt; len &amp;&amp; swapped; ++i) &#123;</div><div class="line">            swapped = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - i; ++j) &#123;</div><div class="line">                <span class="keyword">if</span> (comp.compare(list[j], list[j + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123;</div><div class="line">                    T temp = list[j];</div><div class="line">                    list[j] = list[j + <span class="number">1</span>];</div><div class="line">                    list[j + <span class="number">1</span>] = temp;</div><div class="line">                    swapped = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="char型变量中能不能存贮一个中文汉字"><a href="#char型变量中能不能存贮一个中文汉字" class="headerlink" title="char型变量中能不能存贮一个中文汉字"></a>char型变量中能不能存贮一个中文汉字</h2><p>char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。</p>
<h2 id="用最有效率的方法算出2乘以8等于几"><a href="#用最有效率的方法算出2乘以8等于几" class="headerlink" title="用最有效率的方法算出2乘以8等于几"></a>用最有效率的方法算出2乘以8等于几</h2><p>2&lt;&lt; 3，(左移三位)因为将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，而位运算cpu直接支持的，效率最高，所以，2乘以8等於几的最效率的方法是2&lt;&lt; 3。</p>
<h2 id="静态变量和实例变量的区别"><a href="#静态变量和实例变量的区别" class="headerlink" title="静态变量和实例变量的区别"></a>静态变量和实例变量的区别</h2><p>在语法定义上的区别：静态变量前要加 static 关键字，而实例变量前则不加。</p>
<p>在程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。</p>
<p>例如，对于下面的程序，无论创建多少个实例对象，永远都只分配了一个staticVar变量，并且每创建一个实例对象，这个staticVar就会加1；但是，每创建一个实例对象，就会分配一个instanceVar，即可能分配多个instanceVar，并且每个instanceVar的值都只自加了1次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VariantTest</span></span>&#123;</div><div class="line"></div><div class="line">        publicstatic <span class="keyword">int</span> staticVar = <span class="number">0</span>;</div><div class="line"></div><div class="line">        publicint instanceVar = <span class="number">0</span>;</div><div class="line"></div><div class="line">        publicVariantTest()&#123;</div><div class="line"></div><div class="line">              staticVar++;</div><div class="line"></div><div class="line">              instanceVar++;</div><div class="line"></div><div class="line">              System.out.println(staticVar +instanceVar);</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="switch语句能否作用在-byte-、-long-和String-上"><a href="#switch语句能否作用在-byte-、-long-和String-上" class="headerlink" title="switch语句能否作用在 byte 、 long 和String 上"></a>switch语句能否作用在 byte 、 long 和String 上</h2><p>在switch（e）中，e只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是int基本类型或Integer包装类型，由于byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。显然，long和String类型都不符合switch的语法规定，并且不能被隐式转换成int类型，所以，它们不能作用于swtich语句中。</p>
<p>switch语句能否作用在String上说错了，Java1.7之后已经支持这种写法了！</p>
<h2 id="如何跳出当前的多重嵌套循环"><a href="#如何跳出当前的多重嵌套循环" class="headerlink" title="如何跳出当前的多重嵌套循环"></a>如何跳出当前的多重嵌套循环</h2><p>在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break语句，即可跳出外层循环。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">   <span class="keyword">for</span>(intj=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)&#123;</div><div class="line">       System.out.println(“i=” + i + “,j=” + j);</div><div class="line">       <span class="keyword">if</span>(j == <span class="number">5</span>) <span class="keyword">break</span> ok;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 另外，我个人通常并不使用标号这种方式，而是让外层的循环条件表达式的结果可以受到里层循环体代码的控制，例如，要在二维数组中查找到某个数字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> arr[][] =&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,&#123;<span class="number">9</span>&#125;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">boolean</span> found = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length&amp;&amp;!found;i++)       &#123;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(intj=<span class="number">0</span>;j&lt;arr[i].length;j++)&#123;</div><div class="line"></div><div class="line">              System.out.println(“i=” + i + “,j=” + j);</div><div class="line"></div><div class="line">              <span class="keyword">if</span>(arr[i][j] ==<span class="number">5</span>) &#123;</div><div class="line"></div><div class="line">                      found =<span class="keyword">true</span>;</div><div class="line"></div><div class="line">                      <span class="keyword">break</span>;</div><div class="line"></div><div class="line">              &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="说说-amp-和-amp-amp-的区别"><a href="#说说-amp-和-amp-amp-的区别" class="headerlink" title="说说&amp;和&amp;&amp;的区别"></a>说说&amp;和&amp;&amp;的区别</h2><p> &amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。</p>
<p>​        &amp;&amp;还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式，例如，对于if(str!= null&amp;&amp; !str.equals(s))表达式，当str为null时，后面的表达式不会执行，所以不会出现NullPointerException如果将&amp;&amp;改为&amp;，则会抛出NullPointerException异常。If(x==33 &amp;++y&gt;0) y会增长，If(x==33 &amp;&amp; ++y&gt;0)不会增长</p>
<p>​        &amp;还可以用作位运算符，当&amp;操作符两边的表达式不是boolean类型时，&amp;表示按位与操作，我们通常使用0x0f来与一个整数进行&amp;运算，来获取该整数的最低4个bit位，例如，0x31 &amp; 0x0f的结果为0x01。</p>
<h2 id="一个”-java”源文件中是否可以包括多个类（不是内部类）有什么限制"><a href="#一个”-java”源文件中是否可以包括多个类（不是内部类）有什么限制" class="headerlink" title="一个”.java”源文件中是否可以包括多个类（不是内部类）有什么限制"></a>一个”.java”源文件中是否可以包括多个类（不是内部类）有什么限制</h2><p>  可以有多个类，但只能有一个public的类，并且public的类名必须与文件名相一致。</p>
<h2 id="可以从一个static方法内部发出对非static方法的调用吗"><a href="#可以从一个static方法内部发出对非static方法的调用吗" class="headerlink" title="可以从一个static方法内部发出对非static方法的调用吗"></a>可以从一个static方法内部发出对非static方法的调用吗</h2><p>不可以。因为非static方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而static方法调用时不需要创建对象，可以直接调用。也就是说，当一个static方法被调用时，可能还没有创建任何实例对象，如果从一个static方法中发出对非static方法的调用，那个非static方法是关联到哪个对象上的呢？这个逻辑无法成立，所以，一个static方法内部发出对非static方法的调用。</p>
<h2 id="Hibernate中怎样实现类之间的关系"><a href="#Hibernate中怎样实现类之间的关系" class="headerlink" title="Hibernate中怎样实现类之间的关系"></a>Hibernate中怎样实现类之间的关系</h2><p>  类与类之间的关系主要体现在表与表之间的关系进行操作，它们都是对对象进行操作，我们在程序中把所有的表与类都映射在一起，它们通过配置文件中的many-to-one、one-to-many、many-to-many进行操作。</p>
<h2 id="Hibernate中的update-和saveOrUpdate-的区别"><a href="#Hibernate中的update-和saveOrUpdate-的区别" class="headerlink" title="Hibernate中的update()和saveOrUpdate()的区别"></a>Hibernate中的update()和saveOrUpdate()的区别</h2><p>saveOrUpdate()：</p>
<p>​    1、如果对象已经在本session中持久化了，不做任何事</p>
<p>​    2、如果另一个与本session关联的对象拥有相同的持久化标识(identifier)，抛出一个异常</p>
<p>​    3、如果对象没有持久化标识(identifier)属性，对其调用save()</p>
<p>​    4、如果对象的持久标识(identifier)表明其是一个新实例化的对象，对其调用save()</p>
<p>​    5、如果对象是附带版本信息的（通过<version>或 <timestamp>）并且版本属性的值表明其是一个新实例化的    对象，调用save()。否则update() 这个对象。</timestamp></version></p>
<p>update() ：是将一个游离状态的实体对象直接更新。</p>
<h2 id="Hibernate的缓存机制"><a href="#Hibernate的缓存机制" class="headerlink" title="Hibernate的缓存机制"></a>Hibernate的缓存机制</h2><ol>
<li>一级缓存：内部缓存存在Hibernate中，属于应用事物级缓存。</li>
<li>二级缓存：应用级缓存、 分布式缓存。使用场景：数据不会被第三方修改、数据大小在可接受范围、数据更新频率低、同一数据被系统频繁使用、非关键数据</li>
<li>引入第三方缓存（如ehcache等）。</li>
</ol>
<h2 id="如何优化Hibernate"><a href="#如何优化Hibernate" class="headerlink" title="如何优化Hibernate"></a>如何优化Hibernate</h2><p>1.使用双向一对多关联，不使用单向一对多</p>
<p>2.灵活使用单向一对多关联</p>
<p>3.不用一对一，用多对一取代</p>
<p>4.配置对象缓存，不使用集合缓存</p>
<p>5.一对多集合使用Bag,多对多集合使用Set</p>
<p>6.继承类使用显式多态</p>
<p>7.表字段要少，表关联不要怕多，有二级缓存撑腰</p>
<h2 id="hibernate的延迟加载和openSessionInView"><a href="#hibernate的延迟加载和openSessionInView" class="headerlink" title="hibernate的延迟加载和openSessionInView"></a>hibernate的延迟加载和openSessionInView</h2><p>延迟加载要在session范围内，用到的时候再加载；</p>
<p>opensessioninview是在web层写了一个filter来打开和关闭session，这样就表示在一次request过程中session一直开着，保证了延迟加载在session中的这个前提。</p>
<h2 id="Mysql-优化"><a href="#Mysql-优化" class="headerlink" title="Mysql 优化"></a>Mysql 优化</h2><p>1.如果明确知道只有一条结果返回，limit1能够提高效率</p>
<p>2.把计算放在业务层而不是数据库层，除了节省数据的 CPU ,还有意想不到的查询缓存优化效果。</p>
<p>3.强制类型转换会全表扫描</p>
<p>4.在属性上进行计算不能命中索引 </p>
<p>5.使用 ENUM 而不是字符串</p>
<p>6.数据分区度不大的字段不宜使用索引</p>
<p>7.负向查询和前导模糊查询不能使用索引</p>
<p>8.用TRUNCATE替代DELETE</p>
<p>9.删除重复记录</p>
<p>10.用Where子句替换HAVING子句</p>
<p>11.用EXISTS替代IN、用NOT EXISTS替代NOT IN</p>
<p>12.用索引提高效率</p>
<p>13.用EXISTS替换DISTINCT</p>
<p>14.用&gt;=替代&gt;</p>
<p>15.用IN来替换OR</p>
<h2 id="Mysql-的交集、差集、并集"><a href="#Mysql-的交集、差集、并集" class="headerlink" title="Mysql 的交集、差集、并集"></a>Mysql 的交集、差集、并集</h2><p>只有并集没有交集差集的关键字。</p>
<p>1.并集</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- UNION  不包含重复数据</span></div><div class="line"><span class="comment">-- UNION ALL  包含重复数据</span></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">NAME</span>  <span class="keyword">FROM</span> a <span class="keyword">UNION</span></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">NAME</span>  <span class="keyword">FROM</span> b;</div></pre></td></tr></table></figure>
<p>2.差集</p>
<p>找出在a表中存在的id 但是在b表中不存在的id</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 利用 union</span></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">ID</span> <span class="keyword">FROM</span> (</div><div class="line"><span class="comment">-- 并集</span></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> a.id <span class="keyword">AS</span> <span class="keyword">ID</span> <span class="keyword">FROM</span> a  </div><div class="line"><span class="keyword">UNION</span> ALL</div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> B.ID <span class="keyword">AS</span> <span class="keyword">ID</span> <span class="keyword">FROM</span>  b</div><div class="line">)TEMP <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">ID</span> <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(<span class="keyword">ID</span>) = <span class="number">1</span>;</div></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 子查询 not in</span></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> a <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> b);</div></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 子查询 not exists</span></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> a <span class="keyword">WHERE</span>  <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> b <span class="keyword">WHERE</span> a.id = b.id);</div></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 左连接判断右表IS NULL</span></div><div class="line"><span class="keyword">SELECT</span> a.id <span class="keyword">FROM</span> a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span>  b <span class="keyword">ON</span> a.id = b.id <span class="keyword">WHERE</span> b.id <span class="keyword">IS</span> <span class="literal">NULL</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a.id</div></pre></td></tr></table></figure>
<p>3.交集 INTERSECT</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">ID</span> <span class="keyword">FROM</span> (</div><div class="line"><span class="comment">-- 并集 </span></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> a.id <span class="keyword">AS</span> <span class="keyword">ID</span> <span class="keyword">FROM</span> a  </div><div class="line"><span class="keyword">UNION</span> ALL</div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> B.ID <span class="keyword">AS</span> <span class="keyword">ID</span> <span class="keyword">FROM</span>  b</div><div class="line">)TEMP <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">ID</span> <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(<span class="keyword">ID</span>) != <span class="number">1</span>;</div></pre></td></tr></table></figure>
<h2 id="Java内存模型是什么"><a href="#Java内存模型是什么" class="headerlink" title="Java内存模型是什么"></a>Java内存模型是什么</h2><p> Java内存模型规定和指引Java程序在不同的内存架构、CPU和操作系统间有确定性地行为。它在多线程的情况下尤其重要。Java内存模型对一个线程所做的变动能被其它线程可见提供了保证，它们之间是先行发生关系。这个关系定义了一些规则让程序员在并发编程时思路更清晰。比如，先行发生关系确保了：</p>
<p>​        线程内的代码能够按先后顺序执行，这被称为程序次序规则。</p>
<p>​        对于同一个锁，一个解锁操作一定要发生在时间上后发生的另一个锁定操作之前，也叫做管程锁定规则。</p>
<p>​        前一个对volatile的写操作在后一个volatile的读操作之前，也叫volatile变量规则。</p>
<p>​        一个线程内的任何操作必需在这个线程的start()调用之后，也叫作线程启动规则。</p>
<p>​        一个线程的所有操作都会在线程终止之前，线程终止规则。</p>
<p>​        一个对象的终结操作必需在这个对象构造完成之后，也叫对象终结规则。</p>
<p>可传递性</p>
<h2 id="Thread接口和Runnable接口的区别"><a href="#Thread接口和Runnable接口的区别" class="headerlink" title="Thread接口和Runnable接口的区别"></a>Thread接口和Runnable接口的区别</h2><ol>
<li>可以避免由于Java的单继承特性而带来的局限.</li>
<li>使用Runnable实现多线程可以达到资源共享目的。</li>
</ol>
<h2 id="Runnable接口和Callable接口的区别"><a href="#Runnable接口和Callable接口的区别" class="headerlink" title="Runnable接口和Callable接口的区别"></a>Runnable接口和Callable接口的区别</h2><p>Runnable应该是比较熟悉的接口，它只有一个run()函数，用于将耗时操作写在其中，该函数没有返回值，不能将结果返回给客户程序。然后使用某个线程去执行runnable即可实现多线程，Thread类在调用start()函数后就是执行的是Runnable的run()函数。Runnable的声明如下 :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Callable与Runnable的功能大致相似，Callable中有一个call()函数，但是call()函数有返回值。</p>
<p>Callable的声明如下 :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;  </div><div class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，这是一个泛型接口，call()函数返回的类型就是客户程序传递进来的V类型。<br><strong>不同之处：</strong><br>1.Callable可以返回一个类型V，而Runnable不可以；<br>2.Callable能够抛出checked exception,而Runnable不可以；<br>3.Runnable是自从java1.1就有了，而Callable是1.5之后才加上去的；<br>4.Callable和Runnable都可以应用于executors。而Thread类只支持Runnable；<br>Callable与executors联合在一起，在任务完成时可立刻获得一个更新了的Future；而Runable却要自己处理。 </p>
<p>5.加入线程池运行，Runnable使用ExecutorService的execute方法，Callable使用submit方法。</p>
<h2 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h2><p>先启动若干数量的线程，并让这些线程都处于睡眠状态，当客户端有一个新请求时，就会唤醒线程池中的某一个睡眠线程，让它来处理客户端的这个请求，当处理完这个请求后，线程又处于睡眠状态。</p>
<p>节约大量的的系统资源，使得更多的CPU时间和内存用来处理实际的商业应用，而不是频繁的线程创建与销毁。</p>
<h2 id="线程池的几种方式"><a href="#线程池的几种方式" class="headerlink" title="线程池的几种方式"></a>线程池的几种方式</h2><h2 id="Finalizer对象什么时候会在引用队列中"><a href="#Finalizer对象什么时候会在引用队列中" class="headerlink" title="Finalizer对象什么时候会在引用队列中"></a>Finalizer对象什么时候会在引用队列中</h2><h2 id="CountDownLatch-原理"><a href="#CountDownLatch-原理" class="headerlink" title="CountDownLatch 原理"></a>CountDownLatch 原理</h2><h2 id="CyclicBarrier-原理"><a href="#CyclicBarrier-原理" class="headerlink" title="CyclicBarrier 原理"></a>CyclicBarrier 原理</h2><h2 id="Semaphore-原理"><a href="#Semaphore-原理" class="headerlink" title="Semaphore 原理"></a>Semaphore 原理</h2><h2 id="Exchanger-原理"><a href="#Exchanger-原理" class="headerlink" title="Exchanger 原理"></a>Exchanger 原理</h2><h2 id="CountDownLatch-与-CyclicBarrier-区别"><a href="#CountDownLatch-与-CyclicBarrier-区别" class="headerlink" title="CountDownLatch 与 CyclicBarrier 区别"></a>CountDownLatch 与 CyclicBarrier 区别</h2><h2 id="线程池中的coreNum和maxNum有什么不同"><a href="#线程池中的coreNum和maxNum有什么不同" class="headerlink" title="线程池中的coreNum和maxNum有什么不同"></a>线程池中的coreNum和maxNum有什么不同</h2><h2 id="在不同的业务场景中，线程池参数如何设置"><a href="#在不同的业务场景中，线程池参数如何设置" class="headerlink" title="在不同的业务场景中，线程池参数如何设置"></a>在不同的业务场景中，线程池参数如何设置</h2><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><h2 id="说说线程安全问题"><a href="#说说线程安全问题" class="headerlink" title="说说线程安全问题"></a>说说线程安全问题</h2><h2 id="synchronize-实现原理"><a href="#synchronize-实现原理" class="headerlink" title="synchronize 实现原理"></a>synchronize 实现原理</h2><h2 id="synchronized-和java-util-concurrent-locks-Lock的异同"><a href="#synchronized-和java-util-concurrent-locks-Lock的异同" class="headerlink" title="synchronized 和java.util.concurrent.locks.Lock的异同"></a>synchronized 和java.util.concurrent.locks.Lock的异同</h2><h2 id="介绍下栈和队列"><a href="#介绍下栈和队列" class="headerlink" title="介绍下栈和队列"></a>介绍下栈和队列</h2><h2 id="synchronized、Lock、ReentrantLock、ReadWriteLock"><a href="#synchronized、Lock、ReentrantLock、ReadWriteLock" class="headerlink" title="synchronized、Lock、ReentrantLock、ReadWriteLock"></a>synchronized、Lock、ReentrantLock、ReadWriteLock</h2><h2 id="介绍下CAS-无锁技术"><a href="#介绍下CAS-无锁技术" class="headerlink" title="介绍下CAS(无锁技术)"></a>介绍下CAS(无锁技术)</h2><h2 id="ThreadPoolExecutor的内部工作原理"><a href="#ThreadPoolExecutor的内部工作原理" class="headerlink" title="ThreadPoolExecutor的内部工作原理"></a>ThreadPoolExecutor的内部工作原理</h2><h2 id="分布式环境下，怎么保证线程安全"><a href="#分布式环境下，怎么保证线程安全" class="headerlink" title="分布式环境下，怎么保证线程安全"></a>分布式环境下，怎么保证线程安全</h2><h2 id="有哪些类加载器"><a href="#有哪些类加载器" class="headerlink" title="有哪些类加载器"></a>有哪些类加载器</h2><h2 id="能不能自己写一个类叫java-lang-String"><a href="#能不能自己写一个类叫java-lang-String" class="headerlink" title="能不能自己写一个类叫java.lang.String"></a>能不能自己写一个类叫java.lang.String</h2><h2 id="介绍下B树、二叉树"><a href="#介绍下B树、二叉树" class="headerlink" title="介绍下B树、二叉树"></a>介绍下B树、二叉树</h2><h2 id="分布式锁的实现"><a href="#分布式锁的实现" class="headerlink" title="分布式锁的实现"></a>分布式锁的实现</h2><h2 id="分布式session存储解决方案"><a href="#分布式session存储解决方案" class="headerlink" title="分布式session存储解决方案"></a>分布式session存储解决方案</h2><h2 id="常用的linux命令"><a href="#常用的linux命令" class="headerlink" title="常用的linux命令"></a>常用的linux命令</h2>
      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="ShenWenFang 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="ShenWenFang 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/基础面试题/" rel="tag"># 基础面试题</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/01/15/Python 的基本要素/" rel="next" title="Python 的基本要素">
                <i class="fa fa-chevron-left"></i> Python 的基本要素
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/05/ConcurrentHashMap的锁分离技术/" rel="prev" title="ConcurrentHashMap 的锁定分离技术">
                ConcurrentHashMap 的锁定分离技术 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ4My82MDUx"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="ShenWenFang" />
            
              <p class="site-author-name" itemprop="name">ShenWenFang</p>
              <p class="site-description motion-element" itemprop="description">每一个你不满意的现在，都有一个你没有努力的曾经。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

         <div id="music163player">
             <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=31861269&auto=0&height=66"></iframe>
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基础面试题"><span class="nav-number">1.</span> <span class="nav-text">基础面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言："><span class="nav-number">1.1.</span> <span class="nav-text">引言：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#forward-和redirect的区别"><span class="nav-number">1.2.</span> <span class="nav-text">forward 和redirect的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#int-和-Integer-有什么区别"><span class="nav-number">1.3.</span> <span class="nav-text">int 和 Integer 有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#error和exception有什么区别"><span class="nav-number">1.4.</span> <span class="nav-text">error和exception有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最常见到的runtime-exception"><span class="nav-number">1.5.</span> <span class="nav-text">最常见到的runtime exception</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Overload和Override区别，Overloaded方法可以改变返回值的类型吗"><span class="nav-number">1.6.</span> <span class="nav-text">Overload和Override区别，Overloaded方法可以改变返回值的类型吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java中有哪些集合，主要方法有哪些"><span class="nav-number">1.7.</span> <span class="nav-text">java中有哪些集合，主要方法有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List、Map、Set接口，存取元素时各自特点"><span class="nav-number">1.8.</span> <span class="nav-text">List、Map、Set接口，存取元素时各自特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap与HashTable的区别"><span class="nav-number">1.9.</span> <span class="nav-text">HashMap与HashTable的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap，ConcurrentHashMap与LinkedHashMap的区别"><span class="nav-number">1.10.</span> <span class="nav-text">HashMap，ConcurrentHashMap与LinkedHashMap的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vector和ArrayList的区别"><span class="nav-number">1.11.</span> <span class="nav-text">Vector和ArrayList的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayList-与-LinkedList-的区别"><span class="nav-number">1.12.</span> <span class="nav-text">ArrayList 与 LinkedList 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-中的-LinkedList-是单向链表还是双向链表"><span class="nav-number">1.13.</span> <span class="nav-text">Java 中的 LinkedList 是单向链表还是双向链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String、StringBuffer、StringBuilder之间区别"><span class="nav-number">1.14.</span> <span class="nav-text">String、StringBuffer、StringBuilder之间区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-的常用方有哪些"><span class="nav-number">1.15.</span> <span class="nav-text">Object 的常用方有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mysql-的分页-SQL-语句"><span class="nav-number">1.16.</span> <span class="nav-text">Mysql 的分页 SQL 语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hibernate与MyBatis的异同"><span class="nav-number">1.17.</span> <span class="nav-text">Hibernate与MyBatis的异同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hibernate与MyBatis在sql优化方面异同"><span class="nav-number">1.18.</span> <span class="nav-text">Hibernate与MyBatis在sql优化方面异同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hibernate与MyBatis对象管理对比"><span class="nav-number">1.19.</span> <span class="nav-text">Hibernate与MyBatis对象管理对比</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Jsp九大内置对象"><span class="nav-number">1.20.</span> <span class="nav-text">Jsp九大内置对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Comparator-与-Comparable-有什么不同"><span class="nav-number">1.21.</span> <span class="nav-text">Comparator 与 Comparable 有什么不同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collection-和-Collections的区别"><span class="nav-number">1.22.</span> <span class="nav-text">Collection 和 Collections的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String-s-new-String-“xyz”-创建了几个String-Object"><span class="nav-number">1.23.</span> <span class="nav-text">String s = new String(“xyz”);创建了几个String Object</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程同步的方法"><span class="nav-number">1.24.</span> <span class="nav-text">线程同步的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Volatile和Synchronized四个不同点"><span class="nav-number">1.25.</span> <span class="nav-text">Volatile和Synchronized四个不同点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringMVC运行原理"><span class="nav-number">1.26.</span> <span class="nav-text">SpringMVC运行原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringMVC与Struts2区别与比较总结"><span class="nav-number">1.27.</span> <span class="nav-text">SpringMVC与Struts2区别与比较总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简单总结springMVC和struts2的区别"><span class="nav-number">1.28.</span> <span class="nav-text">简单总结springMVC和struts2的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringMvc怎么和AJAX相互调用的"><span class="nav-number">1.29.</span> <span class="nav-text">SpringMvc怎么和AJAX相互调用的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring有哪些优点"><span class="nav-number">1.30.</span> <span class="nav-text">Spring有哪些优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spring-主要使用了哪些-，IOC和AOP实现原理是什么"><span class="nav-number">1.31.</span> <span class="nav-text">spring 主要使用了哪些 ，IOC和AOP实现原理是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解释AOP模块"><span class="nav-number">1.32.</span> <span class="nav-text">解释AOP模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IoC容器是什么其优点"><span class="nav-number">1.33.</span> <span class="nav-text">IoC容器是什么其优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-的依赖注入方式有哪一些"><span class="nav-number">1.34.</span> <span class="nav-text">Spring 的依赖注入方式有哪一些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring支持的事务管理类型"><span class="nav-number">1.35.</span> <span class="nav-text">Spring支持的事务管理类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal-线程变量副本"><span class="nav-number">1.36.</span> <span class="nav-text">ThreadLocal(线程变量副本)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#throw-和-throws-的区别"><span class="nav-number">1.37.</span> <span class="nav-text">throw 和 throws 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final关键字的作用"><span class="nav-number">1.38.</span> <span class="nav-text">final关键字的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static关键字有哪些作用"><span class="nav-number">1.39.</span> <span class="nav-text">static关键字有哪些作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String是最基本的数据类型吗"><span class="nav-number">1.40.</span> <span class="nav-text">String是最基本的数据类型吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized和java-util-concurrent-locks-Lock的异同"><span class="nav-number">1.41.</span> <span class="nav-text">synchronized和java.util.concurrent.locks.Lock的异同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spring的事务有几种它的隔离级别和传播行为"><span class="nav-number">1.42.</span> <span class="nav-text">spring的事务有几种它的隔离级别和传播行为</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sleep-和-wait-有什么区别"><span class="nav-number">1.43.</span> <span class="nav-text">sleep() 和 wait() 有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程和同步有几种实现方法"><span class="nav-number">1.44.</span> <span class="nav-text">多线程和同步有几种实现方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#启动一个线程是用run-还是start"><span class="nav-number">1.45.</span> <span class="nav-text">启动一个线程是用run()还是start()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final-finally-finalize的区别"><span class="nav-number">1.46.</span> <span class="nav-text">final,finally,finalize的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#abstract-class和interface有什么区别"><span class="nav-number">1.47.</span> <span class="nav-text">abstract class和interface有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Set里的元素不能重复，用-还是equals-判断"><span class="nav-number">1.48.</span> <span class="nav-text">Set里的元素不能重复，用==还是equals ()判断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#struts-框架是如何体现MVC模式"><span class="nav-number">1.49.</span> <span class="nav-text">struts 框架是如何体现MVC模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hibernate-的实体存在哪几种状态"><span class="nav-number">1.50.</span> <span class="nav-text">Hibernate 的实体存在哪几种状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hibernate-的get-和load-的区别"><span class="nav-number">1.51.</span> <span class="nav-text">Hibernate 的get()和load()的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么wait和notify方法要在同步块中调用"><span class="nav-number">1.52.</span> <span class="nav-text">为什么wait和notify方法要在同步块中调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是ThreadLocal变量"><span class="nav-number">1.53.</span> <span class="nav-text">什么是ThreadLocal变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何避免死锁"><span class="nav-number">1.54.</span> <span class="nav-text">如何避免死锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java中活锁和死锁有什么区别"><span class="nav-number">1.55.</span> <span class="nav-text">Java中活锁和死锁有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#怎么检测一个线程是否拥有锁"><span class="nav-number">1.56.</span> <span class="nav-text">怎么检测一个线程是否拥有锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Maven有哪些优点"><span class="nav-number">1.57.</span> <span class="nav-text">Maven有哪些优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Maven常见的依赖范围有哪些"><span class="nav-number">1.58.</span> <span class="nav-text">Maven常见的依赖范围有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用“Mvn-Clean-Package”进行项目打包-其过程执行了哪些动作"><span class="nav-number">1.59.</span> <span class="nav-text">使用“Mvn Clean Package”进行项目打包,其过程执行了哪些动作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Maven-多模块如何聚合"><span class="nav-number">1.60.</span> <span class="nav-text">Maven 多模块如何聚合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓存框架memcache和redis的区别？项目中，怎么去选择？"><span class="nav-number">1.61.</span> <span class="nav-text">缓存框架memcache和redis的区别？项目中，怎么去选择？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java的原子类，实现原理是什么"><span class="nav-number">1.62.</span> <span class="nav-text">java的原子类，实现原理是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库性能优化有哪些方法"><span class="nav-number">1.63.</span> <span class="nav-text">数据库性能优化有哪些方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP请求方法get和post有什么区别"><span class="nav-number">1.64.</span> <span class="nav-text">HTTP请求方法get和post有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux命令，查看某个线程，整个机器负载和文件内容快速查找的命令"><span class="nav-number">1.65.</span> <span class="nav-text">linux命令，查看某个线程，整个机器负载和文件内容快速查找的命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM内存的模型，垃圾回收的机制，如何对JVM进行调优"><span class="nav-number">1.66.</span> <span class="nav-text">JVM内存的模型，垃圾回收的机制，如何对JVM进行调优</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高并发时，又如何保证性能和数据正确"><span class="nav-number">1.67.</span> <span class="nav-text">高并发时，又如何保证性能和数据正确</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分布式事务如何实现"><span class="nav-number">1.68.</span> <span class="nav-text">分布式事务如何实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#抽象类和接口的区别，项目中如何使用它们"><span class="nav-number">1.69.</span> <span class="nav-text">抽象类和接口的区别，项目中如何使用它们</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP通讯有几次握手，有使用过哪些socket框架"><span class="nav-number">1.70.</span> <span class="nav-text">TCP通讯有几次握手，有使用过哪些socket框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java反射机制，反射生成类，可否访问私有变量"><span class="nav-number">1.71.</span> <span class="nav-text">java反射机制，反射生成类，可否访问私有变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RPC是什么，有使用过哪些RPC框架"><span class="nav-number">1.72.</span> <span class="nav-text">RPC是什么，有使用过哪些RPC框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jquery如何绑定页面某元素的点击事件"><span class="nav-number">1.73.</span> <span class="nav-text">jquery如何绑定页面某元素的点击事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile实现原理"><span class="nav-number">1.74.</span> <span class="nav-text">volatile实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#session-与-cookie-区别"><span class="nav-number">1.75.</span> <span class="nav-text">session 与 cookie 区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#session-分布式处理"><span class="nav-number">1.76.</span> <span class="nav-text">session 分布式处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#说说自定义注解的场景及实现"><span class="nav-number">1.77.</span> <span class="nav-text">说说自定义注解的场景及实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashSet-和-HashMap-区别"><span class="nav-number">1.78.</span> <span class="nav-text">HashSet 和 HashMap 区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap-的工作原理及代码实现"><span class="nav-number">1.79.</span> <span class="nav-text">HashMap 的工作原理及代码实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentHashMap-的工作原理及代码实现"><span class="nav-number">1.80.</span> <span class="nav-text">ConcurrentHashMap 的工作原理及代码实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal-原理分析"><span class="nav-number">1.81.</span> <span class="nav-text">ThreadLocal 原理分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建线程的方式及实现"><span class="nav-number">1.82.</span> <span class="nav-text">创建线程的方式及实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sleep-、join（）、yield（）有什么区别"><span class="nav-number">1.83.</span> <span class="nav-text">sleep() 、join（）、yield（）有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentHashMap如何保证线程安全"><span class="nav-number">1.84.</span> <span class="nav-text">ConcurrentHashMap如何保证线程安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new与newInstance-的区别"><span class="nav-number">1.85.</span> <span class="nav-text">new与newInstance()的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK中用到的设计模式"><span class="nav-number">1.86.</span> <span class="nav-text">JDK中用到的设计模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hashCode-amp-amp-equals"><span class="nav-number">1.87.</span> <span class="nav-text">hashCode() && equals()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object类的finalize方法的实现原理"><span class="nav-number">1.88.</span> <span class="nav-text">Object类的finalize方法的实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAS-乐观锁"><span class="nav-number">1.89.</span> <span class="nav-text">CAS 乐观锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ABA-问题"><span class="nav-number">1.90.</span> <span class="nav-text">ABA 问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#乐观锁的业务场景及实现方式"><span class="nav-number">1.91.</span> <span class="nav-text">乐观锁的业务场景及实现方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问修饰符public-private-protected-以及不写时的区别"><span class="nav-number">1.92.</span> <span class="nav-text">访问修饰符public,private,protected,以及不写时的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String-是不是最基本的数据类型"><span class="nav-number">1.93.</span> <span class="nav-text">String 是不是最基本的数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗"><span class="nav-number">1.94.</span> <span class="nav-text">short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#是否可以继承String类"><span class="nav-number">1.95.</span> <span class="nav-text">是否可以继承String类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM加载class文件的原理机制"><span class="nav-number">1.96.</span> <span class="nav-text">JVM加载class文件的原理机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同"><span class="nav-number">1.97.</span> <span class="nav-text">静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GC是什么？为什么要有GC？"><span class="nav-number">1.98.</span> <span class="nav-text">GC是什么？为什么要有GC？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String-s-new-String-“xyz”-创建了几个字符串对象"><span class="nav-number">1.99.</span> <span class="nav-text">String s = new String(“xyz”);创建了几个字符串对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何实现字符串的反转及替换"><span class="nav-number">1.100.</span> <span class="nav-text">如何实现字符串的反转及替换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List、Set、Map是否继承自Collection接口"><span class="nav-number">1.101.</span> <span class="nav-text">List、Set、Map是否继承自Collection接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List、Map、Set三个接口存取元素时，各有什么特点"><span class="nav-number">1.102.</span> <span class="nav-text">List、Map、Set三个接口存取元素时，各有什么特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B"><span class="nav-number">1.103.</span> <span class="nav-text">当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程同步以及线程调度相关的方法"><span class="nav-number">1.104.</span> <span class="nav-text">线程同步以及线程调度相关的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#启动一个线程是调用run-还是start-方法"><span class="nav-number">1.105.</span> <span class="nav-text">启动一个线程是调用run()还是start()方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java中有几种类型的流"><span class="nav-number">1.106.</span> <span class="nav-text">Java中有几种类型的流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在项目中哪些地方用到了XML"><span class="nav-number">1.107.</span> <span class="nav-text">在项目中哪些地方用到了XML</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vector、ArrayList、LinkedList-的区别是什么"><span class="nav-number">1.108.</span> <span class="nav-text">vector、ArrayList、LinkedList 的区别是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何通过反射创建对象"><span class="nav-number">1.109.</span> <span class="nav-text">如何通过反射创建对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Statement与PreparedStatement的区别-什么是SQL注入，如何防止SQL注入"><span class="nav-number">1.110.</span> <span class="nav-text">Statement与PreparedStatement的区别,什么是SQL注入，如何防止SQL注入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用Java写一个单例类"><span class="nav-number">1.111.</span> <span class="nav-text">用Java写一个单例类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用Java写一个冒泡排序"><span class="nav-number">1.112.</span> <span class="nav-text">用Java写一个冒泡排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#char型变量中能不能存贮一个中文汉字"><span class="nav-number">1.113.</span> <span class="nav-text">char型变量中能不能存贮一个中文汉字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用最有效率的方法算出2乘以8等于几"><span class="nav-number">1.114.</span> <span class="nav-text">用最有效率的方法算出2乘以8等于几</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态变量和实例变量的区别"><span class="nav-number">1.115.</span> <span class="nav-text">静态变量和实例变量的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#switch语句能否作用在-byte-、-long-和String-上"><span class="nav-number">1.116.</span> <span class="nav-text">switch语句能否作用在 byte 、 long 和String 上</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何跳出当前的多重嵌套循环"><span class="nav-number">1.117.</span> <span class="nav-text">如何跳出当前的多重嵌套循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#说说-amp-和-amp-amp-的区别"><span class="nav-number">1.118.</span> <span class="nav-text">说说&和&&的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一个”-java”源文件中是否可以包括多个类（不是内部类）有什么限制"><span class="nav-number">1.119.</span> <span class="nav-text">一个”.java”源文件中是否可以包括多个类（不是内部类）有什么限制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可以从一个static方法内部发出对非static方法的调用吗"><span class="nav-number">1.120.</span> <span class="nav-text">可以从一个static方法内部发出对非static方法的调用吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hibernate中怎样实现类之间的关系"><span class="nav-number">1.121.</span> <span class="nav-text">Hibernate中怎样实现类之间的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hibernate中的update-和saveOrUpdate-的区别"><span class="nav-number">1.122.</span> <span class="nav-text">Hibernate中的update()和saveOrUpdate()的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hibernate的缓存机制"><span class="nav-number">1.123.</span> <span class="nav-text">Hibernate的缓存机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何优化Hibernate"><span class="nav-number">1.124.</span> <span class="nav-text">如何优化Hibernate</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hibernate的延迟加载和openSessionInView"><span class="nav-number">1.125.</span> <span class="nav-text">hibernate的延迟加载和openSessionInView</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mysql-优化"><span class="nav-number">1.126.</span> <span class="nav-text">Mysql 优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mysql-的交集、差集、并集"><span class="nav-number">1.127.</span> <span class="nav-text">Mysql 的交集、差集、并集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java内存模型是什么"><span class="nav-number">1.128.</span> <span class="nav-text">Java内存模型是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread接口和Runnable接口的区别"><span class="nav-number">1.129.</span> <span class="nav-text">Thread接口和Runnable接口的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Runnable接口和Callable接口的区别"><span class="nav-number">1.130.</span> <span class="nav-text">Runnable接口和Callable接口的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池的实现原理"><span class="nav-number">1.131.</span> <span class="nav-text">线程池的实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池的几种方式"><span class="nav-number">1.132.</span> <span class="nav-text">线程池的几种方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Finalizer对象什么时候会在引用队列中"><span class="nav-number">1.133.</span> <span class="nav-text">Finalizer对象什么时候会在引用队列中</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CountDownLatch-原理"><span class="nav-number">1.134.</span> <span class="nav-text">CountDownLatch 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CyclicBarrier-原理"><span class="nav-number">1.135.</span> <span class="nav-text">CyclicBarrier 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Semaphore-原理"><span class="nav-number">1.136.</span> <span class="nav-text">Semaphore 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exchanger-原理"><span class="nav-number">1.137.</span> <span class="nav-text">Exchanger 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CountDownLatch-与-CyclicBarrier-区别"><span class="nav-number">1.138.</span> <span class="nav-text">CountDownLatch 与 CyclicBarrier 区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池中的coreNum和maxNum有什么不同"><span class="nav-number">1.139.</span> <span class="nav-text">线程池中的coreNum和maxNum有什么不同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在不同的业务场景中，线程池参数如何设置"><span class="nav-number">1.140.</span> <span class="nav-text">在不同的业务场景中，线程池参数如何设置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的生命周期"><span class="nav-number">1.141.</span> <span class="nav-text">线程的生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#说说线程安全问题"><span class="nav-number">1.142.</span> <span class="nav-text">说说线程安全问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronize-实现原理"><span class="nav-number">1.143.</span> <span class="nav-text">synchronize 实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized-和java-util-concurrent-locks-Lock的异同"><span class="nav-number">1.144.</span> <span class="nav-text">synchronized 和java.util.concurrent.locks.Lock的异同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#介绍下栈和队列"><span class="nav-number">1.145.</span> <span class="nav-text">介绍下栈和队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized、Lock、ReentrantLock、ReadWriteLock"><span class="nav-number">1.146.</span> <span class="nav-text">synchronized、Lock、ReentrantLock、ReadWriteLock</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#介绍下CAS-无锁技术"><span class="nav-number">1.147.</span> <span class="nav-text">介绍下CAS(无锁技术)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadPoolExecutor的内部工作原理"><span class="nav-number">1.148.</span> <span class="nav-text">ThreadPoolExecutor的内部工作原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分布式环境下，怎么保证线程安全"><span class="nav-number">1.149.</span> <span class="nav-text">分布式环境下，怎么保证线程安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有哪些类加载器"><span class="nav-number">1.150.</span> <span class="nav-text">有哪些类加载器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#能不能自己写一个类叫java-lang-String"><span class="nav-number">1.151.</span> <span class="nav-text">能不能自己写一个类叫java.lang.String</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#介绍下B树、二叉树"><span class="nav-number">1.152.</span> <span class="nav-text">介绍下B树、二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分布式锁的实现"><span class="nav-number">1.153.</span> <span class="nav-text">分布式锁的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分布式session存储解决方案"><span class="nav-number">1.154.</span> <span class="nav-text">分布式session存储解决方案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常用的linux命令"><span class="nav-number">1.155.</span> <span class="nav-text">常用的linux命令</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ShenWenFang</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("9lk8dNt56FULANV18qHRXIff-gzGzoHsz", "lSea2qzYEcPELI1zQN1wWQGt");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
