<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="基础面试题," />










<meta name="description" content="基础面试题引言：以下各方面知识点的面试题，是为了将要出来工作的小师妹和小师弟而精心整理的。希望对你们都帮助。这些面试题都是很基础的，希望你们能够好好利用起来。有问题，或者不对的地方欢迎给我留言哈！">
<meta name="keywords" content="基础面试题">
<meta property="og:type" content="article">
<meta property="og:title" content="基础面试题">
<meta property="og:url" content="http://yoursite.com/2018/01/21/基础面试题/index.html">
<meta property="og:site_name" content="ShenWenFang">
<meta property="og:description" content="基础面试题引言：以下各方面知识点的面试题，是为了将要出来工作的小师妹和小师弟而精心整理的。希望对你们都帮助。这些面试题都是很基础的，希望你们能够好好利用起来。有问题，或者不对的地方欢迎给我留言哈！">
<meta property="og:updated_time" content="2018-03-05T15:12:55.477Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="基础面试题">
<meta name="twitter:description" content="基础面试题引言：以下各方面知识点的面试题，是为了将要出来工作的小师妹和小师弟而精心整理的。希望对你们都帮助。这些面试题都是很基础的，希望你们能够好好利用起来。有问题，或者不对的地方欢迎给我留言哈！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/01/21/基础面试题/"/>





  <title>基础面试题 | ShenWenFang</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/another"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://camo.githubusercontent.com/c6286ade715e9bea433b4705870de482a654f78a/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f77686974655f6666666666662e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_left_white_ffffff.png"></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ShenWenFang</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/21/基础面试题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ShenWenFang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShenWenFang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">基础面试题</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-21T20:01:03+08:00">
                2018-01-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/基础面试题/" itemprop="url" rel="index">
                    <span itemprop="name">基础面试题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/01/21/基础面试题/" class="leancloud_visitors" data-flag-title="基础面试题">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  16,968 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  61 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="基础面试题"><a href="#基础面试题" class="headerlink" title="基础面试题"></a>基础面试题</h1><h2 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h2><p>以下各方面知识点的面试题，是为了将要出来工作的小师妹和小师弟而精心整理的。希望对你们都帮助。这些面试题都是很基础的，希望你们能够好好利用起来。有问题，或者不对的地方欢迎给我留言哈！</p>
<a id="more"></a>
<h2 id="forward-和redirect的区别"><a href="#forward-和redirect的区别" class="headerlink" title="forward 和redirect的区别"></a>forward 和redirect的区别</h2><p>forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。</p>
<p>redirect就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求，所以session,request参数都可以获取。</p>
<h2 id="int-和-Integer-有什么区别"><a href="#int-和-Integer-有什么区别" class="headerlink" title="int 和 Integer 有什么区别"></a>int 和 Integer 有什么区别</h2><p>Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int是java的原始数据类型，Integer是java为int提供的封装类。Java为每个原始类型提供了封装类。<br>原始类型封装类,booleanBoolean,charCharacter,byteByte,shortShort,intInteger,longLong,floatFloat,doubleDouble<br>引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为 null，而原始类型实例变量的缺省值与它们的类型有关</p>
<h2 id="error和exception有什么区别"><a href="#error和exception有什么区别" class="headerlink" title="error和exception有什么区别"></a>error和exception有什么区别</h2><p>error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。</p>
<h2 id="Overload和Override区别，Overloaded方法可以改变返回值的类型吗"><a href="#Overload和Override区别，Overloaded方法可以改变返回值的类型吗" class="headerlink" title="Overload和Override区别，Overloaded方法可以改变返回值的类型吗"></a>Overload和Override区别，Overloaded方法可以改变返回值的类型吗</h2><p>方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被”屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。</p>
<h2 id="java中有哪些集合，主要方法有哪些"><a href="#java中有哪些集合，主要方法有哪些" class="headerlink" title="java中有哪些集合，主要方法有哪些"></a>java中有哪些集合，主要方法有哪些</h2><p>主要有LinkedList，ArrayList，Vector等。下面是详细：<br>Collection<br>├List<br>│├LinkedList<br>│├ArrayList<br>│└Vector<br>│ └Stack<br>└Set<br>Map<br>├Hashtable<br>├HashMap<br>└WeakHashMap<br>最常用的集合类是 List 和 Map。 List 的具体实现包括 ArrayList 和 Vector，它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。 List 适用于按数值索引访问元素的情形。 Map 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作“键”和“值”）其中每个键映射到一个值。</p>
<h2 id="List、Map、Set接口，存取元素时各自特点"><a href="#List、Map、Set接口，存取元素时各自特点" class="headerlink" title="List、Map、Set接口，存取元素时各自特点"></a>List、Map、Set接口，存取元素时各自特点</h2><p>List 以特定次序来持有元素，可有重复元素。Set 无法拥有重复元素,内部排序。Map 保存key-value值，value可多值。<br>  List的遍历： List接口有size()和get()方法，用这两个方法可以实现对List的遍历。size()方法得到List中的元素个数。get()方法取得某个位置上的元素</p>
<h2 id="HashMap与HashTable的区别"><a href="#HashMap与HashTable的区别" class="headerlink" title="HashMap与HashTable的区别"></a>HashMap与HashTable的区别</h2><p>1、HashMap是非线程安全的，HashTable是线程安全的。</p>
<p>2、HashMap的键和值都允许有null值存在，而HashTable则不行。</p>
<p>3、因为线程安全的问题，HashMap效率比HashTable的要高。<br>HashMap的实现机制：<br>维护一个每个元素是一个链表的数组，而且链表中的每个节点是一个Entry[]键值对的数据结构。<br>实现了数组+链表的特性，查找快，插入删除也快。<br>对于每个key,他对应的数组索引下标是 int i = hash(key.hashcode)&amp;(len-1);<br>每个新加入的节点放在链表首，然后该新加入的节点指向原链表首</p>
<h2 id="HashMap，ConcurrentHashMap与LinkedHashMap的区别"><a href="#HashMap，ConcurrentHashMap与LinkedHashMap的区别" class="headerlink" title="HashMap，ConcurrentHashMap与LinkedHashMap的区别"></a>HashMap，ConcurrentHashMap与LinkedHashMap的区别</h2><p>ConcurrentHashMap是使用了锁分段技术技术来保证线程安全的，锁分段技术：首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问<br>ConcurrentHashMap 是在每个段（segment）中线程安全的<br>LinkedHashMap维护一个双链表，可以将里面的数据按写入的顺序读出</p>
<p>ConcurrentHashMap应用场景<br>1：ConcurrentHashMap的应用场景是高并发，但是并不能保证线程安全，而同步的HashMap和HashMap的是锁住整个容器，而加锁之后ConcurrentHashMap不需要锁住整个容器，只需要锁住对应的Segment就好了，所以可以保证高并发同步访问，提升了效率。<br>2：可以多线程写。<br>ConcurrentHashMap把HashMap分成若干个Segmenet<br>1.get时，不加锁，先定位到segment然后在找到头结点进行读取操作。而value是volatile变量，所以可以保证在竞争条件时保证读取最新的值，如果读到的value是null，则可能正在修改，那么久调用ReadValueUnderLock函数，加锁保证读到的数据是正确的。</p>
<p>2.Put时会加锁，一律添加到hash链的头部。</p>
<p>3.Remove时也会加锁，由于next是final类型不可改变，所以必须把删除的节点之前的节点都复制一遍。</p>
<p>4.ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对Hash表的不同Segment进行的修改。<br>ConcurrentHashMap的应用场景是高并发，但是并不能保证线程安全，而同步的HashMap和HashTable的是锁住整个容器，而加锁之后ConcurrentHashMap不需要锁住整个容器，只需要锁住对应的segment就好了，所以可以保证高并发同步访问，提升了效率。</p>
<h2 id="Vector和ArrayList的区别"><a href="#Vector和ArrayList的区别" class="headerlink" title="Vector和ArrayList的区别"></a>Vector和ArrayList的区别</h2><p>  首先看这两类都实现List接口，而List接口一共有三个实现类，分别是ArrayList、Vector和LinkedList。List用于存放多个元素，能够维护元素的次序，并且允许元素的重复。3个具体实现类的相关区别如下：</p>
<p>1.ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要讲已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。<br>2.Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。<br>3.LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。</p>
<h2 id="ArrayList-与-LinkedList-的不区别"><a href="#ArrayList-与-LinkedList-的不区别" class="headerlink" title="ArrayList 与 LinkedList 的不区别"></a>ArrayList 与 LinkedList 的不区别</h2><p>最明显的区别是 ArrrayList 底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。<br>1.LinkedList内部存储的是Node<e>，不仅要维护数据域，还要维护prev和next，如果LinkedList中的结点特别多，则LinkedList比ArrayList更占内存。<br>插入删除操作效率：<br>2.LinkedList在做插入和删除操作时，插入或删除头部或尾部时是高效的，操作越靠近中间位置的元素时，需要遍历查找，速度相对慢一些，如果在数据量较大时，每次插入或删除时遍历查找比较费时。所以LinkedList插入与删除，慢在遍历查找，快在只需要更改相关结点的引用地址。<br>ArrayList在做插入和删除操作时，插入或删除尾部时也一样是高效的，操作其他位置，则需要批量移动元素，所以ArrayList插入与删除，快在遍历查找，慢在需要批量移动元素。<br>3.循环遍历效率：<br>由于ArrayList实现了RandomAccess随机访问接口，所以使用for(int i = 0; i &lt; size; i++)遍历会比使用Iterator迭代器来遍历快<br>而由于LinkedList未实现RandomAccess接口，所以推荐使用Iterator迭代器来遍历数据。<br>因此，如果我们需要频繁在列表的中部改变插入或删除元素时，建议使用LinkedList，否则，建议使用ArrayList，因为ArrayList遍历查找元素较快，并且只需存储元素的数据域，不需要额外记录其他数据的位置信息，可以节省内存空间。</e></p>
<h2 id="Java-中的-LinkedList-是单向链表还是双向链表"><a href="#Java-中的-LinkedList-是单向链表还是双向链表" class="headerlink" title="Java 中的 LinkedList 是单向链表还是双向链表"></a>Java 中的 LinkedList 是单向链表还是双向链表</h2><p>是双向链表。</p>
<h2 id="String、StringBuffer、StringBuilder之间区别"><a href="#String、StringBuffer、StringBuilder之间区别" class="headerlink" title="String、StringBuffer、StringBuilder之间区别"></a>String、StringBuffer、StringBuilder之间区别</h2><p>1.三者在执行速度方面的比较：StringBuilder &gt;  StringBuffer  &gt;  String<br>2.在线程方面：StringBuilder是线程非安全的;StringBuffer是线程安全的</p>
<p>3.对于三者的使用：如果要操作少量的数据用 = String；单线程操作字符串缓冲区 下操作大量数据 = StringBuilder；多线程操作字符串缓冲区 下操作大量数据 = StringBuffer；</p>
<h2 id="Object-的常用方有哪些"><a href="#Object-的常用方有哪些" class="headerlink" title="Object 的常用方有哪些"></a>Object 的常用方有哪些</h2><p>clone()、equals()、hashCode()、notify()、notifyAll()、toString()、wait()、finalize()</p>
<h2 id="Mysql-的分页-SQL-语句"><a href="#Mysql-的分页-SQL-语句" class="headerlink" title="Mysql 的分页 SQL 语句"></a>Mysql 的分页 SQL 语句</h2><p>select * from tablename limit m,n(n是指从第m+1条开始，取n条)</p>
<h2 id="Hibernate与MyBatis的异同"><a href="#Hibernate与MyBatis的异同" class="headerlink" title="Hibernate与MyBatis的异同"></a>Hibernate与MyBatis的异同</h2><p>相同点：<br>Hibernate与MyBatis都可以是通过SessionFactoryBuider由XML配置文件生成SessionFactory，然后由SessionFactory 生成Session，最后由Session来开启执行事务和SQL语句。其中SessionFactoryBuider，SessionFactory，Session的生命周期都是差不多的。Hibernate和MyBatis都支持JDBC和JTA事务处理。<br>Mybatis优势：<br>MyBatis可以进行更为细致的SQL优化，可以减少查询字段。<br>MyBatis容易掌握，而Hibernate门槛较高。<br>Hibernate优势：<br>Hibernate的DAO层开发比MyBatis简单，Mybatis需要维护SQL和结果映射。<br>Hibernate对对象的维护和缓存要比MyBatis好，对增删改查的对象的维护要方便。<br>Hibernate数据库移植性很好，MyBatis的数据库移植性不好，不同的数据库需要写不同SQL。<br>Hibernate有更好的二级缓存机制，可以使用第三方缓存。MyBatis本身提供的缓存机制不佳。</p>
<h2 id="Hibernate与MyBatis在sql优化方面异同"><a href="#Hibernate与MyBatis在sql优化方面异同" class="headerlink" title="Hibernate与MyBatis在sql优化方面异同"></a>Hibernate与MyBatis在sql优化方面异同</h2><p>Hibernate的查询会将表中的所有字段查询出来，这一点会有性能消耗。Hibernate也可以自己写SQL来指定需要查询的字段，但这样就破坏了Hibernate开发的简洁性。<br>而Mybatis的SQL是手动编写的，所以可以按需求指定查询的字段。<br>Hibernate HQL语句的调优需要将SQL打印出来，而Hibernate的SQL被很多人嫌弃因为太丑了。<br>MyBatis的SQL是自己手动写的所以调整方便。但Hibernate具有自己的日志统计。Mybatis本身不带日志统计，使用Log4j进行日志记录。</p>
<h2 id="Hibernate与MyBatis对象管理对比"><a href="#Hibernate与MyBatis对象管理对比" class="headerlink" title="Hibernate与MyBatis对象管理对比"></a>Hibernate与MyBatis对象管理对比</h2><p>Hibernate 是完整的对象/关系映射解决方案，它提供了对象状态管理（state management）的功能，使开发者不再需要理会底层数据库系统的细节。也就是说，相对于常见的 JDBC/SQL 持久层方案中需要管理 SQL 语句，Hibernate采用了更自然的面向对象的视角来持久化 Java 应用中的数据。<br>换句话说，使用 Hibernate 的开发者应该总是关注对象的状态（state），不必考虑 SQL 语句的执行。这部分细节已经由 Hibernate 掌管妥当，只有开发者在进行系统性能调优的时候才需要进行了解。而MyBatis在这一块没有文档说明，用户需要对对象自己进行详细的管理。</p>
<h2 id="Jsp九大内置对象"><a href="#Jsp九大内置对象" class="headerlink" title="Jsp九大内置对象"></a>Jsp九大内置对象</h2><p>1.Request:   request对象主要用于客户端请求处理<br>2.Response:   response对象提供了多个方法用来处理HTTP响应，可以调用response中的方法修改ContentType中的MIME类型以及实现页面的跳转等等，<br>3.Page:  page对象有点类似于Java编程中的this指针，就是指当前JSP页面本身。page是java.lang.Object类的对象。<br>4.Session:  session是与请求有关的会话期，它是java.servlet.http.HttpSession类的对象，用来表示和存储当前页面的请求信息。<br>5.Application:  application是javax.servlet.ServletContext类对象的一个实例，用于实现用户之间的数据共享<br>6.Out:<br>7.Exception:  exception内置对象是用来处理页面出现的异常错误<br>8.Config:  config内置对象是ServletConfig类的一个实例。在Servlet初始化的时候，JSP引擎通过config向它传递信息。这种信息可以是属性名/值匹配的参数，也可以是通过ServletContext对象传递的服务器的有关信息。<br>9.pageContext:  pageContext对象是一个比较特殊的对象。它相当于页面中所有其他对象功能的最大集成者，即使用它可以访问到本页面中所有其他对象</p>
<h2 id="Comparator-与-Comparable-有什么不同"><a href="#Comparator-与-Comparable-有什么不同" class="headerlink" title="Comparator 与 Comparable 有什么不同"></a>Comparator 与 Comparable 有什么不同</h2><p>Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。</p>
<h2 id="Collection-和-Collections的区别"><a href="#Collection-和-Collections的区别" class="headerlink" title="Collection 和 Collections的区别"></a>Collection 和 Collections的区别</h2><p>Collection是集合类的上级接口，继承与他的接口主要有Set 和List.<br>Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</p>
<h2 id="线程同步的方法"><a href="#线程同步的方法" class="headerlink" title="线程同步的方法"></a>线程同步的方法</h2><p>wait():使一个线程处于等待状态，并且释放所持有的对象的lock。<br>sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。<br>notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。<br>Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。</p>
<h2 id="Volatile和Synchronized四个不同点"><a href="#Volatile和Synchronized四个不同点" class="headerlink" title="Volatile和Synchronized四个不同点"></a>Volatile和Synchronized四个不同点</h2><ol>
<li>粒度不同，前者锁对象和类，后者针对变量</li>
<li>syn阻塞，volatile线程不阻塞</li>
<li>syn保证三大特性，volatile不保证原子性</li>
<li>syn编译器优化，volatile不优化<br>volatile具备两种特性：<br>保证此变量对所有线程的可见性，指一条线程修改了这个变量的值，新值对于其他线程来说是可见的，但并不是多线程安全的。<br>禁止指令重排序优化。<br>Volatile如何保证内存可见性:<br>1.当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。<br>2.当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。<br>同步：就是一个任务的完成需要依赖另外一个任务，只有等待被依赖的任务完成后，依赖任务才能完成。<br>异步：不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，只要自己任务完成了就算完成了，被依赖的任务是否完成会通知回来。（异步的特点就是通知）。<br>打电话和发短信来比喻同步和异步操作。<br>阻塞：CPU停下来等一个慢的操作完成以后，才会接着完成其他的工作。<br>非阻塞：非阻塞就是在这个慢的执行时，CPU去做其他工作，等这个慢的完成后，CPU才会接着完成后续的操作。<br>非阻塞会造成线程切换增加，增加CPU的使用时间能不能补偿系统的切换成本需要考虑。</li>
</ol>
<h2 id="SpringMVC运行原理"><a href="#SpringMVC运行原理" class="headerlink" title="SpringMVC运行原理"></a>SpringMVC运行原理</h2><ol>
<li>客户端请求提交到DispatcherServlet</li>
<li>由DispatcherServlet控制器查询HandlerMapping，找到并分发到指定的Controller中。</li>
<li>Controller调用业务逻辑处理后，返回ModelAndView</li>
<li>DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图</li>
<li>视图负责将结果显示到客户端</li>
</ol>
<h2 id="SpringMVC与Struts2区别与比较总结"><a href="#SpringMVC与Struts2区别与比较总结" class="headerlink" title="SpringMVC与Struts2区别与比较总结"></a>SpringMVC与Struts2区别与比较总结</h2><p>1、Struts2是类级别的拦截， 一个类对应一个request上下文，SpringMVC是方法级别的拦截，一个方法对应一个request上下文，而方法同时又跟一个url对应,所以说从架构本身上SpringMVC就容易实现restful url,而struts2的架构实现起来要费劲，因为Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了。</p>
<p>2、由上边原因，SpringMVC的方法之间基本上独立的，独享request response数据，请求数据通过参数获取，处理结果通过ModelMap交回给框架，方法之间不共享变量，而Struts2搞的就比较乱，虽然方法之间也是独立的，但其所有Action变量是共享的，这不会影响程序运行，却给我们编码 读程序时带来麻烦，每次来了请求就创建一个Action，一个Action对象对应一个request上下文。<br>3、由于Struts2需要针对每个request进行封装，把request，session等servlet生命周期的变量封装成一个一个Map，供给每个Action使用，并保证线程安全，所以在原则上，是比较耗费内存的。</p>
<p>4、 拦截器实现机制上，Struts2有以自己的interceptor机制，SpringMVC用的是独立的AOP方式，这样导致Struts2的配置文件量还是比SpringMVC大。</p>
<p>5、SpringMVC的入口是servlet，而Struts2是filter（这里要指出，filter和servlet是不同的。以前认为filter是servlet的一种特殊），这就导致了二者的机制不同，这里就牵涉到servlet和filter的区别了。</p>
<p>6、SpringMVC集成了Ajax，使用非常方便，只需一个注解@ResponseBody就可以实现，然后直接返回响应文本即可，而Struts2拦截器集成了Ajax，在Action中处理时一般必须安装插件或者自己写代码集成进去，使用起来也相对不方便。</p>
<p>7、SpringMVC验证支持JSR303，处理起来相对更加灵活方便，而Struts2验证比较繁琐，感觉太烦乱。</p>
<p>8、Spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高（当然Struts2也可以通过不同的目录结构和相关配置做到SpringMVC一样的效果，但是需要xml配置的地方不少）。</p>
<p>9、 设计思想上，Struts2更加符合OOP的编程思想， SpringMVC就比较谨慎，在servlet上扩展。</p>
<p>10、SpringMVC开发效率和性能高于Struts2。<br>11、SpringMVC可以认为已经100%零配置。</p>
<h2 id="简单总结springMVC和struts2的区别"><a href="#简单总结springMVC和struts2的区别" class="headerlink" title="简单总结springMVC和struts2的区别"></a>简单总结springMVC和struts2的区别</h2><ol>
<li>springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过虑器。</li>
<li>springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。</li>
<li>Struts采用值栈存储请求和响应的数据，通过OGNL存取数据， springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。</li>
</ol>
<h2 id="SpringMvc怎么和AJAX相互调用的"><a href="#SpringMvc怎么和AJAX相互调用的" class="headerlink" title="SpringMvc怎么和AJAX相互调用的"></a>SpringMvc怎么和AJAX相互调用的</h2><p>通过Jackson框架就可以把Java里面的对象直接转化成Js可以识别的Json对象<br>具体步骤如下<br>1.加入Jackson.jar<br>2.在配置文件中配置json的映射<br>3.在接受Ajax方法里面可以直接返回Object,List等,但方法前面要加上@ResponseBody注解</p>
<h2 id="Spring有哪些优点"><a href="#Spring有哪些优点" class="headerlink" title="Spring有哪些优点"></a>Spring有哪些优点</h2><p>1.轻量级：Spring在大小和透明性方面绝对属于轻量级的，基础版本的Spring框架大约只有2MB。<br>2.控制反转(IOC)：Spring使用控制反转技术实现了松耦合。依赖被注入到对象，而不是创建或寻找依赖对象。<br>3.面向切面编程(AOP)： Spring支持面向切面编程，同时把应用的业务逻辑与系统的服务分离开来。<br>4.容器：Spring包含并管理应用程序对象的配置及生命周期。<br>5.MVC框架：Spring的web框架是一个设计优良的web MVC框架，很好的取代了一些web框架。<br>6.事务管理：Spring对下至本地业务上至全局业务(JAT)提供了统一的事务管理接口。<br>7.异常处理：Spring提供一个方便的API将特定技术的异常(由JDBC, Hibernate, 或JDO抛出)转化为一致的、Unchecked异常。</p>
<h2 id="spring-主要使用了哪些-，IOC和AOP实现原理是什么"><a href="#spring-主要使用了哪些-，IOC和AOP实现原理是什么" class="headerlink" title="spring 主要使用了哪些 ，IOC和AOP实现原理是什么"></a>spring 主要使用了哪些 ，IOC和AOP实现原理是什么</h2><p>spring主要功能有IOC，AOP，MVC等，IOC实现原理：先反射生成实例，然后调用时主动注入。AOP原理：主要使用java动态代理。</p>
<h2 id="解释AOP模块"><a href="#解释AOP模块" class="headerlink" title="解释AOP模块"></a>解释AOP模块</h2><p>AOP模块用来开发Spring应用程序中具有切面性质的部分。该模块的大部分服务由AOP Aliance提供，这就保证了Spring框架和其他AOP框架之间的互操作性。另外，该模块将元数据编程引入到了Spring。</p>
<h2 id="IoC容器是什么其优点"><a href="#IoC容器是什么其优点" class="headerlink" title="IoC容器是什么其优点"></a>IoC容器是什么其优点</h2><p>Spring IOC负责创建对象、管理对象(通过依赖注入)、整合对象、配置对象以及管理这些对象的生命周期。<br>优点:<br>IOC或依赖注入减少了应用程序的代码量。它使得应用程序的测试很简单，因为在单元测试中不再需要单例或JNDI查找机制。简单的实现以及较少的干扰机制使得松耦合得以实现。IOC容器支持勤性单例及延迟加载服务。</p>
<h2 id="Spring-的依赖注入方式有哪一些"><a href="#Spring-的依赖注入方式有哪一些" class="headerlink" title="Spring 的依赖注入方式有哪一些"></a>Spring 的依赖注入方式有哪一些</h2><p>Spring 的依赖注入可以有两种方式来完成:setter 方法注入和构造方法注入。<br>构造器依赖注入：构造器依赖注入在容器触发构造器的时候完成，该构造器有一系列的参数，每个参数代表注入的对象。<br>Setter方法依赖注入：首先容器会触发一个无参构造函数或无参静态工厂方法实例化对象，之后容器调用bean中的setter方法完成Setter方法依赖注入。</p>
<h2 id="Spring支持的事务管理类型"><a href="#Spring支持的事务管理类型" class="headerlink" title="Spring支持的事务管理类型"></a>Spring支持的事务管理类型</h2><p>Spring支持如下两种方式的事务管理：<br>编程式事务管理：这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。<br>声明式事务管理：这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者XML配置管理事务。</p>
<h2 id="ThreadLocal-线程变量副本"><a href="#ThreadLocal-线程变量副本" class="headerlink" title="ThreadLocal(线程变量副本)"></a>ThreadLocal(线程变量副本)</h2><p>Synchronized实现内存共享，ThreadLocal为每个线程维护一个本地变量。</p>
<p>采用空间换时间，它用于线程间的数据隔离，为每一个使用该变量的线程提供一个副本，每个线程都可以独立地改变自己的副本，而不会和其他线程的副本冲突。</p>
<p>ThreadLocal类中维护一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值为对应线程的变量副本。</p>
<p>ThreadLocal在Spring中发挥着巨大的作用，在管理Request作用域中的Bean、事务管理、任务调度、AOP等模块都出现了它的身影。</p>
<p>Spring中绝大部分Bean都可以声明成Singleton作用域，采用ThreadLocal进行封装，因此有状态的Bean就能够以singleton的方式在多线程中正常工作了。</p>
<h2 id="throw-和-throws-的区别"><a href="#throw-和-throws-的区别" class="headerlink" title="throw 和 throws 的区别"></a>throw 和 throws 的区别</h2><p>throw 用于抛出 java.lang.Throwable 类的一个实例化对象，意思是说你可以通过关键字 throw 抛出一个 Error 或者 一个Exception，如：</p>
<p>throw new IllegalArgumentException(“size must be multiple of 2″)</p>
<p>而throws 的作用是作为方法声明和签名的一部分，方法被抛出相应的异常以便调用者能处理。Java 中，任何未处理的受检查异常强制在 throws 子句中声明。</p>
<h2 id="final关键字的作用"><a href="#final关键字的作用" class="headerlink" title="final关键字的作用"></a>final关键字的作用</h2><p>final class    表示此类不允许有子类。<br>final virable  表示一个常量。<br>final method   表示一个方法不能被重写</p>
<h2 id="String是最基本的数据类型吗"><a href="#String是最基本的数据类型吗" class="headerlink" title="String是最基本的数据类型吗"></a>String是最基本的数据类型吗</h2><p>基本数据类型包括byte、int、char、long、float、double、boolean和short。java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类。</p>
<h2 id="synchronized和java-util-concurrent-locks-Lock的异同"><a href="#synchronized和java-util-concurrent-locks-Lock的异同" class="headerlink" title="synchronized和java.util.concurrent.locks.Lock的异同"></a>synchronized和java.util.concurrent.locks.Lock的异同</h2><p>主要相同点:<br>Lock能完成synchronized所实现的所有功能.(其它不重要)<br>主要不同点:<br>Lock有比synchronized更精确的线程语义和更好的性能(在相同点中回答此点也行)<br>synchronized会自动释放锁.而Lock一定要求程序员手工释放.并且必须在finally从句<br>中释放,如果没有答出在finally中释放不得分.就如Connection没有在finally中关闭一<br>样.连最基本的资源释放都做不好,还谈什么多线程编程.</p>
<h2 id="spring的事务有几种它的隔离级别和传播行为"><a href="#spring的事务有几种它的隔离级别和传播行为" class="headerlink" title="spring的事务有几种它的隔离级别和传播行为"></a>spring的事务有几种它的隔离级别和传播行为</h2><p>声明式事务和编程式事务<br>隔离级别：</p>
<ul>
<li>DEFAULT使用数据库默认的隔离级别</li>
<li>READ_UNCOMMITTED会出现脏读，不可重复读和幻影读问题</li>
<li>READ_COMMITTED会出现重复读和幻影读</li>
<li>REPEATABLE_READ会出现幻影读</li>
<li>SERIALIZABLE最安全，但是代价最大，性能影响极其严重<br>和传播行：</li>
<li>REQUIRED存在事务就融入该事务，不存在就创建事务</li>
<li>SUPPORTS存在事务就融入事务，不存在则不创建事务</li>
<li>MANDATORY存在事务则融入该事务，不存在，抛异常</li>
<li>REQUIRES_NEW总是创建新事务</li>
<li>NOT_SUPPORTED存在事务则挂起，一直执行非事务操作</li>
<li>NEVER总是执行非事务，如果当前存在事务则抛异常</li>
<li>NESTED嵌入式事务</li>
</ul>
<h2 id="sleep-和-wait-有什么区别"><a href="#sleep-和-wait-有什么区别" class="headerlink" title="sleep() 和 wait() 有什么区别"></a>sleep() 和 wait() 有什么区别</h2><p>最大区别是等待时wait会释放锁，而sleep会一直持有锁，wait通常用于线程时交互，sleep通常被用于暂停执行。</p>
<p>sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。<br>wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。</p>
<h2 id="多线程和同步有几种实现方法"><a href="#多线程和同步有几种实现方法" class="headerlink" title="多线程和同步有几种实现方法"></a>多线程和同步有几种实现方法</h2><p>多线程有两种实现方法，分别是继承Thread类与实现Runnable接口<br>同步的实现方面有两种，分别是synchronized,wait与notify</p>
<h2 id="启动一个线程是用run-还是start"><a href="#启动一个线程是用run-还是start" class="headerlink" title="启动一个线程是用run()还是start()"></a>启动一个线程是用run()还是start()</h2><p>启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行。run()方法可以产生必须退出的标志来停止一个线程。 </p>
<h2 id="final-finally-finalize的区别"><a href="#final-finally-finalize的区别" class="headerlink" title="final,finally,finalize的区别"></a>final,finally,finalize的区别</h2><p>final—修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载。<br>　　finally—再异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。<br>　　finalize—方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。 </p>
<h2 id="abstract-class和interface有什么区别"><a href="#abstract-class和interface有什么区别" class="headerlink" title="abstract class和interface有什么区别"></a>abstract class和interface有什么区别</h2><p>抽象类与接口的区别：<br>1.接口可以多重继承 ，抽象类不可以<br>2.接口定义方法，不给实现；而抽象类可以实现部分方法<br>3.接口中基本数据类型的数据成员，都默认为static和final，抽象类则不是<br>如果事先知道某种东西会成为基础类，那么第一个选择就是把它变成一个接口。<br>只有在必须使用方法定义或者成员变量的时候，才应考虑采用抽象类。</p>
<h2 id="Set里的元素不能重复，用-还是equals-判断"><a href="#Set里的元素不能重复，用-还是equals-判断" class="headerlink" title="Set里的元素不能重复，用==还是equals ()判断"></a>Set里的元素不能重复，用==还是equals ()判断</h2><p>Set里的元素是不能重复的，那么用iterator()方法来区分重复与否。equals()是判读两个Set是否相等。<br>equals()和==方法决定引用值是否指向同一对象equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。</p>
<h2 id="struts-框架是如何体现MVC模式"><a href="#struts-框架是如何体现MVC模式" class="headerlink" title="struts 框架是如何体现MVC模式"></a>struts 框架是如何体现MVC模式</h2><p>struts 框架为开发者提供了MVC 的3个逻辑组成部分，主要由ActionServlet、Action和strust-config.xml配置文件组成控制层，由ActionForm 来承担模型层的功能，而struts 下的视图由JSP来完成。<br>处理请求：由ActionServlet接收请求，然后根据 struts-config.xml 中的配置，类判断由于哪个Action来处理请求和由哪个ActionForm来保存数据，在通过Action的返回值来判断应该由哪个JSP来负责页面的展示，最后由 JSP 来完成结果响应。</p>
<h2 id="Hibernate-的实体存在哪几种状态"><a href="#Hibernate-的实体存在哪几种状态" class="headerlink" title="Hibernate 的实体存在哪几种状态"></a>Hibernate 的实体存在哪几种状态</h2><p>Hibernate 中的实体在它的生命周期里面，存在 3 中状态。<br>瞬时：new语句创建的实体类对象是就是瞬时状态，它一般没有id。<br>持久：存放在 Session 中的实体对象就属于持久状态，一般通过 save() 或 saveOrUpdate()等等，方法转换而来。<br>托管：实体中Session中脱离出来的时候，它的状态就属于托管状态了，尽管它具有 id 值，但已经不存在Session 中了，即使 实体中的数据发生变化也不能同步到数据库中。通过 close()、evict()等方法转化而来。</p>
<h2 id="Hibernate-的get-和load-的区别"><a href="#Hibernate-的get-和load-的区别" class="headerlink" title="Hibernate 的get()和load()的区别"></a>Hibernate 的get()和load()的区别</h2><p>Hibernate 对于 load() 方法该方法认为数据一定存在于数据，可以放心的代理来延迟加载，如果在使用过程中发现了问题，只能抛出异常，而get()方法可以不存在。</p>
<h2 id="为什么wait和notify方法要在同步块中调用"><a href="#为什么wait和notify方法要在同步块中调用" class="headerlink" title="为什么wait和notify方法要在同步块中调用"></a>为什么wait和notify方法要在同步块中调用</h2><p>主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。还有一个原因是为了避免wait和notify之间产生竞态条件。</p>
<h2 id="什么是ThreadLocal变量"><a href="#什么是ThreadLocal变量" class="headerlink" title="什么是ThreadLocal变量"></a>什么是ThreadLocal变量</h2><p>ThreadLocal是Java里一种特殊的变量。每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用ThreadLocal让SimpleDateFormat变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。线程局部变量的另一个不错的例子是ThreadLocalRandom类，它在多线程环境中减少了创建代价高昂的Random对象的个数。</p>
<h2 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h2><p>Java多线程中的死锁<br>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件：<br>互斥条件：一个资源每次只能被一个进程使用。<br>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。<br>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。<br>避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。</p>
<h2 id="Java中活锁和死锁有什么区别"><a href="#Java中活锁和死锁有什么区别" class="headerlink" title="Java中活锁和死锁有什么区别"></a>Java中活锁和死锁有什么区别</h2><p>这是上题的扩展，活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者进程的状态可以改变但是却不能继续执行。</p>
<h2 id="怎么检测一个线程是否拥有锁"><a href="#怎么检测一个线程是否拥有锁" class="headerlink" title="怎么检测一个线程是否拥有锁"></a>怎么检测一个线程是否拥有锁</h2><p>我一直不知道我们竟然可以检测一个线程是否拥有锁，直到我参加了一次电话面试。在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。</p>
<h2 id="Maven有哪些优点"><a href="#Maven有哪些优点" class="headerlink" title="Maven有哪些优点"></a>Maven有哪些优点</h2><p>优点如下：<br>简化了项目依赖管理：<br>易于上手，对于新手可能一个”mvn clean package”命令就可能满足他的工作<br>便于与持续集成工具（jenkins）整合<br>便于项目升级，无论是项目本身升级还是项目使用的依赖升级。<br>有助于多模块项目的开发，一个模块开发好后，发布到仓库，依赖该模块时可以直接从仓库更新，而不用自己去编译。<br>maven有很多插件，便于功能扩展，比如生产站点，自动发布版本等</p>
<h2 id="Maven常见的依赖范围有哪些"><a href="#Maven常见的依赖范围有哪些" class="headerlink" title="Maven常见的依赖范围有哪些"></a>Maven常见的依赖范围有哪些</h2><p>1.compile:编译依赖，默认的依赖方式，在编译（编译项目和编译测试用例），运行测试用例，运行（项目实际运行）三个阶段都有效，典型地有spring-core等jar。<br>2.test:测试依赖，只在编译测试用例和运行测试用例有效，典型地有JUnit。<br>provided:对于编译和测试有效，不会打包进发布包中，典型的例子为servlet-api,一般的web工程运行时都使用容器的servlet-api。<br>3.runtime:只在运行测试用例和实际运行时有效，典型地是jdbc驱动jar包。<br>4.system: 不从maven仓库获取该jar,而是通过systemPath指定该jar的路径。<br>5.import: 用于一个dependencyManagement对另一个dependencyManagement的继承。</p>
<h2 id="使用“Mvn-Clean-Package”进行项目打包-其过程执行了哪些动作"><a href="#使用“Mvn-Clean-Package”进行项目打包-其过程执行了哪些动作" class="headerlink" title="使用“Mvn Clean Package”进行项目打包,其过程执行了哪些动作"></a>使用“Mvn Clean Package”进行项目打包,其过程执行了哪些动作</h2><p>在这个命令中我们调用了maven的clean周期的clean阶段绑定的插件任务，以及default周期的package阶段绑定的插件任务<br>默认执行的任务有（maven的术语叫goal, 也有人翻译成目标，我这里用任务啦）：</p>
<p>maven-clean-plugin:clean-&gt;<br>maven-resources-plugin:resources-&gt;<br>maven-compile-plugin:compile-&gt;<br>mavne-resources-plugin:testResources-&gt;<br>maven-compile-plugin:testCompile-&gt;<br>maven-jar-plugin:jar</p>
<h2 id="Maven-多模块如何聚合"><a href="#Maven-多模块如何聚合" class="headerlink" title="Maven 多模块如何聚合"></a>Maven 多模块如何聚合</h2><p>配置一个打包类型为pom的聚合模块，然后在该pom中使用<module>元素声明要聚合的模块</module></p>
<h2 id="缓存框架memcache和redis的区别？项目中，怎么去选择？"><a href="#缓存框架memcache和redis的区别？项目中，怎么去选择？" class="headerlink" title="缓存框架memcache和redis的区别？项目中，怎么去选择？"></a>缓存框架memcache和redis的区别？项目中，怎么去选择？</h2><p>ehcache,memcache和redis等。</p>
<p>区别：</p>
<ol>
<li>Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等。</li>
<li>Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储。</li>
<li>虚拟内存–Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘。</li>
<li>过期策略–memcache在set时就指定，例如set key1 0 0 8,即永不过期。Redis可以通 过例如expire 设定，例如expire name 10。</li>
<li>分布式–设定memcache集群，利用magent做一主多从;redis可以做一主多从。都 可以一主一从。</li>
<li>存储数据安全–memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）。</li>
<li>灾难恢复–memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复。</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份。</li>
</ol>
<h2 id="java的原子类，实现原理是什么"><a href="#java的原子类，实现原理是什么" class="headerlink" title="java的原子类，实现原理是什么"></a>java的原子类，实现原理是什么</h2><p>采用硬件提供原子操作指令实现的，即CAS。每次调用都会先判断预期的值是否符合，才进行写操作，保证数据安全。</p>
<h2 id="数据库性能优化有哪些方法"><a href="#数据库性能优化有哪些方法" class="headerlink" title="数据库性能优化有哪些方法"></a>数据库性能优化有哪些方法</h2><p>使用explain进行优化，查看sql是否充分使用索引。避免使用in,用exist替代，字段值尽可能使用更小的值，任何对列的操作都将导致表扫描，它包括数据库函数、计算表达式等等，查询时要尽可能将操作移至等号右边。使用连接查询(join)代替子查询。</p>
<p>在表的多列字段上建立一个索引，但只有在查询这些字段的第一个字段时，索引才会被使用。</p>
<h2 id="HTTP请求方法get和post有什么区别"><a href="#HTTP请求方法get和post有什么区别" class="headerlink" title="HTTP请求方法get和post有什么区别"></a>HTTP请求方法get和post有什么区别</h2><ol>
<li>Post传输数据时，不需要在URL中显示出来，而Get方法要在URL中显示。</li>
<li>Post传输的数据量大，可以达到2M，而Get方法由于受到URL长度限制,只能传递大约1024字节.</li>
<li>Post就是为了将数据传送到服务器段,Get就是为了从服务器段取得数据.而Get之所以也能传送数据,只是用来设计告诉服务器,你到底需要什么样的数据.Post的信息作为http请求的内容，而Get是在Http头部传输的。</li>
<li>其他 HTTP 请求方法</li>
</ol>
<ul>
<li>HEAD 与 GET 相同，但只返回 HTTP 报头，不返回文档主体。</li>
<li>PUT上传指定的 URI 表示。<br> DELETE    删除指定资源。</li>
<li>OPTIONS 返回服务器支持的 HTTP 方法</li>
<li>CONNECT 把请求连接转换到透明的 TCP/IP 通道。</li>
</ul>
<h2 id="linux命令，查看某个线程，整个机器负载和文件内容快速查找的命令"><a href="#linux命令，查看某个线程，整个机器负载和文件内容快速查找的命令" class="headerlink" title="linux命令，查看某个线程，整个机器负载和文件内容快速查找的命令"></a>linux命令，查看某个线程，整个机器负载和文件内容快速查找的命令</h2><p>查看线程：ps -ef|greptomcat</p>
<p>查看负载：top</p>
<p>文件内容查找：vi  /aa test.txt 或者先打开文件，再查找: vi test.txt   /aa</p>
<h2 id="JVM内存的模型，垃圾回收的机制，如何对JVM进行调优"><a href="#JVM内存的模型，垃圾回收的机制，如何对JVM进行调优" class="headerlink" title="JVM内存的模型，垃圾回收的机制，如何对JVM进行调优"></a>JVM内存的模型，垃圾回收的机制，如何对JVM进行调优</h2><p>由栈和堆组成，栈是运行时单位，堆内存则分为年轻代、年老代、持久代等，年轻代中的对象经过几次的回收，仍然存在则被移到年老代；持久代主要是保存class,method,filed等对象。</p>
<p>sun回收机制：主要对年轻代和年老代中的存活对象进行回收，分为以下：</p>
<p>年轻代串行（Serial Copying）、年轻代并行（ParNew）、年老代串行（SerialMSC），年老代并行（Parallel Mark Sweep），年老代并发（Concurrent Mark-Sweep GC，即CMS）等等,目前CMS回收算法使用最广泛。</p>
<p>JVM调优主要是对堆内容和回收算法进行配置，需要对jdk产生的回收日志进行观察，同时通过工具（Jconsole，jProfile，VisualVM）对堆内存不断分析，这些优化是一个过程，需要不断地进行观察和维护。</p>
<h2 id="高并发时，又如何保证性能和数据正确"><a href="#高并发时，又如何保证性能和数据正确" class="headerlink" title="高并发时，又如何保证性能和数据正确"></a>高并发时，又如何保证性能和数据正确</h2><p>如果是单机内完成这些操作，那使用数据库的事务，即可轻松实现。</p>
<h2 id="分布式事务如何实现"><a href="#分布式事务如何实现" class="headerlink" title="分布式事务如何实现"></a>分布式事务如何实现</h2><p>分布式事务可以采用分布式锁进行实现，目前zookeeper就提供此锁；分布式锁需要牺牲一定性能去实现，若业务支付最终一致性，那此方法是最佳方案。如在京东下订单，过一会才会告诉你订单审核通过，而不是马上响应订单结果。</p>
<h2 id="抽象类和接口的区别，项目中如何使用它们"><a href="#抽象类和接口的区别，项目中如何使用它们" class="headerlink" title="抽象类和接口的区别，项目中如何使用它们"></a>抽象类和接口的区别，项目中如何使用它们</h2><p> 相同点：</p>
<ol>
<li>两者都是抽象类，都不能实例化。</li>
<li>interface实现类及abstractclass的子类都必须要实现已经声明的抽象方法。</li>
</ol>
<p>不同点：</p>
<ol>
<li>interface需要实现，要用implements，而abstractclass需要继承，要用extends。</li>
<li>一个类可以实现多个interface，但一个类只能继承一个abstractclass。</li>
<li>interface强调特定功能的实现，而abstractclass强调所属关系。</li>
<li>尽管interface实现类及abstrctclass的子类都必须要实现相应的抽象方法，但实现的形式不同。interface中的每一个方法都是抽象方法，都只是声明的 (declaration, 没有方法体)，实现类必须要实现。而abstractclass的子类可以有选择地实现。</li>
</ol>
<p>使用：</p>
<ol>
<li>abstract：在既需要统一的接口，又需要实例变量或缺省的方法的情况下，使用abstract;</li>
<li>​ interface：类与类之前需要特定的接口进行协调，而不在乎其如何实现。 作为能够实现特定功能的标识存在，也可以是什么接口方法都没有的纯粹标识。需要将一组类视为单一的类，而调用者只通过接口来与这组类发生联系。需要实现特定的多项功能，而这些功能之间可能完全没有任何联系。        </li>
</ol>
<h2 id="TCP通讯有几次握手，有使用过哪些socket框架"><a href="#TCP通讯有几次握手，有使用过哪些socket框架" class="headerlink" title="TCP通讯有几次握手，有使用过哪些socket框架"></a>TCP通讯有几次握手，有使用过哪些socket框架</h2><p>​         3次握手，客户端–&gt;服务端，服务端–&gt;客户端，客户端–&gt;服务端，当这些过程完成之后，才真正建立起通信。java中比较有名的socket框架有：mina,netty,都是韩国小棒子写的。</p>
<h2 id="java反射机制，反射生成类，可否访问私有变量"><a href="#java反射机制，反射生成类，可否访问私有变量" class="headerlink" title="java反射机制，反射生成类，可否访问私有变量"></a>java反射机制，反射生成类，可否访问私有变量</h2><p>​       即动态生成java的实例，可以。</p>
<p>Java反射机制是一个非常强大的功能，在很多的项目比如Spring，Mybatis都都可以看到反射的身影。通过反射机制，我们可以在运行期间获取对象的类型信息。利用这一点我们可以实现工厂模式和代理模式等设计模式，同时也可以解决java泛型擦除等令人苦恼的问题。</p>
<p>获取一个对象对应的反射类，在Java中有三种方法可以获取一个对象的反射类，</p>
<ul>
<li>通过getClass()方法</li>
<li>通过Class.forName()方法</li>
<li>使用类.class</li>
<li>通过类加载器实现，getClassLoader()</li>
</ul>
<h2 id="RPC是什么，有使用过哪些RPC框架"><a href="#RPC是什么，有使用过哪些RPC框架" class="headerlink" title="RPC是什么，有使用过哪些RPC框架"></a>RPC是什么，有使用过哪些RPC框架</h2><p>​     远程进程调用，本地机器调用远程的服务，在项目规模大到一定程度，需要使用RPC相关框架进行服务化部署。如：hessian 、webservice等</p>
<h2 id="jquery如何绑定页面某元素的点击事件"><a href="#jquery如何绑定页面某元素的点击事件" class="headerlink" title="jquery如何绑定页面某元素的点击事件"></a>jquery如何绑定页面某元素的点击事件</h2><p>​    $(“#btn”).click(function(){ …. })</p>
<h2 id="volatile实现原理"><a href="#volatile实现原理" class="headerlink" title="volatile实现原理"></a>volatile实现原理</h2><p>volatile如何保证可见性和禁止指令重排序的：</p>
<p>观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令，lock前缀指令实际上相当于一个 <strong>内存屏障</strong>（也成内存栅栏），内存屏障会提供3个功能：</p>
<ul>
<li><p>它 <strong>确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面</strong>；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p>
</li>
<li><p>它会 强制将对缓存的修改操作立即写入主存；</p>
</li>
<li><p>如果是写操作，它会导致其他CPU中对应的缓存行无效。</p>
</li>
</ul>
<h2 id="session-与-cookie-区别"><a href="#session-与-cookie-区别" class="headerlink" title="session 与 cookie 区别"></a>session 与 cookie 区别</h2><ol>
<li>cookie数据存放在客户的浏览器上，session数据放在服务器上。</li>
<li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。</li>
<li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。</li>
<li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li>
<li>所以个人建议： 将登陆信息等重要信息存放为SESSION 其他信息如果需要保留，可以放在COOKIE中</li>
</ol>
<h2 id="session-分布式处理"><a href="#session-分布式处理" class="headerlink" title="session 分布式处理"></a>session 分布式处理</h2><p>第一种：粘性session</p>
<p>粘性Session是指将用户锁定到某一个服务器上，比如上面说的例子，用户第一次请求时，负载均衡器将用户的请求转发到了A服务器上，如果负载均衡器设置了粘性Session的话，那么用户以后的每次请求都会转发到A服务器上，相当于把用户和A服务器粘到了一块，这就是粘性Session机制。</p>
<p>第二种：服务器session复制</p>
<p>原理：任何一个服务器上的session发生改变（增删改），该节点会把这个 session的所有内容序列化，然后广播给所有其它节点，不管其他服务器需不需要session，以此来保证Session同步。</p>
<p>第三种：session共享机制</p>
<p>使用分布式缓存方案比如memcached、Redis，但是要求Memcached或Redis必须是集群。</p>
<p>原理：不同的 tomcat指定访问不同的主memcached。多个Memcached之间信息是同步的，能主从备份和高可用。用户访问时首先在tomcat中创建session，然后将session复制一份放到它对应的memcahed上</p>
<p>第四种：session持久化到数据库</p>
<p>原理：就不用多说了吧，拿出一个数据库，专门用来存储session信息。保证session的持久化。 优点：服务器出现问题，session不会丢失 缺点：如果网站的访问量很大，把session存储到数据库中，会对数据库造成很大压力，还需要增加额外的开销维护数据库。</p>
<p>第五种terracotta实现session复制</p>
<p>原理：就不用多说了吧，拿出一个数据库，专门用来存储session信息。保证session的持久化。 优点：服务器出现问题，session不会丢失 缺点：如果网站的访问量很大，把session存储到数据库中，会对数据库造成很大压力，还需要增加额外的开销维护数据库。</p>
<h2 id="说说自定义注解的场景及实现"><a href="#说说自定义注解的场景及实现" class="headerlink" title="说说自定义注解的场景及实现"></a>说说自定义注解的场景及实现</h2><p>跟踪代码的依赖性，实现代替配置文件的功能。比较常见的是Spring等框架中的基于注解配置。</p>
<p>还可以生成文档常见的@See@param@return等。如@override放在方法签名，如果这个方法 并不是覆盖了超类方法，则编译时就能检查出。</p>
<p>使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节，在定义注解时，不能继承其他注解或接口。</p>
<h2 id="HashSet-和-HashMap-区别"><a href="#HashSet-和-HashMap-区别" class="headerlink" title="HashSet 和 HashMap 区别"></a>HashSet 和 HashMap 区别</h2><p> <strong>HashSet：</strong></p>
<p>HashSet实现了Set接口，它不允许集合中出现重复元素。当我们提到HashSet时，第一件事就是在将对象存储在</p>
<p>HashSet之前，要确保重写hashCode（）方法和equals（）方法，这样才能比较对象的值是否相等，确保集合中没有储存相同的对象。如果不重写上述两个方法，那么将使用下面方法默认实现：</p>
<p>public boolean add(Object obj)方法用在Set添加元素时，如果元素值重复时返回 “false”，如果添加成功则返回”true”</p>
<p><strong>HashMap：</strong></p>
<p>HashMap实现了Map接口，Map接口对键值对进行映射。Map中不允许出现重复的键（Key）。Map接口有两个基本的实现TreeMap和HashMap。TreeMap保存了对象的排列次序，而HashMap不能。HashMap可以有空的键值对（Key（null）-Value（null））HashMap是非线程安全的（非Synchronize），要想实现线程安全，那么需要调用collections类的静态方法synchronizeMap（）实现。</p>
<p>public Object put(Object Key,Object value)方法用来将元素添加到map中。</p>
<p>总结：</p>
<p>HashMap 实现了 Map 接口；存储键值对；调用put（）向map中添加元素；HashMap使用键（Key）计算Hashcode；HashMap相对于HashSet较快，因为它是使用唯一的键获取对象。</p>
<p>HashSet 实现了 Set 接口；仅存储对象；调用add（）方法向Set中添加元素；HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false；HashSet较HashMap来说比较慢。</p>
<h2 id="HashMap-的工作原理及代码实现"><a href="#HashMap-的工作原理及代码实现" class="headerlink" title="HashMap 的工作原理及代码实现"></a>HashMap 的工作原理及代码实现</h2><ol>
<li>HashMap是基于哈希表的Map接口的非同步实现，允许使用null值和null键，但不保证映射的顺序。</li>
<li>底层使用数组实现，数组中每一项是个单向链表，即数组和链表的结合体；当链表长度大于一定阈值时，链表转换为红黑树，这样减少链表查询时间。</li>
<li>HashMap在底层将key-value当成一个整体进行处理，这个整体就是一个Node对象。HashMap底层采用一个Node[]数组来保存所有的key-value对，当需要存储一个Node对象时，会根据key的hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Node时，也会根据key的hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Node。</li>
<li>HashMap进行数组扩容需要重新计算扩容后每个元素在数组中的位置，很耗性能</li>
<li>采用了Fail-Fast机制，通过一个modCount值记录修改次数，对HashMap内容的修改都将增加这个值。迭代器初始化过程中会将这个值赋给迭代器的expectedModCount，在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map，马上抛出异常</li>
</ol>
<h2 id="ConcurrentHashMap-的工作原理及代码实现"><a href="#ConcurrentHashMap-的工作原理及代码实现" class="headerlink" title="ConcurrentHashMap 的工作原理及代码实现"></a>ConcurrentHashMap 的工作原理及代码实现</h2><ol>
<li>ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。</li>
<li>它使用了多个锁来控制对hash表的不同段进行的修改，每个段其实就是一个小的hashtable，它们有自己的锁。只要多个并发发生在不同的段上，它们就可以并发进行。</li>
<li>ConcurrentHashMap在底层将key-value当成一个整体进行处理，这个整体就是一个Entry对象。Hashtable底层采用一个Entry[]数组来保存所有的key-value对，当需要存储一个Entry对象时，会根据key的hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据key的hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。</li>
<li>与HashMap不同的是，ConcurrentHashMap使用多个子Hash表，也就是段(Segment)</li>
<li>ConcurrentHashMap完全允许多个读操作并发进行，读操作并不需要加锁。如果使用传统的技术，如HashMap中的实现，如果允许可以在hash链的中间添加或删除元素，读操作不加锁将得到不一致的数据。ConcurrentHashMap实现技术是保证HashEntry几乎是不可变的。</li>
</ol>
<h2 id="ThreadLocal-原理分析"><a href="#ThreadLocal-原理分析" class="headerlink" title="ThreadLocal 原理分析"></a>ThreadLocal 原理分析</h2><p>ThreadLocal 为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。当使用 ThreadLocal 维护变量时，ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p>
<p>每个线程中都保有一个 ThreadLocalMap 的成员变量，ThreadLocalMap 内部采用 WeakReference 数组保存，数组的key即为 ThreadLocal 内部的Hash值。</p>
<h2 id="创建线程的方式及实现"><a href="#创建线程的方式及实现" class="headerlink" title="创建线程的方式及实现"></a>创建线程的方式及实现</h2><p>Java使用Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。Java可以用三种方式来创建线程，如下所示：</p>
<ol>
<li>继承Thread类创建线程</li>
<li>实现Runnable接口创建线程</li>
<li><p>使用Callable和Future创建线程</p>
<p><strong>继承Thread类创建线程</strong></p>
</li>
</ol>
<p>通过继承Thread类来创建并启动多线程的一般步骤如下</p>
<p>1】d定义Thread类的子类，并重写该类的<strong>run()</strong>方法，该方法的方法体就是线程需要完成的任务，run()方法也称为线程执行体。</p>
<p>2】创建Thread子类的实例，也就是创建了线程对象</p>
<p>3】启动线程，即调用线程的<strong>start()</strong>方法</p>
<p>代码实例</p>
<p>public class MyThread extends Thread{//继承Thread类</p>
<p>　　public void run(){</p>
<p>　　//重写run方法</p>
<p>　　}</p>
<p>}</p>
<p>public class Main {</p>
<p>　　public static void main(String[] args){</p>
<p>　　　　new MyThread().start();//创建并启动线程</p>
<p>　　}</p>
<p>}</p>
<p><strong>实现Runnable接口创建线程</strong></p>
<p>通过实现Runnable接口创建并启动线程一般步骤如下：</p>
<p>1】定义Runnable接口的实现类，一样要重写run()方法，这个run（）方法和Thread中的run()方法一样是线程的执行体</p>
<p>2】创建Runnable实现类的实例，并用这个实例作为Thread的target来创建Thread对象，这个Thread对象才是真正的线程对象</p>
<p>3】第三部依然是通过调用线程对象的start()方法来启动线程</p>
<p>代码实例：</p>
<p>public class MyThread2 implements Runnable {//实现Runnable接口</p>
<p>　　public void run(){</p>
<p>　　//重写run方法</p>
<p>　　}</p>
<p>}</p>
<p>public class Main {</p>
<p>　　public static void main(String[] args){</p>
<p>　　　　//创建并启动线程</p>
<p>　　　　MyThread2 myThread=new MyThread2();</p>
<p>　　　　Thread thread=new Thread(myThread);</p>
<p>　　　　thread().start();</p>
<p>　　　　//或者    new Thread(new MyThread2()).start();</p>
<p>　　}</p>
<p>}</p>
<p><strong>使用Callable和Future创建线程</strong></p>
<p>和Runnable接口不一样，Callable接口提供了一个call（）方法作为线程执行体，call()方法比run()方法<em>**</em>功能要强大。</p>
<p>》call()方法可以有返回值</p>
<p>》call()方法可以声明抛出异常</p>
<p>Java5提供了Future接口来代表Callable接口里call()方法的返回值，并且为Future接口提供了一个实现类FutureTask，这个实现类既实现了Future接口，还实现了Runnable接口，因此可以作为Thread类的target。在Future接口里定义了几个公共方法来控制它关联的Callable任务。</p>
<p>>boolean cancel(boolean mayInterruptIfRunning)：视图取消该Future里面关联的Callable任务</p>
<p>>V get()：返回Callable里call（）方法的返回值，调用这个方法会导致程序阻塞，必须等到子线程结束后才会得到返回值</p>
<p>>V get(long timeout,TimeUnit unit)：返回Callable里call（）方法的返回值，最多阻塞timeout时间，经过指定时间没有返回抛出TimeoutException</p>
<p>>boolean isDone()：若Callable任务完成，返回True</p>
<p>>boolean isCancelled()：如果在Callable任务正常完成前被取消，返回True</p>
<p>介绍了相关的概念之后，创建并启动有返回值的线程的步骤如下：</p>
<p>1】创建Callable接口的实现类，并实现call()方法，然后创建该实现类的实例（从java8开始可以直接使用Lambda表达式创建Callable对象）。</p>
<p>2】使用FutureTask类来包装Callable对象，该FutureTask对象封装了Callable对象的call()方法的返回值</p>
<p>3】使用FutureTask对象作为Thread对象的target创建并启动线程（因为FutureTask实现了Runnable接口）</p>
<p>4】调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p>
<p>代码实例：</p>
<p>public class Main {</p>
<p>　　public static void main(String[] args){</p>
<p>　　　MyThread3 th=new MyThread3();</p>
<p>　　　//使用Lambda表达式创建Callable对象</p>
<p>　　   //使用FutureTask类来包装Callable对象</p>
<p>　　　FutureTask<integer> future=new FutureTask<integer>(</integer></integer></p>
<p>　　　　(Callable<integer>)()-&gt;{</integer></p>
<p>　　　　　　return 5;</p>
<p>　　　　}</p>
<p>　　  );</p>
<p>　　　new Thread(task,”有返回值的线程”).start();//实质上还是以Callable对象来创建并启动线程</p>
<p>　　  try{</p>
<p>　　　　System.out.println(“子线程的返回值：”+future.get());//get()方法会阻塞，直到子线程执行结束才返回</p>
<p> 　　 }catch(Exception e){</p>
<p>　　　　ex.printStackTrace();</p>
<p>　　　}</p>
<p>　　}</p>
<p>}</p>
<p><strong>————————————–三种创建线程方法对比————————————–</strong></p>
<p>实现Runnable和实现Callable接口的方式基本相同，不过是后者执行call()方法有返回值，后者线程执行体run()方法无返回值，因此可以把这两种方式归为一种这种方式与继承Thread类的方法之间的差别如下：</p>
<p>1、线程只是实现Runnable或实现Callable接口，还可以继承其他类。</p>
<p>2、这种方式下，多个线程可以共享一个target对象，非常适合多线程处理同一份资源的情形。</p>
<p>3、但是编程稍微复杂，如果需要访问当前线程，必须调用Thread.currentThread()方法。</p>
<p>4、继承Thread类的线程类不能再继承其他父类（Java单继承决定）。</p>
<p>注：一般推荐采用实现接口的方式来创建多线程</p>
<h2 id="sleep-、join（）、yield（）有什么区别"><a href="#sleep-、join（）、yield（）有什么区别" class="headerlink" title="sleep() 、join（）、yield（）有什么区别"></a>sleep() 、join（）、yield（）有什么区别</h2><p>sleep():方法导致了程序暂停执行指定的时间，让出cpu给其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态，但不会释放“锁标志”，不推荐使用。</p>
<p>wait():在其他线程调用对象的notify或notifyAll方法前，导致当前线程等待。线程会释放掉它所占有的“锁标志”，从而使别的线程有机会抢占该锁。</p>
<p>yield():暂停当前正在执行的线程对象。yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。yield()只能使同优先级或更高优先级的线程有执行的机会。</p>
<p>join():等待调用join方法的线程结束，再继续执行。</p>
<p>sleep是针对于thread对象，wait是针对于Object对象。</p>
<h2 id="ConcurrentHashMap如何保证线程安全"><a href="#ConcurrentHashMap如何保证线程安全" class="headerlink" title="ConcurrentHashMap如何保证线程安全"></a>ConcurrentHashMap如何保证线程安全</h2><p>JDK 1.7及以前：</p>
<p>ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对hash表的不同部分进行的修改。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。</p>
<p>JDK 1.8：</p>
<p>Segment虽保留，但已经简化属性，仅仅是为了兼容旧版本。</p>
<p>插入时使用CAS算法：unsafe.compareAndSwapInt(this, valueOffset, expect, update)。 CAS(Compare And Swap)意思是如果valueOffset位置包含的值与expect值相同，则更新valueOffset位置的值为update，并返回true，否则不更新，返回false。插入时不允许key或value为null</p>
<p>与Java8的HashMap有相通之处，底层依然由“数组”+链表+红黑树；</p>
<p>底层结构存放的是TreeBin对象，而不是TreeNode对象；</p>
<p>CAS作为知名无锁算法，那ConcurrentHashMap就没用锁了么？当然不是，当hash值与链表的头结点相同还是会synchronized上锁，锁链表。</p>
<h2 id="new与newInstance-的区别"><a href="#new与newInstance-的区别" class="headerlink" title="new与newInstance()的区别"></a>new与newInstance()的区别</h2><ul>
<li>new是一个关键字，它是调用new指令创建一个对象，然后调用构造方法来初始化这个对象，可以使用带参数的构造器</li>
<li>newInstance()是Class的一个方法，在这个过程中，是先取了这个类的不带参数的构造器Constructor，然后调用构造器的newInstance方法来创建对象。</li>
<li>Class.newInstance不能带参数，如果要带参数需要取得对应的构造器，然后调用该构造器的Constructor.newInstance(Object … initargs)方法</li>
</ul>
<h2 id="JDK中用到的设计模式"><a href="#JDK中用到的设计模式" class="headerlink" title="JDK中用到的设计模式"></a>JDK中用到的设计模式</h2><ul>
<li>装饰模式：java.io</li>
<li>单例模式：Runtime类</li>
<li>简单工厂模式：Integer.valueOf方法</li>
<li>享元模式：String常量池、Integer.valueOf(int i)、Character.valueOf(char c)</li>
<li>迭代器模式：Iterator</li>
<li>职责链模式：ClassLoader的双亲委派模型</li>
<li>解释器模式：正则表达式java.util.regex.Pattern</li>
</ul>
<h2 id="hashCode-amp-amp-equals"><a href="#hashCode-amp-amp-equals" class="headerlink" title="hashCode() &amp;&amp; equals()"></a>hashCode() &amp;&amp; equals()</h2><p><code>hashcode()</code> 返回该对象的哈希码值，支持该方法是为哈希表提供一些优点，例如，<code>java.util.Hashtable</code> 提供的哈希表。</p>
<p>在 Java 应用程序执行期间，在同一对象上多次调用 <code>hashCode</code> 方法时，必须一致地返回相同的整数，前提是对象上 <code>equals</code> 比较中所用的信息没有被修改（<code>equals</code>默认返回对象地址是否相等）。如果根据 <code>equals(Object)</code>方法，两个对象是相等的，那么在两个对象中的每个对象上调用 <code>hashCode</code> 方法都必须生成相同的整数结果。</p>
<p>以下情况不是必需的：如果根据 <code>equals(java.lang.Object)</code> 方法，两个对象不相等，那么在两个对象中的任一对象上调用 <code>hashCode</code> 方法必定会生成不同的整数结果。但是，<strong>程序员应该知道，为不相等的对象生成不同整数结果可以提高哈希表的性能</strong>。</p>
<p>实际上，由 <code>Object</code> 类定义的 <code>hashCode</code> 方法确实会针对不同的对象返回不同的整数。（<strong>这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧I</strong>。）</p>
<ul>
<li><strong>hashCode的存在主要是用于查找的快捷性</strong>，如 Hashtable，HashMap等，hashCode 是用来在散列存储结构中确定对象的存储地址的；</li>
<li>如果两个对象相同，就是适用于 <code>equals(java.lang.Object)</code> 方法，那么这两个对象的 <code>hashCode</code> 一定要相同；</li>
<li>如果对象的 <code>equals</code> 方法被重写，那么对象的 <code>hashCode</code> 也尽量重写，并且产生 <code>hashCode</code>使用的对象，一定要和 <code>equals</code> 方法中使用的一致，否则就会违反上面提到的第2点；</li>
<li><strong>两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里”</strong>。</li>
</ul>
<h2 id="Object类的finalize方法的实现原理"><a href="#Object类的finalize方法的实现原理" class="headerlink" title="Object类的finalize方法的实现原理"></a>Object类的finalize方法的实现原理</h2><p>Object 类提供的实现不Finalize方法和垃圾回收器将派生的类型不标记Object终止除非它们将覆盖Finalize方法。</p>
<p>如果类型未重写Finalize方法，则垃圾回收器会将类型的每个实例的条目添加到调用终止队列中的内部结构。 终止队列中包含垃圾回收器才能回收其内存之前，必须运行其终止代码托管堆中的所有对象的条目。 然后，垃圾回收器调用Finalize在以下情况下自动的方法︰</p>
<ul>
<li>垃圾回收器发现，一个对象不可访问，除非您通过调用从终止豁免已对象后 GC.SuppressFinalize 方法。</li>
<li>在关闭应用程序域中，除非该对象是免于终止的对象。 在关闭期间，终止甚至仍是可访问的对象。</li>
</ul>
<p>Finalize将自动调用一次在给定实例中，除非的对象重新注册通过使用一种机制，如GC.ReRegisterForFinalize和GC.SuppressFinalize尚未随后调用方法。</p>
<p>Finalize操作具有以下限制︰</p>
<ul>
<li>终结器执行时的确切时间不确定。 若要确保确定性释放资源，对你的类的实例实现<strong>Close</strong>方法，或者提供IDisposable.Dispose实现。</li>
<li>两个对象的终结器不保证任何特定顺序运行即使另一个对象引用。 也就是说，如果对象 A 具有对对象 B 的引用，并且二者的终结器，对象 B 可能已经被终结的对象 A 终结器启动时。</li>
<li>终结器运行的线程未指定。</li>
</ul>
<p>Finalize方法可能无法运行完成，或可能根本不运行下列异常情况下︰</p>
<ul>
<li>如果另一个终结器会无限期阻止 （进入无限循环，尝试获取的锁，它可以永远不会获取，等等）。 运行时尝试运行终结器来完成，因为其他终结器可能不会调用终结器块如果无限期。</li>
<li>如果不提供机会清理的运行时，进程将终止。 在这种情况下，运行时的第一个通知的进程是终止的一个 DLL_PROCESS_DETACH 通知。</li>
</ul>
<p>运行时将继续完成在关闭过程的对象，仅当可终结对象数目继续减少。</p>
<p>如果Finalize或的重写Finalize引发异常，并且运行时不承载的应用程序将替代默认策略，运行时终止进程，且无活动<strong>try</strong>/<strong>finally</strong>执行块或终结器。如果终结器无法释放或销毁资源，则此行为确保处理完整性。</p>
<p><strong>实施者注意事项</strong></p>
<p>应重写Finalize类使用非托管的资源，如文件句柄或数据库必须在垃圾回收期间放弃使用它们的托管的对象时释放的连接。</p>
<h2 id="Finalizer对象什么时候会在引用队列中"><a href="#Finalizer对象什么时候会在引用队列中" class="headerlink" title="Finalizer对象什么时候会在引用队列中"></a>Finalizer对象什么时候会在引用队列中</h2><h2 id="CountDownLatch-原理"><a href="#CountDownLatch-原理" class="headerlink" title="CountDownLatch 原理"></a>CountDownLatch 原理</h2><h2 id="CyclicBarrier-原理"><a href="#CyclicBarrier-原理" class="headerlink" title="CyclicBarrier 原理"></a>CyclicBarrier 原理</h2><h2 id="Semaphore-原理"><a href="#Semaphore-原理" class="headerlink" title="Semaphore 原理"></a>Semaphore 原理</h2><h2 id="Exchanger-原理"><a href="#Exchanger-原理" class="headerlink" title="Exchanger 原理"></a>Exchanger 原理</h2><h2 id="CountDownLatch-与-CyclicBarrier-区别"><a href="#CountDownLatch-与-CyclicBarrier-区别" class="headerlink" title="CountDownLatch 与 CyclicBarrier 区别"></a>CountDownLatch 与 CyclicBarrier 区别</h2><h2 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h2><h2 id="线程池的几种方式"><a href="#线程池的几种方式" class="headerlink" title="线程池的几种方式"></a>线程池的几种方式</h2><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><h2 id="说说线程安全问题"><a href="#说说线程安全问题" class="headerlink" title="说说线程安全问题"></a>说说线程安全问题</h2><h2 id="synchronize-实现原理"><a href="#synchronize-实现原理" class="headerlink" title="synchronize 实现原理"></a>synchronize 实现原理</h2><h2 id="synchronized-与-lock-的区别"><a href="#synchronized-与-lock-的区别" class="headerlink" title="synchronized 与 lock 的区别"></a>synchronized 与 lock 的区别</h2><h2 id="CAS-乐观锁"><a href="#CAS-乐观锁" class="headerlink" title="CAS 乐观锁"></a>CAS 乐观锁</h2><h2 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h2><h2 id="乐观锁的业务场景及实现方式"><a href="#乐观锁的业务场景及实现方式" class="headerlink" title="乐观锁的业务场景及实现方式"></a>乐观锁的业务场景及实现方式</h2><p>​                                                                                                   </p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="ShenWenFang 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="ShenWenFang 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/基础面试题/" rel="tag"># 基础面试题</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/01/15/Python 的基本要素/" rel="next" title="Python 的基本要素">
                <i class="fa fa-chevron-left"></i> Python 的基本要素
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/05/ConcurrentHashMap的锁分离技术/" rel="prev" title="ConcurrentHashMap 的锁定分离技术">
                ConcurrentHashMap 的锁定分离技术 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ4My82MDUx"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="ShenWenFang" />
            
              <p class="site-author-name" itemprop="name">ShenWenFang</p>
              <p class="site-description motion-element" itemprop="description">每一个你不满意的现在，都有一个你没有努力的曾经。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

         <div id="music163player">
             <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=31861269&auto=0&height=66"></iframe>
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基础面试题"><span class="nav-number">1.</span> <span class="nav-text">基础面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言："><span class="nav-number">1.1.</span> <span class="nav-text">引言：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#forward-和redirect的区别"><span class="nav-number">1.2.</span> <span class="nav-text">forward 和redirect的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#int-和-Integer-有什么区别"><span class="nav-number">1.3.</span> <span class="nav-text">int 和 Integer 有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#error和exception有什么区别"><span class="nav-number">1.4.</span> <span class="nav-text">error和exception有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Overload和Override区别，Overloaded方法可以改变返回值的类型吗"><span class="nav-number">1.5.</span> <span class="nav-text">Overload和Override区别，Overloaded方法可以改变返回值的类型吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java中有哪些集合，主要方法有哪些"><span class="nav-number">1.6.</span> <span class="nav-text">java中有哪些集合，主要方法有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List、Map、Set接口，存取元素时各自特点"><span class="nav-number">1.7.</span> <span class="nav-text">List、Map、Set接口，存取元素时各自特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap与HashTable的区别"><span class="nav-number">1.8.</span> <span class="nav-text">HashMap与HashTable的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap，ConcurrentHashMap与LinkedHashMap的区别"><span class="nav-number">1.9.</span> <span class="nav-text">HashMap，ConcurrentHashMap与LinkedHashMap的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vector和ArrayList的区别"><span class="nav-number">1.10.</span> <span class="nav-text">Vector和ArrayList的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayList-与-LinkedList-的不区别"><span class="nav-number">1.11.</span> <span class="nav-text">ArrayList 与 LinkedList 的不区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-中的-LinkedList-是单向链表还是双向链表"><span class="nav-number">1.12.</span> <span class="nav-text">Java 中的 LinkedList 是单向链表还是双向链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String、StringBuffer、StringBuilder之间区别"><span class="nav-number">1.13.</span> <span class="nav-text">String、StringBuffer、StringBuilder之间区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-的常用方有哪些"><span class="nav-number">1.14.</span> <span class="nav-text">Object 的常用方有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mysql-的分页-SQL-语句"><span class="nav-number">1.15.</span> <span class="nav-text">Mysql 的分页 SQL 语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hibernate与MyBatis的异同"><span class="nav-number">1.16.</span> <span class="nav-text">Hibernate与MyBatis的异同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hibernate与MyBatis在sql优化方面异同"><span class="nav-number">1.17.</span> <span class="nav-text">Hibernate与MyBatis在sql优化方面异同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hibernate与MyBatis对象管理对比"><span class="nav-number">1.18.</span> <span class="nav-text">Hibernate与MyBatis对象管理对比</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Jsp九大内置对象"><span class="nav-number">1.19.</span> <span class="nav-text">Jsp九大内置对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Comparator-与-Comparable-有什么不同"><span class="nav-number">1.20.</span> <span class="nav-text">Comparator 与 Comparable 有什么不同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collection-和-Collections的区别"><span class="nav-number">1.21.</span> <span class="nav-text">Collection 和 Collections的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程同步的方法"><span class="nav-number">1.22.</span> <span class="nav-text">线程同步的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Volatile和Synchronized四个不同点"><span class="nav-number">1.23.</span> <span class="nav-text">Volatile和Synchronized四个不同点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringMVC运行原理"><span class="nav-number">1.24.</span> <span class="nav-text">SpringMVC运行原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringMVC与Struts2区别与比较总结"><span class="nav-number">1.25.</span> <span class="nav-text">SpringMVC与Struts2区别与比较总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简单总结springMVC和struts2的区别"><span class="nav-number">1.26.</span> <span class="nav-text">简单总结springMVC和struts2的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringMvc怎么和AJAX相互调用的"><span class="nav-number">1.27.</span> <span class="nav-text">SpringMvc怎么和AJAX相互调用的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring有哪些优点"><span class="nav-number">1.28.</span> <span class="nav-text">Spring有哪些优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spring-主要使用了哪些-，IOC和AOP实现原理是什么"><span class="nav-number">1.29.</span> <span class="nav-text">spring 主要使用了哪些 ，IOC和AOP实现原理是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解释AOP模块"><span class="nav-number">1.30.</span> <span class="nav-text">解释AOP模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IoC容器是什么其优点"><span class="nav-number">1.31.</span> <span class="nav-text">IoC容器是什么其优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-的依赖注入方式有哪一些"><span class="nav-number">1.32.</span> <span class="nav-text">Spring 的依赖注入方式有哪一些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring支持的事务管理类型"><span class="nav-number">1.33.</span> <span class="nav-text">Spring支持的事务管理类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal-线程变量副本"><span class="nav-number">1.34.</span> <span class="nav-text">ThreadLocal(线程变量副本)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#throw-和-throws-的区别"><span class="nav-number">1.35.</span> <span class="nav-text">throw 和 throws 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final关键字的作用"><span class="nav-number">1.36.</span> <span class="nav-text">final关键字的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String是最基本的数据类型吗"><span class="nav-number">1.37.</span> <span class="nav-text">String是最基本的数据类型吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized和java-util-concurrent-locks-Lock的异同"><span class="nav-number">1.38.</span> <span class="nav-text">synchronized和java.util.concurrent.locks.Lock的异同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spring的事务有几种它的隔离级别和传播行为"><span class="nav-number">1.39.</span> <span class="nav-text">spring的事务有几种它的隔离级别和传播行为</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sleep-和-wait-有什么区别"><span class="nav-number">1.40.</span> <span class="nav-text">sleep() 和 wait() 有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程和同步有几种实现方法"><span class="nav-number">1.41.</span> <span class="nav-text">多线程和同步有几种实现方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#启动一个线程是用run-还是start"><span class="nav-number">1.42.</span> <span class="nav-text">启动一个线程是用run()还是start()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final-finally-finalize的区别"><span class="nav-number">1.43.</span> <span class="nav-text">final,finally,finalize的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#abstract-class和interface有什么区别"><span class="nav-number">1.44.</span> <span class="nav-text">abstract class和interface有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Set里的元素不能重复，用-还是equals-判断"><span class="nav-number">1.45.</span> <span class="nav-text">Set里的元素不能重复，用==还是equals ()判断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#struts-框架是如何体现MVC模式"><span class="nav-number">1.46.</span> <span class="nav-text">struts 框架是如何体现MVC模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hibernate-的实体存在哪几种状态"><span class="nav-number">1.47.</span> <span class="nav-text">Hibernate 的实体存在哪几种状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hibernate-的get-和load-的区别"><span class="nav-number">1.48.</span> <span class="nav-text">Hibernate 的get()和load()的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么wait和notify方法要在同步块中调用"><span class="nav-number">1.49.</span> <span class="nav-text">为什么wait和notify方法要在同步块中调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是ThreadLocal变量"><span class="nav-number">1.50.</span> <span class="nav-text">什么是ThreadLocal变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何避免死锁"><span class="nav-number">1.51.</span> <span class="nav-text">如何避免死锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java中活锁和死锁有什么区别"><span class="nav-number">1.52.</span> <span class="nav-text">Java中活锁和死锁有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#怎么检测一个线程是否拥有锁"><span class="nav-number">1.53.</span> <span class="nav-text">怎么检测一个线程是否拥有锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Maven有哪些优点"><span class="nav-number">1.54.</span> <span class="nav-text">Maven有哪些优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Maven常见的依赖范围有哪些"><span class="nav-number">1.55.</span> <span class="nav-text">Maven常见的依赖范围有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用“Mvn-Clean-Package”进行项目打包-其过程执行了哪些动作"><span class="nav-number">1.56.</span> <span class="nav-text">使用“Mvn Clean Package”进行项目打包,其过程执行了哪些动作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Maven-多模块如何聚合"><span class="nav-number">1.57.</span> <span class="nav-text">Maven 多模块如何聚合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓存框架memcache和redis的区别？项目中，怎么去选择？"><span class="nav-number">1.58.</span> <span class="nav-text">缓存框架memcache和redis的区别？项目中，怎么去选择？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java的原子类，实现原理是什么"><span class="nav-number">1.59.</span> <span class="nav-text">java的原子类，实现原理是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库性能优化有哪些方法"><span class="nav-number">1.60.</span> <span class="nav-text">数据库性能优化有哪些方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP请求方法get和post有什么区别"><span class="nav-number">1.61.</span> <span class="nav-text">HTTP请求方法get和post有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux命令，查看某个线程，整个机器负载和文件内容快速查找的命令"><span class="nav-number">1.62.</span> <span class="nav-text">linux命令，查看某个线程，整个机器负载和文件内容快速查找的命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM内存的模型，垃圾回收的机制，如何对JVM进行调优"><span class="nav-number">1.63.</span> <span class="nav-text">JVM内存的模型，垃圾回收的机制，如何对JVM进行调优</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高并发时，又如何保证性能和数据正确"><span class="nav-number">1.64.</span> <span class="nav-text">高并发时，又如何保证性能和数据正确</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分布式事务如何实现"><span class="nav-number">1.65.</span> <span class="nav-text">分布式事务如何实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#抽象类和接口的区别，项目中如何使用它们"><span class="nav-number">1.66.</span> <span class="nav-text">抽象类和接口的区别，项目中如何使用它们</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP通讯有几次握手，有使用过哪些socket框架"><span class="nav-number">1.67.</span> <span class="nav-text">TCP通讯有几次握手，有使用过哪些socket框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java反射机制，反射生成类，可否访问私有变量"><span class="nav-number">1.68.</span> <span class="nav-text">java反射机制，反射生成类，可否访问私有变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RPC是什么，有使用过哪些RPC框架"><span class="nav-number">1.69.</span> <span class="nav-text">RPC是什么，有使用过哪些RPC框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jquery如何绑定页面某元素的点击事件"><span class="nav-number">1.70.</span> <span class="nav-text">jquery如何绑定页面某元素的点击事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile实现原理"><span class="nav-number">1.71.</span> <span class="nav-text">volatile实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#session-与-cookie-区别"><span class="nav-number">1.72.</span> <span class="nav-text">session 与 cookie 区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#session-分布式处理"><span class="nav-number">1.73.</span> <span class="nav-text">session 分布式处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#说说自定义注解的场景及实现"><span class="nav-number">1.74.</span> <span class="nav-text">说说自定义注解的场景及实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashSet-和-HashMap-区别"><span class="nav-number">1.75.</span> <span class="nav-text">HashSet 和 HashMap 区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap-的工作原理及代码实现"><span class="nav-number">1.76.</span> <span class="nav-text">HashMap 的工作原理及代码实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentHashMap-的工作原理及代码实现"><span class="nav-number">1.77.</span> <span class="nav-text">ConcurrentHashMap 的工作原理及代码实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal-原理分析"><span class="nav-number">1.78.</span> <span class="nav-text">ThreadLocal 原理分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建线程的方式及实现"><span class="nav-number">1.79.</span> <span class="nav-text">创建线程的方式及实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sleep-、join（）、yield（）有什么区别"><span class="nav-number">1.80.</span> <span class="nav-text">sleep() 、join（）、yield（）有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentHashMap如何保证线程安全"><span class="nav-number">1.81.</span> <span class="nav-text">ConcurrentHashMap如何保证线程安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new与newInstance-的区别"><span class="nav-number">1.82.</span> <span class="nav-text">new与newInstance()的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK中用到的设计模式"><span class="nav-number">1.83.</span> <span class="nav-text">JDK中用到的设计模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hashCode-amp-amp-equals"><span class="nav-number">1.84.</span> <span class="nav-text">hashCode() && equals()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object类的finalize方法的实现原理"><span class="nav-number">1.85.</span> <span class="nav-text">Object类的finalize方法的实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Finalizer对象什么时候会在引用队列中"><span class="nav-number">1.86.</span> <span class="nav-text">Finalizer对象什么时候会在引用队列中</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CountDownLatch-原理"><span class="nav-number">1.87.</span> <span class="nav-text">CountDownLatch 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CyclicBarrier-原理"><span class="nav-number">1.88.</span> <span class="nav-text">CyclicBarrier 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Semaphore-原理"><span class="nav-number">1.89.</span> <span class="nav-text">Semaphore 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exchanger-原理"><span class="nav-number">1.90.</span> <span class="nav-text">Exchanger 原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CountDownLatch-与-CyclicBarrier-区别"><span class="nav-number">1.91.</span> <span class="nav-text">CountDownLatch 与 CyclicBarrier 区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池的实现原理"><span class="nav-number">1.92.</span> <span class="nav-text">线程池的实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池的几种方式"><span class="nav-number">1.93.</span> <span class="nav-text">线程池的几种方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的生命周期"><span class="nav-number">1.94.</span> <span class="nav-text">线程的生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#说说线程安全问题"><span class="nav-number">1.95.</span> <span class="nav-text">说说线程安全问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronize-实现原理"><span class="nav-number">1.96.</span> <span class="nav-text">synchronize 实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized-与-lock-的区别"><span class="nav-number">1.97.</span> <span class="nav-text">synchronized 与 lock 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAS-乐观锁"><span class="nav-number">1.98.</span> <span class="nav-text">CAS 乐观锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ABA-问题"><span class="nav-number">1.99.</span> <span class="nav-text">ABA 问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#乐观锁的业务场景及实现方式"><span class="nav-number">1.100.</span> <span class="nav-text">乐观锁的业务场景及实现方式</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ShenWenFang</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("9lk8dNt56FULANV18qHRXIff-gzGzoHsz", "lSea2qzYEcPELI1zQN1wWQGt");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
